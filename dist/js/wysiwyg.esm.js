var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var utils = {};
const Aacute = "Ã";
const aacute = "Ã¡";
const Abreve = "Ä‚";
const abreve = "Äƒ";
const ac = "âˆ¾";
const acd = "âˆ¿";
const acE = "âˆ¾Ì³";
const Acirc = "Ã‚";
const acirc = "Ã¢";
const acute = "Â´";
const Acy = "Ğ";
const acy = "Ğ°";
const AElig = "Ã†";
const aelig = "Ã¦";
const af = "â¡";
const Afr = "ğ”„";
const afr = "ğ”";
const Agrave = "Ã€";
const agrave = "Ã ";
const alefsym = "â„µ";
const aleph = "â„µ";
const Alpha = "Î‘";
const alpha = "Î±";
const Amacr = "Ä€";
const amacr = "Ä";
const amalg = "â¨¿";
const amp = "&";
const AMP = "&";
const andand = "â©•";
const And = "â©“";
const and = "âˆ§";
const andd = "â©œ";
const andslope = "â©˜";
const andv = "â©š";
const ang = "âˆ ";
const ange = "â¦¤";
const angle = "âˆ ";
const angmsdaa = "â¦¨";
const angmsdab = "â¦©";
const angmsdac = "â¦ª";
const angmsdad = "â¦«";
const angmsdae = "â¦¬";
const angmsdaf = "â¦­";
const angmsdag = "â¦®";
const angmsdah = "â¦¯";
const angmsd = "âˆ¡";
const angrt = "âˆŸ";
const angrtvb = "âŠ¾";
const angrtvbd = "â¦";
const angsph = "âˆ¢";
const angst = "Ã…";
const angzarr = "â¼";
const Aogon = "Ä„";
const aogon = "Ä…";
const Aopf = "ğ”¸";
const aopf = "ğ•’";
const apacir = "â©¯";
const ap = "â‰ˆ";
const apE = "â©°";
const ape = "â‰Š";
const apid = "â‰‹";
const apos = "'";
const ApplyFunction = "â¡";
const approx = "â‰ˆ";
const approxeq = "â‰Š";
const Aring = "Ã…";
const aring = "Ã¥";
const Ascr = "ğ’œ";
const ascr = "ğ’¶";
const Assign = "â‰”";
const ast = "*";
const asymp = "â‰ˆ";
const asympeq = "â‰";
const Atilde = "Ãƒ";
const atilde = "Ã£";
const Auml = "Ã„";
const auml = "Ã¤";
const awconint = "âˆ³";
const awint = "â¨‘";
const backcong = "â‰Œ";
const backepsilon = "Ï¶";
const backprime = "â€µ";
const backsim = "âˆ½";
const backsimeq = "â‹";
const Backslash = "âˆ–";
const Barv = "â«§";
const barvee = "âŠ½";
const barwed = "âŒ…";
const Barwed = "âŒ†";
const barwedge = "âŒ…";
const bbrk = "âµ";
const bbrktbrk = "â¶";
const bcong = "â‰Œ";
const Bcy = "Ğ‘";
const bcy = "Ğ±";
const bdquo = "â€";
const becaus = "âˆµ";
const because = "âˆµ";
const Because = "âˆµ";
const bemptyv = "â¦°";
const bepsi = "Ï¶";
const bernou = "â„¬";
const Bernoullis = "â„¬";
const Beta = "Î’";
const beta = "Î²";
const beth = "â„¶";
const between = "â‰¬";
const Bfr = "ğ”…";
const bfr = "ğ”Ÿ";
const bigcap = "â‹‚";
const bigcirc = "â—¯";
const bigcup = "â‹ƒ";
const bigodot = "â¨€";
const bigoplus = "â¨";
const bigotimes = "â¨‚";
const bigsqcup = "â¨†";
const bigstar = "â˜…";
const bigtriangledown = "â–½";
const bigtriangleup = "â–³";
const biguplus = "â¨„";
const bigvee = "â‹";
const bigwedge = "â‹€";
const bkarow = "â¤";
const blacklozenge = "â§«";
const blacksquare = "â–ª";
const blacktriangle = "â–´";
const blacktriangledown = "â–¾";
const blacktriangleleft = "â—‚";
const blacktriangleright = "â–¸";
const blank = "â£";
const blk12 = "â–’";
const blk14 = "â–‘";
const blk34 = "â–“";
const block$1 = "â–ˆ";
const bne = "=âƒ¥";
const bnequiv = "â‰¡âƒ¥";
const bNot = "â«­";
const bnot = "âŒ";
const Bopf = "ğ”¹";
const bopf = "ğ•“";
const bot = "âŠ¥";
const bottom = "âŠ¥";
const bowtie = "â‹ˆ";
const boxbox = "â§‰";
const boxdl = "â”";
const boxdL = "â••";
const boxDl = "â•–";
const boxDL = "â•—";
const boxdr = "â”Œ";
const boxdR = "â•’";
const boxDr = "â•“";
const boxDR = "â•”";
const boxh = "â”€";
const boxH = "â•";
const boxhd = "â”¬";
const boxHd = "â•¤";
const boxhD = "â•¥";
const boxHD = "â•¦";
const boxhu = "â”´";
const boxHu = "â•§";
const boxhU = "â•¨";
const boxHU = "â•©";
const boxminus = "âŠŸ";
const boxplus = "âŠ";
const boxtimes = "âŠ ";
const boxul = "â”˜";
const boxuL = "â•›";
const boxUl = "â•œ";
const boxUL = "â•";
const boxur = "â””";
const boxuR = "â•˜";
const boxUr = "â•™";
const boxUR = "â•š";
const boxv = "â”‚";
const boxV = "â•‘";
const boxvh = "â”¼";
const boxvH = "â•ª";
const boxVh = "â•«";
const boxVH = "â•¬";
const boxvl = "â”¤";
const boxvL = "â•¡";
const boxVl = "â•¢";
const boxVL = "â•£";
const boxvr = "â”œ";
const boxvR = "â•";
const boxVr = "â•Ÿ";
const boxVR = "â• ";
const bprime = "â€µ";
const breve = "Ë˜";
const Breve = "Ë˜";
const brvbar = "Â¦";
const bscr = "ğ’·";
const Bscr = "â„¬";
const bsemi = "â";
const bsim = "âˆ½";
const bsime = "â‹";
const bsolb = "â§…";
const bsol = "\\";
const bsolhsub = "âŸˆ";
const bull = "â€¢";
const bullet = "â€¢";
const bump = "â‰";
const bumpE = "âª®";
const bumpe = "â‰";
const Bumpeq = "â‰";
const bumpeq = "â‰";
const Cacute = "Ä†";
const cacute = "Ä‡";
const capand = "â©„";
const capbrcup = "â©‰";
const capcap = "â©‹";
const cap = "âˆ©";
const Cap = "â‹’";
const capcup = "â©‡";
const capdot = "â©€";
const CapitalDifferentialD = "â……";
const caps = "âˆ©ï¸€";
const caret = "â";
const caron = "Ë‡";
const Cayleys = "â„­";
const ccaps = "â©";
const Ccaron = "ÄŒ";
const ccaron = "Ä";
const Ccedil = "Ã‡";
const ccedil = "Ã§";
const Ccirc = "Äˆ";
const ccirc = "Ä‰";
const Cconint = "âˆ°";
const ccups = "â©Œ";
const ccupssm = "â©";
const Cdot = "ÄŠ";
const cdot = "Ä‹";
const cedil = "Â¸";
const Cedilla = "Â¸";
const cemptyv = "â¦²";
const cent = "Â¢";
const centerdot = "Â·";
const CenterDot = "Â·";
const cfr = "ğ” ";
const Cfr = "â„­";
const CHcy = "Ğ§";
const chcy = "Ñ‡";
const check = "âœ“";
const checkmark = "âœ“";
const Chi = "Î§";
const chi = "Ï‡";
const circ = "Ë†";
const circeq = "â‰—";
const circlearrowleft = "â†º";
const circlearrowright = "â†»";
const circledast = "âŠ›";
const circledcirc = "âŠš";
const circleddash = "âŠ";
const CircleDot = "âŠ™";
const circledR = "Â®";
const circledS = "â“ˆ";
const CircleMinus = "âŠ–";
const CirclePlus = "âŠ•";
const CircleTimes = "âŠ—";
const cir = "â—‹";
const cirE = "â§ƒ";
const cire = "â‰—";
const cirfnint = "â¨";
const cirmid = "â«¯";
const cirscir = "â§‚";
const ClockwiseContourIntegral = "âˆ²";
const CloseCurlyDoubleQuote = "â€";
const CloseCurlyQuote = "â€™";
const clubs = "â™£";
const clubsuit = "â™£";
const colon = ":";
const Colon = "âˆ·";
const Colone = "â©´";
const colone = "â‰”";
const coloneq = "â‰”";
const comma = ",";
const commat = "@";
const comp = "âˆ";
const compfn = "âˆ˜";
const complement = "âˆ";
const complexes = "â„‚";
const cong = "â‰…";
const congdot = "â©­";
const Congruent = "â‰¡";
const conint = "âˆ®";
const Conint = "âˆ¯";
const ContourIntegral = "âˆ®";
const copf = "ğ•”";
const Copf = "â„‚";
const coprod = "âˆ";
const Coproduct = "âˆ";
const copy = "Â©";
const COPY = "Â©";
const copysr = "â„—";
const CounterClockwiseContourIntegral = "âˆ³";
const crarr = "â†µ";
const cross = "âœ—";
const Cross = "â¨¯";
const Cscr = "ğ’";
const cscr = "ğ’¸";
const csub = "â«";
const csube = "â«‘";
const csup = "â«";
const csupe = "â«’";
const ctdot = "â‹¯";
const cudarrl = "â¤¸";
const cudarrr = "â¤µ";
const cuepr = "â‹";
const cuesc = "â‹Ÿ";
const cularr = "â†¶";
const cularrp = "â¤½";
const cupbrcap = "â©ˆ";
const cupcap = "â©†";
const CupCap = "â‰";
const cup = "âˆª";
const Cup = "â‹“";
const cupcup = "â©Š";
const cupdot = "âŠ";
const cupor = "â©…";
const cups = "âˆªï¸€";
const curarr = "â†·";
const curarrm = "â¤¼";
const curlyeqprec = "â‹";
const curlyeqsucc = "â‹Ÿ";
const curlyvee = "â‹";
const curlywedge = "â‹";
const curren = "Â¤";
const curvearrowleft = "â†¶";
const curvearrowright = "â†·";
const cuvee = "â‹";
const cuwed = "â‹";
const cwconint = "âˆ²";
const cwint = "âˆ±";
const cylcty = "âŒ­";
const dagger = "â€ ";
const Dagger = "â€¡";
const daleth = "â„¸";
const darr = "â†“";
const Darr = "â†¡";
const dArr = "â‡“";
const dash = "â€";
const Dashv = "â«¤";
const dashv = "âŠ£";
const dbkarow = "â¤";
const dblac = "Ë";
const Dcaron = "Ä";
const dcaron = "Ä";
const Dcy = "Ğ”";
const dcy = "Ğ´";
const ddagger = "â€¡";
const ddarr = "â‡Š";
const DD = "â……";
const dd = "â…†";
const DDotrahd = "â¤‘";
const ddotseq = "â©·";
const deg = "Â°";
const Del = "âˆ‡";
const Delta = "Î”";
const delta = "Î´";
const demptyv = "â¦±";
const dfisht = "â¥¿";
const Dfr = "ğ”‡";
const dfr = "ğ”¡";
const dHar = "â¥¥";
const dharl = "â‡ƒ";
const dharr = "â‡‚";
const DiacriticalAcute = "Â´";
const DiacriticalDot = "Ë™";
const DiacriticalDoubleAcute = "Ë";
const DiacriticalGrave = "`";
const DiacriticalTilde = "Ëœ";
const diam = "â‹„";
const diamond = "â‹„";
const Diamond = "â‹„";
const diamondsuit = "â™¦";
const diams = "â™¦";
const die = "Â¨";
const DifferentialD = "â…†";
const digamma = "Ï";
const disin = "â‹²";
const div = "Ã·";
const divide = "Ã·";
const divideontimes = "â‹‡";
const divonx = "â‹‡";
const DJcy = "Ğ‚";
const djcy = "Ñ’";
const dlcorn = "âŒ";
const dlcrop = "âŒ";
const dollar = "$";
const Dopf = "ğ”»";
const dopf = "ğ••";
const Dot = "Â¨";
const dot = "Ë™";
const DotDot = "âƒœ";
const doteq = "â‰";
const doteqdot = "â‰‘";
const DotEqual = "â‰";
const dotminus = "âˆ¸";
const dotplus = "âˆ”";
const dotsquare = "âŠ¡";
const doublebarwedge = "âŒ†";
const DoubleContourIntegral = "âˆ¯";
const DoubleDot = "Â¨";
const DoubleDownArrow = "â‡“";
const DoubleLeftArrow = "â‡";
const DoubleLeftRightArrow = "â‡”";
const DoubleLeftTee = "â«¤";
const DoubleLongLeftArrow = "âŸ¸";
const DoubleLongLeftRightArrow = "âŸº";
const DoubleLongRightArrow = "âŸ¹";
const DoubleRightArrow = "â‡’";
const DoubleRightTee = "âŠ¨";
const DoubleUpArrow = "â‡‘";
const DoubleUpDownArrow = "â‡•";
const DoubleVerticalBar = "âˆ¥";
const DownArrowBar = "â¤“";
const downarrow = "â†“";
const DownArrow = "â†“";
const Downarrow = "â‡“";
const DownArrowUpArrow = "â‡µ";
const DownBreve = "Ì‘";
const downdownarrows = "â‡Š";
const downharpoonleft = "â‡ƒ";
const downharpoonright = "â‡‚";
const DownLeftRightVector = "â¥";
const DownLeftTeeVector = "â¥";
const DownLeftVectorBar = "â¥–";
const DownLeftVector = "â†½";
const DownRightTeeVector = "â¥Ÿ";
const DownRightVectorBar = "â¥—";
const DownRightVector = "â‡";
const DownTeeArrow = "â†§";
const DownTee = "âŠ¤";
const drbkarow = "â¤";
const drcorn = "âŒŸ";
const drcrop = "âŒŒ";
const Dscr = "ğ’Ÿ";
const dscr = "ğ’¹";
const DScy = "Ğ…";
const dscy = "Ñ•";
const dsol = "â§¶";
const Dstrok = "Ä";
const dstrok = "Ä‘";
const dtdot = "â‹±";
const dtri = "â–¿";
const dtrif = "â–¾";
const duarr = "â‡µ";
const duhar = "â¥¯";
const dwangle = "â¦¦";
const DZcy = "Ğ";
const dzcy = "ÑŸ";
const dzigrarr = "âŸ¿";
const Eacute = "Ã‰";
const eacute = "Ã©";
const easter = "â©®";
const Ecaron = "Äš";
const ecaron = "Ä›";
const Ecirc = "ÃŠ";
const ecirc = "Ãª";
const ecir = "â‰–";
const ecolon = "â‰•";
const Ecy = "Ğ­";
const ecy = "Ñ";
const eDDot = "â©·";
const Edot = "Ä–";
const edot = "Ä—";
const eDot = "â‰‘";
const ee = "â…‡";
const efDot = "â‰’";
const Efr = "ğ”ˆ";
const efr = "ğ”¢";
const eg = "âªš";
const Egrave = "Ãˆ";
const egrave = "Ã¨";
const egs = "âª–";
const egsdot = "âª˜";
const el = "âª™";
const Element = "âˆˆ";
const elinters = "â§";
const ell = "â„“";
const els = "âª•";
const elsdot = "âª—";
const Emacr = "Ä’";
const emacr = "Ä“";
const empty = "âˆ…";
const emptyset = "âˆ…";
const EmptySmallSquare = "â—»";
const emptyv = "âˆ…";
const EmptyVerySmallSquare = "â–«";
const emsp13 = "â€„";
const emsp14 = "â€…";
const emsp = "â€ƒ";
const ENG = "ÅŠ";
const eng = "Å‹";
const ensp = "â€‚";
const Eogon = "Ä˜";
const eogon = "Ä™";
const Eopf = "ğ”¼";
const eopf = "ğ•–";
const epar = "â‹•";
const eparsl = "â§£";
const eplus = "â©±";
const epsi = "Îµ";
const Epsilon = "Î•";
const epsilon = "Îµ";
const epsiv = "Ïµ";
const eqcirc = "â‰–";
const eqcolon = "â‰•";
const eqsim = "â‰‚";
const eqslantgtr = "âª–";
const eqslantless = "âª•";
const Equal = "â©µ";
const equals = "=";
const EqualTilde = "â‰‚";
const equest = "â‰Ÿ";
const Equilibrium = "â‡Œ";
const equiv = "â‰¡";
const equivDD = "â©¸";
const eqvparsl = "â§¥";
const erarr = "â¥±";
const erDot = "â‰“";
const escr = "â„¯";
const Escr = "â„°";
const esdot = "â‰";
const Esim = "â©³";
const esim = "â‰‚";
const Eta = "Î—";
const eta = "Î·";
const ETH = "Ã";
const eth = "Ã°";
const Euml = "Ã‹";
const euml = "Ã«";
const euro = "â‚¬";
const excl = "!";
const exist = "âˆƒ";
const Exists = "âˆƒ";
const expectation = "â„°";
const exponentiale = "â…‡";
const ExponentialE = "â…‡";
const fallingdotseq = "â‰’";
const Fcy = "Ğ¤";
const fcy = "Ñ„";
const female = "â™€";
const ffilig = "ï¬ƒ";
const fflig = "ï¬€";
const ffllig = "ï¬„";
const Ffr = "ğ”‰";
const ffr = "ğ”£";
const filig = "ï¬";
const FilledSmallSquare = "â—¼";
const FilledVerySmallSquare = "â–ª";
const fjlig = "fj";
const flat = "â™­";
const fllig = "ï¬‚";
const fltns = "â–±";
const fnof = "Æ’";
const Fopf = "ğ”½";
const fopf = "ğ•—";
const forall = "âˆ€";
const ForAll = "âˆ€";
const fork = "â‹”";
const forkv = "â«™";
const Fouriertrf = "â„±";
const fpartint = "â¨";
const frac12 = "Â½";
const frac13 = "â…“";
const frac14 = "Â¼";
const frac15 = "â…•";
const frac16 = "â…™";
const frac18 = "â…›";
const frac23 = "â…”";
const frac25 = "â…–";
const frac34 = "Â¾";
const frac35 = "â…—";
const frac38 = "â…œ";
const frac45 = "â…˜";
const frac56 = "â…š";
const frac58 = "â…";
const frac78 = "â…";
const frasl = "â„";
const frown = "âŒ¢";
const fscr = "ğ’»";
const Fscr = "â„±";
const gacute = "Çµ";
const Gamma = "Î“";
const gamma = "Î³";
const Gammad = "Ïœ";
const gammad = "Ï";
const gap = "âª†";
const Gbreve = "Ä";
const gbreve = "ÄŸ";
const Gcedil = "Ä¢";
const Gcirc = "Äœ";
const gcirc = "Ä";
const Gcy = "Ğ“";
const gcy = "Ğ³";
const Gdot = "Ä ";
const gdot = "Ä¡";
const ge = "â‰¥";
const gE = "â‰§";
const gEl = "âªŒ";
const gel = "â‹›";
const geq = "â‰¥";
const geqq = "â‰§";
const geqslant = "â©¾";
const gescc = "âª©";
const ges = "â©¾";
const gesdot = "âª€";
const gesdoto = "âª‚";
const gesdotol = "âª„";
const gesl = "â‹›ï¸€";
const gesles = "âª”";
const Gfr = "ğ”Š";
const gfr = "ğ”¤";
const gg = "â‰«";
const Gg = "â‹™";
const ggg = "â‹™";
const gimel = "â„·";
const GJcy = "Ğƒ";
const gjcy = "Ñ“";
const gla = "âª¥";
const gl = "â‰·";
const glE = "âª’";
const glj = "âª¤";
const gnap = "âªŠ";
const gnapprox = "âªŠ";
const gne = "âªˆ";
const gnE = "â‰©";
const gneq = "âªˆ";
const gneqq = "â‰©";
const gnsim = "â‹§";
const Gopf = "ğ”¾";
const gopf = "ğ•˜";
const grave = "`";
const GreaterEqual = "â‰¥";
const GreaterEqualLess = "â‹›";
const GreaterFullEqual = "â‰§";
const GreaterGreater = "âª¢";
const GreaterLess = "â‰·";
const GreaterSlantEqual = "â©¾";
const GreaterTilde = "â‰³";
const Gscr = "ğ’¢";
const gscr = "â„Š";
const gsim = "â‰³";
const gsime = "âª";
const gsiml = "âª";
const gtcc = "âª§";
const gtcir = "â©º";
const gt = ">";
const GT = ">";
const Gt = "â‰«";
const gtdot = "â‹—";
const gtlPar = "â¦•";
const gtquest = "â©¼";
const gtrapprox = "âª†";
const gtrarr = "â¥¸";
const gtrdot = "â‹—";
const gtreqless = "â‹›";
const gtreqqless = "âªŒ";
const gtrless = "â‰·";
const gtrsim = "â‰³";
const gvertneqq = "â‰©ï¸€";
const gvnE = "â‰©ï¸€";
const Hacek = "Ë‡";
const hairsp = "â€Š";
const half = "Â½";
const hamilt = "â„‹";
const HARDcy = "Ğª";
const hardcy = "ÑŠ";
const harrcir = "â¥ˆ";
const harr = "â†”";
const hArr = "â‡”";
const harrw = "â†­";
const Hat = "^";
const hbar = "â„";
const Hcirc = "Ä¤";
const hcirc = "Ä¥";
const hearts = "â™¥";
const heartsuit = "â™¥";
const hellip = "â€¦";
const hercon = "âŠ¹";
const hfr = "ğ”¥";
const Hfr = "â„Œ";
const HilbertSpace = "â„‹";
const hksearow = "â¤¥";
const hkswarow = "â¤¦";
const hoarr = "â‡¿";
const homtht = "âˆ»";
const hookleftarrow = "â†©";
const hookrightarrow = "â†ª";
const hopf = "ğ•™";
const Hopf = "â„";
const horbar = "â€•";
const HorizontalLine = "â”€";
const hscr = "ğ’½";
const Hscr = "â„‹";
const hslash = "â„";
const Hstrok = "Ä¦";
const hstrok = "Ä§";
const HumpDownHump = "â‰";
const HumpEqual = "â‰";
const hybull = "âƒ";
const hyphen = "â€";
const Iacute = "Ã";
const iacute = "Ã­";
const ic = "â£";
const Icirc = "Ã";
const icirc = "Ã®";
const Icy = "Ğ˜";
const icy = "Ğ¸";
const Idot = "Ä°";
const IEcy = "Ğ•";
const iecy = "Ğµ";
const iexcl = "Â¡";
const iff = "â‡”";
const ifr = "ğ”¦";
const Ifr = "â„‘";
const Igrave = "ÃŒ";
const igrave = "Ã¬";
const ii = "â…ˆ";
const iiiint = "â¨Œ";
const iiint = "âˆ­";
const iinfin = "â§œ";
const iiota = "â„©";
const IJlig = "Ä²";
const ijlig = "Ä³";
const Imacr = "Äª";
const imacr = "Ä«";
const image$2 = "â„‘";
const ImaginaryI = "â…ˆ";
const imagline = "â„";
const imagpart = "â„‘";
const imath = "Ä±";
const Im = "â„‘";
const imof = "âŠ·";
const imped = "Æµ";
const Implies = "â‡’";
const incare = "â„…";
const infin = "âˆ";
const infintie = "â§";
const inodot = "Ä±";
const intcal = "âŠº";
const int = "âˆ«";
const Int = "âˆ¬";
const integers = "â„¤";
const Integral = "âˆ«";
const intercal = "âŠº";
const Intersection = "â‹‚";
const intlarhk = "â¨—";
const intprod = "â¨¼";
const InvisibleComma = "â£";
const InvisibleTimes = "â¢";
const IOcy = "Ğ";
const iocy = "Ñ‘";
const Iogon = "Ä®";
const iogon = "Ä¯";
const Iopf = "ğ•€";
const iopf = "ğ•š";
const Iota = "Î™";
const iota = "Î¹";
const iprod = "â¨¼";
const iquest = "Â¿";
const iscr = "ğ’¾";
const Iscr = "â„";
const isin = "âˆˆ";
const isindot = "â‹µ";
const isinE = "â‹¹";
const isins = "â‹´";
const isinsv = "â‹³";
const isinv = "âˆˆ";
const it = "â¢";
const Itilde = "Ä¨";
const itilde = "Ä©";
const Iukcy = "Ğ†";
const iukcy = "Ñ–";
const Iuml = "Ã";
const iuml = "Ã¯";
const Jcirc = "Ä´";
const jcirc = "Äµ";
const Jcy = "Ğ™";
const jcy = "Ğ¹";
const Jfr = "ğ”";
const jfr = "ğ”§";
const jmath = "È·";
const Jopf = "ğ•";
const jopf = "ğ•›";
const Jscr = "ğ’¥";
const jscr = "ğ’¿";
const Jsercy = "Ğˆ";
const jsercy = "Ñ˜";
const Jukcy = "Ğ„";
const jukcy = "Ñ”";
const Kappa = "Îš";
const kappa = "Îº";
const kappav = "Ï°";
const Kcedil = "Ä¶";
const kcedil = "Ä·";
const Kcy = "Ğš";
const kcy = "Ğº";
const Kfr = "ğ”";
const kfr = "ğ”¨";
const kgreen = "Ä¸";
const KHcy = "Ğ¥";
const khcy = "Ñ…";
const KJcy = "ĞŒ";
const kjcy = "Ñœ";
const Kopf = "ğ•‚";
const kopf = "ğ•œ";
const Kscr = "ğ’¦";
const kscr = "ğ“€";
const lAarr = "â‡š";
const Lacute = "Ä¹";
const lacute = "Äº";
const laemptyv = "â¦´";
const lagran = "â„’";
const Lambda = "Î›";
const lambda = "Î»";
const lang = "âŸ¨";
const Lang = "âŸª";
const langd = "â¦‘";
const langle = "âŸ¨";
const lap = "âª…";
const Laplacetrf = "â„’";
const laquo = "Â«";
const larrb = "â‡¤";
const larrbfs = "â¤Ÿ";
const larr = "â†";
const Larr = "â†";
const lArr = "â‡";
const larrfs = "â¤";
const larrhk = "â†©";
const larrlp = "â†«";
const larrpl = "â¤¹";
const larrsim = "â¥³";
const larrtl = "â†¢";
const latail = "â¤™";
const lAtail = "â¤›";
const lat = "âª«";
const late = "âª­";
const lates = "âª­ï¸€";
const lbarr = "â¤Œ";
const lBarr = "â¤";
const lbbrk = "â²";
const lbrace = "{";
const lbrack = "[";
const lbrke = "â¦‹";
const lbrksld = "â¦";
const lbrkslu = "â¦";
const Lcaron = "Ä½";
const lcaron = "Ä¾";
const Lcedil = "Ä»";
const lcedil = "Ä¼";
const lceil = "âŒˆ";
const lcub = "{";
const Lcy = "Ğ›";
const lcy = "Ğ»";
const ldca = "â¤¶";
const ldquo = "â€œ";
const ldquor = "â€";
const ldrdhar = "â¥§";
const ldrushar = "â¥‹";
const ldsh = "â†²";
const le = "â‰¤";
const lE = "â‰¦";
const LeftAngleBracket = "âŸ¨";
const LeftArrowBar = "â‡¤";
const leftarrow = "â†";
const LeftArrow = "â†";
const Leftarrow = "â‡";
const LeftArrowRightArrow = "â‡†";
const leftarrowtail = "â†¢";
const LeftCeiling = "âŒˆ";
const LeftDoubleBracket = "âŸ¦";
const LeftDownTeeVector = "â¥¡";
const LeftDownVectorBar = "â¥™";
const LeftDownVector = "â‡ƒ";
const LeftFloor = "âŒŠ";
const leftharpoondown = "â†½";
const leftharpoonup = "â†¼";
const leftleftarrows = "â‡‡";
const leftrightarrow = "â†”";
const LeftRightArrow = "â†”";
const Leftrightarrow = "â‡”";
const leftrightarrows = "â‡†";
const leftrightharpoons = "â‡‹";
const leftrightsquigarrow = "â†­";
const LeftRightVector = "â¥";
const LeftTeeArrow = "â†¤";
const LeftTee = "âŠ£";
const LeftTeeVector = "â¥š";
const leftthreetimes = "â‹‹";
const LeftTriangleBar = "â§";
const LeftTriangle = "âŠ²";
const LeftTriangleEqual = "âŠ´";
const LeftUpDownVector = "â¥‘";
const LeftUpTeeVector = "â¥ ";
const LeftUpVectorBar = "â¥˜";
const LeftUpVector = "â†¿";
const LeftVectorBar = "â¥’";
const LeftVector = "â†¼";
const lEg = "âª‹";
const leg = "â‹š";
const leq = "â‰¤";
const leqq = "â‰¦";
const leqslant = "â©½";
const lescc = "âª¨";
const les = "â©½";
const lesdot = "â©¿";
const lesdoto = "âª";
const lesdotor = "âªƒ";
const lesg = "â‹šï¸€";
const lesges = "âª“";
const lessapprox = "âª…";
const lessdot = "â‹–";
const lesseqgtr = "â‹š";
const lesseqqgtr = "âª‹";
const LessEqualGreater = "â‹š";
const LessFullEqual = "â‰¦";
const LessGreater = "â‰¶";
const lessgtr = "â‰¶";
const LessLess = "âª¡";
const lesssim = "â‰²";
const LessSlantEqual = "â©½";
const LessTilde = "â‰²";
const lfisht = "â¥¼";
const lfloor = "âŒŠ";
const Lfr = "ğ”";
const lfr = "ğ”©";
const lg = "â‰¶";
const lgE = "âª‘";
const lHar = "â¥¢";
const lhard = "â†½";
const lharu = "â†¼";
const lharul = "â¥ª";
const lhblk = "â–„";
const LJcy = "Ğ‰";
const ljcy = "Ñ™";
const llarr = "â‡‡";
const ll = "â‰ª";
const Ll = "â‹˜";
const llcorner = "âŒ";
const Lleftarrow = "â‡š";
const llhard = "â¥«";
const lltri = "â—º";
const Lmidot = "Ä¿";
const lmidot = "Å€";
const lmoustache = "â°";
const lmoust = "â°";
const lnap = "âª‰";
const lnapprox = "âª‰";
const lne = "âª‡";
const lnE = "â‰¨";
const lneq = "âª‡";
const lneqq = "â‰¨";
const lnsim = "â‹¦";
const loang = "âŸ¬";
const loarr = "â‡½";
const lobrk = "âŸ¦";
const longleftarrow = "âŸµ";
const LongLeftArrow = "âŸµ";
const Longleftarrow = "âŸ¸";
const longleftrightarrow = "âŸ·";
const LongLeftRightArrow = "âŸ·";
const Longleftrightarrow = "âŸº";
const longmapsto = "âŸ¼";
const longrightarrow = "âŸ¶";
const LongRightArrow = "âŸ¶";
const Longrightarrow = "âŸ¹";
const looparrowleft = "â†«";
const looparrowright = "â†¬";
const lopar = "â¦…";
const Lopf = "ğ•ƒ";
const lopf = "ğ•";
const loplus = "â¨­";
const lotimes = "â¨´";
const lowast = "âˆ—";
const lowbar = "_";
const LowerLeftArrow = "â†™";
const LowerRightArrow = "â†˜";
const loz = "â—Š";
const lozenge = "â—Š";
const lozf = "â§«";
const lpar = "(";
const lparlt = "â¦“";
const lrarr = "â‡†";
const lrcorner = "âŒŸ";
const lrhar = "â‡‹";
const lrhard = "â¥­";
const lrm = "â€";
const lrtri = "âŠ¿";
const lsaquo = "â€¹";
const lscr = "ğ“";
const Lscr = "â„’";
const lsh = "â†°";
const Lsh = "â†°";
const lsim = "â‰²";
const lsime = "âª";
const lsimg = "âª";
const lsqb = "[";
const lsquo = "â€˜";
const lsquor = "â€š";
const Lstrok = "Å";
const lstrok = "Å‚";
const ltcc = "âª¦";
const ltcir = "â©¹";
const lt = "<";
const LT = "<";
const Lt = "â‰ª";
const ltdot = "â‹–";
const lthree = "â‹‹";
const ltimes = "â‹‰";
const ltlarr = "â¥¶";
const ltquest = "â©»";
const ltri = "â—ƒ";
const ltrie = "âŠ´";
const ltrif = "â—‚";
const ltrPar = "â¦–";
const lurdshar = "â¥Š";
const luruhar = "â¥¦";
const lvertneqq = "â‰¨ï¸€";
const lvnE = "â‰¨ï¸€";
const macr = "Â¯";
const male = "â™‚";
const malt = "âœ ";
const maltese = "âœ ";
const map$1 = "â†¦";
const mapsto = "â†¦";
const mapstodown = "â†§";
const mapstoleft = "â†¤";
const mapstoup = "â†¥";
const marker = "â–®";
const mcomma = "â¨©";
const Mcy = "Ğœ";
const mcy = "Ğ¼";
const mdash = "â€”";
const mDDot = "âˆº";
const measuredangle = "âˆ¡";
const MediumSpace = "âŸ";
const Mellintrf = "â„³";
const Mfr = "ğ”";
const mfr = "ğ”ª";
const mho = "â„§";
const micro = "Âµ";
const midast = "*";
const midcir = "â«°";
const mid = "âˆ£";
const middot = "Â·";
const minusb = "âŠŸ";
const minus = "âˆ’";
const minusd = "âˆ¸";
const minusdu = "â¨ª";
const MinusPlus = "âˆ“";
const mlcp = "â«›";
const mldr = "â€¦";
const mnplus = "âˆ“";
const models = "âŠ§";
const Mopf = "ğ•„";
const mopf = "ğ•";
const mp = "âˆ“";
const mscr = "ğ“‚";
const Mscr = "â„³";
const mstpos = "âˆ¾";
const Mu = "Îœ";
const mu = "Î¼";
const multimap = "âŠ¸";
const mumap = "âŠ¸";
const nabla = "âˆ‡";
const Nacute = "Åƒ";
const nacute = "Å„";
const nang = "âˆ âƒ’";
const nap = "â‰‰";
const napE = "â©°Ì¸";
const napid = "â‰‹Ì¸";
const napos = "Å‰";
const napprox = "â‰‰";
const natural = "â™®";
const naturals = "â„•";
const natur = "â™®";
const nbsp = "Â ";
const nbump = "â‰Ì¸";
const nbumpe = "â‰Ì¸";
const ncap = "â©ƒ";
const Ncaron = "Å‡";
const ncaron = "Åˆ";
const Ncedil = "Å…";
const ncedil = "Å†";
const ncong = "â‰‡";
const ncongdot = "â©­Ì¸";
const ncup = "â©‚";
const Ncy = "Ğ";
const ncy = "Ğ½";
const ndash = "â€“";
const nearhk = "â¤¤";
const nearr = "â†—";
const neArr = "â‡—";
const nearrow = "â†—";
const ne = "â‰ ";
const nedot = "â‰Ì¸";
const NegativeMediumSpace = "â€‹";
const NegativeThickSpace = "â€‹";
const NegativeThinSpace = "â€‹";
const NegativeVeryThinSpace = "â€‹";
const nequiv = "â‰¢";
const nesear = "â¤¨";
const nesim = "â‰‚Ì¸";
const NestedGreaterGreater = "â‰«";
const NestedLessLess = "â‰ª";
const NewLine = "\n";
const nexist = "âˆ„";
const nexists = "âˆ„";
const Nfr = "ğ”‘";
const nfr = "ğ”«";
const ngE = "â‰§Ì¸";
const nge = "â‰±";
const ngeq = "â‰±";
const ngeqq = "â‰§Ì¸";
const ngeqslant = "â©¾Ì¸";
const nges = "â©¾Ì¸";
const nGg = "â‹™Ì¸";
const ngsim = "â‰µ";
const nGt = "â‰«âƒ’";
const ngt = "â‰¯";
const ngtr = "â‰¯";
const nGtv = "â‰«Ì¸";
const nharr = "â†®";
const nhArr = "â‡";
const nhpar = "â«²";
const ni = "âˆ‹";
const nis = "â‹¼";
const nisd = "â‹º";
const niv = "âˆ‹";
const NJcy = "ĞŠ";
const njcy = "Ñš";
const nlarr = "â†š";
const nlArr = "â‡";
const nldr = "â€¥";
const nlE = "â‰¦Ì¸";
const nle = "â‰°";
const nleftarrow = "â†š";
const nLeftarrow = "â‡";
const nleftrightarrow = "â†®";
const nLeftrightarrow = "â‡";
const nleq = "â‰°";
const nleqq = "â‰¦Ì¸";
const nleqslant = "â©½Ì¸";
const nles = "â©½Ì¸";
const nless = "â‰®";
const nLl = "â‹˜Ì¸";
const nlsim = "â‰´";
const nLt = "â‰ªâƒ’";
const nlt = "â‰®";
const nltri = "â‹ª";
const nltrie = "â‹¬";
const nLtv = "â‰ªÌ¸";
const nmid = "âˆ¤";
const NoBreak = "â ";
const NonBreakingSpace = "Â ";
const nopf = "ğ•Ÿ";
const Nopf = "â„•";
const Not = "â«¬";
const not = "Â¬";
const NotCongruent = "â‰¢";
const NotCupCap = "â‰­";
const NotDoubleVerticalBar = "âˆ¦";
const NotElement = "âˆ‰";
const NotEqual = "â‰ ";
const NotEqualTilde = "â‰‚Ì¸";
const NotExists = "âˆ„";
const NotGreater = "â‰¯";
const NotGreaterEqual = "â‰±";
const NotGreaterFullEqual = "â‰§Ì¸";
const NotGreaterGreater = "â‰«Ì¸";
const NotGreaterLess = "â‰¹";
const NotGreaterSlantEqual = "â©¾Ì¸";
const NotGreaterTilde = "â‰µ";
const NotHumpDownHump = "â‰Ì¸";
const NotHumpEqual = "â‰Ì¸";
const notin = "âˆ‰";
const notindot = "â‹µÌ¸";
const notinE = "â‹¹Ì¸";
const notinva = "âˆ‰";
const notinvb = "â‹·";
const notinvc = "â‹¶";
const NotLeftTriangleBar = "â§Ì¸";
const NotLeftTriangle = "â‹ª";
const NotLeftTriangleEqual = "â‹¬";
const NotLess = "â‰®";
const NotLessEqual = "â‰°";
const NotLessGreater = "â‰¸";
const NotLessLess = "â‰ªÌ¸";
const NotLessSlantEqual = "â©½Ì¸";
const NotLessTilde = "â‰´";
const NotNestedGreaterGreater = "âª¢Ì¸";
const NotNestedLessLess = "âª¡Ì¸";
const notni = "âˆŒ";
const notniva = "âˆŒ";
const notnivb = "â‹¾";
const notnivc = "â‹½";
const NotPrecedes = "âŠ€";
const NotPrecedesEqual = "âª¯Ì¸";
const NotPrecedesSlantEqual = "â‹ ";
const NotReverseElement = "âˆŒ";
const NotRightTriangleBar = "â§Ì¸";
const NotRightTriangle = "â‹«";
const NotRightTriangleEqual = "â‹­";
const NotSquareSubset = "âŠÌ¸";
const NotSquareSubsetEqual = "â‹¢";
const NotSquareSuperset = "âŠÌ¸";
const NotSquareSupersetEqual = "â‹£";
const NotSubset = "âŠ‚âƒ’";
const NotSubsetEqual = "âŠˆ";
const NotSucceeds = "âŠ";
const NotSucceedsEqual = "âª°Ì¸";
const NotSucceedsSlantEqual = "â‹¡";
const NotSucceedsTilde = "â‰¿Ì¸";
const NotSuperset = "âŠƒâƒ’";
const NotSupersetEqual = "âŠ‰";
const NotTilde = "â‰";
const NotTildeEqual = "â‰„";
const NotTildeFullEqual = "â‰‡";
const NotTildeTilde = "â‰‰";
const NotVerticalBar = "âˆ¤";
const nparallel = "âˆ¦";
const npar = "âˆ¦";
const nparsl = "â«½âƒ¥";
const npart = "âˆ‚Ì¸";
const npolint = "â¨”";
const npr = "âŠ€";
const nprcue = "â‹ ";
const nprec = "âŠ€";
const npreceq = "âª¯Ì¸";
const npre = "âª¯Ì¸";
const nrarrc = "â¤³Ì¸";
const nrarr = "â†›";
const nrArr = "â‡";
const nrarrw = "â†Ì¸";
const nrightarrow = "â†›";
const nRightarrow = "â‡";
const nrtri = "â‹«";
const nrtrie = "â‹­";
const nsc = "âŠ";
const nsccue = "â‹¡";
const nsce = "âª°Ì¸";
const Nscr = "ğ’©";
const nscr = "ğ“ƒ";
const nshortmid = "âˆ¤";
const nshortparallel = "âˆ¦";
const nsim = "â‰";
const nsime = "â‰„";
const nsimeq = "â‰„";
const nsmid = "âˆ¤";
const nspar = "âˆ¦";
const nsqsube = "â‹¢";
const nsqsupe = "â‹£";
const nsub = "âŠ„";
const nsubE = "â«…Ì¸";
const nsube = "âŠˆ";
const nsubset = "âŠ‚âƒ’";
const nsubseteq = "âŠˆ";
const nsubseteqq = "â«…Ì¸";
const nsucc = "âŠ";
const nsucceq = "âª°Ì¸";
const nsup = "âŠ…";
const nsupE = "â«†Ì¸";
const nsupe = "âŠ‰";
const nsupset = "âŠƒâƒ’";
const nsupseteq = "âŠ‰";
const nsupseteqq = "â«†Ì¸";
const ntgl = "â‰¹";
const Ntilde = "Ã‘";
const ntilde = "Ã±";
const ntlg = "â‰¸";
const ntriangleleft = "â‹ª";
const ntrianglelefteq = "â‹¬";
const ntriangleright = "â‹«";
const ntrianglerighteq = "â‹­";
const Nu = "Î";
const nu = "Î½";
const num = "#";
const numero = "â„–";
const numsp = "â€‡";
const nvap = "â‰âƒ’";
const nvdash = "âŠ¬";
const nvDash = "âŠ­";
const nVdash = "âŠ®";
const nVDash = "âŠ¯";
const nvge = "â‰¥âƒ’";
const nvgt = ">âƒ’";
const nvHarr = "â¤„";
const nvinfin = "â§";
const nvlArr = "â¤‚";
const nvle = "â‰¤âƒ’";
const nvlt = "<âƒ’";
const nvltrie = "âŠ´âƒ’";
const nvrArr = "â¤ƒ";
const nvrtrie = "âŠµâƒ’";
const nvsim = "âˆ¼âƒ’";
const nwarhk = "â¤£";
const nwarr = "â†–";
const nwArr = "â‡–";
const nwarrow = "â†–";
const nwnear = "â¤§";
const Oacute = "Ã“";
const oacute = "Ã³";
const oast = "âŠ›";
const Ocirc = "Ã”";
const ocirc = "Ã´";
const ocir = "âŠš";
const Ocy = "Ğ";
const ocy = "Ğ¾";
const odash = "âŠ";
const Odblac = "Å";
const odblac = "Å‘";
const odiv = "â¨¸";
const odot = "âŠ™";
const odsold = "â¦¼";
const OElig = "Å’";
const oelig = "Å“";
const ofcir = "â¦¿";
const Ofr = "ğ”’";
const ofr = "ğ”¬";
const ogon = "Ë›";
const Ograve = "Ã’";
const ograve = "Ã²";
const ogt = "â§";
const ohbar = "â¦µ";
const ohm = "Î©";
const oint = "âˆ®";
const olarr = "â†º";
const olcir = "â¦¾";
const olcross = "â¦»";
const oline = "â€¾";
const olt = "â§€";
const Omacr = "ÅŒ";
const omacr = "Å";
const Omega = "Î©";
const omega = "Ï‰";
const Omicron = "ÎŸ";
const omicron = "Î¿";
const omid = "â¦¶";
const ominus = "âŠ–";
const Oopf = "ğ•†";
const oopf = "ğ• ";
const opar = "â¦·";
const OpenCurlyDoubleQuote = "â€œ";
const OpenCurlyQuote = "â€˜";
const operp = "â¦¹";
const oplus = "âŠ•";
const orarr = "â†»";
const Or = "â©”";
const or = "âˆ¨";
const ord = "â©";
const order = "â„´";
const orderof = "â„´";
const ordf = "Âª";
const ordm = "Âº";
const origof = "âŠ¶";
const oror = "â©–";
const orslope = "â©—";
const orv = "â©›";
const oS = "â“ˆ";
const Oscr = "ğ’ª";
const oscr = "â„´";
const Oslash = "Ã˜";
const oslash = "Ã¸";
const osol = "âŠ˜";
const Otilde = "Ã•";
const otilde = "Ãµ";
const otimesas = "â¨¶";
const Otimes = "â¨·";
const otimes = "âŠ—";
const Ouml = "Ã–";
const ouml = "Ã¶";
const ovbar = "âŒ½";
const OverBar = "â€¾";
const OverBrace = "â";
const OverBracket = "â´";
const OverParenthesis = "âœ";
const para = "Â¶";
const parallel = "âˆ¥";
const par = "âˆ¥";
const parsim = "â«³";
const parsl = "â«½";
const part = "âˆ‚";
const PartialD = "âˆ‚";
const Pcy = "ĞŸ";
const pcy = "Ğ¿";
const percnt = "%";
const period = ".";
const permil = "â€°";
const perp = "âŠ¥";
const pertenk = "â€±";
const Pfr = "ğ”“";
const pfr = "ğ”­";
const Phi = "Î¦";
const phi = "Ï†";
const phiv = "Ï•";
const phmmat = "â„³";
const phone = "â˜";
const Pi = "Î ";
const pi = "Ï€";
const pitchfork = "â‹”";
const piv = "Ï–";
const planck = "â„";
const planckh = "â„";
const plankv = "â„";
const plusacir = "â¨£";
const plusb = "âŠ";
const pluscir = "â¨¢";
const plus = "+";
const plusdo = "âˆ”";
const plusdu = "â¨¥";
const pluse = "â©²";
const PlusMinus = "Â±";
const plusmn = "Â±";
const plussim = "â¨¦";
const plustwo = "â¨§";
const pm = "Â±";
const Poincareplane = "â„Œ";
const pointint = "â¨•";
const popf = "ğ•¡";
const Popf = "â„™";
const pound = "Â£";
const prap = "âª·";
const Pr = "âª»";
const pr = "â‰º";
const prcue = "â‰¼";
const precapprox = "âª·";
const prec = "â‰º";
const preccurlyeq = "â‰¼";
const Precedes = "â‰º";
const PrecedesEqual = "âª¯";
const PrecedesSlantEqual = "â‰¼";
const PrecedesTilde = "â‰¾";
const preceq = "âª¯";
const precnapprox = "âª¹";
const precneqq = "âªµ";
const precnsim = "â‹¨";
const pre = "âª¯";
const prE = "âª³";
const precsim = "â‰¾";
const prime = "â€²";
const Prime = "â€³";
const primes = "â„™";
const prnap = "âª¹";
const prnE = "âªµ";
const prnsim = "â‹¨";
const prod = "âˆ";
const Product = "âˆ";
const profalar = "âŒ®";
const profline = "âŒ’";
const profsurf = "âŒ“";
const prop = "âˆ";
const Proportional = "âˆ";
const Proportion = "âˆ·";
const propto = "âˆ";
const prsim = "â‰¾";
const prurel = "âŠ°";
const Pscr = "ğ’«";
const pscr = "ğ“…";
const Psi = "Î¨";
const psi = "Ïˆ";
const puncsp = "â€ˆ";
const Qfr = "ğ””";
const qfr = "ğ”®";
const qint = "â¨Œ";
const qopf = "ğ•¢";
const Qopf = "â„š";
const qprime = "â—";
const Qscr = "ğ’¬";
const qscr = "ğ“†";
const quaternions = "â„";
const quatint = "â¨–";
const quest = "?";
const questeq = "â‰Ÿ";
const quot = '"';
const QUOT = '"';
const rAarr = "â‡›";
const race = "âˆ½Ì±";
const Racute = "Å”";
const racute = "Å•";
const radic = "âˆš";
const raemptyv = "â¦³";
const rang = "âŸ©";
const Rang = "âŸ«";
const rangd = "â¦’";
const range = "â¦¥";
const rangle = "âŸ©";
const raquo = "Â»";
const rarrap = "â¥µ";
const rarrb = "â‡¥";
const rarrbfs = "â¤ ";
const rarrc = "â¤³";
const rarr = "â†’";
const Rarr = "â† ";
const rArr = "â‡’";
const rarrfs = "â¤";
const rarrhk = "â†ª";
const rarrlp = "â†¬";
const rarrpl = "â¥…";
const rarrsim = "â¥´";
const Rarrtl = "â¤–";
const rarrtl = "â†£";
const rarrw = "â†";
const ratail = "â¤š";
const rAtail = "â¤œ";
const ratio = "âˆ¶";
const rationals = "â„š";
const rbarr = "â¤";
const rBarr = "â¤";
const RBarr = "â¤";
const rbbrk = "â³";
const rbrace = "}";
const rbrack = "]";
const rbrke = "â¦Œ";
const rbrksld = "â¦";
const rbrkslu = "â¦";
const Rcaron = "Å˜";
const rcaron = "Å™";
const Rcedil = "Å–";
const rcedil = "Å—";
const rceil = "âŒ‰";
const rcub = "}";
const Rcy = "Ğ ";
const rcy = "Ñ€";
const rdca = "â¤·";
const rdldhar = "â¥©";
const rdquo = "â€";
const rdquor = "â€";
const rdsh = "â†³";
const real = "â„œ";
const realine = "â„›";
const realpart = "â„œ";
const reals = "â„";
const Re = "â„œ";
const rect = "â–­";
const reg = "Â®";
const REG = "Â®";
const ReverseElement = "âˆ‹";
const ReverseEquilibrium = "â‡‹";
const ReverseUpEquilibrium = "â¥¯";
const rfisht = "â¥½";
const rfloor = "âŒ‹";
const rfr = "ğ”¯";
const Rfr = "â„œ";
const rHar = "â¥¤";
const rhard = "â‡";
const rharu = "â‡€";
const rharul = "â¥¬";
const Rho = "Î¡";
const rho = "Ï";
const rhov = "Ï±";
const RightAngleBracket = "âŸ©";
const RightArrowBar = "â‡¥";
const rightarrow = "â†’";
const RightArrow = "â†’";
const Rightarrow = "â‡’";
const RightArrowLeftArrow = "â‡„";
const rightarrowtail = "â†£";
const RightCeiling = "âŒ‰";
const RightDoubleBracket = "âŸ§";
const RightDownTeeVector = "â¥";
const RightDownVectorBar = "â¥•";
const RightDownVector = "â‡‚";
const RightFloor = "âŒ‹";
const rightharpoondown = "â‡";
const rightharpoonup = "â‡€";
const rightleftarrows = "â‡„";
const rightleftharpoons = "â‡Œ";
const rightrightarrows = "â‡‰";
const rightsquigarrow = "â†";
const RightTeeArrow = "â†¦";
const RightTee = "âŠ¢";
const RightTeeVector = "â¥›";
const rightthreetimes = "â‹Œ";
const RightTriangleBar = "â§";
const RightTriangle = "âŠ³";
const RightTriangleEqual = "âŠµ";
const RightUpDownVector = "â¥";
const RightUpTeeVector = "â¥œ";
const RightUpVectorBar = "â¥”";
const RightUpVector = "â†¾";
const RightVectorBar = "â¥“";
const RightVector = "â‡€";
const ring = "Ëš";
const risingdotseq = "â‰“";
const rlarr = "â‡„";
const rlhar = "â‡Œ";
const rlm = "â€";
const rmoustache = "â±";
const rmoust = "â±";
const rnmid = "â«®";
const roang = "âŸ­";
const roarr = "â‡¾";
const robrk = "âŸ§";
const ropar = "â¦†";
const ropf = "ğ•£";
const Ropf = "â„";
const roplus = "â¨®";
const rotimes = "â¨µ";
const RoundImplies = "â¥°";
const rpar = ")";
const rpargt = "â¦”";
const rppolint = "â¨’";
const rrarr = "â‡‰";
const Rrightarrow = "â‡›";
const rsaquo = "â€º";
const rscr = "ğ“‡";
const Rscr = "â„›";
const rsh = "â†±";
const Rsh = "â†±";
const rsqb = "]";
const rsquo = "â€™";
const rsquor = "â€™";
const rthree = "â‹Œ";
const rtimes = "â‹Š";
const rtri = "â–¹";
const rtrie = "âŠµ";
const rtrif = "â–¸";
const rtriltri = "â§";
const RuleDelayed = "â§´";
const ruluhar = "â¥¨";
const rx = "â„";
const Sacute = "Åš";
const sacute = "Å›";
const sbquo = "â€š";
const scap = "âª¸";
const Scaron = "Å ";
const scaron = "Å¡";
const Sc = "âª¼";
const sc = "â‰»";
const sccue = "â‰½";
const sce = "âª°";
const scE = "âª´";
const Scedil = "Å";
const scedil = "ÅŸ";
const Scirc = "Åœ";
const scirc = "Å";
const scnap = "âªº";
const scnE = "âª¶";
const scnsim = "â‹©";
const scpolint = "â¨“";
const scsim = "â‰¿";
const Scy = "Ğ¡";
const scy = "Ñ";
const sdotb = "âŠ¡";
const sdot = "â‹…";
const sdote = "â©¦";
const searhk = "â¤¥";
const searr = "â†˜";
const seArr = "â‡˜";
const searrow = "â†˜";
const sect = "Â§";
const semi = ";";
const seswar = "â¤©";
const setminus = "âˆ–";
const setmn = "âˆ–";
const sext = "âœ¶";
const Sfr = "ğ”–";
const sfr = "ğ”°";
const sfrown = "âŒ¢";
const sharp = "â™¯";
const SHCHcy = "Ğ©";
const shchcy = "Ñ‰";
const SHcy = "Ğ¨";
const shcy = "Ñˆ";
const ShortDownArrow = "â†“";
const ShortLeftArrow = "â†";
const shortmid = "âˆ£";
const shortparallel = "âˆ¥";
const ShortRightArrow = "â†’";
const ShortUpArrow = "â†‘";
const shy = "Â­";
const Sigma = "Î£";
const sigma = "Ïƒ";
const sigmaf = "Ï‚";
const sigmav = "Ï‚";
const sim = "âˆ¼";
const simdot = "â©ª";
const sime = "â‰ƒ";
const simeq = "â‰ƒ";
const simg = "âª";
const simgE = "âª ";
const siml = "âª";
const simlE = "âªŸ";
const simne = "â‰†";
const simplus = "â¨¤";
const simrarr = "â¥²";
const slarr = "â†";
const SmallCircle = "âˆ˜";
const smallsetminus = "âˆ–";
const smashp = "â¨³";
const smeparsl = "â§¤";
const smid = "âˆ£";
const smile = "âŒ£";
const smt = "âªª";
const smte = "âª¬";
const smtes = "âª¬ï¸€";
const SOFTcy = "Ğ¬";
const softcy = "ÑŒ";
const solbar = "âŒ¿";
const solb = "â§„";
const sol = "/";
const Sopf = "ğ•Š";
const sopf = "ğ•¤";
const spades = "â™ ";
const spadesuit = "â™ ";
const spar = "âˆ¥";
const sqcap = "âŠ“";
const sqcaps = "âŠ“ï¸€";
const sqcup = "âŠ”";
const sqcups = "âŠ”ï¸€";
const Sqrt = "âˆš";
const sqsub = "âŠ";
const sqsube = "âŠ‘";
const sqsubset = "âŠ";
const sqsubseteq = "âŠ‘";
const sqsup = "âŠ";
const sqsupe = "âŠ’";
const sqsupset = "âŠ";
const sqsupseteq = "âŠ’";
const square = "â–¡";
const Square = "â–¡";
const SquareIntersection = "âŠ“";
const SquareSubset = "âŠ";
const SquareSubsetEqual = "âŠ‘";
const SquareSuperset = "âŠ";
const SquareSupersetEqual = "âŠ’";
const SquareUnion = "âŠ”";
const squarf = "â–ª";
const squ = "â–¡";
const squf = "â–ª";
const srarr = "â†’";
const Sscr = "ğ’®";
const sscr = "ğ“ˆ";
const ssetmn = "âˆ–";
const ssmile = "âŒ£";
const sstarf = "â‹†";
const Star = "â‹†";
const star = "â˜†";
const starf = "â˜…";
const straightepsilon = "Ïµ";
const straightphi = "Ï•";
const strns = "Â¯";
const sub = "âŠ‚";
const Sub = "â‹";
const subdot = "âª½";
const subE = "â«…";
const sube = "âŠ†";
const subedot = "â«ƒ";
const submult = "â«";
const subnE = "â«‹";
const subne = "âŠŠ";
const subplus = "âª¿";
const subrarr = "â¥¹";
const subset = "âŠ‚";
const Subset = "â‹";
const subseteq = "âŠ†";
const subseteqq = "â«…";
const SubsetEqual = "âŠ†";
const subsetneq = "âŠŠ";
const subsetneqq = "â«‹";
const subsim = "â«‡";
const subsub = "â«•";
const subsup = "â«“";
const succapprox = "âª¸";
const succ = "â‰»";
const succcurlyeq = "â‰½";
const Succeeds = "â‰»";
const SucceedsEqual = "âª°";
const SucceedsSlantEqual = "â‰½";
const SucceedsTilde = "â‰¿";
const succeq = "âª°";
const succnapprox = "âªº";
const succneqq = "âª¶";
const succnsim = "â‹©";
const succsim = "â‰¿";
const SuchThat = "âˆ‹";
const sum = "âˆ‘";
const Sum = "âˆ‘";
const sung = "â™ª";
const sup1 = "Â¹";
const sup2 = "Â²";
const sup3 = "Â³";
const sup = "âŠƒ";
const Sup = "â‹‘";
const supdot = "âª¾";
const supdsub = "â«˜";
const supE = "â«†";
const supe = "âŠ‡";
const supedot = "â«„";
const Superset = "âŠƒ";
const SupersetEqual = "âŠ‡";
const suphsol = "âŸ‰";
const suphsub = "â«—";
const suplarr = "â¥»";
const supmult = "â«‚";
const supnE = "â«Œ";
const supne = "âŠ‹";
const supplus = "â«€";
const supset = "âŠƒ";
const Supset = "â‹‘";
const supseteq = "âŠ‡";
const supseteqq = "â«†";
const supsetneq = "âŠ‹";
const supsetneqq = "â«Œ";
const supsim = "â«ˆ";
const supsub = "â«”";
const supsup = "â«–";
const swarhk = "â¤¦";
const swarr = "â†™";
const swArr = "â‡™";
const swarrow = "â†™";
const swnwar = "â¤ª";
const szlig = "ÃŸ";
const Tab = "	";
const target = "âŒ–";
const Tau = "Î¤";
const tau = "Ï„";
const tbrk = "â´";
const Tcaron = "Å¤";
const tcaron = "Å¥";
const Tcedil = "Å¢";
const tcedil = "Å£";
const Tcy = "Ğ¢";
const tcy = "Ñ‚";
const tdot = "âƒ›";
const telrec = "âŒ•";
const Tfr = "ğ”—";
const tfr = "ğ”±";
const there4 = "âˆ´";
const therefore = "âˆ´";
const Therefore = "âˆ´";
const Theta = "Î˜";
const theta = "Î¸";
const thetasym = "Ï‘";
const thetav = "Ï‘";
const thickapprox = "â‰ˆ";
const thicksim = "âˆ¼";
const ThickSpace = "âŸâ€Š";
const ThinSpace = "â€‰";
const thinsp = "â€‰";
const thkap = "â‰ˆ";
const thksim = "âˆ¼";
const THORN = "Ã";
const thorn = "Ã¾";
const tilde = "Ëœ";
const Tilde = "âˆ¼";
const TildeEqual = "â‰ƒ";
const TildeFullEqual = "â‰…";
const TildeTilde = "â‰ˆ";
const timesbar = "â¨±";
const timesb = "âŠ ";
const times = "Ã—";
const timesd = "â¨°";
const tint = "âˆ­";
const toea = "â¤¨";
const topbot = "âŒ¶";
const topcir = "â«±";
const top = "âŠ¤";
const Topf = "ğ•‹";
const topf = "ğ•¥";
const topfork = "â«š";
const tosa = "â¤©";
const tprime = "â€´";
const trade = "â„¢";
const TRADE = "â„¢";
const triangle = "â–µ";
const triangledown = "â–¿";
const triangleleft = "â—ƒ";
const trianglelefteq = "âŠ´";
const triangleq = "â‰œ";
const triangleright = "â–¹";
const trianglerighteq = "âŠµ";
const tridot = "â—¬";
const trie = "â‰œ";
const triminus = "â¨º";
const TripleDot = "âƒ›";
const triplus = "â¨¹";
const trisb = "â§";
const tritime = "â¨»";
const trpezium = "â¢";
const Tscr = "ğ’¯";
const tscr = "ğ“‰";
const TScy = "Ğ¦";
const tscy = "Ñ†";
const TSHcy = "Ğ‹";
const tshcy = "Ñ›";
const Tstrok = "Å¦";
const tstrok = "Å§";
const twixt = "â‰¬";
const twoheadleftarrow = "â†";
const twoheadrightarrow = "â† ";
const Uacute = "Ãš";
const uacute = "Ãº";
const uarr = "â†‘";
const Uarr = "â†Ÿ";
const uArr = "â‡‘";
const Uarrocir = "â¥‰";
const Ubrcy = "Ğ";
const ubrcy = "Ñ";
const Ubreve = "Å¬";
const ubreve = "Å­";
const Ucirc = "Ã›";
const ucirc = "Ã»";
const Ucy = "Ğ£";
const ucy = "Ñƒ";
const udarr = "â‡…";
const Udblac = "Å°";
const udblac = "Å±";
const udhar = "â¥®";
const ufisht = "â¥¾";
const Ufr = "ğ”˜";
const ufr = "ğ”²";
const Ugrave = "Ã™";
const ugrave = "Ã¹";
const uHar = "â¥£";
const uharl = "â†¿";
const uharr = "â†¾";
const uhblk = "â–€";
const ulcorn = "âŒœ";
const ulcorner = "âŒœ";
const ulcrop = "âŒ";
const ultri = "â—¸";
const Umacr = "Åª";
const umacr = "Å«";
const uml = "Â¨";
const UnderBar = "_";
const UnderBrace = "âŸ";
const UnderBracket = "âµ";
const UnderParenthesis = "â";
const Union = "â‹ƒ";
const UnionPlus = "âŠ";
const Uogon = "Å²";
const uogon = "Å³";
const Uopf = "ğ•Œ";
const uopf = "ğ•¦";
const UpArrowBar = "â¤’";
const uparrow = "â†‘";
const UpArrow = "â†‘";
const Uparrow = "â‡‘";
const UpArrowDownArrow = "â‡…";
const updownarrow = "â†•";
const UpDownArrow = "â†•";
const Updownarrow = "â‡•";
const UpEquilibrium = "â¥®";
const upharpoonleft = "â†¿";
const upharpoonright = "â†¾";
const uplus = "âŠ";
const UpperLeftArrow = "â†–";
const UpperRightArrow = "â†—";
const upsi = "Ï…";
const Upsi = "Ï’";
const upsih = "Ï’";
const Upsilon = "Î¥";
const upsilon = "Ï…";
const UpTeeArrow = "â†¥";
const UpTee = "âŠ¥";
const upuparrows = "â‡ˆ";
const urcorn = "âŒ";
const urcorner = "âŒ";
const urcrop = "âŒ";
const Uring = "Å®";
const uring = "Å¯";
const urtri = "â—¹";
const Uscr = "ğ’°";
const uscr = "ğ“Š";
const utdot = "â‹°";
const Utilde = "Å¨";
const utilde = "Å©";
const utri = "â–µ";
const utrif = "â–´";
const uuarr = "â‡ˆ";
const Uuml = "Ãœ";
const uuml = "Ã¼";
const uwangle = "â¦§";
const vangrt = "â¦œ";
const varepsilon = "Ïµ";
const varkappa = "Ï°";
const varnothing = "âˆ…";
const varphi = "Ï•";
const varpi = "Ï–";
const varpropto = "âˆ";
const varr = "â†•";
const vArr = "â‡•";
const varrho = "Ï±";
const varsigma = "Ï‚";
const varsubsetneq = "âŠŠï¸€";
const varsubsetneqq = "â«‹ï¸€";
const varsupsetneq = "âŠ‹ï¸€";
const varsupsetneqq = "â«Œï¸€";
const vartheta = "Ï‘";
const vartriangleleft = "âŠ²";
const vartriangleright = "âŠ³";
const vBar = "â«¨";
const Vbar = "â««";
const vBarv = "â«©";
const Vcy = "Ğ’";
const vcy = "Ğ²";
const vdash = "âŠ¢";
const vDash = "âŠ¨";
const Vdash = "âŠ©";
const VDash = "âŠ«";
const Vdashl = "â«¦";
const veebar = "âŠ»";
const vee = "âˆ¨";
const Vee = "â‹";
const veeeq = "â‰š";
const vellip = "â‹®";
const verbar = "|";
const Verbar = "â€–";
const vert = "|";
const Vert = "â€–";
const VerticalBar = "âˆ£";
const VerticalLine = "|";
const VerticalSeparator = "â˜";
const VerticalTilde = "â‰€";
const VeryThinSpace = "â€Š";
const Vfr = "ğ”™";
const vfr = "ğ”³";
const vltri = "âŠ²";
const vnsub = "âŠ‚âƒ’";
const vnsup = "âŠƒâƒ’";
const Vopf = "ğ•";
const vopf = "ğ•§";
const vprop = "âˆ";
const vrtri = "âŠ³";
const Vscr = "ğ’±";
const vscr = "ğ“‹";
const vsubnE = "â«‹ï¸€";
const vsubne = "âŠŠï¸€";
const vsupnE = "â«Œï¸€";
const vsupne = "âŠ‹ï¸€";
const Vvdash = "âŠª";
const vzigzag = "â¦š";
const Wcirc = "Å´";
const wcirc = "Åµ";
const wedbar = "â©Ÿ";
const wedge = "âˆ§";
const Wedge = "â‹€";
const wedgeq = "â‰™";
const weierp = "â„˜";
const Wfr = "ğ”š";
const wfr = "ğ”´";
const Wopf = "ğ•";
const wopf = "ğ•¨";
const wp = "â„˜";
const wr = "â‰€";
const wreath = "â‰€";
const Wscr = "ğ’²";
const wscr = "ğ“Œ";
const xcap = "â‹‚";
const xcirc = "â—¯";
const xcup = "â‹ƒ";
const xdtri = "â–½";
const Xfr = "ğ”›";
const xfr = "ğ”µ";
const xharr = "âŸ·";
const xhArr = "âŸº";
const Xi = "Î";
const xi = "Î¾";
const xlarr = "âŸµ";
const xlArr = "âŸ¸";
const xmap = "âŸ¼";
const xnis = "â‹»";
const xodot = "â¨€";
const Xopf = "ğ•";
const xopf = "ğ•©";
const xoplus = "â¨";
const xotime = "â¨‚";
const xrarr = "âŸ¶";
const xrArr = "âŸ¹";
const Xscr = "ğ’³";
const xscr = "ğ“";
const xsqcup = "â¨†";
const xuplus = "â¨„";
const xutri = "â–³";
const xvee = "â‹";
const xwedge = "â‹€";
const Yacute = "Ã";
const yacute = "Ã½";
const YAcy = "Ğ¯";
const yacy = "Ñ";
const Ycirc = "Å¶";
const ycirc = "Å·";
const Ycy = "Ğ«";
const ycy = "Ñ‹";
const yen = "Â¥";
const Yfr = "ğ”œ";
const yfr = "ğ”¶";
const YIcy = "Ğ‡";
const yicy = "Ñ—";
const Yopf = "ğ•";
const yopf = "ğ•ª";
const Yscr = "ğ’´";
const yscr = "ğ“";
const YUcy = "Ğ®";
const yucy = "Ñ";
const yuml = "Ã¿";
const Yuml = "Å¸";
const Zacute = "Å¹";
const zacute = "Åº";
const Zcaron = "Å½";
const zcaron = "Å¾";
const Zcy = "Ğ—";
const zcy = "Ğ·";
const Zdot = "Å»";
const zdot = "Å¼";
const zeetrf = "â„¨";
const ZeroWidthSpace = "â€‹";
const Zeta = "Î–";
const zeta = "Î¶";
const zfr = "ğ”·";
const Zfr = "â„¨";
const ZHcy = "Ğ–";
const zhcy = "Ğ¶";
const zigrarr = "â‡";
const zopf = "ğ•«";
const Zopf = "â„¤";
const Zscr = "ğ’µ";
const zscr = "ğ“";
const zwj = "â€";
const zwnj = "â€Œ";
const require$$0 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$2,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "âˆˆ",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "â¤…",
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities;
var hasRequiredEntities;
function requireEntities() {
  if (hasRequiredEntities) return entities;
  hasRequiredEntities = 1;
  entities = require$$0;
  return entities;
}
var regex$4;
var hasRequiredRegex$4;
function requireRegex$4() {
  if (hasRequiredRegex$4) return regex$4;
  hasRequiredRegex$4 = 1;
  regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  return regex$4;
}
var mdurl = {};
var encode_1;
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode_1;
  hasRequiredEncode = 1;
  var encodeCache = {};
  function getEncodeCache(exclude) {
    var i, ch, cache = encodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = encodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      if (/^[0-9a-z]$/i.test(ch)) {
        cache.push(ch);
      } else {
        cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
      }
    }
    for (i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }
    return cache;
  }
  function encode2(string, exclude, keepEscaped) {
    var i, l, code2, nextCode, cache, result = "";
    if (typeof exclude !== "string") {
      keepEscaped = exclude;
      exclude = encode2.defaultChars;
    }
    if (typeof keepEscaped === "undefined") {
      keepEscaped = true;
    }
    cache = getEncodeCache(exclude);
    for (i = 0, l = string.length; i < l; i++) {
      code2 = string.charCodeAt(i);
      if (keepEscaped && code2 === 37 && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
          result += string.slice(i, i + 3);
          i += 2;
          continue;
        }
      }
      if (code2 < 128) {
        result += cache[code2];
        continue;
      }
      if (code2 >= 55296 && code2 <= 57343) {
        if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
          nextCode = string.charCodeAt(i + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            result += encodeURIComponent(string[i] + string[i + 1]);
            i++;
            continue;
          }
        }
        result += "%EF%BF%BD";
        continue;
      }
      result += encodeURIComponent(string[i]);
    }
    return result;
  }
  encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode2.componentChars = "-_.!~*'()";
  encode_1 = encode2;
  return encode_1;
}
var decode_1;
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode_1;
  hasRequiredDecode = 1;
  var decodeCache = {};
  function getDecodeCache(exclude) {
    var i, ch, cache = decodeCache[exclude];
    if (cache) {
      return cache;
    }
    cache = decodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      cache.push(ch);
    }
    for (i = 0; i < exclude.length; i++) {
      ch = exclude.charCodeAt(i);
      cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
    }
    return cache;
  }
  function decode2(string, exclude) {
    var cache;
    if (typeof exclude !== "string") {
      exclude = decode2.defaultChars;
    }
    cache = getDecodeCache(exclude);
    return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
      var i, l, b1, b2, b3, b4, chr, result = "";
      for (i = 0, l = seq.length; i < l; i += 3) {
        b1 = parseInt(seq.slice(i + 1, i + 3), 16);
        if (b1 < 128) {
          result += cache[b1];
          continue;
        }
        if ((b1 & 224) === 192 && i + 3 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          if ((b2 & 192) === 128) {
            chr = b1 << 6 & 1984 | b2 & 63;
            if (chr < 128) {
              result += "ï¿½ï¿½";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 3;
            continue;
          }
        }
        if ((b1 & 240) === 224 && i + 6 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128) {
            chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
              result += "ï¿½ï¿½ï¿½";
            } else {
              result += String.fromCharCode(chr);
            }
            i += 6;
            continue;
          }
        }
        if ((b1 & 248) === 240 && i + 9 < l) {
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          b4 = parseInt(seq.slice(i + 10, i + 12), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
            chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
            if (chr < 65536 || chr > 1114111) {
              result += "ï¿½ï¿½ï¿½ï¿½";
            } else {
              chr -= 65536;
              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
            }
            i += 9;
            continue;
          }
        }
        result += "ï¿½";
      }
      return result;
    });
  }
  decode2.defaultChars = ";/?:@&=+$,#";
  decode2.componentChars = "";
  decode_1 = decode2;
  return decode_1;
}
var format;
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  format = function format2(url) {
    var result = "";
    result += url.protocol || "";
    result += url.slashes ? "//" : "";
    result += url.auth ? url.auth + "@" : "";
    if (url.hostname && url.hostname.indexOf(":") !== -1) {
      result += "[" + url.hostname + "]";
    } else {
      result += url.hostname || "";
    }
    result += url.port ? ":" + url.port : "";
    result += url.pathname || "";
    result += url.search || "";
    result += url.hash || "";
    return result;
  };
  return format;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
    "javascript": true,
    "javascript:": true
  }, slashedProtocol = {
    "http": true,
    "https": true,
    "ftp": true,
    "gopher": true,
    "file": true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) {
      return url;
    }
    var u = new Url();
    u.parse(url, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, slashesDenoteHost) {
    var i, l, lowerProto, hec, slashes, rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      if (rest[hostEnd - 1] === ":") {
        hostEnd--;
      }
      var host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost(host);
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part2 = hostparts[i];
          if (!part2) {
            continue;
          }
          if (!part2.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part2.length; j < k; j++) {
              if (part2.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part2[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part2.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      }
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "";
    }
    return this;
  };
  Url.prototype.parseHost = function(host) {
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  parse = urlParse;
  return parse;
}
var hasRequiredMdurl;
function requireMdurl() {
  if (hasRequiredMdurl) return mdurl;
  hasRequiredMdurl = 1;
  mdurl.encode = requireEncode();
  mdurl.decode = requireDecode();
  mdurl.format = requireFormat();
  mdurl.parse = requireParse();
  return mdurl;
}
var uc_micro = {};
var regex$3;
var hasRequiredRegex$3;
function requireRegex$3() {
  if (hasRequiredRegex$3) return regex$3;
  hasRequiredRegex$3 = 1;
  regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  return regex$3;
}
var regex$2;
var hasRequiredRegex$2;
function requireRegex$2() {
  if (hasRequiredRegex$2) return regex$2;
  hasRequiredRegex$2 = 1;
  regex$2 = /[\0-\x1F\x7F-\x9F]/;
  return regex$2;
}
var regex$1;
var hasRequiredRegex$1;
function requireRegex$1() {
  if (hasRequiredRegex$1) return regex$1;
  hasRequiredRegex$1 = 1;
  regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  return regex$1;
}
var regex;
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  return regex;
}
var hasRequiredUc_micro;
function requireUc_micro() {
  if (hasRequiredUc_micro) return uc_micro;
  hasRequiredUc_micro = 1;
  uc_micro.Any = requireRegex$3();
  uc_micro.Cc = requireRegex$2();
  uc_micro.Cf = requireRegex$1();
  uc_micro.P = requireRegex$4();
  uc_micro.Z = requireRegex();
  return uc_micro;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports$1) {
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has2(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src2, pos, newElements) {
      return [].concat(src2.slice(0, pos), newElements, src2.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
    var entities2 = requireEntities();
    function replaceEntityPattern(match, name) {
      var code2;
      if (has2(entities2, name)) {
        return entities2[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code2)) {
          return fromCodePoint(code2);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity2);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code2) {
      switch (code2) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code2) {
      if (code2 >= 8192 && code2 <= 8202) {
        return true;
      }
      switch (code2) {
        case 9:
        // \t
        case 10:
        // \n
        case 11:
        // \v
        case 12:
        // \f
        case 13:
        // \r
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = requireRegex$4();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("áº".toLowerCase() === "á¹¾") {
        str = str.replace(/áº/g, "ÃŸ");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports$1.lib = {};
    exports$1.lib.mdurl = requireMdurl();
    exports$1.lib.ucmicro = requireUc_micro();
    exports$1.assign = assign;
    exports$1.isString = isString;
    exports$1.has = has2;
    exports$1.unescapeMd = unescapeMd;
    exports$1.unescapeAll = unescapeAll;
    exports$1.isValidEntityCode = isValidEntityCode;
    exports$1.fromCodePoint = fromCodePoint;
    exports$1.escapeHtml = escapeHtml;
    exports$1.arrayReplaceAt = arrayReplaceAt;
    exports$1.isSpace = isSpace;
    exports$1.isWhiteSpace = isWhiteSpace;
    exports$1.isMdAsciiPunct = isMdAsciiPunct;
    exports$1.isPunctChar = isPunctChar;
    exports$1.escapeRE = escapeRE;
    exports$1.normalizeReference = normalizeReference;
  })(utils);
  return utils;
}
var helpers = {};
var parse_link_label;
var hasRequiredParse_link_label;
function requireParse_link_label() {
  if (hasRequiredParse_link_label) return parse_link_label;
  hasRequiredParse_link_label = 1;
  parse_link_label = function parseLinkLabel(state, start, disableNested) {
    var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
    state.pos = start + 1;
    level = 1;
    while (state.pos < max) {
      marker2 = state.src.charCodeAt(state.pos);
      if (marker2 === 93) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }
      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker2 === 91) {
        if (prevPos === state.pos - 1) {
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }
    if (found) {
      labelEnd = state.pos;
    }
    state.pos = oldPos;
    return labelEnd;
  };
  return parse_link_label;
}
var parse_link_destination;
var hasRequiredParse_link_destination;
function requireParse_link_destination() {
  if (hasRequiredParse_link_destination) return parse_link_destination;
  hasRequiredParse_link_destination = 1;
  var unescapeAll = requireUtils().unescapeAll;
  parse_link_destination = function parseLinkDestination(str, start, max) {
    var code2, level, pos = start, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === 10) {
          return result;
        }
        if (code2 === 60) {
          return result;
        }
        if (code2 === 62) {
          result.pos = pos + 1;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code2 === 92 && pos + 1 < max) {
          pos += 2;
          continue;
        }
        pos++;
      }
      return result;
    }
    level = 0;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 32) {
        break;
      }
      if (code2 < 32 || code2 === 127) {
        break;
      }
      if (code2 === 92 && pos + 1 < max) {
        if (str.charCodeAt(pos + 1) === 32) {
          break;
        }
        pos += 2;
        continue;
      }
      if (code2 === 40) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code2 === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll(str.slice(start, pos));
    result.pos = pos;
    result.ok = true;
    return result;
  };
  return parse_link_destination;
}
var parse_link_title;
var hasRequiredParse_link_title;
function requireParse_link_title() {
  if (hasRequiredParse_link_title) return parse_link_title;
  hasRequiredParse_link_title = 1;
  var unescapeAll = requireUtils().unescapeAll;
  parse_link_title = function parseLinkTitle(str, start, max) {
    var code2, marker2, lines = 0, pos = start, result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (pos >= max) {
      return result;
    }
    marker2 = str.charCodeAt(pos);
    if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
      return result;
    }
    pos++;
    if (marker2 === 40) {
      marker2 = 41;
    }
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === marker2) {
        result.pos = pos + 1;
        result.lines = lines;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      } else if (code2 === 40 && marker2 === 41) {
        return result;
      } else if (code2 === 10) {
        lines++;
      } else if (code2 === 92 && pos + 1 < max) {
        pos++;
        if (str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
      pos++;
    }
    return result;
  };
  return parse_link_title;
}
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  helpers.parseLinkLabel = requireParse_link_label();
  helpers.parseLinkDestination = requireParse_link_destination();
  helpers.parseLinkTitle = requireParse_link_title();
  return helpers;
}
var renderer;
var hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer) return renderer;
  hasRequiredRenderer = 1;
  var assign = requireUtils().assign;
  var unescapeAll = requireUtils().unescapeAll;
  var escapeHtml = requireUtils().escapeHtml;
  var default_rules = {};
  default_rules.code_inline = function(tokens, idx, options2, env, slf) {
    var token2 = tokens[idx];
    return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(token2.content) + "</code>";
  };
  default_rules.code_block = function(tokens, idx, options2, env, slf) {
    var token2 = tokens[idx];
    return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
  };
  default_rules.fence = function(tokens, idx, options2, env, slf) {
    var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
    if (info) {
      arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join("");
    }
    if (options2.highlight) {
      highlighted = options2.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
    } else {
      highlighted = escapeHtml(token2.content);
    }
    if (highlighted.indexOf("<pre") === 0) {
      return highlighted + "\n";
    }
    if (info) {
      i = token2.attrIndex("class");
      tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
      if (i < 0) {
        tmpAttrs.push(["class", options2.langPrefix + langName]);
      } else {
        tmpAttrs[i] = tmpAttrs[i].slice();
        tmpAttrs[i][1] += " " + options2.langPrefix + langName;
      }
      tmpToken = {
        attrs: tmpAttrs
      };
      return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
    }
    return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
  };
  default_rules.image = function(tokens, idx, options2, env, slf) {
    var token2 = tokens[idx];
    token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options2, env);
    return slf.renderToken(tokens, idx, options2);
  };
  default_rules.hardbreak = function(tokens, idx, options2) {
    return options2.xhtmlOut ? "<br />\n" : "<br>\n";
  };
  default_rules.softbreak = function(tokens, idx, options2) {
    return options2.breaks ? options2.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  };
  default_rules.text = function(tokens, idx) {
    return escapeHtml(tokens[idx].content);
  };
  default_rules.html_block = function(tokens, idx) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function(tokens, idx) {
    return tokens[idx].content;
  };
  function Renderer() {
    this.rules = assign({}, default_rules);
  }
  Renderer.prototype.renderAttrs = function renderAttrs(token2) {
    var i, l, result;
    if (!token2.attrs) {
      return "";
    }
    result = "";
    for (i = 0, l = token2.attrs.length; i < l; i++) {
      result += " " + escapeHtml(token2.attrs[i][0]) + '="' + escapeHtml(token2.attrs[i][1]) + '"';
    }
    return result;
  };
  Renderer.prototype.renderToken = function renderToken(tokens, idx, options2) {
    var nextToken, result = "", needLf = false, token2 = tokens[idx];
    if (token2.hidden) {
      return "";
    }
    if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += "\n";
    }
    result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
    result += this.renderAttrs(token2);
    if (token2.nesting === 0 && options2.xhtmlOut) {
      result += " /";
    }
    if (token2.block) {
      needLf = true;
      if (token2.nesting === 1) {
        if (idx + 1 < tokens.length) {
          nextToken = tokens[idx + 1];
          if (nextToken.type === "inline" || nextToken.hidden) {
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
            needLf = false;
          }
        }
      }
    }
    result += needLf ? ">\n" : ">";
    return result;
  };
  Renderer.prototype.renderInline = function(tokens, options2, env) {
    var type, result = "", rules2 = this.rules;
    for (var i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (typeof rules2[type] !== "undefined") {
        result += rules2[type](tokens, i, options2, env, this);
      } else {
        result += this.renderToken(tokens, i, options2);
      }
    }
    return result;
  };
  Renderer.prototype.renderInlineAsText = function(tokens, options2, env) {
    var result = "";
    for (var i = 0, len = tokens.length; i < len; i++) {
      if (tokens[i].type === "text") {
        result += tokens[i].content;
      } else if (tokens[i].type === "image") {
        result += this.renderInlineAsText(tokens[i].children, options2, env);
      } else if (tokens[i].type === "softbreak") {
        result += "\n";
      }
    }
    return result;
  };
  Renderer.prototype.render = function(tokens, options2, env) {
    var i, len, type, result = "", rules2 = this.rules;
    for (i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;
      if (type === "inline") {
        result += this.renderInline(tokens[i].children, options2, env);
      } else if (typeof rules2[type] !== "undefined") {
        result += rules2[type](tokens, i, options2, env, this);
      } else {
        result += this.renderToken(tokens, i, options2, env);
      }
    }
    return result;
  };
  renderer = Renderer;
  return renderer;
}
var ruler;
var hasRequiredRuler;
function requireRuler() {
  if (hasRequiredRuler) return ruler;
  hasRequiredRuler = 1;
  function Ruler() {
    this.__rules__ = [];
    this.__cache__ = null;
  }
  Ruler.prototype.__find__ = function(name) {
    for (var i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name) {
        return i;
      }
    }
    return -1;
  };
  Ruler.prototype.__compile__ = function() {
    var self2 = this;
    var chains = [""];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      rule.alt.forEach(function(altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });
    self2.__cache__ = {};
    chains.forEach(function(chain) {
      self2.__cache__[chain] = [];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }
        self2.__cache__[chain].push(rule.fn);
      });
    });
  };
  Ruler.prototype.at = function(name, fn, options2) {
    var index = this.__find__(name);
    var opt = options2 || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + name);
    }
    this.__rules__[index].fn = fn;
    this.__rules__[index].alt = opt.alt || [];
    this.__cache__ = null;
  };
  Ruler.prototype.before = function(beforeName, ruleName, fn, options2) {
    var index = this.__find__(beforeName);
    var opt = options2 || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(index, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.after = function(afterName, ruleName, fn, options2) {
    var index = this.__find__(afterName);
    var opt = options2 || {};
    if (index === -1) {
      throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(index + 1, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.push = function(ruleName, fn, options2) {
    var opt = options2 || {};
    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.enable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    var result = [];
    list2.forEach(function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = true;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    this.__rules__.forEach(function(rule) {
      rule.enabled = false;
    });
    this.enable(list2, ignoreInvalid);
  };
  Ruler.prototype.disable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    var result = [];
    list2.forEach(function(name) {
      var idx = this.__find__(name);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name);
      }
      this.__rules__[idx].enabled = false;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }
    return this.__cache__[chainName] || [];
  };
  ruler = Ruler;
  return ruler;
}
var normalize;
var hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize;
  hasRequiredNormalize = 1;
  var NEWLINES_RE = /\r\n?|\n/g;
  var NULL_RE = /\0/g;
  normalize = function normalize2(state) {
    var str;
    str = state.src.replace(NEWLINES_RE, "\n");
    str = str.replace(NULL_RE, "ï¿½");
    state.src = str;
  };
  return normalize;
}
var block;
var hasRequiredBlock;
function requireBlock() {
  if (hasRequiredBlock) return block;
  hasRequiredBlock = 1;
  block = function block2(state) {
    var token2;
    if (state.inlineMode) {
      token2 = new state.Token("inline", "", 0);
      token2.content = state.src;
      token2.map = [0, 1];
      token2.children = [];
      state.tokens.push(token2);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  };
  return block;
}
var inline;
var hasRequiredInline;
function requireInline() {
  if (hasRequiredInline) return inline;
  hasRequiredInline = 1;
  inline = function inline2(state) {
    var tokens = state.tokens, tok, i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      tok = tokens[i];
      if (tok.type === "inline") {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  };
  return inline;
}
var linkify$1;
var hasRequiredLinkify$1;
function requireLinkify$1() {
  if (hasRequiredLinkify$1) return linkify$1;
  hasRequiredLinkify$1 = 1;
  var arrayReplaceAt = requireUtils().arrayReplaceAt;
  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }
  linkify$1 = function linkify2(state) {
    var i, j, l, tokens, token2, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
    if (!state.md.options.linkify) {
      return;
    }
    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
        continue;
      }
      tokens = blockTokens[j].children;
      htmlLinkLevel = 0;
      for (i = tokens.length - 1; i >= 0; i--) {
        currentToken = tokens[i];
        if (currentToken.type === "link_close") {
          i--;
          while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
            i--;
          }
          continue;
        }
        if (currentToken.type === "html_inline") {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) {
          continue;
        }
        if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
          text2 = currentToken.content;
          links = state.md.linkify.match(text2);
          nodes = [];
          level = currentToken.level;
          lastPos = 0;
          if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
            links = links.slice(1);
          }
          for (ln = 0; ln < links.length; ln++) {
            url = links[ln].url;
            fullUrl = state.md.normalizeLink(url);
            if (!state.md.validateLink(fullUrl)) {
              continue;
            }
            urlText = links[ln].text;
            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }
            pos = links[ln].index;
            if (pos > lastPos) {
              token2 = new state.Token("text", "", 0);
              token2.content = text2.slice(lastPos, pos);
              token2.level = level;
              nodes.push(token2);
            }
            token2 = new state.Token("link_open", "a", 1);
            token2.attrs = [["href", fullUrl]];
            token2.level = level++;
            token2.markup = "linkify";
            token2.info = "auto";
            nodes.push(token2);
            token2 = new state.Token("text", "", 0);
            token2.content = urlText;
            token2.level = level;
            nodes.push(token2);
            token2 = new state.Token("link_close", "a", -1);
            token2.level = --level;
            token2.markup = "linkify";
            token2.info = "auto";
            nodes.push(token2);
            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text2.length) {
            token2 = new state.Token("text", "", 0);
            token2.content = text2.slice(lastPos);
            token2.level = level;
            nodes.push(token2);
          }
          blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  };
  return linkify$1;
}
var replacements;
var hasRequiredReplacements;
function requireReplacements() {
  if (hasRequiredReplacements) return replacements;
  hasRequiredReplacements = 1;
  var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
  var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
  var SCOPED_ABBR = {
    c: "Â©",
    r: "Â®",
    tm: "â„¢"
  };
  function replaceFn(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  }
  function replace_scoped(inlineTokens) {
    var i, token2, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token2 = inlineTokens[i];
      if (token2.type === "text" && !inside_autolink) {
        token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
      }
      if (token2.type === "link_open" && token2.info === "auto") {
        inside_autolink--;
      }
      if (token2.type === "link_close" && token2.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace_rare(inlineTokens) {
    var i, token2, inside_autolink = 0;
    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token2 = inlineTokens[i];
      if (token2.type === "text" && !inside_autolink) {
        if (RARE_RE.test(token2.content)) {
          token2.content = token2.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“");
        }
      }
      if (token2.type === "link_open" && token2.info === "auto") {
        inside_autolink--;
      }
      if (token2.type === "link_close" && token2.info === "auto") {
        inside_autolink++;
      }
    }
  }
  replacements = function replace(state) {
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline") {
        continue;
      }
      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }
      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  };
  return replacements;
}
var smartquotes;
var hasRequiredSmartquotes;
function requireSmartquotes() {
  if (hasRequiredSmartquotes) return smartquotes;
  hasRequiredSmartquotes = 1;
  var isWhiteSpace = requireUtils().isWhiteSpace;
  var isPunctChar = requireUtils().isPunctChar;
  var isMdAsciiPunct = requireUtils().isMdAsciiPunct;
  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE = "â€™";
  function replaceAt(str, index, ch) {
    return str.slice(0, index) + ch + str.slice(index + 1);
  }
  function process_inlines(tokens, state) {
    var i, token2, text2, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
    stack = [];
    for (i = 0; i < tokens.length; i++) {
      token2 = tokens[i];
      thisLevel = tokens[i].level;
      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) {
          break;
        }
      }
      stack.length = j + 1;
      if (token2.type !== "text") {
        continue;
      }
      text2 = token2.content;
      pos = 0;
      max = text2.length;
      OUTER:
        while (pos < max) {
          QUOTE_RE.lastIndex = pos;
          t = QUOTE_RE.exec(text2);
          if (!t) {
            break;
          }
          canOpen = canClose = true;
          pos = t.index + 1;
          isSingle = t[0] === "'";
          lastChar = 32;
          if (t.index - 1 >= 0) {
            lastChar = text2.charCodeAt(t.index - 1);
          } else {
            for (j = i - 1; j >= 0; j--) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
              if (!tokens[j].content) continue;
              lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
              break;
            }
          }
          nextChar = 32;
          if (pos < max) {
            nextChar = text2.charCodeAt(pos);
          } else {
            for (j = i + 1; j < tokens.length; j++) {
              if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
              if (!tokens[j].content) continue;
              nextChar = tokens[j].content.charCodeAt(0);
              break;
            }
          }
          isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
          isLastWhiteSpace = isWhiteSpace(lastChar);
          isNextWhiteSpace = isWhiteSpace(nextChar);
          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }
          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }
          if (nextChar === 34 && t[0] === '"') {
            if (lastChar >= 48 && lastChar <= 57) {
              canClose = canOpen = false;
            }
          }
          if (canOpen && canClose) {
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }
          if (!canOpen && !canClose) {
            if (isSingle) {
              token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
            }
            continue;
          }
          if (canClose) {
            for (j = stack.length - 1; j >= 0; j--) {
              item = stack[j];
              if (stack[j].level < thisLevel) {
                break;
              }
              if (item.single === isSingle && stack[j].level === thisLevel) {
                item = stack[j];
                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }
                token2.content = replaceAt(token2.content, t.index, closeQuote);
                tokens[item.token].content = replaceAt(
                  tokens[item.token].content,
                  item.pos,
                  openQuote
                );
                pos += closeQuote.length - 1;
                if (item.token === i) {
                  pos += openQuote.length - 1;
                }
                text2 = token2.content;
                max = text2.length;
                stack.length = j;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i,
              pos: t.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
          }
        }
    }
  }
  smartquotes = function smartquotes2(state) {
    var blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }
      process_inlines(state.tokens[blkIdx].children, state);
    }
  };
  return smartquotes;
}
var text_join;
var hasRequiredText_join;
function requireText_join() {
  if (hasRequiredText_join) return text_join;
  hasRequiredText_join = 1;
  text_join = function text_join2(state) {
    var j, l, tokens, curr, max, last, blockTokens = state.tokens;
    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== "inline") continue;
      tokens = blockTokens[j].children;
      max = tokens.length;
      for (curr = 0; curr < max; curr++) {
        if (tokens[curr].type === "text_special") {
          tokens[curr].type = "text";
        }
      }
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    }
  };
  return text_join;
}
var token$1;
var hasRequiredToken$1;
function requireToken$1() {
  if (hasRequiredToken$1) return token$1;
  hasRequiredToken$1 = 1;
  function Token(type, tag, nesting) {
    this.type = type;
    this.tag = tag;
    this.attrs = null;
    this.map = null;
    this.nesting = nesting;
    this.level = 0;
    this.children = null;
    this.content = "";
    this.markup = "";
    this.info = "";
    this.meta = null;
    this.block = false;
    this.hidden = false;
  }
  Token.prototype.attrIndex = function attrIndex(name) {
    var attrs, i, len;
    if (!this.attrs) {
      return -1;
    }
    attrs = this.attrs;
    for (i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name) {
        return i;
      }
    }
    return -1;
  };
  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [attrData];
    }
  };
  Token.prototype.attrSet = function attrSet(name, value) {
    var idx = this.attrIndex(name), attrData = [name, value];
    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  Token.prototype.attrGet = function attrGet(name) {
    var idx = this.attrIndex(name), value = null;
    if (idx >= 0) {
      value = this.attrs[idx][1];
    }
    return value;
  };
  Token.prototype.attrJoin = function attrJoin(name, value) {
    var idx = this.attrIndex(name);
    if (idx < 0) {
      this.attrPush([name, value]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
    }
  };
  token$1 = Token;
  return token$1;
}
var state_core;
var hasRequiredState_core;
function requireState_core() {
  if (hasRequiredState_core) return state_core;
  hasRequiredState_core = 1;
  var Token = requireToken$1();
  function StateCore(src2, md, env) {
    this.src = src2;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md;
  }
  StateCore.prototype.Token = Token;
  state_core = StateCore;
  return state_core;
}
var parser_core;
var hasRequiredParser_core;
function requireParser_core() {
  if (hasRequiredParser_core) return parser_core;
  hasRequiredParser_core = 1;
  var Ruler = requireRuler();
  var _rules = [
    ["normalize", requireNormalize()],
    ["block", requireBlock()],
    ["inline", requireInline()],
    ["linkify", requireLinkify$1()],
    ["replacements", requireReplacements()],
    ["smartquotes", requireSmartquotes()],
    // `text_join` finds `text_special` tokens (for escape sequences)
    // and joins them with the rest of the text
    ["text_join", requireText_join()]
  ];
  function Core() {
    this.ruler = new Ruler();
    for (var i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
  }
  Core.prototype.process = function(state) {
    var i, l, rules2;
    rules2 = this.ruler.getRules("");
    for (i = 0, l = rules2.length; i < l; i++) {
      rules2[i](state);
    }
  };
  Core.prototype.State = requireState_core();
  parser_core = Core;
  return parser_core;
}
var table$1;
var hasRequiredTable$1;
function requireTable$1() {
  if (hasRequiredTable$1) return table$1;
  hasRequiredTable$1 = 1;
  var isSpace = requireUtils().isSpace;
  function getLine(state, line) {
    var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
    return state.src.slice(pos, max);
  }
  function escapedSplit(str) {
    var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
    ch = str.charCodeAt(pos);
    while (pos < max) {
      if (ch === 124) {
        if (!isEscaped) {
          result.push(current + str.substring(lastPos, pos));
          current = "";
          lastPos = pos + 1;
        } else {
          current += str.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }
      isEscaped = ch === 92;
      pos++;
      ch = str.charCodeAt(pos);
    }
    result.push(current + str.substring(lastPos));
    return result;
  }
  table$1 = function table2(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, l, nextLine, columns, columnCount, token2, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
    if (startLine + 2 > endLine) {
      return false;
    }
    nextLine = startLine + 1;
    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    firstCh = state.src.charCodeAt(pos++);
    if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
      return false;
    }
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    secondCh = state.src.charCodeAt(pos++);
    if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
      return false;
    }
    if (firstCh === 45 && isSpace(secondCh)) {
      return false;
    }
    while (pos < state.eMarks[nextLine]) {
      ch = state.src.charCodeAt(pos);
      if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
        return false;
      }
      pos++;
    }
    lineText = getLine(state, startLine + 1);
    columns = lineText.split("|");
    aligns = [];
    for (i = 0; i < columns.length; i++) {
      t = columns[i].trim();
      if (!t) {
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }
      if (!/^:?-+:?$/.test(t)) {
        return false;
      }
      if (t.charCodeAt(t.length - 1) === 58) {
        aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
      } else if (t.charCodeAt(0) === 58) {
        aligns.push("left");
      } else {
        aligns.push("");
      }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
      return false;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) {
      return false;
    }
    if (silent) {
      return true;
    }
    oldParentType = state.parentType;
    state.parentType = "table";
    terminatorRules = state.md.block.ruler.getRules("blockquote");
    token2 = state.push("table_open", "table", 1);
    token2.map = tableLines = [startLine, 0];
    token2 = state.push("thead_open", "thead", 1);
    token2.map = [startLine, startLine + 1];
    token2 = state.push("tr_open", "tr", 1);
    token2.map = [startLine, startLine + 1];
    for (i = 0; i < columns.length; i++) {
      token2 = state.push("th_open", "th", 1);
      if (aligns[i]) {
        token2.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token2 = state.push("inline", "", 0);
      token2.content = columns[i].trim();
      token2.children = [];
      token2 = state.push("th_close", "th", -1);
    }
    token2 = state.push("tr_close", "tr", -1);
    token2 = state.push("thead_close", "thead", -1);
    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "") columns.shift();
      if (columns.length && columns[columns.length - 1] === "") columns.pop();
      if (nextLine === startLine + 2) {
        token2 = state.push("tbody_open", "tbody", 1);
        token2.map = tbodyLines = [startLine + 2, 0];
      }
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [nextLine, nextLine + 1];
      for (i = 0; i < columnCount; i++) {
        token2 = state.push("td_open", "td", 1);
        if (aligns[i]) {
          token2.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i] ? columns[i].trim() : "";
        token2.children = [];
        token2 = state.push("td_close", "td", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
    }
    if (tbodyLines) {
      token2 = state.push("tbody_close", "tbody", -1);
      tbodyLines[1] = nextLine;
    }
    token2 = state.push("table_close", "table", -1);
    tableLines[1] = nextLine;
    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  };
  return table$1;
}
var code;
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code;
  hasRequiredCode = 1;
  code = function code2(state, startLine, endLine) {
    var nextLine, last, token2;
    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }
    last = nextLine = startLine + 1;
    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }
      break;
    }
    state.line = last;
    token2 = state.push("code_block", "code", 0);
    token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
    token2.map = [startLine, state.line];
    return true;
  };
  return code;
}
var fence;
var hasRequiredFence;
function requireFence() {
  if (hasRequiredFence) return fence;
  hasRequiredFence = 1;
  fence = function fence2(state, startLine, endLine, silent) {
    var marker2, len, params2, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (pos + 3 > max) {
      return false;
    }
    marker2 = state.src.charCodeAt(pos);
    if (marker2 !== 126 && marker2 !== 96) {
      return false;
    }
    mem = pos;
    pos = state.skipChars(pos, marker2);
    len = pos - mem;
    if (len < 3) {
      return false;
    }
    markup = state.src.slice(mem, pos);
    params2 = state.src.slice(pos, max);
    if (marker2 === 96) {
      if (params2.indexOf(String.fromCharCode(marker2)) >= 0) {
        return false;
      }
    }
    if (silent) {
      return true;
    }
    nextLine = startLine;
    for (; ; ) {
      nextLine++;
      if (nextLine >= endLine) {
        break;
      }
      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.src.charCodeAt(pos) !== marker2) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        continue;
      }
      pos = state.skipChars(pos, marker2);
      if (pos - mem < len) {
        continue;
      }
      pos = state.skipSpaces(pos);
      if (pos < max) {
        continue;
      }
      haveEndMarker = true;
      break;
    }
    len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    token2 = state.push("fence", "code", 0);
    token2.info = params2;
    token2.content = state.getLines(startLine + 1, nextLine, len, true);
    token2.markup = markup;
    token2.map = [startLine, state.line];
    return true;
  };
  return fence;
}
var blockquote;
var hasRequiredBlockquote;
function requireBlockquote() {
  if (hasRequiredBlockquote) return blockquote;
  hasRequiredBlockquote = 1;
  var isSpace = requireUtils().isSpace;
  blockquote = function blockquote2(state, startLine, endLine, silent) {
    var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 62) {
      return false;
    }
    if (silent) {
      return true;
    }
    oldBMarks = [];
    oldBSCount = [];
    oldSCount = [];
    oldTShift = [];
    terminatorRules = state.md.block.ruler.getRules("blockquote");
    oldParentType = state.parentType;
    state.parentType = "blockquote";
    for (nextLine = startLine; nextLine < endLine; nextLine++) {
      isOutdented = state.sCount[nextLine] < state.blkIndent;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos >= max) {
        break;
      }
      if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
        initial = state.sCount[nextLine] + 1;
        if (state.src.charCodeAt(pos) === 32) {
          pos++;
          initial++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9) {
          spaceAfterMarker = true;
          if ((state.bsCount[nextLine] + initial) % 4 === 3) {
            pos++;
            initial++;
            adjustTab = false;
          } else {
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        offset = initial;
        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (isSpace(ch)) {
            if (ch === 9) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        lastLineEmpty = pos >= max;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }
      if (lastLineEmpty) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        state.lineMax = nextLine;
        if (state.blkIndent !== 0) {
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }
        break;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = -1;
    }
    oldIndent = state.blkIndent;
    state.blkIndent = 0;
    token2 = state.push("blockquote_open", "blockquote", 1);
    token2.markup = ">";
    token2.map = lines = [startLine, 0];
    state.md.block.tokenize(state, startLine, nextLine);
    token2 = state.push("blockquote_close", "blockquote", -1);
    token2.markup = ">";
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;
    for (i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }
    state.blkIndent = oldIndent;
    return true;
  };
  return blockquote;
}
var hr$1;
var hasRequiredHr$1;
function requireHr$1() {
  if (hasRequiredHr$1) return hr$1;
  hasRequiredHr$1 = 1;
  var isSpace = requireUtils().isSpace;
  hr$1 = function hr2(state, startLine, endLine, silent) {
    var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    marker2 = state.src.charCodeAt(pos++);
    if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
      return false;
    }
    cnt = 1;
    while (pos < max) {
      ch = state.src.charCodeAt(pos++);
      if (ch !== marker2 && !isSpace(ch)) {
        return false;
      }
      if (ch === marker2) {
        cnt++;
      }
    }
    if (cnt < 3) {
      return false;
    }
    if (silent) {
      return true;
    }
    state.line = startLine + 1;
    token2 = state.push("hr", "hr", 0);
    token2.map = [startLine, state.line];
    token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
    return true;
  };
  return hr$1;
}
var list;
var hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  var isSpace = requireUtils().isSpace;
  function skipBulletListMarker(state, startLine) {
    var marker2, pos, max, ch;
    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];
    marker2 = state.src.charCodeAt(pos++);
    if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function skipOrderedListMarker(state, startLine) {
    var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
    if (pos + 1 >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch < 48 || ch > 57) {
      return -1;
    }
    for (; ; ) {
      if (pos >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch >= 48 && ch <= 57) {
        if (pos - start >= 10) {
          return -1;
        }
        continue;
      }
      if (ch === 41 || ch === 46) {
        break;
      }
      return -1;
    }
    if (pos < max) {
      ch = state.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        return -1;
      }
    }
    return pos;
  }
  function markTightParagraphs(state, idx) {
    var i, l, level = state.level + 2;
    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }
  list = function list2(state, startLine, endLine, silent) {
    var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, nextLine = startLine, isTerminatingParagraph = false, tight = true;
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    if (silent && state.parentType === "paragraph") {
      if (state.sCount[nextLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }
    if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[nextLine] + state.tShift[nextLine];
      markerValue = Number(state.src.slice(start, posAfterMarker - 1));
      if (isTerminatingParagraph && markerValue !== 1) return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    }
    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
    }
    if (silent) {
      return true;
    }
    markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    listTokIdx = state.tokens.length;
    if (isOrdered) {
      token2 = state.push("ordered_list_open", "ol", 1);
      if (markerValue !== 1) {
        token2.attrs = [["start", markerValue]];
      }
    } else {
      token2 = state.push("bullet_list_open", "ul", 1);
    }
    token2.map = listLines = [nextLine, 0];
    token2.markup = String.fromCharCode(markerCharCode);
    prevEmptyEnd = false;
    terminatorRules = state.md.block.ruler.getRules("list");
    oldParentType = state.parentType;
    state.parentType = "list";
    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];
      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch === 9) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 32) {
          offset++;
        } else {
          break;
        }
        pos++;
      }
      contentStart = pos;
      if (contentStart >= max) {
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }
      if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      }
      indent = initial + indentAfterMarker;
      token2 = state.push("list_item_open", "li", 1);
      token2.markup = String.fromCharCode(markerCharCode);
      token2.map = itemLines = [nextLine, 0];
      if (isOrdered) {
        token2.info = state.src.slice(start, posAfterMarker - 1);
      }
      oldTight = state.tight;
      oldTShift = state.tShift[nextLine];
      oldSCount = state.sCount[nextLine];
      oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
      state.sCount[nextLine] = offset;
      if (contentStart >= max && state.isEmpty(nextLine + 1)) {
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, nextLine, endLine, true);
      }
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[nextLine] = oldTShift;
      state.sCount[nextLine] = oldSCount;
      state.tight = oldTight;
      token2 = state.push("list_item_close", "li", -1);
      token2.markup = String.fromCharCode(markerCharCode);
      nextLine = state.line;
      itemLines[1] = nextLine;
      if (nextLine >= endLine) {
        break;
      }
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      }
      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    }
    if (isOrdered) {
      token2 = state.push("ordered_list_close", "ol", -1);
    } else {
      token2 = state.push("bullet_list_close", "ul", -1);
    }
    token2.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType;
    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }
    return true;
  };
  return list;
}
var reference;
var hasRequiredReference;
function requireReference() {
  if (hasRequiredReference) return reference;
  hasRequiredReference = 1;
  var normalizeReference = requireUtils().normalizeReference;
  var isSpace = requireUtils().isSpace;
  reference = function reference2(state, startLine, _endLine, silent) {
    var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 91) {
      return false;
    }
    while (++pos < max) {
      if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
        if (pos + 1 === max) {
          return false;
        }
        if (state.src.charCodeAt(pos + 1) !== 58) {
          return false;
        }
        break;
      }
    }
    endLine = state.lineMax;
    terminatorRules = state.md.block.ruler.getRules("reference");
    oldParentType = state.parentType;
    state.parentType = "reference";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    max = str.length;
    for (pos = 1; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 91) {
        return false;
      } else if (ch === 93) {
        labelEnd = pos;
        break;
      } else if (ch === 10) {
        lines++;
      } else if (ch === 92) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 10) {
          lines++;
        }
      }
    }
    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
      return false;
    }
    for (pos = labelEnd + 2; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace(ch)) ;
      else {
        break;
      }
    }
    res = state.md.helpers.parseLinkDestination(str, pos, max);
    if (!res.ok) {
      return false;
    }
    href = state.md.normalizeLink(res.str);
    if (!state.md.validateLink(href)) {
      return false;
    }
    pos = res.pos;
    lines += res.lines;
    destEndPos = pos;
    destEndLineNo = lines;
    start = pos;
    for (; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 10) {
        lines++;
      } else if (isSpace(ch)) ;
      else {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(str, pos, max);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      lines += res.lines;
    } else {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
    }
    while (pos < max) {
      ch = str.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
      pos++;
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      if (title) {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
        while (pos < max) {
          ch = str.charCodeAt(pos);
          if (!isSpace(ch)) {
            break;
          }
          pos++;
        }
      }
    }
    if (pos < max && str.charCodeAt(pos) !== 10) {
      return false;
    }
    label = normalizeReference(str.slice(1, labelEnd));
    if (!label) {
      return false;
    }
    if (silent) {
      return true;
    }
    if (typeof state.env.references === "undefined") {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === "undefined") {
      state.env.references[label] = { title, href };
    }
    state.parentType = oldParentType;
    state.line = startLine + lines + 1;
    return true;
  };
  return reference;
}
var html_blocks;
var hasRequiredHtml_blocks;
function requireHtml_blocks() {
  if (hasRequiredHtml_blocks) return html_blocks;
  hasRequiredHtml_blocks = 1;
  html_blocks = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "section",
    "source",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  return html_blocks;
}
var html_re = {};
var hasRequiredHtml_re;
function requireHtml_re() {
  if (hasRequiredHtml_re) return html_re;
  hasRequiredHtml_re = 1;
  var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var unquoted = "[^\"'=<>`\\x00-\\x20]+";
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';
  var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
  var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
  var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
  var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
  var processing = "<[?][\\s\\S]*?[?]>";
  var declaration = "<![A-Z]+\\s+[^>]*>";
  var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
  var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
  html_re.HTML_TAG_RE = HTML_TAG_RE;
  html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  return html_re;
}
var html_block;
var hasRequiredHtml_block;
function requireHtml_block() {
  if (hasRequiredHtml_block) return html_block;
  hasRequiredHtml_block = 1;
  var block_names = requireHtml_blocks();
  var HTML_OPEN_CLOSE_TAG_RE = requireHtml_re().HTML_OPEN_CLOSE_TAG_RE;
  var HTML_SEQUENCES = [
    [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
    [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
  ];
  html_block = function html_block2(state, startLine, endLine, silent) {
    var i, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    lineText = state.src.slice(pos, max);
    for (i = 0; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) {
        break;
      }
    }
    if (i === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      return HTML_SEQUENCES[i][2];
    }
    nextLine = startLine + 1;
    if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);
        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    token2 = state.push("html_block", "", 0);
    token2.map = [startLine, nextLine];
    token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  };
  return html_block;
}
var heading;
var hasRequiredHeading;
function requireHeading() {
  if (hasRequiredHeading) return heading;
  hasRequiredHeading = 1;
  var isSpace = requireUtils().isSpace;
  heading = function heading2(state, startLine, endLine, silent) {
    var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    ch = state.src.charCodeAt(pos);
    if (ch !== 35 || pos >= max) {
      return false;
    }
    level = 1;
    ch = state.src.charCodeAt(++pos);
    while (ch === 35 && pos < max && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max && !isSpace(ch)) {
      return false;
    }
    if (silent) {
      return true;
    }
    max = state.skipSpacesBack(max, pos);
    tmp = state.skipCharsBack(max, 35, pos);
    if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }
    state.line = startLine + 1;
    token2 = state.push("heading_open", "h" + String(level), 1);
    token2.markup = "########".slice(0, level);
    token2.map = [startLine, state.line];
    token2 = state.push("inline", "", 0);
    token2.content = state.src.slice(pos, max).trim();
    token2.map = [startLine, state.line];
    token2.children = [];
    token2 = state.push("heading_close", "h" + String(level), -1);
    token2.markup = "########".slice(0, level);
    return true;
  };
  return heading;
}
var lheading;
var hasRequiredLheading;
function requireLheading() {
  if (hasRequiredLheading) return lheading;
  hasRequiredLheading = 1;
  lheading = function lheading2(state, startLine, endLine) {
    var content, terminate, i, l, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    oldParentType = state.parentType;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] >= state.blkIndent) {
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max) {
          marker2 = state.src.charCodeAt(pos);
          if (marker2 === 45 || marker2 === 61) {
            pos = state.skipChars(pos, marker2);
            pos = state.skipSpaces(pos);
            if (pos >= max) {
              level = marker2 === 61 ? 1 : 2;
              break;
            }
          }
        }
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    if (!level) {
      return false;
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    token2 = state.push("heading_open", "h" + String(level), 1);
    token2.markup = String.fromCharCode(marker2);
    token2.map = [startLine, state.line];
    token2 = state.push("inline", "", 0);
    token2.content = content;
    token2.map = [startLine, state.line - 1];
    token2.children = [];
    token2 = state.push("heading_close", "h" + String(level), -1);
    token2.markup = String.fromCharCode(marker2);
    state.parentType = oldParentType;
    return true;
  };
  return lheading;
}
var paragraph;
var hasRequiredParagraph;
function requireParagraph() {
  if (hasRequiredParagraph) return paragraph;
  hasRequiredParagraph = 1;
  paragraph = function paragraph2(state, startLine, endLine) {
    var content, terminate, i, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
    oldParentType = state.parentType;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    token2 = state.push("paragraph_open", "p", 1);
    token2.map = [startLine, state.line];
    token2 = state.push("inline", "", 0);
    token2.content = content;
    token2.map = [startLine, state.line];
    token2.children = [];
    token2 = state.push("paragraph_close", "p", -1);
    state.parentType = oldParentType;
    return true;
  };
  return paragraph;
}
var state_block;
var hasRequiredState_block;
function requireState_block() {
  if (hasRequiredState_block) return state_block;
  hasRequiredState_block = 1;
  var Token = requireToken$1();
  var isSpace = requireUtils().isSpace;
  function StateBlock(src2, md, env, tokens) {
    var ch, s, start, pos, len, indent, offset, indent_found;
    this.src = src2;
    this.md = md;
    this.env = env;
    this.tokens = tokens;
    this.bMarks = [];
    this.eMarks = [];
    this.tShift = [];
    this.sCount = [];
    this.bsCount = [];
    this.blkIndent = 0;
    this.line = 0;
    this.lineMax = 0;
    this.tight = false;
    this.ddIndent = -1;
    this.listIndent = -1;
    this.parentType = "root";
    this.level = 0;
    this.result = "";
    s = this.src;
    indent_found = false;
    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
      ch = s.charCodeAt(pos);
      if (!indent_found) {
        if (isSpace(ch)) {
          indent++;
          if (ch === 9) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }
      if (ch === 10 || pos === len - 1) {
        if (ch !== 10) {
          pos++;
        }
        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    }
    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1;
  }
  StateBlock.prototype.push = function(type, tag, nesting) {
    var token2 = new Token(type, tag, nesting);
    token2.block = true;
    if (nesting < 0) this.level--;
    token2.level = this.level;
    if (nesting > 0) this.level++;
    this.tokens.push(token2);
    return token2;
  };
  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };
  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (var max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };
  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    var ch;
    for (var max = this.src.length; pos < max; pos++) {
      ch = this.src.charCodeAt(pos);
      if (!isSpace(ch)) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (!isSpace(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipChars = function skipChars(pos, code2) {
    for (var max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code2) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (code2 !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
    if (begin >= end) {
      return "";
    }
    queue = new Array(end - begin);
    for (i = 0; line < end; line++, i++) {
      lineIndent = 0;
      lineStart = first = this.bMarks[line];
      if (line + 1 < end || keepLastLF) {
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }
      while (first < last && lineIndent < indent) {
        ch = this.src.charCodeAt(first);
        if (isSpace(ch)) {
          if (ch === 9) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          lineIndent++;
        } else {
          break;
        }
        first++;
      }
      if (lineIndent > indent) {
        queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
      } else {
        queue[i] = this.src.slice(first, last);
      }
    }
    return queue.join("");
  };
  StateBlock.prototype.Token = Token;
  state_block = StateBlock;
  return state_block;
}
var parser_block;
var hasRequiredParser_block;
function requireParser_block() {
  if (hasRequiredParser_block) return parser_block;
  hasRequiredParser_block = 1;
  var Ruler = requireRuler();
  var _rules = [
    // First 2 params - rule name & source. Secondary array - list of rules,
    // which can be terminated by this one.
    ["table", requireTable$1(), ["paragraph", "reference"]],
    ["code", requireCode()],
    ["fence", requireFence(), ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", requireBlockquote(), ["paragraph", "reference", "blockquote", "list"]],
    ["hr", requireHr$1(), ["paragraph", "reference", "blockquote", "list"]],
    ["list", requireList(), ["paragraph", "reference", "blockquote"]],
    ["reference", requireReference()],
    ["html_block", requireHtml_block(), ["paragraph", "reference", "blockquote"]],
    ["heading", requireHeading(), ["paragraph", "reference", "blockquote"]],
    ["lheading", requireLheading()],
    ["paragraph", requireParagraph()]
  ];
  function ParserBlock() {
    this.ruler = new Ruler();
    for (var i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
    }
  }
  ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    var ok, i, prevLine, rules2 = this.ruler.getRules(""), len = rules2.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) {
        break;
      }
      if (state.sCount[line] < state.blkIndent) {
        break;
      }
      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }
      prevLine = state.line;
      for (i = 0; i < len; i++) {
        ok = rules2[i](state, line, endLine, false);
        if (ok) {
          if (prevLine >= state.line) {
            throw new Error("block rule didn't increment state.line");
          }
          break;
        }
      }
      if (!ok) throw new Error("none of the block rules matched");
      state.tight = !hasEmptyLines;
      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }
      line = state.line;
      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  ParserBlock.prototype.parse = function(src2, md, env, outTokens) {
    var state;
    if (!src2) {
      return;
    }
    state = new this.State(src2, md, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };
  ParserBlock.prototype.State = requireState_block();
  parser_block = ParserBlock;
  return parser_block;
}
var text;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text;
  hasRequiredText = 1;
  function isTerminatorChar(ch) {
    switch (ch) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  text = function text2(state, silent) {
    var pos = state.pos;
    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }
    if (pos === state.pos) {
      return false;
    }
    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
  };
  return text;
}
var linkify;
var hasRequiredLinkify;
function requireLinkify() {
  if (hasRequiredLinkify) return linkify;
  hasRequiredLinkify = 1;
  var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  linkify = function linkify2(state, silent) {
    var pos, max, match, proto, link2, url, fullUrl, token2;
    if (!state.md.options.linkify) return false;
    if (state.linkLevel > 0) return false;
    pos = state.pos;
    max = state.posMax;
    if (pos + 3 > max) return false;
    if (state.src.charCodeAt(pos) !== 58) return false;
    if (state.src.charCodeAt(pos + 1) !== 47) return false;
    if (state.src.charCodeAt(pos + 2) !== 47) return false;
    match = state.pending.match(SCHEME_RE);
    if (!match) return false;
    proto = match[1];
    link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
    if (!link2) return false;
    url = link2.url;
    if (url.length <= proto.length) return false;
    url = url.replace(/\*+$/, "");
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) return false;
    if (!silent) {
      state.pending = state.pending.slice(0, -proto.length);
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "linkify";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "linkify";
      token2.info = "auto";
    }
    state.pos += url.length - proto.length;
    return true;
  };
  return linkify;
}
var newline;
var hasRequiredNewline;
function requireNewline() {
  if (hasRequiredNewline) return newline;
  hasRequiredNewline = 1;
  var isSpace = requireUtils().isSpace;
  newline = function newline2(state, silent) {
    var pmax, max, ws, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10) {
      return false;
    }
    pmax = state.pending.length - 1;
    max = state.posMax;
    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
          ws = pmax - 1;
          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
          state.pending = state.pending.slice(0, ws);
          state.push("hardbreak", "br", 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push("softbreak", "br", 0);
        }
      } else {
        state.push("softbreak", "br", 0);
      }
    }
    pos++;
    while (pos < max && isSpace(state.src.charCodeAt(pos))) {
      pos++;
    }
    state.pos = pos;
    return true;
  };
  return newline;
}
var _escape;
var hasRequired_escape;
function require_escape() {
  if (hasRequired_escape) return _escape;
  hasRequired_escape = 1;
  var isSpace = requireUtils().isSpace;
  var ESCAPED = [];
  for (var i = 0; i < 256; i++) {
    ESCAPED.push(0);
  }
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
  });
  _escape = function escape2(state, silent) {
    var ch1, ch2, origStr, escapedStr, token2, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 92) return false;
    pos++;
    if (pos >= max) return false;
    ch1 = state.src.charCodeAt(pos);
    if (ch1 === 10) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max) {
        ch1 = state.src.charCodeAt(pos);
        if (!isSpace(ch1)) break;
        pos++;
      }
      state.pos = pos;
      return true;
    }
    escapedStr = state.src[pos];
    if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
      ch2 = state.src.charCodeAt(pos + 1);
      if (ch2 >= 56320 && ch2 <= 57343) {
        escapedStr += state.src[pos + 1];
        pos++;
      }
    }
    origStr = "\\" + escapedStr;
    if (!silent) {
      token2 = state.push("text_special", "", 0);
      if (ch1 < 256 && ESCAPED[ch1] !== 0) {
        token2.content = escapedStr;
      } else {
        token2.content = origStr;
      }
      token2.markup = origStr;
      token2.info = "escape";
    }
    state.pos = pos + 1;
    return true;
  };
  return _escape;
}
var backticks;
var hasRequiredBackticks;
function requireBackticks() {
  if (hasRequiredBackticks) return backticks;
  hasRequiredBackticks = 1;
  backticks = function backtick(state, silent) {
    var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
    if (ch !== 96) {
      return false;
    }
    start = pos;
    pos++;
    max = state.posMax;
    while (pos < max && state.src.charCodeAt(pos) === 96) {
      pos++;
    }
    marker2 = state.src.slice(start, pos);
    openerLength = marker2.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent) state.pending += marker2;
      state.pos += openerLength;
      return true;
    }
    matchEnd = pos;
    while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
        matchEnd++;
      }
      closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        if (!silent) {
          token2 = state.push("code_inline", "code", 0);
          token2.markup = marker2;
          token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
        }
        state.pos = matchEnd;
        return true;
      }
      state.backticks[closerLength] = matchStart;
    }
    state.backticksScanned = true;
    if (!silent) state.pending += marker2;
    state.pos += openerLength;
    return true;
  };
  return backticks;
}
var strikethrough$1 = {};
var hasRequiredStrikethrough;
function requireStrikethrough() {
  if (hasRequiredStrikethrough) return strikethrough$1;
  hasRequiredStrikethrough = 1;
  strikethrough$1.tokenize = function strikethrough2(state, silent) {
    var i, scanned, token2, len, ch, start = state.pos, marker2 = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker2 !== 126) {
      return false;
    }
    scanned = state.scanDelims(state.pos, true);
    len = scanned.length;
    ch = String.fromCharCode(marker2);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      token2 = state.push("text", "", 0);
      token2.content = ch;
      len--;
    }
    for (i = 0; i < len; i += 2) {
      token2 = state.push("text", "", 0);
      token2.content = ch + ch;
      state.delimiters.push({
        marker: marker2,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess2(state, delimiters) {
    var i, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
    for (i = 0; i < max; i++) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 126) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      token2 = state.tokens[startDelim.token];
      token2.type = "s_open";
      token2.tag = "s";
      token2.nesting = 1;
      token2.markup = "~~";
      token2.content = "";
      token2 = state.tokens[endDelim.token];
      token2.type = "s_close";
      token2.tag = "s";
      token2.nesting = -1;
      token2.markup = "~~";
      token2.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      i = loneMarkers.pop();
      j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "s_close") {
        j++;
      }
      j--;
      if (i !== j) {
        token2 = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token2;
      }
    }
  }
  strikethrough$1.postProcess = function strikethrough2(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess2(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess2(state, tokens_meta[curr].delimiters);
      }
    }
  };
  return strikethrough$1;
}
var emphasis = {};
var hasRequiredEmphasis;
function requireEmphasis() {
  if (hasRequiredEmphasis) return emphasis;
  hasRequiredEmphasis = 1;
  emphasis.tokenize = function emphasis2(state, silent) {
    var i, scanned, token2, start = state.pos, marker2 = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker2 !== 95 && marker2 !== 42) {
      return false;
    }
    scanned = state.scanDelims(state.pos, marker2 === 42);
    for (i = 0; i < scanned.length; i++) {
      token2 = state.push("text", "", 0);
      token2.content = String.fromCharCode(marker2);
      state.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker: marker2,
        // Total length of these series of delimiters.
        //
        length: scanned.length,
        // A position of the token this delimiter corresponds to.
        //
        token: state.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  };
  function postProcess2(state, delimiters) {
    var i, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
    for (i = max - 1; i >= 0; i--) {
      startDelim = delimiters[i];
      if (startDelim.marker !== 95 && startDelim.marker !== 42) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      endDelim = delimiters[startDelim.end];
      isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
      delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
      delimiters[startDelim.end + 1].token === endDelim.token + 1;
      ch = String.fromCharCode(startDelim.marker);
      token2 = state.tokens[startDelim.token];
      token2.type = isStrong ? "strong_open" : "em_open";
      token2.tag = isStrong ? "strong" : "em";
      token2.nesting = 1;
      token2.markup = isStrong ? ch + ch : ch;
      token2.content = "";
      token2 = state.tokens[endDelim.token];
      token2.type = isStrong ? "strong_close" : "em_close";
      token2.tag = isStrong ? "strong" : "em";
      token2.nesting = -1;
      token2.markup = isStrong ? ch + ch : ch;
      token2.content = "";
      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = "";
        state.tokens[delimiters[startDelim.end + 1].token].content = "";
        i--;
      }
    }
  }
  emphasis.postProcess = function emphasis2(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    postProcess2(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess2(state, tokens_meta[curr].delimiters);
      }
    }
  };
  return emphasis;
}
var link$1;
var hasRequiredLink$1;
function requireLink$1() {
  if (hasRequiredLink$1) return link$1;
  hasRequiredLink$1 = 1;
  var normalizeReference = requireUtils().normalizeReference;
  var isSpace = requireUtils().isSpace;
  link$1 = function link2(state, silent) {
    var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    labelStart = state.pos + 1;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      parseReference = false;
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        }
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      token2 = state.push("link_open", "a", 1);
      token2.attrs = attrs = [["href", href]];
      if (title) {
        attrs.push(["title", title]);
      }
      state.linkLevel++;
      state.md.inline.tokenize(state);
      state.linkLevel--;
      token2 = state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
  return link$1;
}
var image$1;
var hasRequiredImage$1;
function requireImage$1() {
  if (hasRequiredImage$1) return image$1;
  hasRequiredImage$1 = 1;
  var normalizeReference = requireUtils().normalizeReference;
  var isSpace = requireUtils().isSpace;
  image$1 = function image2(state, silent) {
    var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    labelStart = state.pos + 2;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      state.md.inline.parse(
        content,
        state.md,
        state.env,
        tokens = []
      );
      token2 = state.push("image", "img", 0);
      token2.attrs = attrs = [["src", href], ["alt", ""]];
      token2.children = tokens;
      token2.content = content;
      if (title) {
        attrs.push(["title", title]);
      }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
  return image$1;
}
var autolink;
var hasRequiredAutolink;
function requireAutolink() {
  if (hasRequiredAutolink) return autolink;
  hasRequiredAutolink = 1;
  var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
  autolink = function autolink2(state, silent) {
    var url, fullUrl, token2, ch, start, max, pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    start = state.pos;
    max = state.posMax;
    for (; ; ) {
      if (++pos >= max) return false;
      ch = state.src.charCodeAt(pos);
      if (ch === 60) return false;
      if (ch === 62) break;
    }
    url = state.src.slice(start + 1, pos);
    if (AUTOLINK_RE.test(url)) {
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token2 = state.push("link_open", "a", 1);
        token2.attrs = [["href", fullUrl]];
        token2.markup = "autolink";
        token2.info = "auto";
        token2 = state.push("text", "", 0);
        token2.content = state.md.normalizeLinkText(url);
        token2 = state.push("link_close", "a", -1);
        token2.markup = "autolink";
        token2.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    if (EMAIL_RE.test(url)) {
      fullUrl = state.md.normalizeLink("mailto:" + url);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        token2 = state.push("link_open", "a", 1);
        token2.attrs = [["href", fullUrl]];
        token2.markup = "autolink";
        token2.info = "auto";
        token2 = state.push("text", "", 0);
        token2.content = state.md.normalizeLinkText(url);
        token2 = state.push("link_close", "a", -1);
        token2.markup = "autolink";
        token2.info = "auto";
      }
      state.pos += url.length + 2;
      return true;
    }
    return false;
  };
  return autolink;
}
var html_inline;
var hasRequiredHtml_inline;
function requireHtml_inline() {
  if (hasRequiredHtml_inline) return html_inline;
  hasRequiredHtml_inline = 1;
  var HTML_TAG_RE = requireHtml_re().HTML_TAG_RE;
  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }
  function isLetter(ch) {
    var lc = ch | 32;
    return lc >= 97 && lc <= 122;
  }
  html_inline = function html_inline2(state, silent) {
    var ch, match, max, token2, pos = state.pos;
    if (!state.md.options.html) {
      return false;
    }
    max = state.posMax;
    if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
      return false;
    }
    ch = state.src.charCodeAt(pos + 1);
    if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
      return false;
    }
    match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) {
      return false;
    }
    if (!silent) {
      token2 = state.push("html_inline", "", 0);
      token2.content = match[0];
      if (isLinkOpen(token2.content)) state.linkLevel++;
      if (isLinkClose(token2.content)) state.linkLevel--;
    }
    state.pos += match[0].length;
    return true;
  };
  return html_inline;
}
var entity;
var hasRequiredEntity;
function requireEntity() {
  if (hasRequiredEntity) return entity;
  hasRequiredEntity = 1;
  var entities2 = requireEntities();
  var has2 = requireUtils().has;
  var isValidEntityCode = requireUtils().isValidEntityCode;
  var fromCodePoint = requireUtils().fromCodePoint;
  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
  entity = function entity2(state, silent) {
    var ch, code2, match, token2, pos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(pos) !== 38) return false;
    if (pos + 1 >= max) return false;
    ch = state.src.charCodeAt(pos + 1);
    if (ch === 35) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          token2 = state.push("text_special", "", 0);
          token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
          token2.markup = match[0];
          token2.info = "entity";
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has2(entities2, match[1])) {
          if (!silent) {
            token2 = state.push("text_special", "", 0);
            token2.content = entities2[match[1]];
            token2.markup = match[0];
            token2.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
    return false;
  };
  return entity;
}
var balance_pairs;
var hasRequiredBalance_pairs;
function requireBalance_pairs() {
  if (hasRequiredBalance_pairs) return balance_pairs;
  hasRequiredBalance_pairs = 1;
  function processDelimiters(delimiters) {
    var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
    if (!max) return;
    var headerIdx = 0;
    var lastTokenIdx = -2;
    var jumps = [];
    for (closerIdx = 0; closerIdx < max; closerIdx++) {
      closer = delimiters[closerIdx];
      jumps.push(0);
      if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
        headerIdx = closerIdx;
      }
      lastTokenIdx = closer.token;
      closer.length = closer.length || 0;
      if (!closer.close) continue;
      if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
      }
      minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
      openerIdx = headerIdx - jumps[headerIdx] - 1;
      newMinOpenerIdx = openerIdx;
      for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
        opener = delimiters[openerIdx];
        if (opener.marker !== closer.marker) continue;
        if (opener.open && opener.end < 0) {
          isOddMatch = false;
          if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }
          if (!isOddMatch) {
            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
            jumps[openerIdx] = lastJump;
            closer.open = false;
            opener.end = closerIdx;
            opener.close = false;
            newMinOpenerIdx = -1;
            lastTokenIdx = -2;
            break;
          }
        }
      }
      if (newMinOpenerIdx !== -1) {
        openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
      }
    }
  }
  balance_pairs = function link_pairs(state) {
    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
    processDelimiters(state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(tokens_meta[curr].delimiters);
      }
    }
  };
  return balance_pairs;
}
var fragments_join;
var hasRequiredFragments_join;
function requireFragments_join() {
  if (hasRequiredFragments_join) return fragments_join;
  hasRequiredFragments_join = 1;
  fragments_join = function fragments_join2(state) {
    var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].nesting < 0) level--;
      tokens[curr].level = level;
      if (tokens[curr].nesting > 0) level++;
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  };
  return fragments_join;
}
var state_inline;
var hasRequiredState_inline;
function requireState_inline() {
  if (hasRequiredState_inline) return state_inline;
  hasRequiredState_inline = 1;
  var Token = requireToken$1();
  var isWhiteSpace = requireUtils().isWhiteSpace;
  var isPunctChar = requireUtils().isPunctChar;
  var isMdAsciiPunct = requireUtils().isMdAsciiPunct;
  function StateInline(src2, md, env, outTokens) {
    this.src = src2;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    this.cache = {};
    this.delimiters = [];
    this._prev_delimiters = [];
    this.backticks = {};
    this.backticksScanned = false;
    this.linkLevel = 0;
  }
  StateInline.prototype.pushPending = function() {
    var token2 = new Token("text", "", 0);
    token2.content = this.pending;
    token2.level = this.pendingLevel;
    this.tokens.push(token2);
    this.pending = "";
    return token2;
  };
  StateInline.prototype.push = function(type, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }
    var token2 = new Token(type, tag, nesting);
    var token_meta = null;
    if (nesting < 0) {
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }
    token2.level = this.level;
    if (nesting > 0) {
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = { delimiters: this.delimiters };
    }
    this.pendingLevel = this.level;
    this.tokens.push(token2);
    this.tokens_meta.push(token_meta);
    return token2;
  };
  StateInline.prototype.scanDelims = function(start, canSplitWord) {
    var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
    lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
    while (pos < max && this.src.charCodeAt(pos) === marker2) {
      pos++;
    }
    count = pos - start;
    nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
    isLastWhiteSpace = isWhiteSpace(lastChar);
    isNextWhiteSpace = isWhiteSpace(nextChar);
    if (isNextWhiteSpace) {
      left_flanking = false;
    } else if (isNextPunctChar) {
      if (!(isLastWhiteSpace || isLastPunctChar)) {
        left_flanking = false;
      }
    }
    if (isLastWhiteSpace) {
      right_flanking = false;
    } else if (isLastPunctChar) {
      if (!(isNextWhiteSpace || isNextPunctChar)) {
        right_flanking = false;
      }
    }
    if (!canSplitWord) {
      can_open = left_flanking && (!right_flanking || isLastPunctChar);
      can_close = right_flanking && (!left_flanking || isNextPunctChar);
    } else {
      can_open = left_flanking;
      can_close = right_flanking;
    }
    return {
      can_open,
      can_close,
      length: count
    };
  };
  StateInline.prototype.Token = Token;
  state_inline = StateInline;
  return state_inline;
}
var parser_inline;
var hasRequiredParser_inline;
function requireParser_inline() {
  if (hasRequiredParser_inline) return parser_inline;
  hasRequiredParser_inline = 1;
  var Ruler = requireRuler();
  var _rules = [
    ["text", requireText()],
    ["linkify", requireLinkify()],
    ["newline", requireNewline()],
    ["escape", require_escape()],
    ["backticks", requireBackticks()],
    ["strikethrough", requireStrikethrough().tokenize],
    ["emphasis", requireEmphasis().tokenize],
    ["link", requireLink$1()],
    ["image", requireImage$1()],
    ["autolink", requireAutolink()],
    ["html_inline", requireHtml_inline()],
    ["entity", requireEntity()]
  ];
  var _rules2 = [
    ["balance_pairs", requireBalance_pairs()],
    ["strikethrough", requireStrikethrough().postProcess],
    ["emphasis", requireEmphasis().postProcess],
    // rules for pairs separate '**' into its own text tokens, which may be left unused,
    // rule below merges unused segments back with the rest of the text
    ["fragments_join", requireFragments_join()]
  ];
  function ParserInline() {
    var i;
    this.ruler = new Ruler();
    for (i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
    this.ruler2 = new Ruler();
    for (i = 0; i < _rules2.length; i++) {
      this.ruler2.push(_rules2[i][0], _rules2[i][1]);
    }
  }
  ParserInline.prototype.skipToken = function(state) {
    var ok, i, pos = state.pos, rules2 = this.ruler.getRules(""), len = rules2.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
    if (typeof cache[pos] !== "undefined") {
      state.pos = cache[pos];
      return;
    }
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        state.level++;
        ok = rules2[i](state, true);
        state.level--;
        if (ok) {
          if (pos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    } else {
      state.pos = state.posMax;
    }
    if (!ok) {
      state.pos++;
    }
    cache[pos] = state.pos;
  };
  ParserInline.prototype.tokenize = function(state) {
    var ok, i, prevPos, rules2 = this.ruler.getRules(""), len = rules2.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
    while (state.pos < end) {
      prevPos = state.pos;
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          ok = rules2[i](state, false);
          if (ok) {
            if (prevPos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      }
      if (ok) {
        if (state.pos >= end) {
          break;
        }
        continue;
      }
      state.pending += state.src[state.pos++];
    }
    if (state.pending) {
      state.pushPending();
    }
  };
  ParserInline.prototype.parse = function(str, md, env, outTokens) {
    var i, rules2, len;
    var state = new this.State(str, md, env, outTokens);
    this.tokenize(state);
    rules2 = this.ruler2.getRules("");
    len = rules2.length;
    for (i = 0; i < len; i++) {
      rules2[i](state);
    }
  };
  ParserInline.prototype.State = requireState_inline();
  parser_inline = ParserInline;
  return parser_inline;
}
var re;
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re;
  hasRequiredRe = 1;
  re = function(opts) {
    var re2 = {};
    opts = opts || {};
    re2.src_Any = requireRegex$3().source;
    re2.src_Cc = requireRegex$2().source;
    re2.src_Z = requireRegex().source;
    re2.src_P = requireRegex$4().source;
    re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
    re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
    var text_separators = "[><ï½œ]";
    re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
    re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
    re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
    re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
    re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
    re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
    re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
    re2.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
    re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
    re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
    re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
    re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
    re2.src_host_strict = re2.src_host + re2.src_host_terminator;
    re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
    re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
    re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
    re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re2.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
    re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re2.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
    return re2;
  };
  return re;
}
var linkifyIt;
var hasRequiredLinkifyIt;
function requireLinkifyIt() {
  if (hasRequiredLinkifyIt) return linkifyIt;
  hasRequiredLinkifyIt = 1;
  function assign(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString(obj) {
    return _class(obj) === "[object String]";
  }
  function isObject(obj) {
    return _class(obj) === "[object Object]";
  }
  function isRegExp(obj) {
    return _class(obj) === "[object RegExp]";
  }
  function isFunction(obj) {
    return _class(obj) === "[object Function]";
  }
  function escapeRE(str) {
    return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  var defaultOptions = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };
  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function(acc, k) {
      return acc || defaultOptions.hasOwnProperty(k);
    }, false);
  }
  var defaultSchemas = {
    "http:": {
      validate: function(text2, pos, self2) {
        var tail = text2.slice(pos);
        if (!self2.re.http) {
          self2.re.http = new RegExp(
            "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.http.test(tail)) {
          return tail.match(self2.re.http)[0].length;
        }
        return 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(text2, pos, self2) {
        var tail = text2.slice(pos);
        if (!self2.re.no_http) {
          self2.re.no_http = new RegExp(
            "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.no_http.test(tail)) {
          if (pos >= 3 && text2[pos - 3] === ":") {
            return 0;
          }
          if (pos >= 3 && text2[pos - 3] === "/") {
            return 0;
          }
          return tail.match(self2.re.no_http)[0].length;
        }
        return 0;
      }
    },
    "mailto:": {
      validate: function(text2, pos, self2) {
        var tail = text2.slice(pos);
        if (!self2.re.mailto) {
          self2.re.mailto = new RegExp(
            "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
            "i"
          );
        }
        if (self2.re.mailto.test(tail)) {
          return tail.match(self2.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };
  var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
  var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
  function resetScanCache(self2) {
    self2.__index__ = -1;
    self2.__text_cache__ = "";
  }
  function createValidator(re2) {
    return function(text2, pos) {
      var tail = text2.slice(pos);
      if (re2.test(tail)) {
        return tail.match(re2)[0].length;
      }
      return 0;
    };
  }
  function createNormalizer() {
    return function(match, self2) {
      self2.normalize(match);
    };
  }
  function compile(self2) {
    var re2 = self2.re = requireRe()(self2.__opts__);
    var tlds = self2.__tlds__.slice();
    self2.onCompile();
    if (!self2.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }
    tlds.push(re2.src_xn);
    re2.src_tlds = tlds.join("|");
    function untpl(tpl) {
      return tpl.replace("%TLDS%", re2.src_tlds);
    }
    re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
    re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
    re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
    re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
    var aliases = [];
    self2.__compiled__ = {};
    function schemaError(name, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
    }
    Object.keys(self2.__schemas__).forEach(function(name) {
      var val = self2.__schemas__[name];
      if (val === null) {
        return;
      }
      var compiled = { validate: null, link: null };
      self2.__compiled__[name] = compiled;
      if (isObject(val)) {
        if (isRegExp(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name, val);
        }
        if (isFunction(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name, val);
        }
        return;
      }
      if (isString(val)) {
        aliases.push(name);
        return;
      }
      schemaError(name, val);
    });
    aliases.forEach(function(alias) {
      if (!self2.__compiled__[self2.__schemas__[alias]]) {
        return;
      }
      self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
      self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
    });
    self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
    var slist = Object.keys(self2.__compiled__).filter(function(name) {
      return name.length > 0 && self2.__compiled__[name];
    }).map(escapeRE).join("|");
    self2.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
    self2.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
    self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
    self2.re.pretest = RegExp(
      "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
      "i"
    );
    resetScanCache(self2);
  }
  function Match(self2, shift) {
    var start = self2.__index__, end = self2.__last_index__, text2 = self2.__text_cache__.slice(start, end);
    this.schema = self2.__schema__.toLowerCase();
    this.index = start + shift;
    this.lastIndex = end + shift;
    this.raw = text2;
    this.text = text2;
    this.url = text2;
  }
  function createMatch(self2, shift) {
    var match = new Match(self2, shift);
    self2.__compiled__[match.schema].normalize(match, self2);
    return match;
  }
  function LinkifyIt(schemas, options2) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas, options2);
    }
    if (!options2) {
      if (isOptionsObj(schemas)) {
        options2 = schemas;
        schemas = {};
      }
    }
    this.__opts__ = assign({}, defaultOptions, options2);
    this.__index__ = -1;
    this.__last_index__ = -1;
    this.__schema__ = "";
    this.__text_cache__ = "";
    this.__schemas__ = assign({}, defaultSchemas, schemas);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile(this);
  }
  LinkifyIt.prototype.add = function add(schema, definition) {
    this.__schemas__[schema] = definition;
    compile(this);
    return this;
  };
  LinkifyIt.prototype.set = function set(options2) {
    this.__opts__ = assign(this.__opts__, options2);
    return this;
  };
  LinkifyIt.prototype.test = function test(text2) {
    this.__text_cache__ = text2;
    this.__index__ = -1;
    if (!text2.length) {
      return false;
    }
    var m, ml, me, len, shift, next2, re2, tld_pos, at_pos;
    if (this.re.schema_test.test(text2)) {
      re2 = this.re.schema_search;
      re2.lastIndex = 0;
      while ((m = re2.exec(text2)) !== null) {
        len = this.testSchemaAt(text2, m[2], re2.lastIndex);
        if (len) {
          this.__schema__ = m[2];
          this.__index__ = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }
    if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
      tld_pos = text2.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml.index + ml[1].length;
            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = "";
              this.__index__ = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }
    if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
      at_pos = text2.indexOf("@");
      if (at_pos >= 0) {
        if ((me = text2.match(this.re.email_fuzzy)) !== null) {
          shift = me.index + me[1].length;
          next2 = me.index + me[0].length;
          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
            this.__schema__ = "mailto:";
            this.__index__ = shift;
            this.__last_index__ = next2;
          }
        }
      }
    }
    return this.__index__ >= 0;
  };
  LinkifyIt.prototype.pretest = function pretest(text2) {
    return this.re.pretest.test(text2);
  };
  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
    if (!this.__compiled__[schema.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
  };
  LinkifyIt.prototype.match = function match(text2) {
    var shift = 0, result = [];
    if (this.__index__ >= 0 && this.__text_cache__ === text2) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }
    var tail = shift ? text2.slice(shift) : text2;
    while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }
    if (result.length) {
      return result;
    }
    return null;
  };
  LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
    this.__text_cache__ = text2;
    this.__index__ = -1;
    if (!text2.length) return null;
    var m = this.re.schema_at_start.exec(text2);
    if (!m) return null;
    var len = this.testSchemaAt(text2, m[2], m[0].length);
    if (!len) return null;
    this.__schema__ = m[2];
    this.__index__ = m.index + m[1].length;
    this.__last_index__ = m.index + m[0].length + len;
    return createMatch(this, 0);
  };
  LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
    list2 = Array.isArray(list2) ? list2 : [list2];
    if (!keepOld) {
      this.__tlds__ = list2.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }
    this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el2, idx, arr) {
      return el2 !== arr[idx - 1];
    }).reverse();
    compile(this);
    return this;
  };
  LinkifyIt.prototype.normalize = function normalize2(match) {
    if (!match.schema) {
      match.url = "http://" + match.url;
    }
    if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
      match.url = "mailto:" + match.url;
    }
  };
  LinkifyIt.prototype.onCompile = function onCompile() {
  };
  linkifyIt = LinkifyIt;
  return linkifyIt;
}
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output2 = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output2.push(value);
        counter--;
      }
    } else {
      output2.push(value);
    }
  }
  return output2;
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta2, numPoints, firstTime) {
  let k = 0;
  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
  delta2 += floor(delta2 / numPoints);
  for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {
    delta2 = floor(delta2 / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
};
const decode = function(input) {
  const output2 = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output2.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output2.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output2.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output2);
};
const encode = function(input) {
  const output2 = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta2 = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output2.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output2.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output2.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta2) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta2 += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta2 > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta2;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output2.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output2.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount === basicLength);
        delta2 = 0;
        ++handledCPCount;
      }
    }
    ++delta2;
    ++n;
  }
  return output2.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
};
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode,
  default: punycode,
  encode,
  toASCII,
  toUnicode,
  ucs2decode,
  ucs2encode
}, Symbol.toStringTag, { value: "Module" }));
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var _default;
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  _default = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
      // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
      quotes: "â€œâ€â€˜â€™",
      /* â€œâ€â€˜â€™ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 100
      // Internal protection, recursion limit
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };
  return _default;
}
var zero;
var hasRequiredZero;
function requireZero() {
  if (hasRequiredZero) return zero;
  hasRequiredZero = 1;
  zero = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
      // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
      quotes: "â€œâ€â€˜â€™",
      /* â€œâ€â€˜â€™ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20
      // Internal protection, recursion limit
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "text"
        ],
        rules2: [
          "balance_pairs",
          "fragments_join"
        ]
      }
    }
  };
  return zero;
}
var commonmark;
var hasRequiredCommonmark;
function requireCommonmark() {
  if (hasRequiredCommonmark) return commonmark;
  hasRequiredCommonmark = 1;
  commonmark = {
    options: {
      html: true,
      // Enable HTML tags in source
      xhtmlOut: true,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: "language-",
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
      // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
      quotes: "â€œâ€â€˜â€™",
      /* â€œâ€â€˜â€™ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20
      // Internal protection, recursion limit
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text"
        ],
        rules2: [
          "balance_pairs",
          "emphasis",
          "fragments_join"
        ]
      }
    }
  };
  return commonmark;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var utils2 = requireUtils();
  var helpers2 = requireHelpers();
  var Renderer = requireRenderer();
  var ParserCore = requireParser_core();
  var ParserBlock = requireParser_block();
  var ParserInline = requireParser_inline();
  var LinkifyIt = requireLinkifyIt();
  var mdurl2 = requireMdurl();
  var punycode2 = require$$8;
  var config = {
    default: require_default(),
    zero: requireZero(),
    commonmark: requireCommonmark()
  };
  var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
  function validateLink(url) {
    var str = url.trim().toLowerCase();
    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
  }
  var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
  function normalizeLink(url) {
    var parsed = mdurl2.parse(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode2.toASCII(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return mdurl2.encode(mdurl2.format(parsed));
  }
  function normalizeLinkText(url) {
    var parsed = mdurl2.parse(url, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode2.toUnicode(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return mdurl2.decode(mdurl2.format(parsed), mdurl2.decode.defaultChars + "%");
  }
  function MarkdownIt(presetName, options2) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options2);
    }
    if (!options2) {
      if (!utils2.isString(presetName)) {
        options2 = presetName || {};
        presetName = "default";
      }
    }
    this.inline = new ParserInline();
    this.block = new ParserBlock();
    this.core = new ParserCore();
    this.renderer = new Renderer();
    this.linkify = new LinkifyIt();
    this.validateLink = validateLink;
    this.normalizeLink = normalizeLink;
    this.normalizeLinkText = normalizeLinkText;
    this.utils = utils2;
    this.helpers = utils2.assign({}, helpers2);
    this.options = {};
    this.configure(presetName);
    if (options2) {
      this.set(options2);
    }
  }
  MarkdownIt.prototype.set = function(options2) {
    utils2.assign(this.options, options2);
    return this;
  };
  MarkdownIt.prototype.configure = function(presets) {
    var self2 = this, presetName;
    if (utils2.isString(presets)) {
      presetName = presets;
      presets = config[presetName];
      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }
    if (!presets) {
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    }
    if (presets.options) {
      self2.set(presets.options);
    }
    if (presets.components) {
      Object.keys(presets.components).forEach(function(name) {
        if (presets.components[name].rules) {
          self2[name].ruler.enableOnly(presets.components[name].rules);
        }
        if (presets.components[name].rules2) {
          self2[name].ruler2.enableOnly(presets.components[name].rules2);
        }
      });
    }
    return this;
  };
  MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.enable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.enable(list2, true));
    var missed = list2.filter(function(name) {
      return result.indexOf(name) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
    var result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.disable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.disable(list2, true));
    var missed = list2.filter(function(name) {
      return result.indexOf(name) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.use = function(plugin2) {
    var args = [this].concat(Array.prototype.slice.call(arguments, 1));
    plugin2.apply(plugin2, args);
    return this;
  };
  MarkdownIt.prototype.parse = function(src2, env) {
    if (typeof src2 !== "string") {
      throw new Error("Input data should be a String");
    }
    var state = new this.core.State(src2, this, env);
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.render = function(src2, env) {
    env = env || {};
    return this.renderer.render(this.parse(src2, env), this.options, env);
  };
  MarkdownIt.prototype.parseInline = function(src2, env) {
    var state = new this.core.State(src2, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.renderInline = function(src2, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src2, env), this.options, env);
  };
  lib = MarkdownIt;
  return lib;
}
var markdownIt;
var hasRequiredMarkdownIt;
function requireMarkdownIt() {
  if (hasRequiredMarkdownIt) return markdownIt;
  hasRequiredMarkdownIt = 1;
  markdownIt = requireLib();
  return markdownIt;
}
var markdownItExports = requireMarkdownIt();
const Markdown = /* @__PURE__ */ getDefaultExportFromCjs(markdownItExports);
const ICONS = {
  note: `<svg class="octicon octicon-info" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path stroke="currentColor" d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>`,
  tip: `<svg class="octicon octicon-lightbulb" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path stroke="currentColor" d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"/></svg>`,
  important: `<svg class="octicon octicon-report" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path stroke="currentColor" d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>`,
  warning: `<svg class="octicon octicon-alert" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path stroke="currentColor" d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>`,
  caution: `<svg class="octicon octicon-stop" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path stroke="currentColor" d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>`
};
const DEFAULT_TYPES = {
  note: { label: "Note", icon: ICONS.note },
  tip: { label: "Tip", icon: ICONS.tip },
  important: { label: "Important", icon: ICONS.important },
  warning: { label: "Warning", icon: ICONS.warning },
  caution: { label: "Caution", icon: ICONS.caution }
};
function findBlockquoteClose(tokens, bqStart) {
  let depth = 0;
  for (let j = bqStart; j < tokens.length; j++) {
    if (tokens[j].type === "blockquote_open") depth++;
    if (tokens[j].type === "blockquote_close") {
      depth--;
      if (depth === 0) return j;
    }
  }
  return -1;
}
function countInlineTokens(tokens, bqStart, bqEnd) {
  let count = 0;
  let depth = 0;
  for (let j = bqStart; j <= bqEnd; j++) {
    if (tokens[j].type === "blockquote_open") depth++;
    if (tokens[j].type === "blockquote_close") depth--;
    if (depth === 1 && tokens[j].type === "inline") count++;
  }
  return count;
}
function findFirstDirectInline(tokens, bqStart, bqEnd) {
  let depth = 0;
  for (let j = bqStart; j <= bqEnd; j++) {
    if (tokens[j].type === "blockquote_open") depth++;
    if (tokens[j].type === "blockquote_close") depth--;
    if (depth === 1 && tokens[j].type === "inline") return j;
  }
  return -1;
}
function alertsPlugin(md, options2 = {}) {
  const ignoreUnknown = options2.ignoreUnknownTypes !== false;
  const alertTypes = Object.assign({}, DEFAULT_TYPES, options2.types || {});
  md.core.ruler.push("github_alerts", (state) => {
    const tokens = state.tokens;
    let i = 0;
    while (i < tokens.length) {
      if (tokens[i].type !== "blockquote_open") {
        i++;
        continue;
      }
      const bqStart = i;
      const bqEnd = findBlockquoteClose(tokens, bqStart);
      if (bqEnd === -1) {
        i++;
        continue;
      }
      const firstInlineIdx = findFirstDirectInline(tokens, bqStart, bqEnd);
      if (firstInlineIdx === -1) {
        i++;
        continue;
      }
      const rawContent = tokens[firstInlineIdx].content;
      const firstLine = rawContent.split("\n")[0];
      const headerMatch = firstLine.match(/^\[!([\w-]+)\][ \t]?(.*)?$/);
      if (!headerMatch) {
        i++;
        continue;
      }
      const typeKey = headerMatch[1].toLowerCase();
      const typeInfo = alertTypes[typeKey];
      if (!typeInfo && ignoreUnknown) {
        i++;
        continue;
      }
      const sameLine = (headerMatch[2] || "").trim();
      const nlPos = rawContent.indexOf("\n");
      const restLines = nlPos !== -1 ? rawContent.slice(nlPos + 1) : "";
      const inlineCount = countInlineTokens(tokens, bqStart, bqEnd);
      const isOneLiner = sameLine !== "" && restLines === "" && inlineCount === 1;
      const firstParaContent = restLines || null;
      const newTokens = [];
      const label = typeInfo ? typeInfo.label : typeKey.charAt(0).toUpperCase() + typeKey.slice(1);
      const titleText = sameLine || label;
      const icon = typeInfo ? typeInfo.icon || "" : "";
      const extraClass = isOneLiner ? " markdown-alert-oneliner" : "";
      const divOpenTok = new state.Token("html_block", "", 0);
      divOpenTok.content = `<div class="markdown-alert markdown-alert-${typeKey}${extraClass}">
`;
      newTokens.push(divOpenTok);
      const titleTok = new state.Token("html_block", "", 0);
      titleTok.content = `<p class="markdown-alert-title" dir="auto">${icon}${titleText}</p>
`;
      newTokens.push(titleTok);
      let skipFirstPara = false;
      for (let j = bqStart + 1; j < bqEnd; j++) {
        const tok = tokens[j];
        if (!skipFirstPara && tok.type === "paragraph_open") {
          if (firstParaContent === null) {
            skipFirstPara = true;
            j += 2;
            continue;
          }
          newTokens.push(tok);
          j++;
          const newInline = new state.Token("inline", "", 0);
          newInline.content = firstParaContent;
          newInline.children = [];
          state.md.inline.parse(newInline.content, state.md, state.env, newInline.children);
          newTokens.push(newInline);
          j++;
          newTokens.push(tokens[j]);
          skipFirstPara = true;
          continue;
        }
        newTokens.push(tok);
      }
      const divCloseTok = new state.Token("html_block", "", 0);
      divCloseTok.content = `</div>
`;
      newTokens.push(divCloseTok);
      tokens.splice(bqStart, bqEnd - bqStart + 1, ...newTokens);
      i = bqStart + newTokens.length;
    }
  });
}
const PATTERN = /^\[([ xX])\]\s+/;
function checklistPlugin$1(md) {
  md.core.ruler.after("inline", "task_list", (state) => {
    const tokens = state.tokens;
    for (let i = 2; i < tokens.length; i++) {
      if (!isTaskListItem(tokens, i)) {
        continue;
      }
      const inlineToken = tokens[i];
      const children = inlineToken.children;
      if (!children || !children.length) {
        continue;
      }
      const firstChild = children[0];
      if (firstChild.type !== "text") {
        continue;
      }
      const match = firstChild.content.match(PATTERN);
      if (!match) {
        continue;
      }
      const checked = match[1].toLowerCase() === "x";
      firstChild.content = firstChild.content.slice(match[0].length);
      const checkbox = new state.Token("html_inline", "", 0);
      checkbox.content = checked ? `<input type="checkbox" checked disabled> ` : `<input type="checkbox" disabled> `;
      children.unshift(checkbox);
      const liOpenToken = tokens[i - 2];
      liOpenToken.attrSet("class", "task-list-item");
      for (let j = i - 3; j >= 0; j--) {
        if (tokens[j].type === "bullet_list_open") {
          tokens[j].attrSet("class", "task-list");
          break;
        }
      }
    }
  });
}
function isTaskListItem(tokens, index) {
  return tokens[index].type === "inline" && tokens[index - 1].type === "paragraph_open" && tokens[index - 2].type === "list_item_open";
}
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules$1 = {};
rules$1.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules$1.lineBreak = {
  filter: "br",
  replacement: function(content, node, options2) {
    return options2.br + "\n";
  }
};
rules$1.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options2) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options2.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules$1.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules$1.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules$1.listItem = {
  filter: "li",
  replacement: function(content, node, options2) {
    var prefix = options2.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node.nextSibling ? "\n" : "");
  }
};
rules$1.indentedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules$1.fencedCodeBlock = {
  filter: function(node, options2) {
    return options2.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options2) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code2 = node.firstChild.textContent;
    var fenceChar = options2.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code2)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence2 = repeat(fenceChar, fenceSize);
    return "\n\n" + fence2 + language + "\n" + code2.replace(/\n$/, "") + "\n" + fence2 + "\n\n";
  }
};
rules$1.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options2) {
    return "\n\n" + options2.hr + "\n\n";
  }
};
rules$1.inlineLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules$1.referenceLink = {
  filter: function(node, options2) {
    return options2.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options2) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference2;
    switch (options2.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference2 = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference2 = "[" + id + "]: " + href + title;
    }
    this.references.push(reference2);
    return replacement;
  },
  references: [],
  append: function(options2) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules$1.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options2) {
    if (!content.trim()) return "";
    return options2.emDelimiter + content + options2.emDelimiter;
  }
};
rules$1.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options2) {
    if (!content.trim()) return "";
    return options2.strongDelimiter + content + options2.strongDelimiter;
  }
};
rules$1.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter2 = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter2) !== -1) delimiter2 = delimiter2 + "`";
    return delimiter2 + extraSpace + content + extraSpace + delimiter2;
  }
};
rules$1.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src2 = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src2 ? "![" + alt + "](" + src2 + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options2) {
  this.options = options2;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options2.blankReplacement
  };
  this.keepReplacement = options2.keepReplacement;
  this.defaultRule = {
    replacement: options2.defaultReplacement
  };
  this.array = [];
  for (var key in options2.rules) this.array.push(options2.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options)) return rule;
    if (rule = findRule(this._keep, node, this.options)) return rule;
    if (rule = findRule(this._remove, node, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};
function findRule(rules2, node, options2) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options2)) return rule;
  }
  return void 0;
}
function filterValue(rule, node, options2) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options2)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options2) {
  var element = options2.element;
  var isBlock2 = options2.isBlock;
  var isVoid2 = options2.isVoid;
  var isPre = options2.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text2 = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text2[0] === " ") {
        text2 = text2.substr(1);
      }
      if (!text2) {
        node = remove(node);
        continue;
      }
      node.data = text2;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options2) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options2.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options2) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options2);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options2) {
  if (node.isBlock || options2.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options2)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options2)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options2) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options2.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options2) {
  if (!(this instanceof TurndownService)) return new TurndownService(options2);
  var defaults = {
    rules: rules$1,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options2);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output2 = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output2);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin2) {
    if (Array.isArray(plugin2)) {
      for (var i = 0; i < plugin2.length; i++) this.use(plugin2[i]);
    } else if (typeof plugin2 === "function") {
      plugin2(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape2) {
      return accumulator.replace(escape2[0], escape2[1]);
    }, string);
  }
};
function process(parentNode) {
  var self2 = this;
  return reduce.call(parentNode.childNodes, function(output2, node) {
    node = new Node(node, self2.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self2.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self2, node);
    }
    return join(output2, replacement);
  }, "");
}
function postProcess(output2) {
  var self2 = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output2 = join(output2, rule.append(self2.options));
    }
  });
  return output2.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output2, replacement) {
  var s1 = trimTrailingNewlines(output2);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output2.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var highlightRegExp = /highlight-(?:(?:text|source)-)?([a-z0-9]+)/;
function highlightedCodeBlock(turndownService) {
  turndownService.addRule("highlightedCodeBlock", {
    filter: function(node) {
      var firstChild = node.firstChild;
      return node.nodeName === "DIV" && highlightRegExp.test(node.className) && firstChild && firstChild.nodeName === "PRE";
    },
    replacement: function(content, node, options2) {
      var className = node.className || "";
      var language = (className.match(highlightRegExp) || [null, ""])[1];
      return "\n\n" + options2.fence + language + "\n" + node.firstChild.textContent + "\n" + options2.fence + "\n\n";
    }
  });
}
function strikethrough(turndownService) {
  turndownService.addRule("strikethrough", {
    filter: ["del", "s", "strike"],
    replacement: function(content) {
      return "~~" + content + "~~";
    }
  });
}
var rules = {};
function cleanCellContent(content) {
  if (!content) return "   ";
  let cleaned = content.trim().replace(/\s+/g, " ").replace(/\|/g, "\\|").replace(/\\/g, "\\\\").replace(/\n+/g, " ").replace(/\r+/g, " ");
  if (!cleaned || cleaned.match(/^\s*$/)) {
    return "   ";
  }
  if (cleaned.length < 3) {
    cleaned += " ".repeat(3 - cleaned.length);
  }
  return cleaned;
}
function cell(content, node, index) {
  if (index === null && node && node.parentNode) {
    index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
  }
  if (index === null) index = 0;
  var prefix = " ";
  if (index === 0) prefix = "| ";
  let cellContent = cleanCellContent(content);
  let colspan = 1;
  if (node && node.getAttribute) {
    colspan = parseInt(node.getAttribute("colspan") || "1", 10);
    if (isNaN(colspan) || colspan < 1) colspan = 1;
  }
  let result = prefix + cellContent + " |";
  for (let i = 1; i < colspan; i++) {
    result += "   |";
  }
  return result;
}
function isHeadingRow(tr) {
  if (!tr || !tr.parentNode) return false;
  var parentNode = tr.parentNode;
  if (parentNode.nodeName === "THEAD") return true;
  if (parentNode.firstChild === tr && (parentNode.nodeName === "TABLE" || parentNode.nodeName === "TBODY")) {
    var cellNodes = Array.prototype.filter.call(tr.childNodes, function(n) {
      return n.nodeType === 1;
    });
    if (cellNodes.length === 0) return false;
    return Array.prototype.every.call(cellNodes, function(n) {
      return n.nodeName === "TH";
    });
  }
  return false;
}
function getTableColCount(table2) {
  if (!table2 || !table2.rows) return 0;
  let maxCols = 0;
  for (let i = 0; i < table2.rows.length; i++) {
    const row = table2.rows[i];
    if (!row || !row.childNodes) continue;
    let colCount = 0;
    for (let j = 0; j < row.childNodes.length; j++) {
      const cell2 = row.childNodes[j];
      if (cell2.nodeType === 1 && (cell2.nodeName === "TD" || cell2.nodeName === "TH")) {
        const colspan = parseInt(cell2.getAttribute("colspan") || "1", 10);
        colCount += isNaN(colspan) ? 1 : Math.max(1, colspan);
      }
    }
    if (colCount > maxCols) maxCols = colCount;
  }
  return maxCols;
}
function shouldSkipTable(table2) {
  if (!table2) return true;
  if (!table2.rows || table2.rows.length === 0) return true;
  let contentCells = 0;
  let totalCells = 0;
  for (let i = 0; i < table2.rows.length; i++) {
    const row = table2.rows[i];
    if (!row || !row.childNodes) continue;
    for (let j = 0; j < row.childNodes.length; j++) {
      const cell2 = row.childNodes[j];
      if (cell2.nodeType === 1 && (cell2.nodeName === "TD" || cell2.nodeName === "TH")) {
        totalCells++;
        if (cell2.textContent && cell2.textContent.trim()) {
          contentCells++;
        }
      }
    }
  }
  if (totalCells === 0) return true;
  if (totalCells === 1 && contentCells === 0) return true;
  return false;
}
rules.tableCell = {
  filter: ["th", "td"],
  replacement: function(content, node) {
    return cell(content, node, null);
  }
};
rules.tableRow = {
  filter: "tr",
  replacement: function(content, node) {
    if (!content || !content.trim()) return "";
    var borderCells = "";
    if (isHeadingRow(node)) {
      const table2 = node.closest("table");
      if (table2) {
        const colCount = getTableColCount(table2);
        if (colCount > 0) {
          for (var i = 0; i < colCount; i++) {
            const prefix = i === 0 ? "| " : " ";
            borderCells += prefix + "--- |";
          }
        }
      }
    }
    return "\n" + content + (borderCells ? "\n" + borderCells : "");
  }
};
rules.table = {
  filter: "table",
  replacement: function(content, node) {
    if (shouldSkipTable(node)) {
      return "";
    }
    content = content.replace(/\n+/g, "\n").trim();
    if (!content) return "";
    const lines = content.split("\n").filter((line) => line.trim());
    if (lines.length === 0) return "";
    const hasHeaderSeparator = lines.length >= 2 && /\|\s*-+/.test(lines[1]);
    let result = lines.join("\n");
    if (!hasHeaderSeparator && lines.length >= 1) {
      const firstLine = lines[0];
      const colCount = (firstLine.match(/\|/g) || []).length - 1;
      if (colCount > 0) {
        let separator = "|";
        for (let i = 0; i < colCount; i++) {
          separator += " --- |";
        }
        const resultLines = [lines[0], separator, ...lines.slice(1)];
        result = resultLines.join("\n");
      }
    }
    return "\n\n" + result + "\n\n";
  }
};
rules.tableSection = {
  filter: ["thead", "tbody", "tfoot"],
  replacement: function(content) {
    return content;
  }
};
rules.tableCaption = {
  filter: ["caption"],
  replacement: function() {
    return "";
  }
};
rules.tableColgroup = {
  filter: ["colgroup", "col"],
  replacement: function() {
    return "";
  }
};
function tables(turndownService) {
  for (var key in rules) {
    turndownService.addRule(key, rules[key]);
  }
}
function githubAlerts(turndownService) {
  function getAlertType(node) {
    for (const cls of node.classList) {
      const m = cls.match(/^markdown-alert-(.+)$/);
      if (m && cls !== "markdown-alert" && !cls.startsWith("markdown-alert-oneliner")) {
        return m[1];
      }
    }
    return null;
  }
  turndownService.addRule("githubAlerts", {
    filter: (node) => {
      if (node.nodeName !== "DIV") return false;
      if (!node.classList.contains("markdown-alert")) return false;
      return getAlertType(node) !== null;
    },
    replacement: (content, node) => {
      const alertType = getAlertType(node);
      const typeStr = alertType.toUpperCase();
      const titleEl = node.querySelector(":scope > p.markdown-alert-title");
      const titleText = titleEl ? titleEl.textContent.trim() : "";
      const defaultLabel = alertType.charAt(0).toUpperCase() + alertType.slice(1);
      const inlineTitle = titleText && titleText !== defaultLabel ? ` ${titleText}` : "";
      const paragraphs = node.querySelectorAll(":scope > p:not(.markdown-alert-title)");
      let bodyContent = "";
      paragraphs.forEach((p, index) => {
        const text2 = turndownService.turndown(p.innerHTML);
        if (index === 0) {
          bodyContent += text2;
        } else {
          bodyContent += "\n>\n> " + text2;
        }
      });
      if (inlineTitle && !bodyContent) {
        return `> [!${typeStr}]${inlineTitle}

`;
      }
      return `> [!${typeStr}]${inlineTitle}
> ${bodyContent}

`;
    }
  });
}
function checklistPlugin(turndownService) {
  turndownService.addRule("taskListItem", {
    filter: (node) => {
      if (node.nodeName !== "LI") return false;
      const checkbox = node.querySelector(':scope > input[type="checkbox"]');
      return checkbox !== null;
    },
    replacement: (content, node) => {
      const checkbox = node.querySelector(':scope > input[type="checkbox"]');
      const checked = checkbox.checked || checkbox.hasAttribute("checked");
      const mark = checked ? "[x]" : "[ ]";
      const text2 = content.replace(/^\s*\[[ xX]\]\s*/m, "").replace(/^\s*/, "").replace(/\n/g, "\n    ");
      return `- ${mark} ${text2}
`;
    }
  });
  turndownService.addRule("taskListCheckbox", {
    filter: (node) => {
      if (node.nodeName !== "INPUT") return false;
      if (node.getAttribute("type") !== "checkbox") return false;
      const parent = node.parentNode;
      return parent && parent.nodeName === "LI";
    },
    replacement: () => ""
  });
}
var tinymce$2 = { exports: {} };
var hasRequiredTinymce;
function requireTinymce() {
  if (hasRequiredTinymce) return tinymce$2.exports;
  hasRequiredTinymce = 1;
  (function(module) {
    (function() {
      (function(domGlobals) {
        var noop = function() {
        };
        var compose = function(fa, fb) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return fa(fb.apply(null, args));
          };
        };
        var constant = function(value2) {
          return function() {
            return value2;
          };
        };
        var identity = function(x) {
          return x;
        };
        function curry(fn) {
          var initialArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            initialArgs[_i - 1] = arguments[_i];
          }
          return function() {
            var restArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              restArgs[_i2] = arguments[_i2];
            }
            var all2 = initialArgs.concat(restArgs);
            return fn.apply(null, all2);
          };
        }
        var not2 = function(f) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return !f.apply(null, args);
          };
        };
        var die2 = function(msg) {
          return function() {
            throw new Error(msg);
          };
        };
        var never = constant(false);
        var always = constant(true);
        var none = function() {
          return NONE;
        };
        var NONE = (function() {
          var eq2 = function(o) {
            return o.isNone();
          };
          var call = function(thunk) {
            return thunk();
          };
          var id = function(n) {
            return n;
          };
          var me = {
            fold: function(n, s) {
              return n();
            },
            is: never,
            isSome: never,
            isNone: always,
            getOr: id,
            getOrThunk: call,
            getOrDie: function(msg) {
              throw new Error(msg || "error: getOrDie called on none.");
            },
            getOrNull: constant(null),
            getOrUndefined: constant(void 0),
            or: id,
            orThunk: call,
            map: none,
            each: noop,
            bind: none,
            exists: never,
            forall: always,
            filter: none,
            equals: eq2,
            equals_: eq2,
            toArray: function() {
              return [];
            },
            toString: constant("none()")
          };
          if (Object.freeze) {
            Object.freeze(me);
          }
          return me;
        })();
        var some = function(a) {
          var constant_a = constant(a);
          var self2 = function() {
            return me;
          };
          var bind2 = function(f) {
            return f(a);
          };
          var me = {
            fold: function(n, s) {
              return s(a);
            },
            is: function(v) {
              return a === v;
            },
            isSome: always,
            isNone: never,
            getOr: constant_a,
            getOrThunk: constant_a,
            getOrDie: constant_a,
            getOrNull: constant_a,
            getOrUndefined: constant_a,
            or: self2,
            orThunk: self2,
            map: function(f) {
              return some(f(a));
            },
            each: function(f) {
              f(a);
            },
            bind: bind2,
            exists: bind2,
            forall: bind2,
            filter: function(f) {
              return f(a) ? me : NONE;
            },
            toArray: function() {
              return [a];
            },
            toString: function() {
              return "some(" + a + ")";
            },
            equals: function(o) {
              return o.is(a);
            },
            equals_: function(o, elementEq) {
              return o.fold(never, function(b) {
                return elementEq(a, b);
              });
            }
          };
          return me;
        };
        var from = function(value2) {
          return value2 === null || value2 === void 0 ? NONE : some(value2);
        };
        var Option = {
          some,
          none,
          from
        };
        var typeOf = function(x) {
          if (x === null) {
            return "null";
          }
          var t = typeof x;
          if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
            return "array";
          }
          if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
            return "string";
          }
          return t;
        };
        var isType = function(type2) {
          return function(value2) {
            return typeOf(value2) === type2;
          };
        };
        var isString = isType("string");
        var isObject = isType("object");
        var isArray = isType("array");
        var isNull = isType("null");
        var isBoolean = isType("boolean");
        var isFunction = isType("function");
        var isNumber = isType("number");
        var nativeSlice = Array.prototype.slice;
        var nativeIndexOf = Array.prototype.indexOf;
        var nativePush = Array.prototype.push;
        var rawIndexOf = function(ts, t) {
          return nativeIndexOf.call(ts, t);
        };
        var indexOf = function(xs, x) {
          var r = rawIndexOf(xs, x);
          return r === -1 ? Option.none() : Option.some(r);
        };
        var contains = function(xs, x) {
          return rawIndexOf(xs, x) > -1;
        };
        var exists = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return true;
            }
          }
          return false;
        };
        var map2 = function(xs, f) {
          var len = xs.length;
          var r = new Array(len);
          for (var i2 = 0; i2 < len; i2++) {
            var x = xs[i2];
            r[i2] = f(x, i2);
          }
          return r;
        };
        var each = function(xs, f) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            f(x, i2);
          }
        };
        var eachr = function(xs, f) {
          for (var i2 = xs.length - 1; i2 >= 0; i2--) {
            var x = xs[i2];
            f(x, i2);
          }
        };
        var partition = function(xs, pred) {
          var pass = [];
          var fail = [];
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            var arr2 = pred(x, i2) ? pass : fail;
            arr2.push(x);
          }
          return {
            pass,
            fail
          };
        };
        var filter = function(xs, pred) {
          var r = [];
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              r.push(x);
            }
          }
          return r;
        };
        var foldr = function(xs, f, acc) {
          eachr(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var foldl = function(xs, f, acc) {
          each(xs, function(x) {
            acc = f(acc, x);
          });
          return acc;
        };
        var find = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return Option.some(x);
            }
          }
          return Option.none();
        };
        var findIndex = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            if (pred(x, i2)) {
              return Option.some(i2);
            }
          }
          return Option.none();
        };
        var flatten = function(xs) {
          var r = [];
          for (var i2 = 0, len = xs.length; i2 < len; ++i2) {
            if (!isArray(xs[i2])) {
              throw new Error("Arr.flatten item " + i2 + " was not an array, input: " + xs);
            }
            nativePush.apply(r, xs[i2]);
          }
          return r;
        };
        var bind = function(xs, f) {
          var output2 = map2(xs, f);
          return flatten(output2);
        };
        var forall2 = function(xs, pred) {
          for (var i2 = 0, len = xs.length; i2 < len; ++i2) {
            var x = xs[i2];
            if (pred(x, i2) !== true) {
              return false;
            }
          }
          return true;
        };
        var reverse = function(xs) {
          var r = nativeSlice.call(xs, 0);
          r.reverse();
          return r;
        };
        var difference = function(a1, a2) {
          return filter(a1, function(x) {
            return !contains(a2, x);
          });
        };
        var mapToObject = function(xs, f) {
          var r = {};
          for (var i2 = 0, len = xs.length; i2 < len; i2++) {
            var x = xs[i2];
            r[String(x)] = f(x, i2);
          }
          return r;
        };
        var sort = function(xs, comparator) {
          var copy2 = nativeSlice.call(xs, 0);
          copy2.sort(comparator);
          return copy2;
        };
        var head = function(xs) {
          return xs.length === 0 ? Option.none() : Option.some(xs[0]);
        };
        var last = function(xs) {
          return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
        };
        var from$1 = isFunction(Array.from) ? Array.from : function(x) {
          return nativeSlice.call(x);
        };
        var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
        var path = function(parts, scope) {
          var o = scope !== void 0 && scope !== null ? scope : Global;
          for (var i2 = 0; i2 < parts.length && o !== void 0 && o !== null; ++i2) {
            o = o[parts[i2]];
          }
          return o;
        };
        var resolve = function(p, scope) {
          var parts = p.split(".");
          return path(parts, scope);
        };
        var unsafe = function(name2, scope) {
          return resolve(name2, scope);
        };
        var getOrDie = function(name2, scope) {
          var actual = unsafe(name2, scope);
          if (actual === void 0 || actual === null) {
            throw new Error(name2 + " not available on this browser");
          }
          return actual;
        };
        var Global$1 = { getOrDie };
        var url = function() {
          return Global$1.getOrDie("URL");
        };
        var createObjectURL = function(blob) {
          return url().createObjectURL(blob);
        };
        var revokeObjectURL = function(u) {
          url().revokeObjectURL(u);
        };
        var URL = {
          createObjectURL,
          revokeObjectURL
        };
        var nav = domGlobals.navigator, userAgent = nav.userAgent;
        var opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone2, tablet, windowsPhone;
        var matchMediaQuery = function(query) {
          return "matchMedia" in domGlobals.window ? domGlobals.matchMedia(query).matches : false;
        };
        opera = false;
        android = /Android/.test(userAgent);
        webkit = /WebKit/.test(userAgent);
        ie = !webkit && !opera && /MSIE/gi.test(userAgent) && /Explorer/gi.test(nav.appName);
        ie = ie && /MSIE (\w+)\./.exec(userAgent)[1];
        ie11 = userAgent.indexOf("Trident/") !== -1 && (userAgent.indexOf("rv:") !== -1 || nav.appName.indexOf("Netscape") !== -1) ? 11 : false;
        ie12 = userAgent.indexOf("Edge/") !== -1 && !ie && !ie11 ? 12 : false;
        ie = ie || ie11 || ie12;
        gecko = !webkit && !ie11 && /Gecko/.test(userAgent);
        mac = userAgent.indexOf("Mac") !== -1;
        iDevice = /(iPad|iPhone)/.test(userAgent);
        fileApi = "FormData" in domGlobals.window && "FileReader" in domGlobals.window && "URL" in domGlobals.window && !!URL.createObjectURL;
        phone2 = matchMediaQuery("only screen and (max-device-width: 480px)") && (android || iDevice);
        tablet = matchMediaQuery("only screen and (min-width: 800px)") && (android || iDevice);
        windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
        if (ie12) {
          webkit = false;
        }
        var contentEditable = !iDevice || fileApi || parseInt(userAgent.match(/AppleWebKit\/(\d*)/)[1], 10) >= 534;
        var Env = {
          opera,
          webkit,
          ie,
          gecko,
          mac,
          iOS: iDevice,
          android,
          contentEditable,
          transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          caretAfter: ie !== 8,
          range: domGlobals.window.getSelection && "Range" in domGlobals.window,
          documentMode: ie && !ie12 ? domGlobals.document.documentMode || 7 : 10,
          fileApi,
          ceFalse: ie === false || ie > 8,
          cacheSuffix: null,
          container: null,
          overrideViewPort: null,
          experimentalShadowDom: false,
          canHaveCSP: ie === false || ie > 11,
          desktop: !phone2 && !tablet,
          windowsPhone
        };
        var promise = function() {
          function bind2(fn, thisArg) {
            return function() {
              fn.apply(thisArg, arguments);
            };
          }
          var isArray2 = Array.isArray || function(value2) {
            return Object.prototype.toString.call(value2) === "[object Array]";
          };
          var Promise3 = function(fn) {
            if (typeof this !== "object") {
              throw new TypeError("Promises must be constructed via new");
            }
            if (typeof fn !== "function") {
              throw new TypeError("not a function");
            }
            this._state = null;
            this._value = null;
            this._deferreds = [];
            doResolve(fn, bind2(resolve2, this), bind2(reject, this));
          };
          var asap = Promise3.immediateFn || typeof setImmediate === "function" && setImmediate || function(fn) {
            setTimeout(fn, 1);
          };
          function handle2(deferred) {
            var me = this;
            if (this._state === null) {
              this._deferreds.push(deferred);
              return;
            }
            asap(function() {
              var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
              if (cb === null) {
                (me._state ? deferred.resolve : deferred.reject)(me._value);
                return;
              }
              var ret;
              try {
                ret = cb(me._value);
              } catch (e) {
                deferred.reject(e);
                return;
              }
              deferred.resolve(ret);
            });
          }
          function resolve2(newValue) {
            try {
              if (newValue === this) {
                throw new TypeError("A promise cannot be resolved with itself.");
              }
              if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                var then = newValue.then;
                if (typeof then === "function") {
                  doResolve(bind2(then, newValue), bind2(resolve2, this), bind2(reject, this));
                  return;
                }
              }
              this._state = true;
              this._value = newValue;
              finale.call(this);
            } catch (e) {
              reject.call(this, e);
            }
          }
          function reject(newValue) {
            this._state = false;
            this._value = newValue;
            finale.call(this);
          }
          function finale() {
            for (var i2 = 0, len = this._deferreds.length; i2 < len; i2++) {
              handle2.call(this, this._deferreds[i2]);
            }
            this._deferreds = null;
          }
          function Handler(onFulfilled, onRejected, resolve3, reject2) {
            this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
            this.onRejected = typeof onRejected === "function" ? onRejected : null;
            this.resolve = resolve3;
            this.reject = reject2;
          }
          function doResolve(fn, onFulfilled, onRejected) {
            var done2 = false;
            try {
              fn(function(value2) {
                if (done2) {
                  return;
                }
                done2 = true;
                onFulfilled(value2);
              }, function(reason) {
                if (done2) {
                  return;
                }
                done2 = true;
                onRejected(reason);
              });
            } catch (ex) {
              if (done2) {
                return;
              }
              done2 = true;
              onRejected(ex);
            }
          }
          Promise3.prototype.catch = function(onRejected) {
            return this.then(null, onRejected);
          };
          Promise3.prototype.then = function(onFulfilled, onRejected) {
            var me = this;
            return new Promise3(function(resolve3, reject2) {
              handle2.call(me, new Handler(onFulfilled, onRejected, resolve3, reject2));
            });
          };
          Promise3.all = function() {
            var args = Array.prototype.slice.call(arguments.length === 1 && isArray2(arguments[0]) ? arguments[0] : arguments);
            return new Promise3(function(resolve3, reject2) {
              if (args.length === 0) {
                return resolve3([]);
              }
              var remaining = args.length;
              function res(i3, val) {
                try {
                  if (val && (typeof val === "object" || typeof val === "function")) {
                    var then = val.then;
                    if (typeof then === "function") {
                      then.call(val, function(val2) {
                        res(i3, val2);
                      }, reject2);
                      return;
                    }
                  }
                  args[i3] = val;
                  if (--remaining === 0) {
                    resolve3(args);
                  }
                } catch (ex) {
                  reject2(ex);
                }
              }
              for (var i2 = 0; i2 < args.length; i2++) {
                res(i2, args[i2]);
              }
            });
          };
          Promise3.resolve = function(value2) {
            if (value2 && typeof value2 === "object" && value2.constructor === Promise3) {
              return value2;
            }
            return new Promise3(function(resolve3) {
              resolve3(value2);
            });
          };
          Promise3.reject = function(value2) {
            return new Promise3(function(resolve3, reject2) {
              reject2(value2);
            });
          };
          Promise3.race = function(values) {
            return new Promise3(function(resolve3, reject2) {
              for (var i2 = 0, len = values.length; i2 < len; i2++) {
                values[i2].then(resolve3, reject2);
              }
            });
          };
          return Promise3;
        };
        var promiseObj = window.Promise ? window.Promise : promise();
        var requestAnimationFramePromise;
        var requestAnimationFrame = function(callback, element) {
          var i2, requestAnimationFrameFunc = domGlobals.window.requestAnimationFrame;
          var vendors = [
            "ms",
            "moz",
            "webkit"
          ];
          var featurefill = function(callback2) {
            domGlobals.window.setTimeout(callback2, 0);
          };
          for (i2 = 0; i2 < vendors.length && !requestAnimationFrameFunc; i2++) {
            requestAnimationFrameFunc = domGlobals.window[vendors[i2] + "RequestAnimationFrame"];
          }
          if (!requestAnimationFrameFunc) {
            requestAnimationFrameFunc = featurefill;
          }
          requestAnimationFrameFunc(callback, element);
        };
        var wrappedSetTimeout = function(callback, time) {
          if (typeof time !== "number") {
            time = 0;
          }
          return setTimeout(callback, time);
        };
        var wrappedSetInterval = function(callback, time) {
          if (typeof time !== "number") {
            time = 1;
          }
          return setInterval(callback, time);
        };
        var wrappedClearTimeout = function(id) {
          return clearTimeout(id);
        };
        var wrappedClearInterval = function(id) {
          return clearInterval(id);
        };
        var debounce = function(callback, time) {
          var timer, func;
          func = function() {
            var args = arguments;
            clearTimeout(timer);
            timer = wrappedSetTimeout(function() {
              callback.apply(this, args);
            }, time);
          };
          func.stop = function() {
            clearTimeout(timer);
          };
          return func;
        };
        var Delay = {
          requestAnimationFrame: function(callback, element) {
            if (requestAnimationFramePromise) {
              requestAnimationFramePromise.then(callback);
              return;
            }
            requestAnimationFramePromise = new promiseObj(function(resolve2) {
              if (!element) {
                element = domGlobals.document.body;
              }
              requestAnimationFrame(resolve2, element);
            }).then(callback);
          },
          setTimeout: wrappedSetTimeout,
          setInterval: wrappedSetInterval,
          setEditorTimeout: function(editor, callback, time) {
            return wrappedSetTimeout(function() {
              if (!editor.removed) {
                callback();
              }
            }, time);
          },
          setEditorInterval: function(editor, callback, time) {
            var timer;
            timer = wrappedSetInterval(function() {
              if (!editor.removed) {
                callback();
              } else {
                clearInterval(timer);
              }
            }, time);
            return timer;
          },
          debounce,
          throttle: debounce,
          clearInterval: wrappedClearInterval,
          clearTimeout: wrappedClearTimeout
        };
        var eventExpandoPrefix = "mce-data-";
        var mouseEventRe = /^(?:mouse|contextmenu)|click/;
        var deprecated = {
          keyLocation: 1,
          layerX: 1,
          layerY: 1,
          returnValue: 1,
          webkitMovementX: 1,
          webkitMovementY: 1,
          keyIdentifier: 1
        };
        var hasIsDefaultPrevented = function(event) {
          return event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
        };
        var returnFalse = function() {
          return false;
        };
        var returnTrue = function() {
          return true;
        };
        var addEvent = function(target2, name2, callback, capture) {
          if (target2.addEventListener) {
            target2.addEventListener(name2, callback, capture || false);
          } else if (target2.attachEvent) {
            target2.attachEvent("on" + name2, callback);
          }
        };
        var removeEvent = function(target2, name2, callback, capture) {
          if (target2.removeEventListener) {
            target2.removeEventListener(name2, callback, capture || false);
          } else if (target2.detachEvent) {
            target2.detachEvent("on" + name2, callback);
          }
        };
        var getTargetFromShadowDom = function(event, defaultTarget) {
          if (event.composedPath) {
            var composedPath = event.composedPath();
            if (composedPath && composedPath.length > 0) {
              return composedPath[0];
            }
          }
          return defaultTarget;
        };
        var fix = function(originalEvent, data2) {
          var name2;
          var event = data2 || {};
          for (name2 in originalEvent) {
            if (!deprecated[name2]) {
              event[name2] = originalEvent[name2];
            }
          }
          if (!event.target) {
            event.target = event.srcElement || domGlobals.document;
          }
          if (Env.experimentalShadowDom) {
            event.target = getTargetFromShadowDom(originalEvent, event.target);
          }
          if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === void 0 && originalEvent.clientX !== void 0) {
            var eventDoc = event.target.ownerDocument || domGlobals.document;
            var doc2 = eventDoc.documentElement;
            var body = eventDoc.body;
            event.pageX = originalEvent.clientX + (doc2 && doc2.scrollLeft || body && body.scrollLeft || 0) - (doc2 && doc2.clientLeft || body && body.clientLeft || 0);
            event.pageY = originalEvent.clientY + (doc2 && doc2.scrollTop || body && body.scrollTop || 0) - (doc2 && doc2.clientTop || body && body.clientTop || 0);
          }
          event.preventDefault = function() {
            event.isDefaultPrevented = returnTrue;
            if (originalEvent) {
              if (originalEvent.preventDefault) {
                originalEvent.preventDefault();
              } else {
                originalEvent.returnValue = false;
              }
            }
          };
          event.stopPropagation = function() {
            event.isPropagationStopped = returnTrue;
            if (originalEvent) {
              if (originalEvent.stopPropagation) {
                originalEvent.stopPropagation();
              } else {
                originalEvent.cancelBubble = true;
              }
            }
          };
          event.stopImmediatePropagation = function() {
            event.isImmediatePropagationStopped = returnTrue;
            event.stopPropagation();
          };
          if (hasIsDefaultPrevented(event) === false) {
            event.isDefaultPrevented = returnFalse;
            event.isPropagationStopped = returnFalse;
            event.isImmediatePropagationStopped = returnFalse;
          }
          if (typeof event.metaKey === "undefined") {
            event.metaKey = false;
          }
          return event;
        };
        var bindOnReady = function(win, callback, eventUtils) {
          var doc2 = win.document, event = { type: "ready" };
          if (eventUtils.domLoaded) {
            callback(event);
            return;
          }
          var isDocReady = function() {
            return doc2.readyState === "complete" || doc2.readyState === "interactive" && doc2.body;
          };
          var readyHandler = function() {
            if (!eventUtils.domLoaded) {
              eventUtils.domLoaded = true;
              callback(event);
            }
          };
          var waitForDomLoaded = function() {
            if (isDocReady()) {
              removeEvent(doc2, "readystatechange", waitForDomLoaded);
              readyHandler();
            }
          };
          var tryScroll = function() {
            try {
              doc2.documentElement.doScroll("left");
            } catch (ex) {
              Delay.setTimeout(tryScroll);
              return;
            }
            readyHandler();
          };
          if (doc2.addEventListener && !(Env.ie && Env.ie < 11)) {
            if (isDocReady()) {
              readyHandler();
            } else {
              addEvent(win, "DOMContentLoaded", readyHandler);
            }
          } else {
            addEvent(doc2, "readystatechange", waitForDomLoaded);
            if (doc2.documentElement.doScroll && win.self === win.top) {
              tryScroll();
            }
          }
          addEvent(win, "load", readyHandler);
        };
        var EventUtils = function() {
          var self2 = this;
          var events = {}, count2, expando2, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
          expando2 = eventExpandoPrefix + (+/* @__PURE__ */ new Date()).toString(32);
          hasMouseEnterLeave = "onmouseenter" in domGlobals.document.documentElement;
          hasFocusIn = "onfocusin" in domGlobals.document.documentElement;
          mouseEnterLeave = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
          };
          count2 = 1;
          self2.domLoaded = false;
          self2.events = events;
          var executeHandlers = function(evt, id) {
            var callbackList, i2, l, callback;
            var container = events[id];
            callbackList = container && container[evt.type];
            if (callbackList) {
              for (i2 = 0, l = callbackList.length; i2 < l; i2++) {
                callback = callbackList[i2];
                if (callback && callback.func.call(callback.scope, evt) === false) {
                  evt.preventDefault();
                }
                if (evt.isImmediatePropagationStopped()) {
                  return;
                }
              }
            }
          };
          self2.bind = function(target2, names, callback, scope) {
            var id, callbackList, i2, name2, fakeName, nativeHandler, capture;
            var win = domGlobals.window;
            var defaultNativeHandler = function(evt) {
              executeHandlers(fix(evt || win.event), id);
            };
            if (!target2 || target2.nodeType === 3 || target2.nodeType === 8) {
              return;
            }
            if (!target2[expando2]) {
              id = count2++;
              target2[expando2] = id;
              events[id] = {};
            } else {
              id = target2[expando2];
            }
            scope = scope || target2;
            names = names.split(" ");
            i2 = names.length;
            while (i2--) {
              name2 = names[i2];
              nativeHandler = defaultNativeHandler;
              fakeName = capture = false;
              if (name2 === "DOMContentLoaded") {
                name2 = "ready";
              }
              if (self2.domLoaded && name2 === "ready" && target2.readyState === "complete") {
                callback.call(scope, fix({ type: name2 }));
                continue;
              }
              if (!hasMouseEnterLeave) {
                fakeName = mouseEnterLeave[name2];
                if (fakeName) {
                  nativeHandler = function(evt) {
                    var current, related;
                    current = evt.currentTarget;
                    related = evt.relatedTarget;
                    if (related && current.contains) {
                      related = current.contains(related);
                    } else {
                      while (related && related !== current) {
                        related = related.parentNode;
                      }
                    }
                    if (!related) {
                      evt = fix(evt || win.event);
                      evt.type = evt.type === "mouseout" ? "mouseleave" : "mouseenter";
                      evt.target = current;
                      executeHandlers(evt, id);
                    }
                  };
                }
              }
              if (!hasFocusIn && (name2 === "focusin" || name2 === "focusout")) {
                capture = true;
                fakeName = name2 === "focusin" ? "focus" : "blur";
                nativeHandler = function(evt) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === "focus" ? "focusin" : "focusout";
                  executeHandlers(evt, id);
                };
              }
              callbackList = events[id][name2];
              if (!callbackList) {
                events[id][name2] = callbackList = [{
                  func: callback,
                  scope
                }];
                callbackList.fakeName = fakeName;
                callbackList.capture = capture;
                callbackList.nativeHandler = nativeHandler;
                if (name2 === "ready") {
                  bindOnReady(target2, nativeHandler, self2);
                } else {
                  addEvent(target2, fakeName || name2, nativeHandler, capture);
                }
              } else {
                if (name2 === "ready" && self2.domLoaded) {
                  callback({ type: name2 });
                } else {
                  callbackList.push({
                    func: callback,
                    scope
                  });
                }
              }
            }
            target2 = callbackList = 0;
            return callback;
          };
          self2.unbind = function(target2, names, callback) {
            var id, callbackList, i2, ci, name2, eventMap;
            if (!target2 || target2.nodeType === 3 || target2.nodeType === 8) {
              return self2;
            }
            id = target2[expando2];
            if (id) {
              eventMap = events[id];
              if (names) {
                names = names.split(" ");
                i2 = names.length;
                while (i2--) {
                  name2 = names[i2];
                  callbackList = eventMap[name2];
                  if (callbackList) {
                    if (callback) {
                      ci = callbackList.length;
                      while (ci--) {
                        if (callbackList[ci].func === callback) {
                          var nativeHandler = callbackList.nativeHandler;
                          var fakeName = callbackList.fakeName, capture = callbackList.capture;
                          callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                          callbackList.nativeHandler = nativeHandler;
                          callbackList.fakeName = fakeName;
                          callbackList.capture = capture;
                          eventMap[name2] = callbackList;
                        }
                      }
                    }
                    if (!callback || callbackList.length === 0) {
                      delete eventMap[name2];
                      removeEvent(target2, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                    }
                  }
                }
              } else {
                for (name2 in eventMap) {
                  callbackList = eventMap[name2];
                  removeEvent(target2, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                }
                eventMap = {};
              }
              for (name2 in eventMap) {
                return self2;
              }
              delete events[id];
              try {
                delete target2[expando2];
              } catch (ex) {
                target2[expando2] = null;
              }
            }
            return self2;
          };
          self2.fire = function(target2, name2, args) {
            var id;
            if (!target2 || target2.nodeType === 3 || target2.nodeType === 8) {
              return self2;
            }
            args = fix(null, args);
            args.type = name2;
            args.target = target2;
            do {
              id = target2[expando2];
              if (id) {
                executeHandlers(args, id);
              }
              target2 = target2.parentNode || target2.ownerDocument || target2.defaultView || target2.parentWindow;
            } while (target2 && !args.isPropagationStopped());
            return self2;
          };
          self2.clean = function(target2) {
            var i2, children2;
            var unbind = self2.unbind;
            if (!target2 || target2.nodeType === 3 || target2.nodeType === 8) {
              return self2;
            }
            if (target2[expando2]) {
              unbind(target2);
            }
            if (!target2.getElementsByTagName) {
              target2 = target2.document;
            }
            if (target2 && target2.getElementsByTagName) {
              unbind(target2);
              children2 = target2.getElementsByTagName("*");
              i2 = children2.length;
              while (i2--) {
                target2 = children2[i2];
                if (target2[expando2]) {
                  unbind(target2);
                }
              }
            }
            return self2;
          };
          self2.destroy = function() {
            events = {};
          };
          self2.cancel = function(e) {
            if (e) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
            return false;
          };
        };
        EventUtils.Event = new EventUtils();
        EventUtils.Event.bind(domGlobals.window, "ready", function() {
        });
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document2, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$1, expando = "sizzle" + -/* @__PURE__ */ new Date(), preferredDoc = domGlobals.window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, strundefined = "undefined", MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf$1 = arr.indexOf || function(elem) {
          var i2 = 0, len = this.length;
          for (; i2 < len; i2++) {
            if (this[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 65536;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        };
        try {
          push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {
            apply: arr.length ? function(target2, els2) {
              push_native.apply(target2, slice.call(els2));
            } : function(target2, els2) {
              var j = target2.length, i2 = 0;
              while (target2[j++] = els2[i2++]) {
              }
              target2.length = j - 1;
            }
          };
        }
        var Sizzle = function(selector, context2, results, seed2) {
          var match2, elem, m, nodeType, i2, groups, old, nid, newContext, newSelector;
          if ((context2 ? context2.ownerDocument || context2 : preferredDoc) !== document2) {
            setDocument(context2);
          }
          context2 = context2 || document2;
          results = results || [];
          if (!selector || typeof selector !== "string") {
            return results;
          }
          if ((nodeType = context2.nodeType) !== 1 && nodeType !== 9) {
            return [];
          }
          if (documentIsHTML && !seed2) {
            if (match2 = rquickExpr.exec(selector)) {
              if (m = match2[1]) {
                if (nodeType === 9) {
                  elem = context2.getElementById(m);
                  if (elem && elem.parentNode) {
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (context2.ownerDocument && (elem = context2.ownerDocument.getElementById(m)) && contains$1(context2, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match2[2]) {
                push.apply(results, context2.getElementsByTagName(selector));
                return results;
              } else if ((m = match2[3]) && support.getElementsByClassName) {
                push.apply(results, context2.getElementsByClassName(m));
                return results;
              }
            }
            if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              nid = old = expando;
              newContext = context2;
              newSelector = nodeType === 9 && selector;
              if (nodeType === 1 && context2.nodeName.toLowerCase() !== "object") {
                groups = tokenize(selector);
                if (old = context2.getAttribute("id")) {
                  nid = old.replace(rescape, "\\$&");
                } else {
                  context2.setAttribute("id", nid);
                }
                nid = "[id='" + nid + "'] ";
                i2 = groups.length;
                while (i2--) {
                  groups[i2] = nid + toSelector(groups[i2]);
                }
                newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
                newSelector = groups.join(",");
              }
              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                } finally {
                  if (!old) {
                    context2.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim, "$1"), context2, results, seed2);
        };
        function createCache() {
          var keys2 = [];
          function cache(key, value2) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache[keys2.shift()];
            }
            return cache[key + " "] = value2;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
          if (diff2) {
            return diff2;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type2) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return name2 === "input" && elem.type === type2;
          };
        }
        function createButtonPseudo(type2) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return (name2 === "input" || name2 === "button") && elem.type === type2;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed2, matches2) {
              var j, matchIndexes = fn([], seed2.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed2[j = matchIndexes[i2]]) {
                  seed2[j] = !(matches2[j] = seed2[j]);
                }
              }
            });
          });
        }
        function testContext(context2) {
          return context2 && typeof context2.getElementsByTagName !== strundefined && context2;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
          var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
          return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node2) {
          var hasCompare, doc2 = node2 ? node2.ownerDocument || node2 : preferredDoc, parent2 = doc2.defaultView;
          function getTop(win) {
            try {
              return win.top;
            } catch (ex) {
            }
            return null;
          }
          if (doc2 === document2 || doc2.nodeType !== 9 || !doc2.documentElement) {
            return document2;
          }
          document2 = doc2;
          docElem = doc2.documentElement;
          documentIsHTML = !isXML(doc2);
          if (parent2 && parent2 !== getTop(parent2)) {
            if (parent2.addEventListener) {
              parent2.addEventListener("unload", function() {
                setDocument();
              }, false);
            } else if (parent2.attachEvent) {
              parent2.attachEvent("onunload", function() {
                setDocument();
              });
            }
          }
          support.attributes = true;
          support.getElementsByTagName = true;
          support.getElementsByClassName = rnative.test(doc2.getElementsByClassName);
          support.getById = true;
          Expr.find.ID = function(id, context2) {
            if (typeof context2.getElementById !== strundefined && documentIsHTML) {
              var m = context2.getElementById(id);
              return m && m.parentNode ? [m] : [];
            }
          };
          Expr.filter.ID = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find.TAG = support.getElementsByTagName ? function(tag, context2) {
            if (typeof context2.getElementsByTagName !== strundefined) {
              return context2.getElementsByTagName(tag);
            }
          } : function(tag, context2) {
            var elem, tmp = [], i2 = 0, results = context2.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find.CLASS = support.getElementsByClassName && function(className, context2) {
            if (documentIsHTML) {
              return context2.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          support.disconnectedMatch = true;
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains$1 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
            if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a === doc2 || a.ownerDocument === preferredDoc && contains$1(preferredDoc, a)) {
                return -1;
              }
              if (b === doc2 || b.ownerDocument === preferredDoc && contains$1(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap2 = [a], bp = [b];
            if (!aup || !bup) {
              return a === doc2 ? -1 : b === doc2 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap2.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap2[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? siblingCheck(ap2[i2], bp[i2]) : ap2[i2] === preferredDoc ? -1 : bp[i2] === preferredDoc ? 1 : 0;
          };
          return doc2;
        };
        Sizzle.matches = function(expr, elements) {
          return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
          if ((elem.ownerDocument || elem) !== document2) {
            setDocument(elem);
          }
          expr = expr.replace(rattributeQuotes, "='$1']");
          if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
            }
          }
          return Sizzle(expr, document2, null, [elem]).length > 0;
        };
        Sizzle.contains = function(context2, elem) {
          if ((context2.ownerDocument || context2) !== document2) {
            setDocument(context2);
          }
          return contains$1(context2, elem);
        };
        Sizzle.attr = function(elem, name2) {
          if ((elem.ownerDocument || elem) !== document2) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support.detectDuplicates;
          sortInput = !support.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle.getText = function(elem) {
          var node2, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node2 = elem[i2++]) {
              ret += getText(node2);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle.selectors = {
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": { dir: "parentNode" },
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match2) {
              match2[1] = match2[1].replace(runescape, funescape);
              match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
              if (match2[2] === "~=") {
                match2[3] = " " + match2[3] + " ";
              }
              return match2.slice(0, 4);
            },
            CHILD: function(match2) {
              match2[1] = match2[1].toLowerCase();
              if (match2[1].slice(0, 3) === "nth") {
                if (!match2[3]) {
                  Sizzle.error(match2[0]);
                }
                match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
              } else if (match2[3]) {
                Sizzle.error(match2[0]);
              }
              return match2;
            },
            PSEUDO: function(match2) {
              var excess, unquoted = !match2[6] && match2[2];
              if (matchExpr.CHILD.test(match2[0])) {
                return null;
              }
              if (match2[3]) {
                match2[2] = match2[4] || match2[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match2[0] = match2[0].slice(0, excess);
                match2[2] = unquoted.slice(0, excess);
              }
              return match2.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            CLASS: function(className) {
              var pattern2 = classCache[className + " "];
              return pattern2 || (pattern2 = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern2.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
              });
            },
            ATTR: function(name2, operator, check2) {
              return function(elem) {
                var result = Sizzle.attr(elem, name2);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check2 : operator === "!=" ? result !== check2 : operator === "^=" ? check2 && result.indexOf(check2) === 0 : operator === "*=" ? check2 && result.indexOf(check2) > -1 : operator === "$=" ? check2 && result.slice(-check2.length) === check2 : operator === "~=" ? (" " + result + " ").indexOf(check2) > -1 : operator === "|=" ? result === check2 || result.slice(0, check2.length + 1) === check2 + "-" : false;
              };
            },
            CHILD: function(type2, what, argument, first2, last2) {
              var simple = type2.slice(0, 3) !== "nth", forward = type2.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last2 === 0 ? function(elem) {
                return !!elem.parentNode;
              } : function(elem, context2, xml) {
                var cache, outerCache, node2, diff2, nodeIndex2, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                if (parent2) {
                  if (simple) {
                    while (dir2) {
                      node2 = elem;
                      while (node2 = node2[dir2]) {
                        if (ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type2 === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent2.firstChild : parent2.lastChild];
                  if (forward && useCache) {
                    outerCache = parent2[expando] || (parent2[expando] = {});
                    cache = outerCache[type2] || [];
                    nodeIndex2 = cache[0] === dirruns && cache[1];
                    diff2 = cache[0] === dirruns && cache[2];
                    node2 = nodeIndex2 && parent2.childNodes[nodeIndex2];
                    while (node2 = ++nodeIndex2 && node2 && node2[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                      if (node2.nodeType === 1 && ++diff2 && node2 === elem) {
                        outerCache[type2] = [
                          dirruns,
                          nodeIndex2,
                          diff2
                        ];
                        break;
                      }
                    }
                  } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type2]) && cache[0] === dirruns) {
                    diff2 = cache[1];
                  } else {
                    while (node2 = ++nodeIndex2 && node2 && node2[dir2] || (diff2 = nodeIndex2 = 0) || start2.pop()) {
                      if ((ofType ? node2.nodeName.toLowerCase() === name2 : node2.nodeType === 1) && ++diff2) {
                        if (useCache) {
                          (node2[expando] || (node2[expando] = {}))[type2] = [
                            dirruns,
                            diff2
                          ];
                        }
                        if (node2 === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff2 -= last2;
                  return diff2 === first2 || diff2 % first2 === 0 && diff2 / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [
                  pseudo,
                  pseudo,
                  "",
                  argument
                ];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches2) {
                  var idx, matched = fn(seed2, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf$1.call(seed2, matched[i2]);
                    seed2[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
              return matcher[expando] ? markFunction(function(seed2, matches2, context2, xml) {
                var elem, unmatched = matcher(seed2, null, xml, []), i2 = seed2.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed2[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, context2, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return Sizzle(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text2) {
              text2 = text2.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text2) > -1;
              };
            }),
            lang: markFunction(function(lang2) {
              if (!ridentifier.test(lang2 || "")) {
                Sizzle.error("unsupported lang: " + lang2);
              }
              lang2 = lang2.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang2 || elemLang.indexOf(lang2 + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            target: function(elem) {
              var hash = domGlobals.window.location && domGlobals.window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === docElem;
            },
            focus: function(elem) {
              return elem === document2.activeElement && (!document2.hasFocus || document2.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            enabled: function(elem) {
              return elem.disabled === false;
            },
            disabled: function(elem) {
              return elem.disabled === true;
            },
            checked: function(elem) {
              var nodeName = elem.nodeName.toLowerCase();
              return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              var name2 = elem.nodeName.toLowerCase();
              return name2 === "input" && elem.type === "button" || name2 === "button";
            },
            text: function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
          var matched, match2, tokens, type2, soFar, groups, preFilters, cached2 = tokenCache[selector + " "];
          if (cached2) {
            return parseOnly ? 0 : cached2.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match2 = rcomma.exec(soFar))) {
              if (match2) {
                soFar = soFar.slice(match2[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match2 = rcombinators.exec(soFar)) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                type: match2[0].replace(rtrim, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type2 in Expr.filter) {
              if ((match2 = matchExpr[type2].exec(soFar)) && (!preFilters[type2] || (match2 = preFilters[type2](match2)))) {
                matched = match2.shift();
                tokens.push({
                  value: matched,
                  type: type2,
                  matches: match2
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base2) {
          var dir2 = combinator.dir, checkNonElements = base2 && dir2 === "parentNode", doneName = done++;
          return combinator.first ? function(elem, context2, xml) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context2, xml);
              }
            }
          } : function(elem, context2, xml) {
            var oldCache, outerCache, newCache = [
              dirruns,
              doneName
            ];
            if (xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context2, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if ((oldCache = outerCache[dir2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return newCache[2] = oldCache[2];
                  } else {
                    outerCache[dir2] = newCache;
                    if (newCache[2] = matcher(elem, context2, xml)) {
                      return true;
                    }
                  }
                }
              }
            }
          };
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context2, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context2, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map3, filter2, context2, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map3 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter2 || filter2(elem, context2, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map3.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed2, results, context2, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(selector || "*", context2.nodeType ? [context2] : context2, []), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? postFinder || (seed2 ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context2, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context2, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed2) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf$1.call(seed2, elem) : preMap[i2]) > -1) {
                    seed2[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf$1.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context2, xml) {
            return !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i2 > 1 && elementMatcher(matchers), i2 > 1 && toSelector(tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i2 < j && matcherFromTokens(tokens.slice(i2, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context2, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context2 !== document2 && context2;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context2, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed2) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context2, xml);
              }
              if (seed2) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match2) {
          var i2, setMatchers = [], elementMatchers = [], cached2 = compilerCache[selector + " "];
          if (!cached2) {
            if (!match2) {
              match2 = tokenize(selector);
            }
            i2 = match2.length;
            while (i2--) {
              cached2 = matcherFromTokens(match2[i2]);
              if (cached2[expando]) {
                setMatchers.push(cached2);
              } else {
                elementMatchers.push(cached2);
              }
            }
            cached2 = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached2.selector = selector;
          }
          return cached2;
        };
        select = Sizzle.select = function(selector, context2, results, seed2) {
          var i2, tokens, token2, type2, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match2.length === 1) {
            tokens = match2[0] = match2[0].slice(0);
            if (tokens.length > 2 && (token2 = tokens[0]).type === "ID" && support.getById && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context2 = (Expr.find.ID(token2.matches[0].replace(runescape, funescape), context2) || [])[0];
              if (!context2) {
                return results;
              } else if (compiled) {
                context2 = context2.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i2--) {
              token2 = tokens[i2];
              if (Expr.relative[type2 = token2.type]) {
                break;
              }
              if (find2 = Expr.find[type2]) {
                if (seed2 = find2(token2.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2)) {
                  tokens.splice(i2, 1);
                  selector = seed2.length && toSelector(tokens);
                  if (!selector) {
                    push.apply(results, seed2);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match2))(seed2, context2, !documentIsHTML, results, rsibling.test(selector) && testContext(context2.parentNode) || context2);
          return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = true;
        var isArray$1 = Array.isArray;
        var toArray = function(obj) {
          var array = obj, i2, l;
          if (!isArray$1(obj)) {
            array = [];
            for (i2 = 0, l = obj.length; i2 < l; i2++) {
              array[i2] = obj[i2];
            }
          }
          return array;
        };
        var each$1 = function(o, cb, s) {
          var n, l;
          if (!o) {
            return 0;
          }
          s = s || o;
          if (o.length !== void 0) {
            for (n = 0, l = o.length; n < l; n++) {
              if (cb.call(s, o[n], n, o) === false) {
                return 0;
              }
            }
          } else {
            for (n in o) {
              if (o.hasOwnProperty(n)) {
                if (cb.call(s, o[n], n, o) === false) {
                  return 0;
                }
              }
            }
          }
          return 1;
        };
        var map$12 = function(array, callback) {
          var out = [];
          each$1(array, function(item, index) {
            out.push(callback(item, index, array));
          });
          return out;
        };
        var filter$1 = function(a, f) {
          var o = [];
          each$1(a, function(v, index) {
            if (!f || f(v, index, a)) {
              o.push(v);
            }
          });
          return o;
        };
        var indexOf$2 = function(a, v) {
          var i2, l;
          if (a) {
            for (i2 = 0, l = a.length; i2 < l; i2++) {
              if (a[i2] === v) {
                return i2;
              }
            }
          }
          return -1;
        };
        var reduce2 = function(collection, iteratee, accumulator, thisArg) {
          var i2 = 0;
          if (arguments.length < 3) {
            accumulator = collection[0];
          }
          for (; i2 < collection.length; i2++) {
            accumulator = iteratee.call(thisArg, accumulator, collection[i2], i2);
          }
          return accumulator;
        };
        var findIndex$1 = function(array, predicate, thisArg) {
          var i2, l;
          for (i2 = 0, l = array.length; i2 < l; i2++) {
            if (predicate.call(thisArg, array[i2], i2, array)) {
              return i2;
            }
          }
          return -1;
        };
        var find$1 = function(array, predicate, thisArg) {
          var idx = findIndex$1(array, predicate, thisArg);
          if (idx !== -1) {
            return array[idx];
          }
          return void 0;
        };
        var last$1 = function(collection) {
          return collection[collection.length - 1];
        };
        var ArrUtils = {
          isArray: isArray$1,
          toArray,
          each: each$1,
          map: map$12,
          filter: filter$1,
          indexOf: indexOf$2,
          reduce: reduce2,
          findIndex: findIndex$1,
          find: find$1,
          last: last$1
        };
        var whiteSpaceRegExp = /^\s*|\s*$/g;
        var trim = function(str) {
          return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp, "");
        };
        var is2 = function(obj, type2) {
          if (!type2) {
            return obj !== void 0;
          }
          if (type2 === "array" && ArrUtils.isArray(obj)) {
            return true;
          }
          return typeof obj === type2;
        };
        var makeMap = function(items, delim, map3) {
          var i2;
          items = items || [];
          delim = delim || ",";
          if (typeof items === "string") {
            items = items.split(delim);
          }
          map3 = map3 || {};
          i2 = items.length;
          while (i2--) {
            map3[items[i2]] = {};
          }
          return map3;
        };
        var hasOwnProperty = function(obj, prop2) {
          return Object.prototype.hasOwnProperty.call(obj, prop2);
        };
        var create = function(s, p, root2) {
          var self2 = this;
          var sp, ns, cn, scn, c, de = 0;
          s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
          cn = s[3].match(/(^|\.)(\w+)$/i)[2];
          ns = self2.createNS(s[3].replace(/\.\w+$/, ""), root2);
          if (ns[cn]) {
            return;
          }
          if (s[2] === "static") {
            ns[cn] = p;
            if (this.onCreate) {
              this.onCreate(s[2], s[3], ns[cn]);
            }
            return;
          }
          if (!p[cn]) {
            p[cn] = function() {
            };
            de = 1;
          }
          ns[cn] = p[cn];
          self2.extend(ns[cn].prototype, p);
          if (s[5]) {
            sp = self2.resolve(s[5]).prototype;
            scn = s[5].match(/\.(\w+)$/i)[1];
            c = ns[cn];
            if (de) {
              ns[cn] = function() {
                return sp[scn].apply(this, arguments);
              };
            } else {
              ns[cn] = function() {
                this.parent = sp[scn];
                return c.apply(this, arguments);
              };
            }
            ns[cn].prototype[cn] = ns[cn];
            self2.each(sp, function(f, n) {
              ns[cn].prototype[n] = sp[n];
            });
            self2.each(p, function(f, n) {
              if (sp[n]) {
                ns[cn].prototype[n] = function() {
                  this.parent = sp[n];
                  return f.apply(this, arguments);
                };
              } else {
                if (n !== cn) {
                  ns[cn].prototype[n] = f;
                }
              }
            });
          }
          self2.each(p.static, function(f, n) {
            ns[cn][n] = f;
          });
        };
        var extend2 = function(obj, ext) {
          var i2, l, name2;
          var args = arguments;
          var value2;
          for (i2 = 1, l = args.length; i2 < l; i2++) {
            ext = args[i2];
            for (name2 in ext) {
              if (ext.hasOwnProperty(name2)) {
                value2 = ext[name2];
                if (value2 !== void 0) {
                  obj[name2] = value2;
                }
              }
            }
          }
          return obj;
        };
        var walk = function(o, f, n, s) {
          s = s || this;
          if (o) {
            if (n) {
              o = o[n];
            }
            ArrUtils.each(o, function(o2, i2) {
              if (f.call(s, o2, i2, n) === false) {
                return false;
              }
              walk(o2, f, n, s);
            });
          }
        };
        var createNS = function(n, o) {
          var i2, v;
          o = o || domGlobals.window;
          n = n.split(".");
          for (i2 = 0; i2 < n.length; i2++) {
            v = n[i2];
            if (!o[v]) {
              o[v] = {};
            }
            o = o[v];
          }
          return o;
        };
        var resolve$1 = function(n, o) {
          var i2, l;
          o = o || domGlobals.window;
          n = n.split(".");
          for (i2 = 0, l = n.length; i2 < l; i2++) {
            o = o[n[i2]];
            if (!o) {
              break;
            }
          }
          return o;
        };
        var explode = function(s, d) {
          if (!s || is2(s, "array")) {
            return s;
          }
          return ArrUtils.map(s.split(d || ","), trim);
        };
        var _addCacheSuffix = function(url2) {
          var cacheSuffix = Env.cacheSuffix;
          if (cacheSuffix) {
            url2 += (url2.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
          }
          return url2;
        };
        var Tools = {
          trim,
          isArray: ArrUtils.isArray,
          is: is2,
          toArray: ArrUtils.toArray,
          makeMap,
          each: ArrUtils.each,
          map: ArrUtils.map,
          grep: ArrUtils.filter,
          inArray: ArrUtils.indexOf,
          hasOwn: hasOwnProperty,
          extend: extend2,
          create,
          walk,
          createNS,
          resolve: resolve$1,
          explode,
          _addCacheSuffix
        };
        var doc = domGlobals.document, push$1 = Array.prototype.push, slice$1 = Array.prototype.slice;
        var rquickExpr$1 = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
        var Event = EventUtils.Event;
        var skipUniques = Tools.makeMap("children,contents,next,prev");
        var isDefined = function(obj) {
          return typeof obj !== "undefined";
        };
        var isString$1 = function(obj) {
          return typeof obj === "string";
        };
        var isWindow = function(obj) {
          return obj && obj === obj.window;
        };
        var createFragment = function(html2, fragDoc) {
          var frag, node2, container;
          fragDoc = fragDoc || doc;
          container = fragDoc.createElement("div");
          frag = fragDoc.createDocumentFragment();
          container.innerHTML = html2;
          while (node2 = container.firstChild) {
            frag.appendChild(node2);
          }
          return frag;
        };
        var domManipulate = function(targetNodes, sourceItem, callback, reverse2) {
          var i2;
          if (isString$1(sourceItem)) {
            sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
          } else if (sourceItem.length && !sourceItem.nodeType) {
            sourceItem = DomQuery.makeArray(sourceItem);
            if (reverse2) {
              for (i2 = sourceItem.length - 1; i2 >= 0; i2--) {
                domManipulate(targetNodes, sourceItem[i2], callback, reverse2);
              }
            } else {
              for (i2 = 0; i2 < sourceItem.length; i2++) {
                domManipulate(targetNodes, sourceItem[i2], callback, reverse2);
              }
            }
            return targetNodes;
          }
          if (sourceItem.nodeType) {
            i2 = targetNodes.length;
            while (i2--) {
              callback.call(targetNodes[i2], sourceItem);
            }
          }
          return targetNodes;
        };
        var hasClass = function(node2, className) {
          return node2 && className && (" " + node2.className + " ").indexOf(" " + className + " ") !== -1;
        };
        var wrap = function(elements, wrapper, all2) {
          var lastParent, newWrapper;
          wrapper = DomQuery(wrapper)[0];
          elements.each(function() {
            var self2 = this;
            if (!all2 || lastParent !== self2.parentNode) {
              lastParent = self2.parentNode;
              newWrapper = wrapper.cloneNode(false);
              self2.parentNode.insertBefore(newWrapper, self2);
              newWrapper.appendChild(self2);
            } else {
              newWrapper.appendChild(self2);
            }
          });
          return elements;
        };
        var numericCssMap = Tools.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " ");
        var booleanMap = Tools.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " ");
        var propFix = {
          for: "htmlFor",
          class: "className",
          readonly: "readOnly"
        };
        var cssFix = { float: "cssFloat" };
        var attrHooks = {}, cssHooks = {};
        var DomQuery = function(selector, context2) {
          return new DomQuery.fn.init(selector, context2);
        };
        var inArray = function(item, array) {
          var i2;
          if (array.indexOf) {
            return array.indexOf(item);
          }
          i2 = array.length;
          while (i2--) {
            if (array[i2] === item) {
              return i2;
            }
          }
          return -1;
        };
        var whiteSpaceRegExp$1 = /^\s*|\s*$/g;
        var trim$1 = function(str) {
          return str === null || str === void 0 ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
        };
        var each$2 = function(obj, callback) {
          var length, key, i2, value2;
          if (obj) {
            length = obj.length;
            if (length === void 0) {
              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  value2 = obj[key];
                  if (callback.call(value2, key, value2) === false) {
                    break;
                  }
                }
              }
            } else {
              for (i2 = 0; i2 < length; i2++) {
                value2 = obj[i2];
                if (callback.call(value2, i2, value2) === false) {
                  break;
                }
              }
            }
          }
          return obj;
        };
        var grep = function(array, callback) {
          var out = [];
          each$2(array, function(i2, item) {
            if (callback(item, i2)) {
              out.push(item);
            }
          });
          return out;
        };
        var getElementDocument = function(element) {
          if (!element) {
            return doc;
          }
          if (element.nodeType === 9) {
            return element;
          }
          return element.ownerDocument;
        };
        DomQuery.fn = DomQuery.prototype = {
          constructor: DomQuery,
          selector: "",
          context: null,
          length: 0,
          init: function(selector, context2) {
            var self2 = this;
            var match2, node2;
            if (!selector) {
              return self2;
            }
            if (selector.nodeType) {
              self2.context = self2[0] = selector;
              self2.length = 1;
              return self2;
            }
            if (context2 && context2.nodeType) {
              self2.context = context2;
            } else {
              if (context2) {
                return DomQuery(selector).attr(context2);
              }
              self2.context = context2 = domGlobals.document;
            }
            if (isString$1(selector)) {
              self2.selector = selector;
              if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                match2 = [
                  null,
                  selector,
                  null
                ];
              } else {
                match2 = rquickExpr$1.exec(selector);
              }
              if (match2) {
                if (match2[1]) {
                  node2 = createFragment(selector, getElementDocument(context2)).firstChild;
                  while (node2) {
                    push$1.call(self2, node2);
                    node2 = node2.nextSibling;
                  }
                } else {
                  node2 = getElementDocument(context2).getElementById(match2[2]);
                  if (!node2) {
                    return self2;
                  }
                  if (node2.id !== match2[2]) {
                    return self2.find(selector);
                  }
                  self2.length = 1;
                  self2[0] = node2;
                }
              } else {
                return DomQuery(context2).find(selector);
              }
            } else {
              this.add(selector, false);
            }
            return self2;
          },
          toArray: function() {
            return Tools.toArray(this);
          },
          add: function(items, sort2) {
            var self2 = this;
            var nodes, i2;
            if (isString$1(items)) {
              return self2.add(DomQuery(items));
            }
            if (sort2 !== false) {
              nodes = DomQuery.unique(self2.toArray().concat(DomQuery.makeArray(items)));
              self2.length = nodes.length;
              for (i2 = 0; i2 < nodes.length; i2++) {
                self2[i2] = nodes[i2];
              }
            } else {
              push$1.apply(self2, DomQuery.makeArray(items));
            }
            return self2;
          },
          attr: function(name2, value2) {
            var self2 = this;
            var hook;
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.attr(name3, value3);
              });
            } else if (isDefined(value2)) {
              this.each(function() {
                var hook2;
                if (this.nodeType === 1) {
                  hook2 = attrHooks[name2];
                  if (hook2 && hook2.set) {
                    hook2.set(this, value2);
                    return;
                  }
                  if (value2 === null) {
                    this.removeAttribute(name2, 2);
                  } else {
                    this.setAttribute(name2, value2, 2);
                  }
                }
              });
            } else {
              if (self2[0] && self2[0].nodeType === 1) {
                hook = attrHooks[name2];
                if (hook && hook.get) {
                  return hook.get(self2[0], name2);
                }
                if (booleanMap[name2]) {
                  return self2.prop(name2) ? name2 : void 0;
                }
                value2 = self2[0].getAttribute(name2, 2);
                if (value2 === null) {
                  value2 = void 0;
                }
              }
              return value2;
            }
            return self2;
          },
          removeAttr: function(name2) {
            return this.attr(name2, null);
          },
          prop: function(name2, value2) {
            var self2 = this;
            name2 = propFix[name2] || name2;
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.prop(name3, value3);
              });
            } else if (isDefined(value2)) {
              this.each(function() {
                if (this.nodeType === 1) {
                  this[name2] = value2;
                }
              });
            } else {
              if (self2[0] && self2[0].nodeType && name2 in self2[0]) {
                return self2[0][name2];
              }
              return value2;
            }
            return self2;
          },
          css: function(name2, value2) {
            var self2 = this;
            var elm, hook;
            var camel = function(name3) {
              return name3.replace(/-(\D)/g, function(a, b) {
                return b.toUpperCase();
              });
            };
            var dashed = function(name3) {
              return name3.replace(/[A-Z]/g, function(a) {
                return "-" + a;
              });
            };
            if (typeof name2 === "object") {
              each$2(name2, function(name3, value3) {
                self2.css(name3, value3);
              });
            } else {
              if (isDefined(value2)) {
                name2 = camel(name2);
                if (typeof value2 === "number" && !numericCssMap[name2]) {
                  value2 = value2.toString() + "px";
                }
                self2.each(function() {
                  var style = this.style;
                  hook = cssHooks[name2];
                  if (hook && hook.set) {
                    hook.set(this, value2);
                    return;
                  }
                  try {
                    this.style[cssFix[name2] || name2] = value2;
                  } catch (ex) {
                  }
                  if (value2 === null || value2 === "") {
                    if (style.removeProperty) {
                      style.removeProperty(dashed(name2));
                    } else {
                      style.removeAttribute(name2);
                    }
                  }
                });
              } else {
                elm = self2[0];
                hook = cssHooks[name2];
                if (hook && hook.get) {
                  return hook.get(elm);
                }
                if (elm.ownerDocument.defaultView) {
                  try {
                    return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name2));
                  } catch (ex) {
                    return void 0;
                  }
                } else if (elm.currentStyle) {
                  return elm.currentStyle[camel(name2)];
                } else {
                  return "";
                }
              }
            }
            return self2;
          },
          remove: function() {
            var self2 = this;
            var node2, i2 = this.length;
            while (i2--) {
              node2 = self2[i2];
              Event.clean(node2);
              if (node2.parentNode) {
                node2.parentNode.removeChild(node2);
              }
            }
            return this;
          },
          empty: function() {
            var self2 = this;
            var node2, i2 = this.length;
            while (i2--) {
              node2 = self2[i2];
              while (node2.firstChild) {
                node2.removeChild(node2.firstChild);
              }
            }
            return this;
          },
          html: function(value2) {
            var self2 = this;
            var i2;
            if (isDefined(value2)) {
              i2 = self2.length;
              try {
                while (i2--) {
                  self2[i2].innerHTML = value2;
                }
              } catch (ex) {
                DomQuery(self2[i2]).empty().append(value2);
              }
              return self2;
            }
            return self2[0] ? self2[0].innerHTML : "";
          },
          text: function(value2) {
            var self2 = this;
            var i2;
            if (isDefined(value2)) {
              i2 = self2.length;
              while (i2--) {
                if ("innerText" in self2[i2]) {
                  self2[i2].innerText = value2;
                } else {
                  self2[0].textContent = value2;
                }
              }
              return self2;
            }
            return self2[0] ? self2[0].innerText || self2[0].textContent : "";
          },
          append: function() {
            return domManipulate(this, arguments, function(node2) {
              if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
                this.appendChild(node2);
              }
            });
          },
          prepend: function() {
            return domManipulate(this, arguments, function(node2) {
              if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
                this.insertBefore(node2, this.firstChild);
              }
            }, true);
          },
          before: function() {
            var self2 = this;
            if (self2[0] && self2[0].parentNode) {
              return domManipulate(self2, arguments, function(node2) {
                this.parentNode.insertBefore(node2, this);
              });
            }
            return self2;
          },
          after: function() {
            var self2 = this;
            if (self2[0] && self2[0].parentNode) {
              return domManipulate(self2, arguments, function(node2) {
                this.parentNode.insertBefore(node2, this.nextSibling);
              }, true);
            }
            return self2;
          },
          appendTo: function(val) {
            DomQuery(val).append(this);
            return this;
          },
          prependTo: function(val) {
            DomQuery(val).prepend(this);
            return this;
          },
          replaceWith: function(content) {
            return this.before(content).remove();
          },
          wrap: function(content) {
            return wrap(this, content);
          },
          wrapAll: function(content) {
            return wrap(this, content, true);
          },
          wrapInner: function(content) {
            this.each(function() {
              DomQuery(this).contents().wrapAll(content);
            });
            return this;
          },
          unwrap: function() {
            return this.parent().each(function() {
              DomQuery(this).replaceWith(this.childNodes);
            });
          },
          clone: function() {
            var result = [];
            this.each(function() {
              result.push(this.cloneNode(true));
            });
            return DomQuery(result);
          },
          addClass: function(className) {
            return this.toggleClass(className, true);
          },
          removeClass: function(className) {
            return this.toggleClass(className, false);
          },
          toggleClass: function(className, state) {
            var self2 = this;
            if (typeof className !== "string") {
              return self2;
            }
            if (className.indexOf(" ") !== -1) {
              each$2(className.split(" "), function() {
                self2.toggleClass(this, state);
              });
            } else {
              self2.each(function(index, node2) {
                var existingClassName, classState;
                classState = hasClass(node2, className);
                if (classState !== state) {
                  existingClassName = node2.className;
                  if (classState) {
                    node2.className = trim$1((" " + existingClassName + " ").replace(" " + className + " ", " "));
                  } else {
                    node2.className += existingClassName ? " " + className : className;
                  }
                }
              });
            }
            return self2;
          },
          hasClass: function(className) {
            return hasClass(this[0], className);
          },
          each: function(callback) {
            return each$2(this, callback);
          },
          on: function(name2, callback) {
            return this.each(function() {
              Event.bind(this, name2, callback);
            });
          },
          off: function(name2, callback) {
            return this.each(function() {
              Event.unbind(this, name2, callback);
            });
          },
          trigger: function(name2) {
            return this.each(function() {
              if (typeof name2 === "object") {
                Event.fire(this, name2.type, name2);
              } else {
                Event.fire(this, name2);
              }
            });
          },
          show: function() {
            return this.css("display", "");
          },
          hide: function() {
            return this.css("display", "none");
          },
          slice: function() {
            return new DomQuery(slice$1.apply(this, arguments));
          },
          eq: function(index) {
            return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          find: function(selector) {
            var i2, l;
            var ret = [];
            for (i2 = 0, l = this.length; i2 < l; i2++) {
              DomQuery.find(selector, this[i2], ret);
            }
            return DomQuery(ret);
          },
          filter: function(selector) {
            if (typeof selector === "function") {
              return DomQuery(grep(this.toArray(), function(item, i2) {
                return selector(i2, item);
              }));
            }
            return DomQuery(DomQuery.filter(selector, this.toArray()));
          },
          closest: function(selector) {
            var result = [];
            if (selector instanceof DomQuery) {
              selector = selector[0];
            }
            this.each(function(i2, node2) {
              while (node2) {
                if (typeof selector === "string" && DomQuery(node2).is(selector)) {
                  result.push(node2);
                  break;
                } else if (node2 === selector) {
                  result.push(node2);
                  break;
                }
                node2 = node2.parentNode;
              }
            });
            return DomQuery(result);
          },
          offset: function(offset) {
            var elm, doc2, docElm;
            var x = 0, y = 0, pos;
            if (!offset) {
              elm = this[0];
              if (elm) {
                doc2 = elm.ownerDocument;
                docElm = doc2.documentElement;
                if (elm.getBoundingClientRect) {
                  pos = elm.getBoundingClientRect();
                  x = pos.left + (docElm.scrollLeft || doc2.body.scrollLeft) - docElm.clientLeft;
                  y = pos.top + (docElm.scrollTop || doc2.body.scrollTop) - docElm.clientTop;
                }
              }
              return {
                left: x,
                top: y
              };
            }
            return this.css(offset);
          },
          push: push$1,
          sort: [].sort,
          splice: [].splice
        };
        Tools.extend(DomQuery, {
          extend: Tools.extend,
          makeArray: function(object) {
            if (isWindow(object) || object.nodeType) {
              return [object];
            }
            return Tools.toArray(object);
          },
          inArray,
          isArray: Tools.isArray,
          each: each$2,
          trim: trim$1,
          grep,
          find: Sizzle,
          expr: Sizzle.selectors,
          unique: Sizzle.uniqueSort,
          text: Sizzle.getText,
          contains: Sizzle.contains,
          filter: function(expr, elems, not3) {
            var i2 = elems.length;
            if (not3) {
              expr = ":not(" + expr + ")";
            }
            while (i2--) {
              if (elems[i2].nodeType !== 1) {
                elems.splice(i2, 1);
              }
            }
            if (elems.length === 1) {
              elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
            } else {
              elems = DomQuery.find.matches(expr, elems);
            }
            return elems;
          }
        });
        var dir = function(el2, prop2, until) {
          var matched = [];
          var cur = el2[prop2];
          if (typeof until !== "string" && until instanceof DomQuery) {
            until = until[0];
          }
          while (cur && cur.nodeType !== 9) {
            if (until !== void 0) {
              if (cur === until) {
                break;
              }
              if (typeof until === "string" && DomQuery(cur).is(until)) {
                break;
              }
            }
            if (cur.nodeType === 1) {
              matched.push(cur);
            }
            cur = cur[prop2];
          }
          return matched;
        };
        var sibling = function(node2, siblingName, nodeType, until) {
          var result = [];
          if (until instanceof DomQuery) {
            until = until[0];
          }
          for (; node2; node2 = node2[siblingName]) {
            if (node2.nodeType !== nodeType) {
              continue;
            }
            if (until !== void 0) {
              if (node2 === until) {
                break;
              }
              if (typeof until === "string" && DomQuery(node2).is(until)) {
                break;
              }
            }
            result.push(node2);
          }
          return result;
        };
        var firstSibling = function(node2, siblingName, nodeType) {
          for (node2 = node2[siblingName]; node2; node2 = node2[siblingName]) {
            if (node2.nodeType === nodeType) {
              return node2;
            }
          }
          return null;
        };
        each$2({
          parent: function(node2) {
            var parent2 = node2.parentNode;
            return parent2 && parent2.nodeType !== 11 ? parent2 : null;
          },
          parents: function(node2) {
            return dir(node2, "parentNode");
          },
          next: function(node2) {
            return firstSibling(node2, "nextSibling", 1);
          },
          prev: function(node2) {
            return firstSibling(node2, "previousSibling", 1);
          },
          children: function(node2) {
            return sibling(node2.firstChild, "nextSibling", 1);
          },
          contents: function(node2) {
            return Tools.toArray((node2.nodeName === "iframe" ? node2.contentDocument || node2.contentWindow.document : node2).childNodes);
          }
        }, function(name2, fn) {
          DomQuery.fn[name2] = function(selector) {
            var self2 = this;
            var result = [];
            self2.each(function() {
              var nodes = fn.call(result, this, selector, result);
              if (nodes) {
                if (DomQuery.isArray(nodes)) {
                  result.push.apply(result, nodes);
                } else {
                  result.push(nodes);
                }
              }
            });
            if (this.length > 1) {
              if (!skipUniques[name2]) {
                result = DomQuery.unique(result);
              }
              if (name2.indexOf("parents") === 0) {
                result = result.reverse();
              }
            }
            result = DomQuery(result);
            if (selector) {
              return result.filter(selector);
            }
            return result;
          };
        });
        each$2({
          parentsUntil: function(node2, until) {
            return dir(node2, "parentNode", until);
          },
          nextUntil: function(node2, until) {
            return sibling(node2, "nextSibling", 1, until).slice(1);
          },
          prevUntil: function(node2, until) {
            return sibling(node2, "previousSibling", 1, until).slice(1);
          }
        }, function(name2, fn) {
          DomQuery.fn[name2] = function(selector, filter2) {
            var self2 = this;
            var result = [];
            self2.each(function() {
              var nodes = fn.call(result, this, selector, result);
              if (nodes) {
                if (DomQuery.isArray(nodes)) {
                  result.push.apply(result, nodes);
                } else {
                  result.push(nodes);
                }
              }
            });
            if (this.length > 1) {
              result = DomQuery.unique(result);
              if (name2.indexOf("parents") === 0 || name2 === "prevUntil") {
                result = result.reverse();
              }
            }
            result = DomQuery(result);
            if (filter2) {
              return result.filter(filter2);
            }
            return result;
          };
        });
        DomQuery.fn.is = function(selector) {
          return !!selector && this.filter(selector).length > 0;
        };
        DomQuery.fn.init.prototype = DomQuery.fn;
        DomQuery.overrideDefaults = function(callback) {
          var defaults;
          var sub2 = function(selector, context2) {
            defaults = defaults || callback();
            if (arguments.length === 0) {
              selector = defaults.element;
            }
            if (!context2) {
              context2 = defaults.context;
            }
            return new sub2.fn.init(selector, context2);
          };
          DomQuery.extend(sub2, this);
          return sub2;
        };
        var appendHooks = function(targetHooks, prop2, hooks) {
          each$2(hooks, function(name2, func) {
            targetHooks[name2] = targetHooks[name2] || {};
            targetHooks[name2][prop2] = func;
          });
        };
        if (Env.ie && Env.ie < 8) {
          appendHooks(attrHooks, "get", {
            maxlength: function(elm) {
              var value2 = elm.maxLength;
              if (value2 === 2147483647) {
                return void 0;
              }
              return value2;
            },
            size: function(elm) {
              var value2 = elm.size;
              if (value2 === 20) {
                return void 0;
              }
              return value2;
            },
            class: function(elm) {
              return elm.className;
            },
            style: function(elm) {
              var value2 = elm.style.cssText;
              if (value2.length === 0) {
                return void 0;
              }
              return value2;
            }
          });
          appendHooks(attrHooks, "set", {
            class: function(elm, value2) {
              elm.className = value2;
            },
            style: function(elm, value2) {
              elm.style.cssText = value2;
            }
          });
        }
        if (Env.ie && Env.ie < 9) {
          cssFix.float = "styleFloat";
          appendHooks(cssHooks, "set", {
            opacity: function(elm, value2) {
              var style = elm.style;
              if (value2 === null || value2 === "") {
                style.removeAttribute("filter");
              } else {
                style.zoom = 1;
                style.filter = "alpha(opacity=" + value2 * 100 + ")";
              }
            }
          });
        }
        DomQuery.attrHooks = attrHooks;
        DomQuery.cssHooks = cssHooks;
        var cached = function(f) {
          var called = false;
          var r;
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (!called) {
              called = true;
              r = f.apply(null, args);
            }
            return r;
          };
        };
        var firstMatch = function(regexes, s) {
          for (var i2 = 0; i2 < regexes.length; i2++) {
            var x = regexes[i2];
            if (x.test(s)) {
              return x;
            }
          }
          return void 0;
        };
        var find$2 = function(regexes, agent) {
          var r = firstMatch(regexes, agent);
          if (!r) {
            return {
              major: 0,
              minor: 0
            };
          }
          var group = function(i2) {
            return Number(agent.replace(r, "$" + i2));
          };
          return nu2(group(1), group(2));
        };
        var detect = function(versionRegexes, agent) {
          var cleanedAgent = String(agent).toLowerCase();
          if (versionRegexes.length === 0) {
            return unknown();
          }
          return find$2(versionRegexes, cleanedAgent);
        };
        var unknown = function() {
          return nu2(0, 0);
        };
        var nu2 = function(major, minor) {
          return {
            major,
            minor
          };
        };
        var Version = {
          nu: nu2,
          detect,
          unknown
        };
        var edge = "Edge";
        var chrome = "Chrome";
        var ie$1 = "IE";
        var opera$1 = "Opera";
        var firefox = "Firefox";
        var safari = "Safari";
        var isBrowser = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$1 = function() {
          return nu$1({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$1 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isEdge: isBrowser(edge, current),
            isChrome: isBrowser(chrome, current),
            isIE: isBrowser(ie$1, current),
            isOpera: isBrowser(opera$1, current),
            isFirefox: isBrowser(firefox, current),
            isSafari: isBrowser(safari, current)
          };
        };
        var Browser = {
          unknown: unknown$1,
          nu: nu$1
        };
        var windows = "Windows";
        var ios = "iOS";
        var android$1 = "Android";
        var linux = "Linux";
        var osx = "OSX";
        var solaris = "Solaris";
        var freebsd = "FreeBSD";
        var isOS = function(name2, current) {
          return function() {
            return current === name2;
          };
        };
        var unknown$2 = function() {
          return nu$2({
            current: void 0,
            version: Version.unknown()
          });
        };
        var nu$2 = function(info) {
          var current = info.current;
          var version = info.version;
          return {
            current,
            version,
            isWindows: isOS(windows, current),
            isiOS: isOS(ios, current),
            isAndroid: isOS(android$1, current),
            isOSX: isOS(osx, current),
            isLinux: isOS(linux, current),
            isSolaris: isOS(solaris, current),
            isFreeBSD: isOS(freebsd, current)
          };
        };
        var OperatingSystem = {
          unknown: unknown$2,
          nu: nu$2
        };
        var DeviceType = function(os, browser2, userAgent2) {
          var isiPad = os.isiOS() && /ipad/i.test(userAgent2) === true;
          var isiPhone = os.isiOS() && !isiPad;
          var isAndroid3 = os.isAndroid() && os.version.major === 3;
          var isAndroid4 = os.isAndroid() && os.version.major === 4;
          var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent2) === true;
          var isTouch2 = os.isiOS() || os.isAndroid();
          var isPhone = isTouch2 && !isTablet;
          var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent2) === false;
          return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet),
            isPhone: constant(isPhone),
            isTouch: constant(isTouch2),
            isAndroid: os.isAndroid,
            isiOS: os.isiOS,
            isWebView: constant(iOSwebview)
          };
        };
        var detect$1 = function(candidates, userAgent2) {
          var agent = String(userAgent2).toLowerCase();
          return find(candidates, function(candidate) {
            return candidate.search(agent);
          });
        };
        var detectBrowser = function(browsers2, userAgent2) {
          return detect$1(browsers2, userAgent2).map(function(browser2) {
            var version = Version.detect(browser2.versionRegexes, userAgent2);
            return {
              current: browser2.name,
              version
            };
          });
        };
        var detectOs = function(oses2, userAgent2) {
          return detect$1(oses2, userAgent2).map(function(os) {
            var version = Version.detect(os.versionRegexes, userAgent2);
            return {
              current: os.name,
              version
            };
          });
        };
        var UaString = {
          detectBrowser,
          detectOs
        };
        var contains$2 = function(str, substr) {
          return str.indexOf(substr) !== -1;
        };
        var trim$2 = function(str) {
          return str.replace(/^\s+|\s+$/g, "");
        };
        var lTrim = function(str) {
          return str.replace(/^\s+/g, "");
        };
        var rTrim = function(str) {
          return str.replace(/\s+$/g, "");
        };
        var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
        var checkContains = function(target2) {
          return function(uastring) {
            return contains$2(uastring, target2);
          };
        };
        var browsers = [
          {
            name: "Edge",
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: function(uastring) {
              return contains$2(uastring, "edge/") && contains$2(uastring, "chrome") && contains$2(uastring, "safari") && contains$2(uastring, "applewebkit");
            }
          },
          {
            name: "Chrome",
            versionRegexes: [
              /.*?chrome\/([0-9]+)\.([0-9]+).*/,
              normalVersionRegex
            ],
            search: function(uastring) {
              return contains$2(uastring, "chrome") && !contains$2(uastring, "chromeframe");
            }
          },
          {
            name: "IE",
            versionRegexes: [
              /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
              /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: function(uastring) {
              return contains$2(uastring, "msie") || contains$2(uastring, "trident");
            }
          },
          {
            name: "Opera",
            versionRegexes: [
              normalVersionRegex,
              /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains("opera")
          },
          {
            name: "Firefox",
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains("firefox")
          },
          {
            name: "Safari",
            versionRegexes: [
              normalVersionRegex,
              /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: function(uastring) {
              return (contains$2(uastring, "safari") || contains$2(uastring, "mobile/")) && contains$2(uastring, "applewebkit");
            }
          }
        ];
        var oses = [
          {
            name: "Windows",
            search: checkContains("win"),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "iOS",
            search: function(uastring) {
              return contains$2(uastring, "iphone") || contains$2(uastring, "ipad");
            },
            versionRegexes: [
              /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
              /.*cpu os ([0-9]+)_([0-9]+).*/,
              /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
          },
          {
            name: "Android",
            search: checkContains("android"),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "OSX",
            search: checkContains("os x"),
            versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
          },
          {
            name: "Linux",
            search: checkContains("linux"),
            versionRegexes: []
          },
          {
            name: "Solaris",
            search: checkContains("sunos"),
            versionRegexes: []
          },
          {
            name: "FreeBSD",
            search: checkContains("freebsd"),
            versionRegexes: []
          }
        ];
        var PlatformInfo = {
          browsers: constant(browsers),
          oses: constant(oses)
        };
        var detect$2 = function(userAgent2) {
          var browsers2 = PlatformInfo.browsers();
          var oses2 = PlatformInfo.oses();
          var browser2 = UaString.detectBrowser(browsers2, userAgent2).fold(Browser.unknown, Browser.nu);
          var os = UaString.detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
          var deviceType = DeviceType(os, browser2, userAgent2);
          return {
            browser: browser2,
            os,
            deviceType
          };
        };
        var PlatformDetection = { detect: detect$2 };
        var detect$3 = cached(function() {
          var userAgent2 = domGlobals.navigator.userAgent;
          return PlatformDetection.detect(userAgent2);
        });
        var PlatformDetection$1 = { detect: detect$3 };
        var fromHtml = function(html2, scope) {
          var doc2 = scope || domGlobals.document;
          var div2 = doc2.createElement("div");
          div2.innerHTML = html2;
          if (!div2.hasChildNodes() || div2.childNodes.length > 1) {
            domGlobals.console.error("HTML does not have a single root node", html2);
            throw new Error("HTML must have a single root node");
          }
          return fromDom(div2.childNodes[0]);
        };
        var fromTag = function(tag, scope) {
          var doc2 = scope || domGlobals.document;
          var node2 = doc2.createElement(tag);
          return fromDom(node2);
        };
        var fromText = function(text2, scope) {
          var doc2 = scope || domGlobals.document;
          var node2 = doc2.createTextNode(text2);
          return fromDom(node2);
        };
        var fromDom = function(node2) {
          if (node2 === null || node2 === void 0) {
            throw new Error("Node cannot be null or undefined");
          }
          return { dom: constant(node2) };
        };
        var fromPoint = function(docElm, x, y) {
          var doc2 = docElm.dom();
          return Option.from(doc2.elementFromPoint(x, y)).map(fromDom);
        };
        var Element2 = {
          fromHtml,
          fromTag,
          fromText,
          fromDom,
          fromPoint
        };
        var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
        var ELEMENT = domGlobals.Node.ELEMENT_NODE;
        var TEXT = domGlobals.Node.TEXT_NODE;
        var name = function(element) {
          var r = element.dom().nodeName;
          return r.toLowerCase();
        };
        var type = function(element) {
          return element.dom().nodeType;
        };
        var isType$1 = function(t) {
          return function(element) {
            return type(element) === t;
          };
        };
        var isElement = isType$1(ELEMENT);
        var isText = isType$1(TEXT);
        var keys = Object.keys;
        var hasOwnProperty$1 = Object.hasOwnProperty;
        var each$3 = function(obj, f) {
          var props = keys(obj);
          for (var k = 0, len = props.length; k < len; k++) {
            var i2 = props[k];
            var x = obj[i2];
            f(x, i2);
          }
        };
        var map$2 = function(obj, f) {
          return tupleMap(obj, function(x, i2) {
            return {
              k: i2,
              v: f(x, i2)
            };
          });
        };
        var tupleMap = function(obj, f) {
          var r = {};
          each$3(obj, function(x, i2) {
            var tuple = f(x, i2);
            r[tuple.k] = tuple.v;
          });
          return r;
        };
        var bifilter = function(obj, pred) {
          var t = {};
          var f = {};
          each$3(obj, function(x, i2) {
            var branch = pred(x, i2) ? t : f;
            branch[i2] = x;
          });
          return {
            t,
            f
          };
        };
        var has2 = function(obj, key) {
          return hasOwnProperty$1.call(obj, key);
        };
        var isSupported = function(dom2) {
          return dom2.style !== void 0 && isFunction(dom2.style.getPropertyValue);
        };
        var inBody = function(element) {
          var dom2 = isText(element) ? element.dom().parentNode : element.dom();
          return dom2 !== void 0 && dom2 !== null && dom2.ownerDocument.body.contains(dom2);
        };
        var rawSet = function(dom2, key, value2) {
          if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
            dom2.setAttribute(key, value2 + "");
          } else {
            domGlobals.console.error("Invalid call to Attr.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("Attribute value was not simple");
          }
        };
        var set = function(element, key, value2) {
          rawSet(element.dom(), key, value2);
        };
        var setAll = function(element, attrs) {
          var dom2 = element.dom();
          each$3(attrs, function(v, k) {
            rawSet(dom2, k, v);
          });
        };
        var get = function(element, key) {
          var v = element.dom().getAttribute(key);
          return v === null ? void 0 : v;
        };
        var has$1 = function(element, key) {
          var dom2 = element.dom();
          return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
        };
        var remove2 = function(element, key) {
          element.dom().removeAttribute(key);
        };
        var internalSet = function(dom2, property, value2) {
          if (!isString(value2)) {
            domGlobals.console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("CSS value must be a string: " + value2);
          }
          if (isSupported(dom2)) {
            dom2.style.setProperty(property, value2);
          }
        };
        var setAll$1 = function(element, css2) {
          var dom2 = element.dom();
          each$3(css2, function(v, k) {
            internalSet(dom2, k, v);
          });
        };
        var get$1 = function(element, property) {
          var dom2 = element.dom();
          var styles = domGlobals.window.getComputedStyle(dom2);
          var r = styles.getPropertyValue(property);
          var v = r === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r;
          return v === null ? void 0 : v;
        };
        var getUnsafeProperty = function(dom2, property) {
          return isSupported(dom2) ? dom2.style.getPropertyValue(property) : "";
        };
        var getRaw = function(element, property) {
          var dom2 = element.dom();
          var raw = getUnsafeProperty(dom2, property);
          return Option.from(raw).filter(function(r) {
            return r.length > 0;
          });
        };
        var getAllRaw = function(element) {
          var css2 = {};
          var dom2 = element.dom();
          if (isSupported(dom2)) {
            for (var i2 = 0; i2 < dom2.style.length; i2++) {
              var ruleName = dom2.style.item(i2);
              css2[ruleName] = dom2.style[ruleName];
            }
          }
          return css2;
        };
        var Immutable = function() {
          var fields = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            fields[_i] = arguments[_i];
          }
          return function() {
            var values = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              values[_i2] = arguments[_i2];
            }
            if (fields.length !== values.length) {
              throw new Error('Wrong number of arguments to struct. Expected "[' + fields.length + ']", got ' + values.length + " arguments");
            }
            var struct = {};
            each(fields, function(name2, i2) {
              struct[name2] = constant(values[i2]);
            });
            return struct;
          };
        };
        var toArray$1 = function(target2, f) {
          var r = [];
          var recurse = function(e) {
            r.push(e);
            return f(e);
          };
          var cur = f(target2);
          do {
            cur = cur.bind(recurse);
          } while (cur.isSome());
          return r;
        };
        var Recurse = { toArray: toArray$1 };
        var node = function() {
          var f = Global$1.getOrDie("Node");
          return f;
        };
        var compareDocumentPosition = function(a, b, match2) {
          return (a.compareDocumentPosition(b) & match2) !== 0;
        };
        var documentPositionPreceding = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
        };
        var documentPositionContainedBy = function(a, b) {
          return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
        };
        var Node2 = {
          documentPositionPreceding,
          documentPositionContainedBy
        };
        var ELEMENT$1 = ELEMENT;
        var DOCUMENT$1 = DOCUMENT;
        var is$1 = function(element, selector) {
          var dom2 = element.dom();
          if (dom2.nodeType !== ELEMENT$1) {
            return false;
          } else {
            var elem = dom2;
            if (elem.matches !== void 0) {
              return elem.matches(selector);
            } else if (elem.msMatchesSelector !== void 0) {
              return elem.msMatchesSelector(selector);
            } else if (elem.webkitMatchesSelector !== void 0) {
              return elem.webkitMatchesSelector(selector);
            } else if (elem.mozMatchesSelector !== void 0) {
              return elem.mozMatchesSelector(selector);
            } else {
              throw new Error("Browser lacks native selectors");
            }
          }
        };
        var bypassSelector = function(dom2) {
          return dom2.nodeType !== ELEMENT$1 && dom2.nodeType !== DOCUMENT$1 || dom2.childElementCount === 0;
        };
        var all = function(selector, scope) {
          var base2 = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base2) ? [] : map2(base2.querySelectorAll(selector), Element2.fromDom);
        };
        var one = function(selector, scope) {
          var base2 = scope === void 0 ? domGlobals.document : scope.dom();
          return bypassSelector(base2) ? Option.none() : Option.from(base2.querySelector(selector)).map(Element2.fromDom);
        };
        var eq = function(e1, e2) {
          return e1.dom() === e2.dom();
        };
        var regularContains = function(e1, e2) {
          var d1 = e1.dom();
          var d2 = e2.dom();
          return d1 === d2 ? false : d1.contains(d2);
        };
        var ieContains = function(e1, e2) {
          return Node2.documentPositionContainedBy(e1.dom(), e2.dom());
        };
        var browser = PlatformDetection$1.detect().browser;
        var contains$3 = browser.isIE() ? ieContains : regularContains;
        var owner = function(element) {
          return Element2.fromDom(element.dom().ownerDocument);
        };
        var documentElement = function(element) {
          return Element2.fromDom(element.dom().ownerDocument.documentElement);
        };
        var defaultView = function(element) {
          return Element2.fromDom(element.dom().ownerDocument.defaultView);
        };
        var parent = function(element) {
          return Option.from(element.dom().parentNode).map(Element2.fromDom);
        };
        var parents = function(element, isRoot) {
          var stop2 = isFunction(isRoot) ? isRoot : never;
          var dom2 = element.dom();
          var ret = [];
          while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
            var rawParent = dom2.parentNode;
            var p = Element2.fromDom(rawParent);
            ret.push(p);
            if (stop2(p) === true) {
              break;
            } else {
              dom2 = rawParent;
            }
          }
          return ret;
        };
        var prevSibling = function(element) {
          return Option.from(element.dom().previousSibling).map(Element2.fromDom);
        };
        var nextSibling = function(element) {
          return Option.from(element.dom().nextSibling).map(Element2.fromDom);
        };
        var prevSiblings = function(element) {
          return reverse(Recurse.toArray(element, prevSibling));
        };
        var nextSiblings = function(element) {
          return Recurse.toArray(element, nextSibling);
        };
        var children = function(element) {
          return map2(element.dom().childNodes, Element2.fromDom);
        };
        var child = function(element, index) {
          var cs = element.dom().childNodes;
          return Option.from(cs[index]).map(Element2.fromDom);
        };
        var firstChild = function(element) {
          return child(element, 0);
        };
        var lastChild = function(element) {
          return child(element, element.dom().childNodes.length - 1);
        };
        var childNodesCount = function(element) {
          return element.dom().childNodes.length;
        };
        Immutable("element", "offset");
        var browser$1 = PlatformDetection$1.detect().browser;
        var firstElement = function(nodes) {
          return find(nodes, isElement);
        };
        var getTableCaptionDeltaY = function(elm) {
          if (browser$1.isFirefox() && name(elm) === "table") {
            return firstElement(children(elm)).filter(function(elm2) {
              return name(elm2) === "caption";
            }).bind(function(caption) {
              return firstElement(nextSiblings(caption)).map(function(body) {
                var bodyTop = body.dom().offsetTop;
                var captionTop = caption.dom().offsetTop;
                var captionHeight = caption.dom().offsetHeight;
                return bodyTop <= captionTop ? -captionHeight : 0;
              });
            }).getOr(0);
          } else {
            return 0;
          }
        };
        var getPos = function(body, elm, rootElm) {
          var x = 0, y = 0, offsetParent;
          var doc2 = body.ownerDocument;
          var pos;
          rootElm = rootElm ? rootElm : body;
          if (elm) {
            if (rootElm === body && elm.getBoundingClientRect && get$1(Element2.fromDom(body), "position") === "static") {
              pos = elm.getBoundingClientRect();
              x = pos.left + (doc2.documentElement.scrollLeft || body.scrollLeft) - doc2.documentElement.clientLeft;
              y = pos.top + (doc2.documentElement.scrollTop || body.scrollTop) - doc2.documentElement.clientTop;
              return {
                x,
                y
              };
            }
            offsetParent = elm;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType) {
              x += offsetParent.offsetLeft || 0;
              y += offsetParent.offsetTop || 0;
              offsetParent = offsetParent.offsetParent;
            }
            offsetParent = elm.parentNode;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType) {
              x -= offsetParent.scrollLeft || 0;
              y -= offsetParent.scrollTop || 0;
              offsetParent = offsetParent.parentNode;
            }
            y += getTableCaptionDeltaY(Element2.fromDom(elm));
          }
          return {
            x,
            y
          };
        };
        var Position = { getPos };
        var exports$1 = {}, module$1 = { exports: exports$1 };
        (function(define, exports$12, module2, require2) {
          (function(f) {
            if (typeof exports$12 === "object" && typeof module2 !== "undefined") {
              module2.exports = f();
            } else {
              var g;
              if (typeof window !== "undefined") {
                g = window;
              } else if (typeof commonjsGlobal !== "undefined") {
                g = commonjsGlobal;
              } else if (typeof self !== "undefined") {
                g = self;
              } else {
                g = this;
              }
              g.EphoxContactWrapper = f();
            }
          })(function() {
            return (/* @__PURE__ */ (function() {
              function r(e, n, t) {
                function o(i3, f) {
                  if (!n[i3]) {
                    if (!e[i3]) {
                      var c = false;
                      if (!f && c)
                        return c(i3, true);
                      if (u)
                        return u(i3, true);
                      var a = new Error("Cannot find module '" + i3 + "'");
                      throw a.code = "MODULE_NOT_FOUND", a;
                    }
                    var p = n[i3] = { exports: {} };
                    e[i3][0].call(p.exports, function(r2) {
                      var n2 = e[i3][1][r2];
                      return o(n2 || r2);
                    }, p, p.exports, r, e, n, t);
                  }
                  return n[i3].exports;
                }
                for (var u = false, i2 = 0; i2 < t.length; i2++)
                  o(t[i2]);
                return o;
              }
              return r;
            })())({
              1: [
                function(require3, module3, exports$13) {
                  var process3 = module3.exports = {};
                  var cachedSetTimeout;
                  var cachedClearTimeout;
                  function defaultSetTimout() {
                    throw new Error("setTimeout has not been defined");
                  }
                  function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined");
                  }
                  (function() {
                    try {
                      if (typeof setTimeout === "function") {
                        cachedSetTimeout = setTimeout;
                      } else {
                        cachedSetTimeout = defaultSetTimout;
                      }
                    } catch (e) {
                      cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                      if (typeof clearTimeout === "function") {
                        cachedClearTimeout = clearTimeout;
                      } else {
                        cachedClearTimeout = defaultClearTimeout;
                      }
                    } catch (e) {
                      cachedClearTimeout = defaultClearTimeout;
                    }
                  })();
                  function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                      return setTimeout(fun, 0);
                    }
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                      cachedSetTimeout = setTimeout;
                      return setTimeout(fun, 0);
                    }
                    try {
                      return cachedSetTimeout(fun, 0);
                    } catch (e) {
                      try {
                        return cachedSetTimeout.call(null, fun, 0);
                      } catch (e2) {
                        return cachedSetTimeout.call(this, fun, 0);
                      }
                    }
                  }
                  function runClearTimeout(marker2) {
                    if (cachedClearTimeout === clearTimeout) {
                      return clearTimeout(marker2);
                    }
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                      cachedClearTimeout = clearTimeout;
                      return clearTimeout(marker2);
                    }
                    try {
                      return cachedClearTimeout(marker2);
                    } catch (e) {
                      try {
                        return cachedClearTimeout.call(null, marker2);
                      } catch (e2) {
                        return cachedClearTimeout.call(this, marker2);
                      }
                    }
                  }
                  var queue = [];
                  var draining = false;
                  var currentQueue;
                  var queueIndex = -1;
                  function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                      return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                      queue = currentQueue.concat(queue);
                    } else {
                      queueIndex = -1;
                    }
                    if (queue.length) {
                      drainQueue();
                    }
                  }
                  function drainQueue() {
                    if (draining) {
                      return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while (len) {
                      currentQueue = queue;
                      queue = [];
                      while (++queueIndex < len) {
                        if (currentQueue) {
                          currentQueue[queueIndex].run();
                        }
                      }
                      queueIndex = -1;
                      len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                  }
                  process3.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                      for (var i2 = 1; i2 < arguments.length; i2++) {
                        args[i2 - 1] = arguments[i2];
                      }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                      runTimeout(drainQueue);
                    }
                  };
                  function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                  }
                  Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                  };
                  process3.title = "browser";
                  process3.browser = true;
                  process3.env = {};
                  process3.argv = [];
                  process3.version = "";
                  process3.versions = {};
                  function noop2() {
                  }
                  process3.on = noop2;
                  process3.addListener = noop2;
                  process3.once = noop2;
                  process3.off = noop2;
                  process3.removeListener = noop2;
                  process3.removeAllListeners = noop2;
                  process3.emit = noop2;
                  process3.prependListener = noop2;
                  process3.prependOnceListener = noop2;
                  process3.listeners = function(name2) {
                    return [];
                  };
                  process3.binding = function(name2) {
                    throw new Error("process.binding is not supported");
                  };
                  process3.cwd = function() {
                    return "/";
                  };
                  process3.chdir = function(dir2) {
                    throw new Error("process.chdir is not supported");
                  };
                  process3.umask = function() {
                    return 0;
                  };
                },
                {}
              ],
              2: [
                function(require3, module3, exports$13) {
                  (function(setImmediate2) {
                    (function(root2) {
                      var setTimeoutFunc = setTimeout;
                      function noop2() {
                      }
                      function bind2(fn, thisArg) {
                        return function() {
                          fn.apply(thisArg, arguments);
                        };
                      }
                      function Promise3(fn) {
                        if (typeof this !== "object")
                          throw new TypeError("Promises must be constructed via new");
                        if (typeof fn !== "function")
                          throw new TypeError("not a function");
                        this._state = 0;
                        this._handled = false;
                        this._value = void 0;
                        this._deferreds = [];
                        doResolve(fn, this);
                      }
                      function handle2(self2, deferred) {
                        while (self2._state === 3) {
                          self2 = self2._value;
                        }
                        if (self2._state === 0) {
                          self2._deferreds.push(deferred);
                          return;
                        }
                        self2._handled = true;
                        Promise3._immediateFn(function() {
                          var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                          if (cb === null) {
                            (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
                            return;
                          }
                          var ret;
                          try {
                            ret = cb(self2._value);
                          } catch (e) {
                            reject(deferred.promise, e);
                            return;
                          }
                          resolve2(deferred.promise, ret);
                        });
                      }
                      function resolve2(self2, newValue) {
                        try {
                          if (newValue === self2)
                            throw new TypeError("A promise cannot be resolved with itself.");
                          if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                            var then = newValue.then;
                            if (newValue instanceof Promise3) {
                              self2._state = 3;
                              self2._value = newValue;
                              finale(self2);
                              return;
                            } else if (typeof then === "function") {
                              doResolve(bind2(then, newValue), self2);
                              return;
                            }
                          }
                          self2._state = 1;
                          self2._value = newValue;
                          finale(self2);
                        } catch (e) {
                          reject(self2, e);
                        }
                      }
                      function reject(self2, newValue) {
                        self2._state = 2;
                        self2._value = newValue;
                        finale(self2);
                      }
                      function finale(self2) {
                        if (self2._state === 2 && self2._deferreds.length === 0) {
                          Promise3._immediateFn(function() {
                            if (!self2._handled) {
                              Promise3._unhandledRejectionFn(self2._value);
                            }
                          });
                        }
                        for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {
                          handle2(self2, self2._deferreds[i2]);
                        }
                        self2._deferreds = null;
                      }
                      function Handler(onFulfilled, onRejected, promise2) {
                        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
                        this.onRejected = typeof onRejected === "function" ? onRejected : null;
                        this.promise = promise2;
                      }
                      function doResolve(fn, self2) {
                        var done2 = false;
                        try {
                          fn(function(value2) {
                            if (done2)
                              return;
                            done2 = true;
                            resolve2(self2, value2);
                          }, function(reason) {
                            if (done2)
                              return;
                            done2 = true;
                            reject(self2, reason);
                          });
                        } catch (ex) {
                          if (done2)
                            return;
                          done2 = true;
                          reject(self2, ex);
                        }
                      }
                      Promise3.prototype["catch"] = function(onRejected) {
                        return this.then(null, onRejected);
                      };
                      Promise3.prototype.then = function(onFulfilled, onRejected) {
                        var prom = new this.constructor(noop2);
                        handle2(this, new Handler(onFulfilled, onRejected, prom));
                        return prom;
                      };
                      Promise3.all = function(arr2) {
                        var args = Array.prototype.slice.call(arr2);
                        return new Promise3(function(resolve3, reject2) {
                          if (args.length === 0)
                            return resolve3([]);
                          var remaining = args.length;
                          function res(i3, val) {
                            try {
                              if (val && (typeof val === "object" || typeof val === "function")) {
                                var then = val.then;
                                if (typeof then === "function") {
                                  then.call(val, function(val2) {
                                    res(i3, val2);
                                  }, reject2);
                                  return;
                                }
                              }
                              args[i3] = val;
                              if (--remaining === 0) {
                                resolve3(args);
                              }
                            } catch (ex) {
                              reject2(ex);
                            }
                          }
                          for (var i2 = 0; i2 < args.length; i2++) {
                            res(i2, args[i2]);
                          }
                        });
                      };
                      Promise3.resolve = function(value2) {
                        if (value2 && typeof value2 === "object" && value2.constructor === Promise3) {
                          return value2;
                        }
                        return new Promise3(function(resolve3) {
                          resolve3(value2);
                        });
                      };
                      Promise3.reject = function(value2) {
                        return new Promise3(function(resolve3, reject2) {
                          reject2(value2);
                        });
                      };
                      Promise3.race = function(values) {
                        return new Promise3(function(resolve3, reject2) {
                          for (var i2 = 0, len = values.length; i2 < len; i2++) {
                            values[i2].then(resolve3, reject2);
                          }
                        });
                      };
                      Promise3._immediateFn = typeof setImmediate2 === "function" ? function(fn) {
                        setImmediate2(fn);
                      } : function(fn) {
                        setTimeoutFunc(fn, 0);
                      };
                      Promise3._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                        if (typeof console !== "undefined" && console) {
                          console.warn("Possible Unhandled Promise Rejection:", err);
                        }
                      };
                      Promise3._setImmediateFn = function _setImmediateFn(fn) {
                        Promise3._immediateFn = fn;
                      };
                      Promise3._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                        Promise3._unhandledRejectionFn = fn;
                      };
                      if (typeof module3 !== "undefined" && module3.exports) {
                        module3.exports = Promise3;
                      } else if (!root2.Promise) {
                        root2.Promise = Promise3;
                      }
                    })(this);
                  }).call(this, require3("timers").setImmediate);
                },
                { "timers": 3 }
              ],
              3: [
                function(require3, module3, exports$13) {
                  (function(setImmediate2, clearImmediate) {
                    var nextTick = require3("process/browser.js").nextTick;
                    var apply = Function.prototype.apply;
                    var slice2 = Array.prototype.slice;
                    var immediateIds = {};
                    var nextImmediateId = 0;
                    exports$13.setTimeout = function() {
                      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                    };
                    exports$13.setInterval = function() {
                      return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                    };
                    exports$13.clearTimeout = exports$13.clearInterval = function(timeout) {
                      timeout.close();
                    };
                    function Timeout(id, clearFn) {
                      this._id = id;
                      this._clearFn = clearFn;
                    }
                    Timeout.prototype.unref = Timeout.prototype.ref = function() {
                    };
                    Timeout.prototype.close = function() {
                      this._clearFn.call(window, this._id);
                    };
                    exports$13.enroll = function(item, msecs) {
                      clearTimeout(item._idleTimeoutId);
                      item._idleTimeout = msecs;
                    };
                    exports$13.unenroll = function(item) {
                      clearTimeout(item._idleTimeoutId);
                      item._idleTimeout = -1;
                    };
                    exports$13._unrefActive = exports$13.active = function(item) {
                      clearTimeout(item._idleTimeoutId);
                      var msecs = item._idleTimeout;
                      if (msecs >= 0) {
                        item._idleTimeoutId = setTimeout(function onTimeout() {
                          if (item._onTimeout)
                            item._onTimeout();
                        }, msecs);
                      }
                    };
                    exports$13.setImmediate = typeof setImmediate2 === "function" ? setImmediate2 : function(fn) {
                      var id = nextImmediateId++;
                      var args = arguments.length < 2 ? false : slice2.call(arguments, 1);
                      immediateIds[id] = true;
                      nextTick(function onNextTick() {
                        if (immediateIds[id]) {
                          if (args) {
                            fn.apply(null, args);
                          } else {
                            fn.call(null);
                          }
                          exports$13.clearImmediate(id);
                        }
                      });
                      return id;
                    };
                    exports$13.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                      delete immediateIds[id];
                    };
                  }).call(this, require3("timers").setImmediate, require3("timers").clearImmediate);
                },
                {
                  "process/browser.js": 1,
                  "timers": 3
                }
              ],
              4: [
                function(require3, module3, exports$13) {
                  var promisePolyfill = require3("promise-polyfill");
                  var Global2 = (function() {
                    if (typeof window !== "undefined") {
                      return window;
                    } else {
                      return Function("return this;")();
                    }
                  })();
                  module3.exports = { boltExport: Global2.Promise || promisePolyfill };
                },
                { "promise-polyfill": 2 }
              ]
            }, {}, [4])(4);
          });
        })(void 0, exports$1, module$1);
        var Promise2 = module$1.exports.boltExport;
        var nu$3 = function(baseFn) {
          var data2 = Option.none();
          var callbacks = [];
          var map3 = function(f) {
            return nu$3(function(nCallback) {
              get2(function(data3) {
                nCallback(f(data3));
              });
            });
          };
          var get2 = function(nCallback) {
            if (isReady()) {
              call(nCallback);
            } else {
              callbacks.push(nCallback);
            }
          };
          var set2 = function(x) {
            data2 = Option.some(x);
            run(callbacks);
            callbacks = [];
          };
          var isReady = function() {
            return data2.isSome();
          };
          var run = function(cbs) {
            each(cbs, call);
          };
          var call = function(cb) {
            data2.each(function(x) {
              domGlobals.setTimeout(function() {
                cb(x);
              }, 0);
            });
          };
          baseFn(set2);
          return {
            get: get2,
            map: map3,
            isReady
          };
        };
        var pure = function(a) {
          return nu$3(function(callback) {
            callback(a);
          });
        };
        var LazyValue = {
          nu: nu$3,
          pure
        };
        var errorReporter = function(err) {
          domGlobals.setTimeout(function() {
            throw err;
          }, 0);
        };
        var make = function(run) {
          var get2 = function(callback) {
            run().then(callback, errorReporter);
          };
          var map3 = function(fab) {
            return make(function() {
              return run().then(fab);
            });
          };
          var bind2 = function(aFutureB) {
            return make(function() {
              return run().then(function(v) {
                return aFutureB(v).toPromise();
              });
            });
          };
          var anonBind = function(futureB) {
            return make(function() {
              return run().then(function() {
                return futureB.toPromise();
              });
            });
          };
          var toLazy = function() {
            return LazyValue.nu(get2);
          };
          var toCached = function() {
            var cache = null;
            return make(function() {
              if (cache === null) {
                cache = run();
              }
              return cache;
            });
          };
          var toPromise = run;
          return {
            map: map3,
            bind: bind2,
            anonBind,
            toLazy,
            toCached,
            toPromise,
            get: get2
          };
        };
        var nu$4 = function(baseFn) {
          return make(function() {
            return new Promise2(baseFn);
          });
        };
        var pure$1 = function(a) {
          return make(function() {
            return Promise2.resolve(a);
          });
        };
        var Future = {
          nu: nu$4,
          pure: pure$1
        };
        var par2 = function(asyncValues, nu3) {
          return nu3(function(callback) {
            var r = [];
            var count2 = 0;
            var cb = function(i2) {
              return function(value2) {
                r[i2] = value2;
                count2++;
                if (count2 >= asyncValues.length) {
                  callback(r);
                }
              };
            };
            if (asyncValues.length === 0) {
              callback([]);
            } else {
              each(asyncValues, function(asyncValue, i2) {
                asyncValue.get(cb(i2));
              });
            }
          });
        };
        var par$1 = function(futures) {
          return par2(futures, Future.nu);
        };
        var value = function(o) {
          var is3 = function(v) {
            return o === v;
          };
          var or3 = function(opt) {
            return value(o);
          };
          var orThunk = function(f) {
            return value(o);
          };
          var map3 = function(f) {
            return value(f(o));
          };
          var mapError = function(f) {
            return value(o);
          };
          var each2 = function(f) {
            f(o);
          };
          var bind2 = function(f) {
            return f(o);
          };
          var fold = function(_, onValue) {
            return onValue(o);
          };
          var exists2 = function(f) {
            return f(o);
          };
          var forall3 = function(f) {
            return f(o);
          };
          var toOption = function() {
            return Option.some(o);
          };
          return {
            is: is3,
            isValue: always,
            isError: never,
            getOr: constant(o),
            getOrThunk: constant(o),
            getOrDie: constant(o),
            or: or3,
            orThunk,
            fold,
            map: map3,
            mapError,
            each: each2,
            bind: bind2,
            exists: exists2,
            forall: forall3,
            toOption
          };
        };
        var error2 = function(message) {
          var getOrThunk = function(f) {
            return f();
          };
          var getOrDie2 = function() {
            return die2(String(message))();
          };
          var or3 = function(opt) {
            return opt;
          };
          var orThunk = function(f) {
            return f();
          };
          var map3 = function(f) {
            return error2(message);
          };
          var mapError = function(f) {
            return error2(f(message));
          };
          var bind2 = function(f) {
            return error2(message);
          };
          var fold = function(onError, _) {
            return onError(message);
          };
          return {
            is: never,
            isValue: never,
            isError: always,
            getOr: identity,
            getOrThunk,
            getOrDie: getOrDie2,
            or: or3,
            orThunk,
            fold,
            map: map3,
            mapError,
            each: noop,
            bind: bind2,
            exists: never,
            forall: always,
            toOption: Option.none
          };
        };
        var fromOption = function(opt, err) {
          return opt.fold(function() {
            return error2(err);
          }, value);
        };
        var Result = {
          value,
          error: error2,
          fromOption
        };
        function StyleSheetLoader(document3, settings) {
          if (settings === void 0) {
            settings = {};
          }
          var idCount = 0;
          var loadedStates = {};
          var maxLoadTime;
          maxLoadTime = settings.maxLoadTime || 5e3;
          var appendToHead = function(node2) {
            document3.getElementsByTagName("head")[0].appendChild(node2);
          };
          var load = function(url2, loadedCallback, errorCallback) {
            var link2, style, startTime, state;
            var passed = function() {
              var callbacks = state.passed;
              var i2 = callbacks.length;
              while (i2--) {
                callbacks[i2]();
              }
              state.status = 2;
              state.passed = [];
              state.failed = [];
            };
            var failed = function() {
              var callbacks = state.failed;
              var i2 = callbacks.length;
              while (i2--) {
                callbacks[i2]();
              }
              state.status = 3;
              state.passed = [];
              state.failed = [];
            };
            var isOldWebKit = function() {
              var webKitChunks = domGlobals.navigator.userAgent.match(/WebKit\/(\d*)/);
              return !!(webKitChunks && parseInt(webKitChunks[1], 10) < 536);
            };
            var wait = function(testCallback, waitCallback) {
              if (!testCallback()) {
                if ((/* @__PURE__ */ new Date()).getTime() - startTime < maxLoadTime) {
                  Delay.setTimeout(waitCallback);
                } else {
                  failed();
                }
              }
            };
            var waitForWebKitLinkLoaded = function() {
              wait(function() {
                var styleSheets = document3.styleSheets;
                var styleSheet, i2 = styleSheets.length, owner2;
                while (i2--) {
                  styleSheet = styleSheets[i2];
                  owner2 = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
                  if (owner2 && owner2.id === link2.id) {
                    passed();
                    return true;
                  }
                }
              }, waitForWebKitLinkLoaded);
            };
            var waitForGeckoLinkLoaded = function() {
              wait(function() {
                try {
                  var cssRules = style.sheet.cssRules;
                  passed();
                  return !!cssRules;
                } catch (ex) {
                }
              }, waitForGeckoLinkLoaded);
            };
            url2 = Tools._addCacheSuffix(url2);
            if (!loadedStates[url2]) {
              state = {
                passed: [],
                failed: []
              };
              loadedStates[url2] = state;
            } else {
              state = loadedStates[url2];
            }
            if (loadedCallback) {
              state.passed.push(loadedCallback);
            }
            if (errorCallback) {
              state.failed.push(errorCallback);
            }
            if (state.status === 1) {
              return;
            }
            if (state.status === 2) {
              passed();
              return;
            }
            if (state.status === 3) {
              failed();
              return;
            }
            state.status = 1;
            link2 = document3.createElement("link");
            link2.rel = "stylesheet";
            link2.type = "text/css";
            link2.id = "u" + idCount++;
            link2.async = false;
            link2.defer = false;
            startTime = (/* @__PURE__ */ new Date()).getTime();
            if (settings.contentCssCors) {
              link2.crossOrigin = "anonymous";
            }
            if ("onload" in link2 && !isOldWebKit()) {
              link2.onload = waitForWebKitLinkLoaded;
              link2.onerror = failed;
            } else {
              if (domGlobals.navigator.userAgent.indexOf("Firefox") > 0) {
                style = document3.createElement("style");
                style.textContent = '@import "' + url2 + '"';
                waitForGeckoLinkLoaded();
                appendToHead(style);
                return;
              }
              waitForWebKitLinkLoaded();
            }
            appendToHead(link2);
            link2.href = url2;
          };
          var loadF = function(url2) {
            return Future.nu(function(resolve2) {
              load(url2, compose(resolve2, constant(Result.value(url2))), compose(resolve2, constant(Result.error(url2))));
            });
          };
          var unbox = function(result) {
            return result.fold(identity, identity);
          };
          var loadAll = function(urls, success, failure) {
            par$1(map2(urls, loadF)).get(function(result) {
              var parts = partition(result, function(r) {
                return r.isValue();
              });
              if (parts.fail.length > 0) {
                failure(parts.fail.map(unbox));
              } else {
                success(parts.pass.map(unbox));
              }
            });
          };
          return {
            load,
            loadAll
          };
        }
        function TreeWalker(startNode, rootNode) {
          var node2 = startNode;
          var findSibling2 = function(node3, startName, siblingName, shallow2) {
            var sibling2, parent2;
            if (node3) {
              if (!shallow2 && node3[startName]) {
                return node3[startName];
              }
              if (node3 !== rootNode) {
                sibling2 = node3[siblingName];
                if (sibling2) {
                  return sibling2;
                }
                for (parent2 = node3.parentNode; parent2 && parent2 !== rootNode; parent2 = parent2.parentNode) {
                  sibling2 = parent2[siblingName];
                  if (sibling2) {
                    return sibling2;
                  }
                }
              }
            }
          };
          var findPreviousNode = function(node3, startName, siblingName, shallow2) {
            var sibling2, parent2, child2;
            if (node3) {
              sibling2 = node3[siblingName];
              if (rootNode && sibling2 === rootNode) {
                return;
              }
              if (sibling2) {
                if (!shallow2) {
                  for (child2 = sibling2[startName]; child2; child2 = child2[startName]) {
                    if (!child2[startName]) {
                      return child2;
                    }
                  }
                }
                return sibling2;
              }
              parent2 = node3.parentNode;
              if (parent2 && parent2 !== rootNode) {
                return parent2;
              }
            }
          };
          this.current = function() {
            return node2;
          };
          this.next = function(shallow2) {
            node2 = findSibling2(node2, "firstChild", "nextSibling", shallow2);
            return node2;
          };
          this.prev = function(shallow2) {
            node2 = findSibling2(node2, "lastChild", "previousSibling", shallow2);
            return node2;
          };
          this.prev2 = function(shallow2) {
            node2 = findPreviousNode(node2, "lastChild", "previousSibling", shallow2);
            return node2;
          };
        }
        var blocks = [
          "article",
          "aside",
          "details",
          "div",
          "dt",
          "figcaption",
          "footer",
          "form",
          "fieldset",
          "header",
          "hgroup",
          "html",
          "main",
          "nav",
          "section",
          "summary",
          "body",
          "p",
          "dl",
          "multicol",
          "dd",
          "figure",
          "address",
          "center",
          "blockquote",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "listing",
          "xmp",
          "pre",
          "plaintext",
          "menu",
          "dir",
          "ul",
          "ol",
          "li",
          "hr",
          "table",
          "tbody",
          "thead",
          "tfoot",
          "th",
          "tr",
          "td",
          "caption"
        ];
        var voids = [
          "area",
          "base",
          "basefont",
          "br",
          "col",
          "frame",
          "hr",
          "img",
          "input",
          "isindex",
          "link",
          "meta",
          "param",
          "embed",
          "source",
          "wbr",
          "track"
        ];
        var tableCells = [
          "td",
          "th"
        ];
        var tableSections = [
          "thead",
          "tbody",
          "tfoot"
        ];
        var textBlocks = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "p",
          "div",
          "address",
          "pre",
          "form",
          "blockquote",
          "center",
          "dir",
          "fieldset",
          "header",
          "footer",
          "article",
          "section",
          "hgroup",
          "aside",
          "nav",
          "figure"
        ];
        var headings = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6"
        ];
        var listItems = [
          "li",
          "dd",
          "dt"
        ];
        var lists2 = [
          "ul",
          "ol",
          "dl"
        ];
        var wsElements = [
          "pre",
          "script",
          "textarea",
          "style"
        ];
        var lazyLookup = function(items) {
          var lookup;
          return function(node2) {
            lookup = lookup ? lookup : mapToObject(items, constant(true));
            return lookup.hasOwnProperty(name(node2));
          };
        };
        var isHeading = lazyLookup(headings);
        var isBlock2 = lazyLookup(blocks);
        var isInline = function(node2) {
          return isElement(node2) && !isBlock2(node2);
        };
        var isBr = function(node2) {
          return isElement(node2) && name(node2) === "br";
        };
        var isTextBlock = lazyLookup(textBlocks);
        var isList = lazyLookup(lists2);
        var isListItem = lazyLookup(listItems);
        var isVoid2 = lazyLookup(voids);
        var isTableSection = lazyLookup(tableSections);
        var isTableCell = lazyLookup(tableCells);
        var isWsPreserveElement = lazyLookup(wsElements);
        var isNodeType = function(type2) {
          return function(node2) {
            return !!node2 && node2.nodeType === type2;
          };
        };
        var isRestrictedNode = function(node2) {
          return !!node2 && !Object.getPrototypeOf(node2);
        };
        var isElement$1 = isNodeType(1);
        var matchNodeNames = function(names) {
          var items = names.toLowerCase().split(" ");
          return function(node2) {
            var i2, name2;
            if (node2 && node2.nodeType) {
              name2 = node2.nodeName.toLowerCase();
              for (i2 = 0; i2 < items.length; i2++) {
                if (name2 === items[i2]) {
                  return true;
                }
              }
            }
            return false;
          };
        };
        var matchStyleValues = function(name2, values) {
          var items = values.toLowerCase().split(" ");
          return function(node2) {
            var i2, cssValue;
            if (isElement$1(node2)) {
              for (i2 = 0; i2 < items.length; i2++) {
                var computed = node2.ownerDocument.defaultView.getComputedStyle(node2, null);
                cssValue = computed ? computed.getPropertyValue(name2) : null;
                if (cssValue === items[i2]) {
                  return true;
                }
              }
            }
            return false;
          };
        };
        var hasPropValue = function(propName, propValue) {
          return function(node2) {
            return isElement$1(node2) && node2[propName] === propValue;
          };
        };
        var hasAttribute = function(attrName, attrValue) {
          return function(node2) {
            return isElement$1(node2) && node2.hasAttribute(attrName);
          };
        };
        var hasAttributeValue = function(attrName, attrValue) {
          return function(node2) {
            return isElement$1(node2) && node2.getAttribute(attrName) === attrValue;
          };
        };
        var isBogus = function(node2) {
          return isElement$1(node2) && node2.hasAttribute("data-mce-bogus");
        };
        var isBogusAll = function(node2) {
          return isElement$1(node2) && node2.getAttribute("data-mce-bogus") === "all";
        };
        var isTable = function(node2) {
          return isElement$1(node2) && node2.tagName === "TABLE";
        };
        var hasContentEditableState = function(value2) {
          return function(node2) {
            if (isElement$1(node2)) {
              if (node2.contentEditable === value2) {
                return true;
              }
              if (node2.getAttribute("data-mce-contenteditable") === value2) {
                return true;
              }
            }
            return false;
          };
        };
        var isText$1 = isNodeType(3);
        var isComment = isNodeType(8);
        var isDocument = isNodeType(9);
        var isDocumentFragment = isNodeType(11);
        var isBr$1 = matchNodeNames("br");
        var isContentEditableTrue = hasContentEditableState("true");
        var isContentEditableFalse = hasContentEditableState("false");
        var NodeType = {
          isText: isText$1,
          isElement: isElement$1,
          isComment,
          isDocument,
          isDocumentFragment,
          isBr: isBr$1,
          isContentEditableTrue,
          isContentEditableFalse,
          isRestrictedNode,
          matchNodeNames,
          hasPropValue,
          hasAttribute,
          hasAttributeValue,
          matchStyleValues,
          isBogus,
          isBogusAll,
          isTable
        };
        var surroundedBySpans = function(node2) {
          var previousIsSpan = node2.previousSibling && node2.previousSibling.nodeName === "SPAN";
          var nextIsSpan = node2.nextSibling && node2.nextSibling.nodeName === "SPAN";
          return previousIsSpan && nextIsSpan;
        };
        var isBookmarkNode = function(node2) {
          return node2 && node2.tagName === "SPAN" && node2.getAttribute("data-mce-type") === "bookmark";
        };
        var trimNode = function(dom2, node2) {
          var i2, children2 = node2.childNodes;
          if (NodeType.isElement(node2) && isBookmarkNode(node2)) {
            return;
          }
          for (i2 = children2.length - 1; i2 >= 0; i2--) {
            trimNode(dom2, children2[i2]);
          }
          if (NodeType.isDocument(node2) === false) {
            if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
              var trimmedLength = Tools.trim(node2.nodeValue).length;
              if (dom2.isBlock(node2.parentNode) || trimmedLength > 0) {
                return;
              }
              if (trimmedLength === 0 && surroundedBySpans(node2)) {
                return;
              }
            } else if (NodeType.isElement(node2)) {
              children2 = node2.childNodes;
              if (children2.length === 1 && isBookmarkNode(children2[0])) {
                node2.parentNode.insertBefore(children2[0], node2);
              }
              if (children2.length || isVoid2(Element2.fromDom(node2))) {
                return;
              }
            }
            dom2.remove(node2);
          }
          return node2;
        };
        var TrimNode = { trimNode };
        var makeMap$1 = Tools.makeMap;
        var namedEntities, baseEntities, reverseEntities;
        var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var rawCharsRegExp = /[<>&\"\']/g;
        var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
        var asciiMap = {
          128: "â‚¬",
          130: "â€š",
          131: "Æ’",
          132: "â€",
          133: "â€¦",
          134: "â€ ",
          135: "â€¡",
          136: "Ë†",
          137: "â€°",
          138: "Å ",
          139: "â€¹",
          140: "Å’",
          142: "Å½",
          145: "â€˜",
          146: "â€™",
          147: "â€œ",
          148: "â€",
          149: "â€¢",
          150: "â€“",
          151: "â€”",
          152: "Ëœ",
          153: "â„¢",
          154: "Å¡",
          155: "â€º",
          156: "Å“",
          158: "Å¾",
          159: "Å¸"
        };
        baseEntities = {
          '"': "&quot;",
          "'": "&#39;",
          "<": "&lt;",
          ">": "&gt;",
          "&": "&amp;",
          "`": "&#96;"
        };
        reverseEntities = {
          "&lt;": "<",
          "&gt;": ">",
          "&amp;": "&",
          "&quot;": '"',
          "&apos;": "'"
        };
        var nativeDecode = function(text2) {
          var elm;
          elm = Element2.fromTag("div").dom();
          elm.innerHTML = text2;
          return elm.textContent || elm.innerText || text2;
        };
        var buildEntitiesLookup = function(items, radix) {
          var i2, chr, entity2;
          var lookup = {};
          if (items) {
            items = items.split(",");
            radix = radix || 10;
            for (i2 = 0; i2 < items.length; i2 += 2) {
              chr = String.fromCharCode(parseInt(items[i2], radix));
              if (!baseEntities[chr]) {
                entity2 = "&" + items[i2 + 1] + ";";
                lookup[chr] = entity2;
                lookup[entity2] = chr;
              }
            }
            return lookup;
          }
        };
        namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
        var encodeRaw = function(text2, attr) {
          return text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            return baseEntities[chr] || chr;
          });
        };
        var encodeAllRaw = function(text2) {
          return ("" + text2).replace(rawCharsRegExp, function(chr) {
            return baseEntities[chr] || chr;
          });
        };
        var encodeNumeric = function(text2, attr) {
          return text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            if (chr.length > 1) {
              return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
            }
            return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
          });
        };
        var encodeNamed = function(text2, attr, entities2) {
          entities2 = entities2 || namedEntities;
          return text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
            return baseEntities[chr] || entities2[chr] || chr;
          });
        };
        var getEncodeFunc = function(name2, entities2) {
          var entitiesMap = buildEntitiesLookup(entities2) || namedEntities;
          var encodeNamedAndNumeric = function(text2, attr) {
            return text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
              if (baseEntities[chr] !== void 0) {
                return baseEntities[chr];
              }
              if (entitiesMap[chr] !== void 0) {
                return entitiesMap[chr];
              }
              if (chr.length > 1) {
                return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
              }
              return "&#" + chr.charCodeAt(0) + ";";
            });
          };
          var encodeCustomNamed = function(text2, attr) {
            return encodeNamed(text2, attr, entitiesMap);
          };
          var nameMap = makeMap$1(name2.replace(/\+/g, ","));
          if (nameMap.named && nameMap.numeric) {
            return encodeNamedAndNumeric;
          }
          if (nameMap.named) {
            if (entities2) {
              return encodeCustomNamed;
            }
            return encodeNamed;
          }
          if (nameMap.numeric) {
            return encodeNumeric;
          }
          return encodeRaw;
        };
        var decode2 = function(text2) {
          return text2.replace(entityRegExp, function(all2, numeric) {
            if (numeric) {
              if (numeric.charAt(0).toLowerCase() === "x") {
                numeric = parseInt(numeric.substr(1), 16);
              } else {
                numeric = parseInt(numeric, 10);
              }
              if (numeric > 65535) {
                numeric -= 65536;
                return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
              }
              return asciiMap[numeric] || String.fromCharCode(numeric);
            }
            return reverseEntities[all2] || namedEntities[all2] || nativeDecode(all2);
          });
        };
        var Entities = {
          encodeRaw,
          encodeAllRaw,
          encodeNumeric,
          encodeNamed,
          getEncodeFunc,
          decode: decode2
        };
        var mapCache = {}, dummyObj = {};
        var makeMap$2 = Tools.makeMap, each$4 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray$1 = Tools.inArray;
        var split = function(items, delim) {
          items = Tools.trim(items);
          return items ? items.split(delim || " ") : [];
        };
        var compileSchema = function(type2) {
          var schema = {};
          var globalAttributes, blockContent;
          var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
          var add2 = function(name2, attributes2, children2) {
            var ni2, attributesOrder, element;
            var arrayToMap = function(array, obj) {
              var map3 = {};
              var i2, l;
              for (i2 = 0, l = array.length; i2 < l; i2++) {
                map3[array[i2]] = obj || {};
              }
              return map3;
            };
            children2 = children2 || [];
            attributes2 = attributes2 || "";
            if (typeof children2 === "string") {
              children2 = split(children2);
            }
            name2 = split(name2);
            ni2 = name2.length;
            while (ni2--) {
              attributesOrder = split([
                globalAttributes,
                attributes2
              ].join(" "));
              element = {
                attributes: arrayToMap(attributesOrder),
                attributesOrder,
                children: arrayToMap(children2, dummyObj)
              };
              schema[name2[ni2]] = element;
            }
          };
          var addAttrs = function(name2, attributes2) {
            var ni2, schemaItem, i2, l;
            name2 = split(name2);
            ni2 = name2.length;
            attributes2 = split(attributes2);
            while (ni2--) {
              schemaItem = schema[name2[ni2]];
              for (i2 = 0, l = attributes2.length; i2 < l; i2++) {
                schemaItem.attributes[attributes2[i2]] = {};
                schemaItem.attributesOrder.push(attributes2[i2]);
              }
            }
          };
          if (mapCache[type2]) {
            return mapCache[type2];
          }
          globalAttributes = "id accesskey class dir lang style tabindex title role";
          blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
          phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
          if (type2 !== "html4") {
            globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
            blockContent += " article aside details dialog figure main header footer hgroup section nav";
            phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
          }
          if (type2 !== "html5-strict") {
            globalAttributes += " xml:lang";
            html4PhrasingContent = "acronym applet basefont big font strike tt";
            phrasingContent = [
              phrasingContent,
              html4PhrasingContent
            ].join(" ");
            each$4(split(html4PhrasingContent), function(name2) {
              add2(name2, "", phrasingContent);
            });
            html4BlockContent = "center dir isindex noframes";
            blockContent = [
              blockContent,
              html4BlockContent
            ].join(" ");
            flowContent = [
              blockContent,
              phrasingContent
            ].join(" ");
            each$4(split(html4BlockContent), function(name2) {
              add2(name2, "", flowContent);
            });
          }
          flowContent = flowContent || [
            blockContent,
            phrasingContent
          ].join(" ");
          add2("html", "manifest", "head body");
          add2("head", "", "base command link meta noscript script style title");
          add2("title hr noscript br");
          add2("base", "href target");
          add2("link", "href rel media hreflang type sizes hreflang");
          add2("meta", "name http-equiv content charset");
          add2("style", "media type scoped");
          add2("script", "src async defer type charset");
          add2("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
          add2("address dt dd div caption", "", flowContent);
          add2("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
          add2("blockquote", "cite", flowContent);
          add2("ol", "reversed start type", "li");
          add2("ul", "", "li");
          add2("li", "value", flowContent);
          add2("dl", "", "dt dd");
          add2("a", "href target rel media hreflang type", phrasingContent);
          add2("q", "cite", phrasingContent);
          add2("ins del", "cite datetime", flowContent);
          add2("img", "src sizes srcset alt usemap ismap width height");
          add2("iframe", "src name width height", flowContent);
          add2("embed", "src type width height");
          add2("object", "data type typemustmatch name usemap form width height", [
            flowContent,
            "param"
          ].join(" "));
          add2("param", "name value");
          add2("map", "name", [
            flowContent,
            "area"
          ].join(" "));
          add2("area", "alt coords shape href target rel media hreflang type");
          add2("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
          add2("colgroup", "span", "col");
          add2("col", "span");
          add2("tbody thead tfoot", "", "tr");
          add2("tr", "", "td th");
          add2("td", "colspan rowspan headers", flowContent);
          add2("th", "colspan rowspan headers scope abbr", flowContent);
          add2("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
          add2("fieldset", "disabled form name", [
            flowContent,
            "legend"
          ].join(" "));
          add2("label", "form for", phrasingContent);
          add2("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
          add2("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
          add2("select", "disabled form multiple name required size", "option optgroup");
          add2("optgroup", "disabled label", "option");
          add2("option", "disabled label selected value");
          add2("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
          add2("menu", "type label", [
            flowContent,
            "li"
          ].join(" "));
          add2("noscript", "", flowContent);
          if (type2 !== "html4") {
            add2("wbr");
            add2("ruby", "", [
              phrasingContent,
              "rt rp"
            ].join(" "));
            add2("figcaption", "", flowContent);
            add2("mark rt rp summary bdi", "", phrasingContent);
            add2("canvas", "width height", flowContent);
            add2("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
              flowContent,
              "track source"
            ].join(" "));
            add2("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
              flowContent,
              "track source"
            ].join(" "));
            add2("picture", "", "img source");
            add2("source", "src srcset type media sizes");
            add2("track", "kind src srclang label default");
            add2("datalist", "", [
              phrasingContent,
              "option"
            ].join(" "));
            add2("article section nav aside main header footer", "", flowContent);
            add2("hgroup", "", "h1 h2 h3 h4 h5 h6");
            add2("figure", "", [
              flowContent,
              "figcaption"
            ].join(" "));
            add2("time", "datetime", phrasingContent);
            add2("dialog", "open", flowContent);
            add2("command", "type label icon disabled checked radiogroup command");
            add2("output", "for form name", phrasingContent);
            add2("progress", "value max", phrasingContent);
            add2("meter", "value min max low high optimum", phrasingContent);
            add2("details", "open", [
              flowContent,
              "summary"
            ].join(" "));
            add2("keygen", "autofocus challenge disabled form keytype name");
          }
          if (type2 !== "html5-strict") {
            addAttrs("script", "language xml:space");
            addAttrs("style", "xml:space");
            addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
            addAttrs("embed", "align name hspace vspace");
            addAttrs("param", "valuetype type");
            addAttrs("a", "charset name rev shape coords");
            addAttrs("br", "clear");
            addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
            addAttrs("img", "name longdesc align border hspace vspace");
            addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
            addAttrs("font basefont", "size color face");
            addAttrs("input", "usemap align");
            addAttrs("select", "onchange");
            addAttrs("textarea");
            addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
            addAttrs("ul", "type compact");
            addAttrs("li", "type");
            addAttrs("ol dl menu dir", "compact");
            addAttrs("pre", "width xml:space");
            addAttrs("hr", "align noshade size width");
            addAttrs("isindex", "prompt");
            addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
            addAttrs("col", "width align char charoff valign");
            addAttrs("colgroup", "width align char charoff valign");
            addAttrs("thead", "align char charoff valign");
            addAttrs("tr", "align char charoff valign bgcolor");
            addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
            addAttrs("form", "accept");
            addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
            addAttrs("tfoot", "align char charoff valign");
            addAttrs("tbody", "align char charoff valign");
            addAttrs("area", "nohref");
            addAttrs("body", "background bgcolor text link vlink alink");
          }
          if (type2 !== "html4") {
            addAttrs("input button select textarea", "autofocus");
            addAttrs("input textarea", "placeholder");
            addAttrs("a", "download");
            addAttrs("link script img", "crossorigin");
            addAttrs("iframe", "sandbox seamless allowfullscreen");
          }
          each$4(split("a form meter progress dfn"), function(name2) {
            if (schema[name2]) {
              delete schema[name2].children[name2];
            }
          });
          delete schema.caption.children.table;
          delete schema.script;
          mapCache[type2] = schema;
          return schema;
        };
        var compileElementMap = function(value2, mode) {
          var styles;
          if (value2) {
            styles = {};
            if (typeof value2 === "string") {
              value2 = { "*": value2 };
            }
            each$4(value2, function(value3, key) {
              styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$1(value3, /[, ]/);
            });
          }
          return styles;
        };
        function Schema(settings) {
          var elements = {};
          var children2 = {};
          var patternElements = [];
          var validStyles;
          var invalidStyles;
          var schemaItems;
          var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
          var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
          var customElementsMap = {}, specialElements = {};
          var createLookupTable = function(option, defaultValue, extendWith) {
            var value2 = settings[option];
            if (!value2) {
              value2 = mapCache[option];
              if (!value2) {
                value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
                value2 = extend$1(value2, extendWith);
                mapCache[option] = value2;
              }
            } else {
              value2 = makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
            }
            return value2;
          };
          settings = settings || {};
          schemaItems = compileSchema(settings.schema);
          if (settings.verify_html === false) {
            settings.valid_elements = "*[*]";
          }
          validStyles = compileElementMap(settings.valid_styles);
          invalidStyles = compileElementMap(settings.invalid_styles, "map");
          validClasses = compileElementMap(settings.valid_classes, "map");
          whiteSpaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
          selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
          shortEndedElementsMap = createLookupTable("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
          boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls");
          nonEmptyElementsMap = createLookupTable("non_empty_elements", "td th iframe video audio object script pre code", shortEndedElementsMap);
          moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", "table", nonEmptyElementsMap);
          textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
          blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
          textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp");
          each$4((settings.special || "script noscript iframe noframes noembed title style textarea xmp").split(" "), function(name2) {
            specialElements[name2] = new RegExp("</" + name2 + "[^>]*>", "gi");
          });
          var patternToRegExp = function(str) {
            return new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
          };
          var addValidElements = function(validElements) {
            var ei, el2, ai, al, matches2, element, attr, attrData, elementName, attrName, attrType, attributes2, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, key, value2;
            var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
            if (validElements) {
              validElements = split(validElements, ",");
              if (elements["@"]) {
                globalAttributes = elements["@"].attributes;
                globalAttributesOrder = elements["@"].attributesOrder;
              }
              for (ei = 0, el2 = validElements.length; ei < el2; ei++) {
                matches2 = elementRuleRegExp.exec(validElements[ei]);
                if (matches2) {
                  prefix = matches2[1];
                  elementName = matches2[2];
                  outputName = matches2[3];
                  attrData = matches2[5];
                  attributes2 = {};
                  attributesOrder = [];
                  element = {
                    attributes: attributes2,
                    attributesOrder
                  };
                  if (prefix === "#") {
                    element.paddEmpty = true;
                  }
                  if (prefix === "-") {
                    element.removeEmpty = true;
                  }
                  if (matches2[4] === "!") {
                    element.removeEmptyAttrs = true;
                  }
                  if (globalAttributes) {
                    for (key in globalAttributes) {
                      attributes2[key] = globalAttributes[key];
                    }
                    attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
                  }
                  if (attrData) {
                    attrData = split(attrData, "|");
                    for (ai = 0, al = attrData.length; ai < al; ai++) {
                      matches2 = attrRuleRegExp.exec(attrData[ai]);
                      if (matches2) {
                        attr = {};
                        attrType = matches2[1];
                        attrName = matches2[2].replace(/[\\:]:/g, ":");
                        prefix = matches2[3];
                        value2 = matches2[4];
                        if (attrType === "!") {
                          element.attributesRequired = element.attributesRequired || [];
                          element.attributesRequired.push(attrName);
                          attr.required = true;
                        }
                        if (attrType === "-") {
                          delete attributes2[attrName];
                          attributesOrder.splice(inArray$1(attributesOrder, attrName), 1);
                          continue;
                        }
                        if (prefix) {
                          if (prefix === "=") {
                            element.attributesDefault = element.attributesDefault || [];
                            element.attributesDefault.push({
                              name: attrName,
                              value: value2
                            });
                            attr.defaultValue = value2;
                          }
                          if (prefix === ":") {
                            element.attributesForced = element.attributesForced || [];
                            element.attributesForced.push({
                              name: attrName,
                              value: value2
                            });
                            attr.forcedValue = value2;
                          }
                          if (prefix === "<") {
                            attr.validValues = makeMap$2(value2, "?");
                          }
                        }
                        if (hasPatternsRegExp.test(attrName)) {
                          element.attributePatterns = element.attributePatterns || [];
                          attr.pattern = patternToRegExp(attrName);
                          element.attributePatterns.push(attr);
                        } else {
                          if (!attributes2[attrName]) {
                            attributesOrder.push(attrName);
                          }
                          attributes2[attrName] = attr;
                        }
                      }
                    }
                  }
                  if (!globalAttributes && elementName === "@") {
                    globalAttributes = attributes2;
                    globalAttributesOrder = attributesOrder;
                  }
                  if (outputName) {
                    element.outputName = elementName;
                    elements[outputName] = element;
                  }
                  if (hasPatternsRegExp.test(elementName)) {
                    element.pattern = patternToRegExp(elementName);
                    patternElements.push(element);
                  } else {
                    elements[elementName] = element;
                  }
                }
              }
            }
          };
          var setValidElements = function(validElements) {
            elements = {};
            patternElements = [];
            addValidElements(validElements);
            each$4(schemaItems, function(element, name2) {
              children2[name2] = element.children;
            });
          };
          var addCustomElements = function(customElements) {
            var customElementRegExp = /^(~)?(.+)$/;
            if (customElements) {
              mapCache.text_block_elements = mapCache.block_elements = null;
              each$4(split(customElements, ","), function(rule) {
                var matches2 = customElementRegExp.exec(rule), inline2 = matches2[1] === "~", cloneName = inline2 ? "span" : "div", name2 = matches2[2];
                children2[name2] = children2[cloneName];
                customElementsMap[name2] = cloneName;
                if (!inline2) {
                  blockElementsMap[name2.toUpperCase()] = {};
                  blockElementsMap[name2] = {};
                }
                if (!elements[name2]) {
                  var customRule = elements[cloneName];
                  customRule = extend$1({}, customRule);
                  delete customRule.removeEmptyAttrs;
                  delete customRule.removeEmpty;
                  elements[name2] = customRule;
                }
                each$4(children2, function(element, elmName) {
                  if (element[cloneName]) {
                    children2[elmName] = element = extend$1({}, children2[elmName]);
                    element[name2] = element[cloneName];
                  }
                });
              });
            }
          };
          var addValidChildren = function(validChildren) {
            var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
            mapCache[settings.schema] = null;
            if (validChildren) {
              each$4(split(validChildren, ","), function(rule) {
                var matches2 = childRuleRegExp.exec(rule);
                var parent2, prefix;
                if (matches2) {
                  prefix = matches2[1];
                  if (prefix) {
                    parent2 = children2[matches2[2]];
                  } else {
                    parent2 = children2[matches2[2]] = { "#comment": {} };
                  }
                  parent2 = children2[matches2[2]];
                  each$4(split(matches2[3], "|"), function(child2) {
                    if (prefix === "-") {
                      delete parent2[child2];
                    } else {
                      parent2[child2] = {};
                    }
                  });
                }
              });
            }
          };
          var getElementRule = function(name2) {
            var element = elements[name2], i2;
            if (element) {
              return element;
            }
            i2 = patternElements.length;
            while (i2--) {
              element = patternElements[i2];
              if (element.pattern.test(name2)) {
                return element;
              }
            }
          };
          if (!settings.valid_elements) {
            each$4(schemaItems, function(element, name2) {
              elements[name2] = {
                attributes: element.attributes,
                attributesOrder: element.attributesOrder
              };
              children2[name2] = element.children;
            });
            if (settings.schema !== "html5") {
              each$4(split("strong/b em/i"), function(item) {
                item = split(item, "/");
                elements[item[1]].outputName = item[0];
              });
            }
            each$4(split("ol ul sub sup blockquote span font a table tbody tr strong em b i"), function(name2) {
              if (elements[name2]) {
                elements[name2].removeEmpty = true;
              }
            });
            each$4(split("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), function(name2) {
              elements[name2].paddEmpty = true;
            });
            each$4(split("span"), function(name2) {
              elements[name2].removeEmptyAttrs = true;
            });
          } else {
            setValidElements(settings.valid_elements);
          }
          addCustomElements(settings.custom_elements);
          addValidChildren(settings.valid_children);
          addValidElements(settings.extended_valid_elements);
          addValidChildren("+ol[ul|ol],+ul[ul|ol]");
          each$4({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
          }, function(parents2, item) {
            if (elements[item]) {
              elements[item].parentsRequired = split(parents2);
            }
          });
          if (settings.invalid_elements) {
            each$4(explode$1(settings.invalid_elements), function(item) {
              if (elements[item]) {
                delete elements[item];
              }
            });
          }
          if (!getElementRule("span")) {
            addValidElements("span[!data-mce-type|*]");
          }
          var getValidStyles = function() {
            return validStyles;
          };
          var getInvalidStyles = function() {
            return invalidStyles;
          };
          var getValidClasses = function() {
            return validClasses;
          };
          var getBoolAttrs = function() {
            return boolAttrMap;
          };
          var getBlockElements = function() {
            return blockElementsMap;
          };
          var getTextBlockElements = function() {
            return textBlockElementsMap;
          };
          var getTextInlineElements = function() {
            return textInlineElementsMap;
          };
          var getShortEndedElements = function() {
            return shortEndedElementsMap;
          };
          var getSelfClosingElements = function() {
            return selfClosingElementsMap;
          };
          var getNonEmptyElements = function() {
            return nonEmptyElementsMap;
          };
          var getMoveCaretBeforeOnEnterElements = function() {
            return moveCaretBeforeOnEnterElementsMap;
          };
          var getWhiteSpaceElements = function() {
            return whiteSpaceElementsMap;
          };
          var getSpecialElements = function() {
            return specialElements;
          };
          var isValidChild = function(name2, child2) {
            var parent2 = children2[name2.toLowerCase()];
            return !!(parent2 && parent2[child2.toLowerCase()]);
          };
          var isValid2 = function(name2, attr) {
            var attrPatterns, i2;
            var rule = getElementRule(name2);
            if (rule) {
              if (attr) {
                if (rule.attributes[attr]) {
                  return true;
                }
                attrPatterns = rule.attributePatterns;
                if (attrPatterns) {
                  i2 = attrPatterns.length;
                  while (i2--) {
                    if (attrPatterns[i2].pattern.test(name2)) {
                      return true;
                    }
                  }
                }
              } else {
                return true;
              }
            }
            return false;
          };
          var getCustomElements = function() {
            return customElementsMap;
          };
          return {
            children: children2,
            elements,
            getValidStyles,
            getValidClasses,
            getBlockElements,
            getInvalidStyles,
            getShortEndedElements,
            getTextBlockElements,
            getTextInlineElements,
            getBoolAttrs,
            getElementRule,
            getSelfClosingElements,
            getNonEmptyElements,
            getMoveCaretBeforeOnEnterElements,
            getWhiteSpaceElements,
            getSpecialElements,
            isValidChild,
            isValid: isValid2,
            getCustomElements,
            addValidElements,
            setValidElements,
            addCustomElements,
            addValidChildren
          };
        }
        var toHex = function(match2, r, g, b) {
          var hex = function(val) {
            val = parseInt(val, 10).toString(16);
            return val.length > 1 ? val : "0" + val;
          };
          return "#" + hex(r) + hex(g) + hex(b);
        };
        function Styles(settings, schema) {
          var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
          var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
          var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
          var trimRightRegExp = /\s+$/;
          var i2;
          var encodingLookup = {};
          var encodingItems;
          var validStyles;
          var invalidStyles;
          var invisibleChar = "\uFEFF";
          settings = settings || {};
          if (schema) {
            validStyles = schema.getValidStyles();
            invalidStyles = schema.getInvalidStyles();
          }
          encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
          for (i2 = 0; i2 < encodingItems.length; i2++) {
            encodingLookup[encodingItems[i2]] = invisibleChar + i2;
            encodingLookup[invisibleChar + i2] = encodingItems[i2];
          }
          return {
            toHex: function(color) {
              return color.replace(rgbRegExp, toHex);
            },
            parse: function(css2) {
              var styles = {};
              var matches2, name2, value2, isEncoded;
              var urlConverter = settings.url_converter;
              var urlConverterScope = settings.url_converter_scope || this;
              var compress = function(prefix, suffix, noJoin) {
                var top2, right, bottom2, left;
                top2 = styles[prefix + "-top" + suffix];
                if (!top2) {
                  return;
                }
                right = styles[prefix + "-right" + suffix];
                if (!right) {
                  return;
                }
                bottom2 = styles[prefix + "-bottom" + suffix];
                if (!bottom2) {
                  return;
                }
                left = styles[prefix + "-left" + suffix];
                if (!left) {
                  return;
                }
                var box = [
                  top2,
                  right,
                  bottom2,
                  left
                ];
                i2 = box.length - 1;
                while (i2--) {
                  if (box[i2] !== box[i2 + 1]) {
                    break;
                  }
                }
                if (i2 > -1 && noJoin) {
                  return;
                }
                styles[prefix + suffix] = i2 === -1 ? box[0] : box.join(" ");
                delete styles[prefix + "-top" + suffix];
                delete styles[prefix + "-right" + suffix];
                delete styles[prefix + "-bottom" + suffix];
                delete styles[prefix + "-left" + suffix];
              };
              var canCompress = function(key) {
                var value3 = styles[key], i3;
                if (!value3) {
                  return;
                }
                value3 = value3.split(" ");
                i3 = value3.length;
                while (i3--) {
                  if (value3[i3] !== value3[0]) {
                    return false;
                  }
                }
                styles[key] = value3[0];
                return true;
              };
              var compress2 = function(target2, a, b, c) {
                if (!canCompress(a)) {
                  return;
                }
                if (!canCompress(b)) {
                  return;
                }
                if (!canCompress(c)) {
                  return;
                }
                styles[target2] = styles[a] + " " + styles[b] + " " + styles[c];
                delete styles[a];
                delete styles[b];
                delete styles[c];
              };
              var encode2 = function(str) {
                isEncoded = true;
                return encodingLookup[str];
              };
              var decode3 = function(str, keepSlashes) {
                if (isEncoded) {
                  str = str.replace(/\uFEFF[0-9]/g, function(str2) {
                    return encodingLookup[str2];
                  });
                }
                if (!keepSlashes) {
                  str = str.replace(/\\([\'\";:])/g, "$1");
                }
                return str;
              };
              var decodeSingleHexSequence = function(escSeq) {
                return String.fromCharCode(parseInt(escSeq.slice(1), 16));
              };
              var decodeHexSequences = function(value3) {
                return value3.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
              };
              var processUrl = function(match2, url2, url22, url3, str, str2) {
                str = str || str2;
                if (str) {
                  str = decode3(str);
                  return "'" + str.replace(/\'/g, "\\'") + "'";
                }
                url2 = decode3(url2 || url22 || url3);
                if (!settings.allow_script_urls) {
                  var scriptUrl = url2.replace(/[\s\r\n]+/g, "");
                  if (/(java|vb)script:/i.test(scriptUrl)) {
                    return "";
                  }
                  if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                    return "";
                  }
                }
                if (urlConverter) {
                  url2 = urlConverter.call(urlConverterScope, url2, "style");
                }
                return "url('" + url2.replace(/\'/g, "\\'") + "')";
              };
              if (css2) {
                css2 = css2.replace(/[\u0000-\u001F]/g, "");
                css2 = css2.replace(/\\[\"\';:\uFEFF]/g, encode2).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
                  return str.replace(/[;:]/g, encode2);
                });
                while (matches2 = styleRegExp.exec(css2)) {
                  styleRegExp.lastIndex = matches2.index + matches2[0].length;
                  name2 = matches2[1].replace(trimRightRegExp, "").toLowerCase();
                  value2 = matches2[2].replace(trimRightRegExp, "");
                  if (name2 && value2) {
                    name2 = decodeHexSequences(name2);
                    value2 = decodeHexSequences(value2);
                    if (name2.indexOf(invisibleChar) !== -1 || name2.indexOf('"') !== -1) {
                      continue;
                    }
                    if (!settings.allow_script_urls && (name2 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                      continue;
                    }
                    if (name2 === "font-weight" && value2 === "700") {
                      value2 = "bold";
                    } else if (name2 === "color" || name2 === "background-color") {
                      value2 = value2.toLowerCase();
                    }
                    value2 = value2.replace(rgbRegExp, toHex);
                    value2 = value2.replace(urlOrStrRegExp, processUrl);
                    styles[name2] = isEncoded ? decode3(value2, true) : value2;
                  }
                }
                compress("border", "", true);
                compress("border", "-width");
                compress("border", "-color");
                compress("border", "-style");
                compress("padding", "");
                compress("margin", "");
                compress2("border", "border-width", "border-style", "border-color");
                if (styles.border === "medium none") {
                  delete styles.border;
                }
                if (styles["border-image"] === "none") {
                  delete styles["border-image"];
                }
              }
              return styles;
            },
            serialize: function(styles, elementName) {
              var css2 = "", name2, value2;
              var serializeStyles = function(name3) {
                var styleList, i3, l, value3;
                styleList = validStyles[name3];
                if (styleList) {
                  for (i3 = 0, l = styleList.length; i3 < l; i3++) {
                    name3 = styleList[i3];
                    value3 = styles[name3];
                    if (value3) {
                      css2 += (css2.length > 0 ? " " : "") + name3 + ": " + value3 + ";";
                    }
                  }
                }
              };
              var isValid2 = function(name3, elementName2) {
                var styleMap;
                styleMap = invalidStyles["*"];
                if (styleMap && styleMap[name3]) {
                  return false;
                }
                styleMap = invalidStyles[elementName2];
                if (styleMap && styleMap[name3]) {
                  return false;
                }
                return true;
              };
              if (elementName && validStyles) {
                serializeStyles("*");
                serializeStyles(elementName);
              } else {
                for (name2 in styles) {
                  value2 = styles[name2];
                  if (value2 && (!invalidStyles || isValid2(name2, elementName))) {
                    css2 += (css2.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
                  }
                }
              }
              return css2;
            }
          };
        }
        var each$5 = Tools.each;
        var grep$1 = Tools.grep;
        var isIE = Env.ie;
        var simpleSelectorRe = /^([a-z0-9],?)+$/i;
        var whiteSpaceRegExp$2 = /^[ \t\r\n]*$/;
        var setupAttrHooks = function(styles, settings, getContext) {
          var attrHooks2 = {};
          var keepValues = settings.keep_values;
          var keepUrlHook = {
            set: function($elm, value2, name2) {
              if (settings.url_converter) {
                value2 = settings.url_converter.call(settings.url_converter_scope || getContext(), value2, name2, $elm[0]);
              }
              $elm.attr("data-mce-" + name2, value2).attr(name2, value2);
            },
            get: function($elm, name2) {
              return $elm.attr("data-mce-" + name2) || $elm.attr(name2);
            }
          };
          attrHooks2 = {
            style: {
              set: function($elm, value2) {
                if (value2 !== null && typeof value2 === "object") {
                  $elm.css(value2);
                  return;
                }
                if (keepValues) {
                  $elm.attr("data-mce-style", value2);
                }
                $elm.attr("style", value2);
              },
              get: function($elm) {
                var value2 = $elm.attr("data-mce-style") || $elm.attr("style");
                value2 = styles.serialize(styles.parse(value2), $elm[0].nodeName);
                return value2;
              }
            }
          };
          if (keepValues) {
            attrHooks2.href = attrHooks2.src = keepUrlHook;
          }
          return attrHooks2;
        };
        var updateInternalStyleAttr = function(styles, $elm) {
          var rawValue = $elm.attr("style");
          var value2 = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
          if (!value2) {
            value2 = null;
          }
          $elm.attr("data-mce-style", value2);
        };
        var findNodeIndex = function(node2, normalized) {
          var idx = 0, lastNodeType, nodeType;
          if (node2) {
            for (lastNodeType = node2.nodeType, node2 = node2.previousSibling; node2; node2 = node2.previousSibling) {
              nodeType = node2.nodeType;
              if (normalized && nodeType === 3) {
                if (nodeType === lastNodeType || !node2.nodeValue.length) {
                  continue;
                }
              }
              idx++;
              lastNodeType = nodeType;
            }
          }
          return idx;
        };
        function DOMUtils(doc2, settings) {
          var _this = this;
          if (settings === void 0) {
            settings = {};
          }
          var attrHooks2;
          var addedStyles = {};
          var win = domGlobals.window;
          var files = {};
          var counter = 0;
          var stdMode = true;
          var boxModel = true;
          var styleSheetLoader = StyleSheetLoader(doc2, { contentCssCors: settings.contentCssCors });
          var boundEvents = [];
          var schema = settings.schema ? settings.schema : Schema({});
          var styles = Styles({
            url_converter: settings.url_converter,
            url_converter_scope: settings.url_converter_scope
          }, settings.schema);
          var events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;
          var blockElementsMap = schema.getBlockElements();
          var $ = DomQuery.overrideDefaults(function() {
            return {
              context: doc2,
              element: self2.getRoot()
            };
          });
          var isBlock3 = function(node2) {
            if (typeof node2 === "string") {
              return !!blockElementsMap[node2];
            } else if (node2) {
              var type2 = node2.nodeType;
              if (type2) {
                return !!(type2 === 1 && blockElementsMap[node2.nodeName]);
              }
            }
            return false;
          };
          var get2 = function(elm) {
            if (elm && doc2 && typeof elm === "string") {
              var node2 = doc2.getElementById(elm);
              if (node2 && node2.id !== elm) {
                return doc2.getElementsByName(elm)[1];
              } else {
                return node2;
              }
            }
            return elm;
          };
          var $$ = function(elm) {
            if (typeof elm === "string") {
              elm = get2(elm);
            }
            return $(elm);
          };
          var getAttrib = function(elm, name2, defaultVal) {
            var hook, value2;
            var $elm = $$(elm);
            if ($elm.length) {
              hook = attrHooks2[name2];
              if (hook && hook.get) {
                value2 = hook.get($elm, name2);
              } else {
                value2 = $elm.attr(name2);
              }
            }
            if (typeof value2 === "undefined") {
              value2 = defaultVal || "";
            }
            return value2;
          };
          var getAttribs = function(elm) {
            var node2 = get2(elm);
            if (!node2) {
              return [];
            }
            return node2.attributes;
          };
          var setAttrib = function(elm, name2, value2) {
            var originalValue, hook;
            if (value2 === "") {
              value2 = null;
            }
            var $elm = $$(elm);
            originalValue = $elm.attr(name2);
            if (!$elm.length) {
              return;
            }
            hook = attrHooks2[name2];
            if (hook && hook.set) {
              hook.set($elm, value2, name2);
            } else {
              $elm.attr(name2, value2);
            }
            if (originalValue !== value2 && settings.onSetAttrib) {
              settings.onSetAttrib({
                attrElm: $elm,
                attrName: name2,
                attrValue: value2
              });
            }
          };
          var clone2 = function(node2, deep2) {
            if (!isIE || node2.nodeType !== 1 || deep2) {
              return node2.cloneNode(deep2);
            }
            if (!deep2) {
              var clone_1 = doc2.createElement(node2.nodeName);
              each$5(getAttribs(node2), function(attr) {
                setAttrib(clone_1, attr.nodeName, getAttrib(node2, attr.nodeName));
              });
              return clone_1;
            }
            return null;
          };
          var getRoot = function() {
            return settings.root_element || doc2.body;
          };
          var getViewPort = function(argWin) {
            var actWin = !argWin ? win : argWin;
            var doc3 = actWin.document;
            var rootElm = doc3.documentElement;
            return {
              x: actWin.pageXOffset || rootElm.scrollLeft,
              y: actWin.pageYOffset || rootElm.scrollTop,
              w: actWin.innerWidth || rootElm.clientWidth,
              h: actWin.innerHeight || rootElm.clientHeight
            };
          };
          var getPos2 = function(elm, rootElm) {
            return Position.getPos(doc2.body, get2(elm), rootElm);
          };
          var setStyle = function(elm, name2, value2) {
            var $elm = $$(elm).css(name2, value2);
            if (settings.update_styles) {
              updateInternalStyleAttr(styles, $elm);
            }
          };
          var setStyles = function(elm, stylesArg) {
            var $elm = $$(elm).css(stylesArg);
            if (settings.update_styles) {
              updateInternalStyleAttr(styles, $elm);
            }
          };
          var getStyle2 = function(elm, name2, computed) {
            var $elm = $$(elm);
            if (computed) {
              return $elm.css(name2);
            }
            name2 = name2.replace(/-(\D)/g, function(a, b) {
              return b.toUpperCase();
            });
            if (name2 === "float") {
              name2 = Env.ie && Env.ie < 12 ? "styleFloat" : "cssFloat";
            }
            return $elm[0] && $elm[0].style ? $elm[0].style[name2] : void 0;
          };
          var getSize = function(elm) {
            var w, h;
            elm = get2(elm);
            w = getStyle2(elm, "width");
            h = getStyle2(elm, "height");
            if (w.indexOf("px") === -1) {
              w = 0;
            }
            if (h.indexOf("px") === -1) {
              h = 0;
            }
            return {
              w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
              h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
            };
          };
          var getRect = function(elm) {
            var pos, size;
            elm = get2(elm);
            pos = getPos2(elm);
            size = getSize(elm);
            return {
              x: pos.x,
              y: pos.y,
              w: size.w,
              h: size.h
            };
          };
          var is3 = function(elm, selector) {
            var i2;
            if (!elm) {
              return false;
            }
            if (!Array.isArray(elm)) {
              if (selector === "*") {
                return elm.nodeType === 1;
              }
              if (simpleSelectorRe.test(selector)) {
                var selectors = selector.toLowerCase().split(/,/);
                var elmName = elm.nodeName.toLowerCase();
                for (i2 = selectors.length - 1; i2 >= 0; i2--) {
                  if (selectors[i2] === elmName) {
                    return true;
                  }
                }
                return false;
              }
              if (elm.nodeType && elm.nodeType !== 1) {
                return false;
              }
            }
            var elms = !Array.isArray(elm) ? [elm] : elm;
            return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
          };
          var getParents2 = function(elm, selector, root2, collect) {
            var result = [];
            var selectorVal;
            var node2 = get2(elm);
            collect = collect === void 0;
            root2 = root2 || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
            if (Tools.is(selector, "string")) {
              selectorVal = selector;
              if (selector === "*") {
                selector = function(node3) {
                  return node3.nodeType === 1;
                };
              } else {
                selector = function(node3) {
                  return is3(node3, selectorVal);
                };
              }
            }
            while (node2) {
              if (node2 === root2 || !node2.nodeType || node2.nodeType === 9) {
                break;
              }
              if (!selector || typeof selector === "function" && selector(node2)) {
                if (collect) {
                  result.push(node2);
                } else {
                  return [node2];
                }
              }
              node2 = node2.parentNode;
            }
            return collect ? result : null;
          };
          var getParent = function(node2, selector, root2) {
            var parents2 = getParents2(node2, selector, root2, false);
            return parents2 && parents2.length > 0 ? parents2[0] : null;
          };
          var _findSib = function(node2, selector, name2) {
            var func = selector;
            if (node2) {
              if (typeof selector === "string") {
                func = function(node3) {
                  return is3(node3, selector);
                };
              }
              for (node2 = node2[name2]; node2; node2 = node2[name2]) {
                if (typeof func === "function" && func(node2)) {
                  return node2;
                }
              }
            }
            return null;
          };
          var getNext = function(node2, selector) {
            return _findSib(node2, selector, "nextSibling");
          };
          var getPrev = function(node2, selector) {
            return _findSib(node2, selector, "previousSibling");
          };
          var select2 = function(selector, scope) {
            return Sizzle(selector, get2(scope) || settings.root_element || doc2, []);
          };
          var run = function(elm, func, scope) {
            var result;
            var node2 = typeof elm === "string" ? get2(elm) : elm;
            if (!node2) {
              return false;
            }
            if (Tools.isArray(node2) && (node2.length || node2.length === 0)) {
              result = [];
              each$5(node2, function(elm2, i2) {
                if (elm2) {
                  if (typeof elm2 === "string") {
                    elm2 = get2(elm2);
                  }
                  result.push(func.call(scope, elm2, i2));
                }
              });
              return result;
            }
            var context2 = scope ? scope : _this;
            return func.call(context2, node2);
          };
          var setAttribs = function(elm, attrs) {
            $$(elm).each(function(i2, node2) {
              each$5(attrs, function(value2, name2) {
                setAttrib(node2, name2, value2);
              });
            });
          };
          var setHTML = function(elm, html2) {
            var $elm = $$(elm);
            if (isIE) {
              $elm.each(function(i2, target2) {
                if (target2.canHaveHTML === false) {
                  return;
                }
                while (target2.firstChild) {
                  target2.removeChild(target2.firstChild);
                }
                try {
                  target2.innerHTML = "<br>" + html2;
                  target2.removeChild(target2.firstChild);
                } catch (ex) {
                  DomQuery("<div></div>").html("<br>" + html2).contents().slice(1).appendTo(target2);
                }
                return html2;
              });
            } else {
              $elm.html(html2);
            }
          };
          var add2 = function(parentElm, name2, attrs, html2, create3) {
            return run(parentElm, function(parentElm2) {
              var newElm = typeof name2 === "string" ? doc2.createElement(name2) : name2;
              setAttribs(newElm, attrs);
              if (html2) {
                if (typeof html2 !== "string" && html2.nodeType) {
                  newElm.appendChild(html2);
                } else if (typeof html2 === "string") {
                  setHTML(newElm, html2);
                }
              }
              return !create3 ? parentElm2.appendChild(newElm) : newElm;
            });
          };
          var create2 = function(name2, attrs, html2) {
            return add2(doc2.createElement(name2), name2, attrs, html2, true);
          };
          var decode3 = Entities.decode;
          var encode2 = Entities.encodeAllRaw;
          var createHTML = function(name2, attrs, html2) {
            var outHtml = "", key;
            outHtml += "<" + name2;
            for (key in attrs) {
              if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] !== "undefined") {
                outHtml += " " + key + '="' + encode2(attrs[key]) + '"';
              }
            }
            if (typeof html2 !== "undefined") {
              return outHtml + ">" + html2 + "</" + name2 + ">";
            }
            return outHtml + " />";
          };
          var createFragment2 = function(html2) {
            var node2;
            var container = doc2.createElement("div");
            var frag = doc2.createDocumentFragment();
            frag.appendChild(container);
            if (html2) {
              container.innerHTML = html2;
            }
            while (node2 = container.firstChild) {
              frag.appendChild(node2);
            }
            frag.removeChild(container);
            return frag;
          };
          var remove3 = function(node2, keepChildren) {
            var $node = $$(node2);
            if (keepChildren) {
              $node.each(function() {
                var child2;
                while (child2 = this.firstChild) {
                  if (child2.nodeType === 3 && child2.data.length === 0) {
                    this.removeChild(child2);
                  } else {
                    this.parentNode.insertBefore(child2, this);
                  }
                }
              }).remove();
            } else {
              $node.remove();
            }
            return $node.length > 1 ? $node.toArray() : $node[0];
          };
          var removeAllAttribs = function(e) {
            return run(e, function(e2) {
              var i2;
              var attrs = e2.attributes;
              for (i2 = attrs.length - 1; i2 >= 0; i2--) {
                e2.removeAttributeNode(attrs.item(i2));
              }
            });
          };
          var parseStyle = function(cssText) {
            return styles.parse(cssText);
          };
          var serializeStyle = function(stylesArg, name2) {
            return styles.serialize(stylesArg, name2);
          };
          var addStyle = function(cssText) {
            var head2, styleElm;
            if (self2 !== DOMUtils.DOM && doc2 === domGlobals.document) {
              if (addedStyles[cssText]) {
                return;
              }
              addedStyles[cssText] = true;
            }
            styleElm = doc2.getElementById("mceDefaultStyles");
            if (!styleElm) {
              styleElm = doc2.createElement("style");
              styleElm.id = "mceDefaultStyles";
              styleElm.type = "text/css";
              head2 = doc2.getElementsByTagName("head")[0];
              if (head2.firstChild) {
                head2.insertBefore(styleElm, head2.firstChild);
              } else {
                head2.appendChild(styleElm);
              }
            }
            if (styleElm.styleSheet) {
              styleElm.styleSheet.cssText += cssText;
            } else {
              styleElm.appendChild(doc2.createTextNode(cssText));
            }
          };
          var loadCSS = function(url2) {
            var head2;
            if (self2 !== DOMUtils.DOM && doc2 === domGlobals.document) {
              DOMUtils.DOM.loadCSS(url2);
              return;
            }
            if (!url2) {
              url2 = "";
            }
            head2 = doc2.getElementsByTagName("head")[0];
            each$5(url2.split(","), function(url3) {
              var link2;
              url3 = Tools._addCacheSuffix(url3);
              if (files[url3]) {
                return;
              }
              files[url3] = true;
              link2 = create2("link", {
                rel: "stylesheet",
                href: url3
              });
              head2.appendChild(link2);
            });
          };
          var toggleClass2 = function(elm, cls, state) {
            $$(elm).toggleClass(cls, state).each(function() {
              if (this.className === "") {
                DomQuery(this).attr("class", null);
              }
            });
          };
          var addClass = function(elm, cls) {
            $$(elm).addClass(cls);
          };
          var removeClass = function(elm, cls) {
            toggleClass2(elm, cls, false);
          };
          var hasClass2 = function(elm, cls) {
            return $$(elm).hasClass(cls);
          };
          var show = function(elm) {
            $$(elm).show();
          };
          var hide = function(elm) {
            $$(elm).hide();
          };
          var isHidden = function(elm) {
            return $$(elm).css("display") === "none";
          };
          var uniqueId2 = function(prefix) {
            return (!prefix ? "mce_" : prefix) + counter++;
          };
          var getOuterHTML = function(elm) {
            var node2 = typeof elm === "string" ? get2(elm) : elm;
            return NodeType.isElement(node2) ? node2.outerHTML : DomQuery("<div></div>").append(DomQuery(node2).clone()).html();
          };
          var setOuterHTML = function(elm, html2) {
            $$(elm).each(function() {
              try {
                if ("outerHTML" in this) {
                  this.outerHTML = html2;
                  return;
                }
              } catch (ex) {
              }
              remove3(DomQuery(this).html(html2), true);
            });
          };
          var insertAfter2 = function(node2, reference2) {
            var referenceNode = get2(reference2);
            return run(node2, function(node3) {
              var parent2, nextSibling2;
              parent2 = referenceNode.parentNode;
              nextSibling2 = referenceNode.nextSibling;
              if (nextSibling2) {
                parent2.insertBefore(node3, nextSibling2);
              } else {
                parent2.appendChild(node3);
              }
              return node3;
            });
          };
          var replace = function(newElm, oldElm, keepChildren) {
            return run(oldElm, function(oldElm2) {
              if (Tools.is(oldElm2, "array")) {
                newElm = newElm.cloneNode(true);
              }
              if (keepChildren) {
                each$5(grep$1(oldElm2.childNodes), function(node2) {
                  newElm.appendChild(node2);
                });
              }
              return oldElm2.parentNode.replaceChild(newElm, oldElm2);
            });
          };
          var rename = function(elm, name2) {
            var newElm;
            if (elm.nodeName !== name2.toUpperCase()) {
              newElm = create2(name2);
              each$5(getAttribs(elm), function(attrNode) {
                setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
              });
              replace(newElm, elm, true);
            }
            return newElm || elm;
          };
          var findCommonAncestor = function(a, b) {
            var ps = a, pe;
            while (ps) {
              pe = b;
              while (pe && ps !== pe) {
                pe = pe.parentNode;
              }
              if (ps === pe) {
                break;
              }
              ps = ps.parentNode;
            }
            if (!ps && a.ownerDocument) {
              return a.ownerDocument.documentElement;
            }
            return ps;
          };
          var toHex2 = function(rgbVal) {
            return styles.toHex(Tools.trim(rgbVal));
          };
          var isEmpty2 = function(node2, elements) {
            var i2, attributes2, type2, whitespace2, walker, name2, brCount = 0;
            node2 = node2.firstChild;
            if (node2) {
              walker = new TreeWalker(node2, node2.parentNode);
              elements = elements || (schema ? schema.getNonEmptyElements() : null);
              whitespace2 = schema ? schema.getWhiteSpaceElements() : {};
              do {
                type2 = node2.nodeType;
                if (NodeType.isElement(node2)) {
                  var bogusVal = node2.getAttribute("data-mce-bogus");
                  if (bogusVal) {
                    node2 = walker.next(bogusVal === "all");
                    continue;
                  }
                  name2 = node2.nodeName.toLowerCase();
                  if (elements && elements[name2]) {
                    if (name2 === "br") {
                      brCount++;
                      node2 = walker.next();
                      continue;
                    }
                    return false;
                  }
                  attributes2 = getAttribs(node2);
                  i2 = attributes2.length;
                  while (i2--) {
                    name2 = attributes2[i2].nodeName;
                    if (name2 === "name" || name2 === "data-mce-bookmark") {
                      return false;
                    }
                  }
                }
                if (type2 === 8) {
                  return false;
                }
                if (type2 === 3 && !whiteSpaceRegExp$2.test(node2.nodeValue)) {
                  return false;
                }
                if (type2 === 3 && node2.parentNode && whitespace2[node2.parentNode.nodeName] && whiteSpaceRegExp$2.test(node2.nodeValue)) {
                  return false;
                }
                node2 = walker.next();
              } while (node2);
            }
            return brCount <= 1;
          };
          var createRng = function() {
            return doc2.createRange();
          };
          var split2 = function(parentElm, splitElm, replacementElm) {
            var r = createRng(), bef, aft, pa;
            if (parentElm && splitElm) {
              r.setStart(parentElm.parentNode, findNodeIndex(parentElm));
              r.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
              bef = r.extractContents();
              r = createRng();
              r.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
              r.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
              aft = r.extractContents();
              pa = parentElm.parentNode;
              pa.insertBefore(TrimNode.trimNode(self2, bef), parentElm);
              if (replacementElm) {
                pa.insertBefore(replacementElm, parentElm);
              } else {
                pa.insertBefore(splitElm, parentElm);
              }
              pa.insertBefore(TrimNode.trimNode(self2, aft), parentElm);
              remove3(parentElm);
              return replacementElm || splitElm;
            }
          };
          var bind2 = function(target2, name2, func, scope) {
            if (Tools.isArray(target2)) {
              var i2 = target2.length;
              while (i2--) {
                target2[i2] = bind2(target2[i2], name2, func, scope);
              }
              return target2;
            }
            if (settings.collect && (target2 === doc2 || target2 === win)) {
              boundEvents.push([
                target2,
                name2,
                func,
                scope
              ]);
            }
            return events.bind(target2, name2, func, scope || self2);
          };
          var unbind = function(target2, name2, func) {
            var i2;
            if (Tools.isArray(target2)) {
              i2 = target2.length;
              while (i2--) {
                target2[i2] = unbind(target2[i2], name2, func);
              }
              return target2;
            }
            if (boundEvents && (target2 === doc2 || target2 === win)) {
              i2 = boundEvents.length;
              while (i2--) {
                var item = boundEvents[i2];
                if (target2 === item[0] && (!name2 || name2 === item[1]) && (!func || func === item[2])) {
                  events.unbind(item[0], item[1], item[2]);
                }
              }
            }
            return events.unbind(target2, name2, func);
          };
          var fire = function(target2, name2, evt) {
            return events.fire(target2, name2, evt);
          };
          var getContentEditable = function(node2) {
            if (node2 && NodeType.isElement(node2)) {
              var contentEditable2 = node2.getAttribute("data-mce-contenteditable");
              if (contentEditable2 && contentEditable2 !== "inherit") {
                return contentEditable2;
              }
              return node2.contentEditable !== "inherit" ? node2.contentEditable : null;
            } else {
              return null;
            }
          };
          var getContentEditableParent = function(node2) {
            var root2 = getRoot();
            var state = null;
            for (; node2 && node2 !== root2; node2 = node2.parentNode) {
              state = getContentEditable(node2);
              if (state !== null) {
                break;
              }
            }
            return state;
          };
          var destroy2 = function() {
            if (boundEvents) {
              var i2 = boundEvents.length;
              while (i2--) {
                var item = boundEvents[i2];
                events.unbind(item[0], item[1], item[2]);
              }
            }
            if (Sizzle.setDocument) {
              Sizzle.setDocument();
            }
          };
          var isChildOf = function(node2, parent2) {
            while (node2) {
              if (parent2 === node2) {
                return true;
              }
              node2 = node2.parentNode;
            }
            return false;
          };
          var dumpRng = function(r) {
            return "startContainer: " + r.startContainer.nodeName + ", startOffset: " + r.startOffset + ", endContainer: " + r.endContainer.nodeName + ", endOffset: " + r.endOffset;
          };
          var self2 = {
            doc: doc2,
            settings,
            win,
            files,
            stdMode,
            boxModel,
            styleSheetLoader,
            boundEvents,
            styles,
            schema,
            events,
            isBlock: isBlock3,
            $,
            $$,
            root: null,
            clone: clone2,
            getRoot,
            getViewPort,
            getRect,
            getSize,
            getParent,
            getParents: getParents2,
            get: get2,
            getNext,
            getPrev,
            select: select2,
            is: is3,
            add: add2,
            create: create2,
            createHTML,
            createFragment: createFragment2,
            remove: remove3,
            setStyle,
            getStyle: getStyle2,
            setStyles,
            removeAllAttribs,
            setAttrib,
            setAttribs,
            getAttrib,
            getPos: getPos2,
            parseStyle,
            serializeStyle,
            addStyle,
            loadCSS,
            addClass,
            removeClass,
            hasClass: hasClass2,
            toggleClass: toggleClass2,
            show,
            hide,
            isHidden,
            uniqueId: uniqueId2,
            setHTML,
            getOuterHTML,
            setOuterHTML,
            decode: decode3,
            encode: encode2,
            insertAfter: insertAfter2,
            replace,
            rename,
            findCommonAncestor,
            toHex: toHex2,
            run,
            getAttribs,
            isEmpty: isEmpty2,
            createRng,
            nodeIndex: findNodeIndex,
            split: split2,
            bind: bind2,
            unbind,
            fire,
            getContentEditable,
            getContentEditableParent,
            destroy: destroy2,
            isChildOf,
            dumpRng
          };
          attrHooks2 = setupAttrHooks(styles, settings, function() {
            return self2;
          });
          return self2;
        }
        (function(DOMUtils2) {
          DOMUtils2.DOM = DOMUtils2(domGlobals.document);
          DOMUtils2.nodeIndex = findNodeIndex;
        })(DOMUtils || (DOMUtils = {}));
        var DOMUtils$1 = DOMUtils;
        var DOM = DOMUtils$1.DOM;
        var each$6 = Tools.each, grep$2 = Tools.grep;
        var isFunction$1 = function(f) {
          return typeof f === "function";
        };
        var ScriptLoader = function() {
          var QUEUED = 0;
          var LOADING = 1;
          var LOADED = 2;
          var FAILED = 3;
          var states = {};
          var queue = [];
          var scriptLoadedCallbacks = {};
          var queueLoadedCallbacks = [];
          var loading = 0;
          var loadScript = function(url2, success, failure) {
            var dom2 = DOM;
            var elm, id;
            var done2 = function() {
              dom2.remove(id);
              if (elm) {
                elm.onreadystatechange = elm.onload = elm = null;
              }
              success();
            };
            var error3 = function() {
              if (isFunction$1(failure)) {
                failure();
              } else {
                if (typeof console !== "undefined" && console.log) {
                  console.log("Failed to load script: " + url2);
                }
              }
            };
            id = dom2.uniqueId();
            elm = domGlobals.document.createElement("script");
            elm.id = id;
            elm.type = "text/javascript";
            elm.src = Tools._addCacheSuffix(url2);
            elm.onload = done2;
            elm.onerror = error3;
            (domGlobals.document.getElementsByTagName("head")[0] || domGlobals.document.body).appendChild(elm);
          };
          this.isDone = function(url2) {
            return states[url2] === LOADED;
          };
          this.markDone = function(url2) {
            states[url2] = LOADED;
          };
          this.add = this.load = function(url2, success, scope, failure) {
            var state = states[url2];
            if (state === void 0) {
              queue.push(url2);
              states[url2] = QUEUED;
            }
            if (success) {
              if (!scriptLoadedCallbacks[url2]) {
                scriptLoadedCallbacks[url2] = [];
              }
              scriptLoadedCallbacks[url2].push({
                success,
                failure,
                scope: scope || this
              });
            }
          };
          this.remove = function(url2) {
            delete states[url2];
            delete scriptLoadedCallbacks[url2];
          };
          this.loadQueue = function(success, scope, failure) {
            this.loadScripts(queue, success, scope, failure);
          };
          this.loadScripts = function(scripts, success, scope, failure) {
            var loadScripts2;
            var failures = [];
            var execCallbacks = function(name2, url2) {
              each$6(scriptLoadedCallbacks[url2], function(callback) {
                if (isFunction$1(callback[name2])) {
                  callback[name2].call(callback.scope);
                }
              });
              scriptLoadedCallbacks[url2] = void 0;
            };
            queueLoadedCallbacks.push({
              success,
              failure,
              scope: scope || this
            });
            loadScripts2 = function() {
              var loadingScripts = grep$2(scripts);
              scripts.length = 0;
              each$6(loadingScripts, function(url2) {
                if (states[url2] === LOADED) {
                  execCallbacks("success", url2);
                  return;
                }
                if (states[url2] === FAILED) {
                  execCallbacks("failure", url2);
                  return;
                }
                if (states[url2] !== LOADING) {
                  states[url2] = LOADING;
                  loading++;
                  loadScript(url2, function() {
                    states[url2] = LOADED;
                    loading--;
                    execCallbacks("success", url2);
                    loadScripts2();
                  }, function() {
                    states[url2] = FAILED;
                    loading--;
                    failures.push(url2);
                    execCallbacks("failure", url2);
                    loadScripts2();
                  });
                }
              });
              if (!loading) {
                var notifyCallbacks = queueLoadedCallbacks.slice(0);
                queueLoadedCallbacks.length = 0;
                each$6(notifyCallbacks, function(callback) {
                  if (failures.length === 0) {
                    if (isFunction$1(callback.success)) {
                      callback.success.call(callback.scope);
                    }
                  } else {
                    if (isFunction$1(callback.failure)) {
                      callback.failure.call(callback.scope, failures);
                    }
                  }
                });
              }
            };
            loadScripts2();
          };
        };
        ScriptLoader.ScriptLoader = new ScriptLoader();
        var each$7 = Tools.each;
        function AddOnManager() {
          var _this = this;
          var items = [];
          var urls = {};
          var lookup = {};
          var _listeners = [];
          var get2 = function(name2) {
            if (lookup[name2]) {
              return lookup[name2].instance;
            }
            return void 0;
          };
          var dependencies = function(name2) {
            var result;
            if (lookup[name2]) {
              result = lookup[name2].dependencies;
            }
            return result || [];
          };
          var requireLangPack = function(name2, languages) {
            var language = AddOnManager.language;
            if (language && AddOnManager.languageLoad !== false) {
              if (languages) {
                languages = "," + languages + ",";
                if (languages.indexOf("," + language.substr(0, 2) + ",") !== -1) {
                  language = language.substr(0, 2);
                } else if (languages.indexOf("," + language + ",") === -1) {
                  return;
                }
              }
              ScriptLoader.ScriptLoader.add(urls[name2] + "/langs/" + language + ".js");
            }
          };
          var add2 = function(id, addOn, dependencies2) {
            items.push(addOn);
            lookup[id] = {
              instance: addOn,
              dependencies: dependencies2
            };
            var result = partition(_listeners, function(listener) {
              return listener.name === id;
            });
            _listeners = result.fail;
            each$7(result.pass, function(listener) {
              listener.callback();
            });
            return addOn;
          };
          var remove3 = function(name2) {
            delete urls[name2];
            delete lookup[name2];
          };
          var createUrl = function(baseUrl, dep) {
            if (typeof dep === "object") {
              return dep;
            }
            return typeof baseUrl === "string" ? {
              prefix: "",
              resource: dep,
              suffix: ""
            } : {
              prefix: baseUrl.prefix,
              resource: dep,
              suffix: baseUrl.suffix
            };
          };
          var addComponents = function(pluginName, scripts) {
            var pluginUrl = _this.urls[pluginName];
            each$7(scripts, function(script) {
              ScriptLoader.ScriptLoader.add(pluginUrl + "/" + script);
            });
          };
          var loadDependencies = function(name2, addOnUrl, success, scope) {
            var deps = dependencies(name2);
            each$7(deps, function(dep) {
              var newUrl = createUrl(addOnUrl, dep);
              load(newUrl.resource, newUrl, void 0, void 0);
            });
            if (success) {
              if (scope) {
                success.call(scope);
              } else {
                success.call(ScriptLoader);
              }
            }
          };
          var load = function(name2, addOnUrl, success, scope, failure) {
            if (urls[name2]) {
              return;
            }
            var urlString = typeof addOnUrl === "string" ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
            if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
              urlString = AddOnManager.baseURL + "/" + urlString;
            }
            urls[name2] = urlString.substring(0, urlString.lastIndexOf("/"));
            if (lookup[name2]) {
              loadDependencies(name2, addOnUrl, success, scope);
            } else {
              ScriptLoader.ScriptLoader.add(urlString, function() {
                return loadDependencies(name2, addOnUrl, success, scope);
              }, scope, failure);
            }
          };
          var waitFor = function(name2, callback) {
            if (lookup.hasOwnProperty(name2)) {
              callback();
            } else {
              _listeners.push({
                name: name2,
                callback
              });
            }
          };
          return {
            items,
            urls,
            lookup,
            _listeners,
            get: get2,
            dependencies,
            requireLangPack,
            add: add2,
            remove: remove3,
            createUrl,
            addComponents,
            load,
            waitFor
          };
        }
        (function(AddOnManager2) {
          AddOnManager2.PluginManager = AddOnManager2();
          AddOnManager2.ThemeManager = AddOnManager2();
        })(AddOnManager || (AddOnManager = {}));
        var before = function(marker2, element) {
          var parent$1 = parent(marker2);
          parent$1.each(function(v) {
            v.dom().insertBefore(element.dom(), marker2.dom());
          });
        };
        var after = function(marker2, element) {
          var sibling2 = nextSibling(marker2);
          sibling2.fold(function() {
            var parent$1 = parent(marker2);
            parent$1.each(function(v) {
              append(v, element);
            });
          }, function(v) {
            before(v, element);
          });
        };
        var prepend = function(parent2, element) {
          var firstChild$1 = firstChild(parent2);
          firstChild$1.fold(function() {
            append(parent2, element);
          }, function(v) {
            parent2.dom().insertBefore(element.dom(), v.dom());
          });
        };
        var append = function(parent2, element) {
          parent2.dom().appendChild(element.dom());
        };
        var wrap$1 = function(element, wrapper) {
          before(element, wrapper);
          append(wrapper, element);
        };
        var before$1 = function(marker2, elements) {
          each(elements, function(x) {
            before(marker2, x);
          });
        };
        var append$1 = function(parent2, elements) {
          each(elements, function(x) {
            append(parent2, x);
          });
        };
        var empty2 = function(element) {
          element.dom().textContent = "";
          each(children(element), function(rogue) {
            remove$1(rogue);
          });
        };
        var remove$1 = function(element) {
          var dom2 = element.dom();
          if (dom2.parentNode !== null) {
            dom2.parentNode.removeChild(dom2);
          }
        };
        var unwrap = function(wrapper) {
          var children$1 = children(wrapper);
          if (children$1.length > 0) {
            before$1(wrapper, children$1);
          }
          remove$1(wrapper);
        };
        var first = function(fn, rate) {
          var timer = null;
          var cancel = function() {
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
              timer = null;
            }
          };
          var throttle = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (timer === null) {
              timer = domGlobals.setTimeout(function() {
                fn.apply(null, args);
                timer = null;
              }, rate);
            }
          };
          return {
            cancel,
            throttle
          };
        };
        var last$2 = function(fn, rate) {
          var timer = null;
          var cancel = function() {
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
              timer = null;
            }
          };
          var throttle = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (timer !== null) {
              domGlobals.clearTimeout(timer);
            }
            timer = domGlobals.setTimeout(function() {
              fn.apply(null, args);
              timer = null;
            }, rate);
          };
          return {
            cancel,
            throttle
          };
        };
        var Cell = function(initial) {
          var value2 = initial;
          var get2 = function() {
            return value2;
          };
          var set2 = function(v) {
            value2 = v;
          };
          var clone2 = function() {
            return Cell(get2());
          };
          return {
            get: get2,
            set: set2,
            clone: clone2
          };
        };
        var read = function(element, attr) {
          var value2 = get(element, attr);
          return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
        };
        var add = function(element, attr, id) {
          var old = read(element, attr);
          var nu3 = old.concat([id]);
          set(element, attr, nu3.join(" "));
          return true;
        };
        var remove$2 = function(element, attr, id) {
          var nu3 = filter(read(element, attr), function(v) {
            return v !== id;
          });
          if (nu3.length > 0) {
            set(element, attr, nu3.join(" "));
          } else {
            remove2(element, attr);
          }
          return false;
        };
        var supports = function(element) {
          return element.dom().classList !== void 0;
        };
        var get$2 = function(element) {
          return read(element, "class");
        };
        var add$1 = function(element, clazz) {
          return add(element, "class", clazz);
        };
        var remove$3 = function(element, clazz) {
          return remove$2(element, "class", clazz);
        };
        var add$2 = function(element, clazz) {
          if (supports(element)) {
            element.dom().classList.add(clazz);
          } else {
            add$1(element, clazz);
          }
        };
        var cleanClass = function(element) {
          var classList = supports(element) ? element.dom().classList : get$2(element);
          if (classList.length === 0) {
            remove2(element, "class");
          }
        };
        var remove$4 = function(element, clazz) {
          if (supports(element)) {
            var classList = element.dom().classList;
            classList.remove(clazz);
          } else {
            remove$3(element, clazz);
          }
          cleanClass(element);
        };
        var has$2 = function(element, clazz) {
          return supports(element) && element.dom().classList.contains(clazz);
        };
        var descendants = function(scope, predicate) {
          var result = [];
          each(children(scope), function(x) {
            if (predicate(x)) {
              result = result.concat([x]);
            }
            result = result.concat(descendants(x, predicate));
          });
          return result;
        };
        var descendants$1 = function(scope, selector) {
          return all(selector, scope);
        };
        function ClosestOrAncestor(is3, ancestor2, scope, a, isRoot) {
          return is3(scope, a) ? Option.some(scope) : isFunction(isRoot) && isRoot(scope) ? Option.none() : ancestor2(scope, a, isRoot);
        }
        var ancestor = function(scope, predicate, isRoot) {
          var element = scope.dom();
          var stop2 = isFunction(isRoot) ? isRoot : constant(false);
          while (element.parentNode) {
            element = element.parentNode;
            var el2 = Element2.fromDom(element);
            if (predicate(el2)) {
              return Option.some(el2);
            } else if (stop2(el2)) {
              break;
            }
          }
          return Option.none();
        };
        var closest = function(scope, predicate, isRoot) {
          var is3 = function(s, test) {
            return test(s);
          };
          return ClosestOrAncestor(is3, ancestor, scope, predicate, isRoot);
        };
        var ancestor$1 = function(scope, selector, isRoot) {
          return ancestor(scope, function(e) {
            return is$1(e, selector);
          }, isRoot);
        };
        var descendant = function(scope, selector) {
          return one(selector, scope);
        };
        var closest$1 = function(scope, selector, isRoot) {
          return ClosestOrAncestor(is$1, ancestor$1, scope, selector, isRoot);
        };
        var annotation = constant("mce-annotation");
        var dataAnnotation = constant("data-mce-annotation");
        var dataAnnotationId = constant("data-mce-annotation-uid");
        var identify = function(editor, annotationName) {
          var rng = editor.selection.getRng();
          var start2 = Element2.fromDom(rng.startContainer);
          var root2 = Element2.fromDom(editor.getBody());
          var selector = annotationName.fold(function() {
            return "." + annotation();
          }, function(an) {
            return "[" + dataAnnotation() + '="' + an + '"]';
          });
          var newStart = child(start2, rng.startOffset).getOr(start2);
          var closest2 = closest$1(newStart, selector, function(n) {
            return eq(n, root2);
          });
          var getAttr = function(c, property) {
            if (has$1(c, property)) {
              return Option.some(get(c, property));
            } else {
              return Option.none();
            }
          };
          return closest2.bind(function(c) {
            return getAttr(c, "" + dataAnnotationId()).bind(function(uid) {
              return getAttr(c, "" + dataAnnotation()).map(function(name2) {
                var elements = findMarkers(editor, uid);
                return {
                  uid,
                  name: name2,
                  elements
                };
              });
            });
          });
        };
        var isAnnotation = function(elem) {
          return isElement(elem) && has$2(elem, annotation());
        };
        var findMarkers = function(editor, uid) {
          var body = Element2.fromDom(editor.getBody());
          return descendants$1(body, "[" + dataAnnotationId() + '="' + uid + '"]');
        };
        var findAll = function(editor, name2) {
          var body = Element2.fromDom(editor.getBody());
          var markers = descendants$1(body, "[" + dataAnnotation() + '="' + name2 + '"]');
          var directory = {};
          each(markers, function(m) {
            var uid = get(m, dataAnnotationId());
            var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
            directory[uid] = nodesAlready.concat([m]);
          });
          return directory;
        };
        var setup = function(editor, registry) {
          var changeCallbacks = Cell({});
          var initData = function() {
            return {
              listeners: [],
              previous: Cell(Option.none())
            };
          };
          var withCallbacks = function(name2, f) {
            updateCallbacks(name2, function(data2) {
              f(data2);
              return data2;
            });
          };
          var updateCallbacks = function(name2, f) {
            var callbackMap = changeCallbacks.get();
            var data2 = callbackMap.hasOwnProperty(name2) ? callbackMap[name2] : initData();
            var outputData = f(data2);
            callbackMap[name2] = outputData;
            changeCallbacks.set(callbackMap);
          };
          var fireCallbacks = function(name2, uid, elements) {
            withCallbacks(name2, function(data2) {
              each(data2.listeners, function(f) {
                return f(true, name2, {
                  uid,
                  nodes: map2(elements, function(elem) {
                    return elem.dom();
                  })
                });
              });
            });
          };
          var fireNoAnnotation = function(name2) {
            withCallbacks(name2, function(data2) {
              each(data2.listeners, function(f) {
                return f(false, name2);
              });
            });
          };
          var onNodeChange = last$2(function() {
            var callbackMap = changeCallbacks.get();
            var annotations = sort(keys(callbackMap));
            each(annotations, function(name2) {
              updateCallbacks(name2, function(data2) {
                var prev = data2.previous.get();
                identify(editor, Option.some(name2)).fold(function() {
                  if (prev.isSome()) {
                    fireNoAnnotation(name2);
                    data2.previous.set(Option.none());
                  }
                }, function(_a) {
                  var uid = _a.uid, name3 = _a.name, elements = _a.elements;
                  if (!prev.is(uid)) {
                    fireCallbacks(name3, uid, elements);
                    data2.previous.set(Option.some(uid));
                  }
                });
                return {
                  previous: data2.previous,
                  listeners: data2.listeners
                };
              });
            });
          }, 30);
          editor.on("remove", function() {
            onNodeChange.cancel();
          });
          editor.on("nodeChange", function() {
            onNodeChange.throttle();
          });
          var addListener = function(name2, f) {
            updateCallbacks(name2, function(data2) {
              return {
                previous: data2.previous,
                listeners: data2.listeners.concat([f])
              };
            });
          };
          return { addListener };
        };
        var setup$1 = function(editor, registry) {
          var identifyParserNode = function(span) {
            var optAnnotation = Option.from(span.attributes.map[dataAnnotation()]);
            return optAnnotation.bind(registry.lookup);
          };
          editor.on("init", function() {
            editor.serializer.addNodeFilter("span", function(spans) {
              each(spans, function(span) {
                identifyParserNode(span).each(function(settings) {
                  if (settings.persistent === false) {
                    span.unwrap();
                  }
                });
              });
            });
          });
        };
        var create$1 = function() {
          var annotations = {};
          var register2 = function(name2, settings) {
            annotations[name2] = {
              name: name2,
              settings
            };
          };
          var lookup = function(name2) {
            return annotations.hasOwnProperty(name2) ? Option.from(annotations[name2]).map(function(a) {
              return a.settings;
            }) : Option.none();
          };
          return {
            register: register2,
            lookup
          };
        };
        var __assign = function() {
          __assign = Object.assign || function __assign2(t) {
            for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s = arguments[i2];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
              if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
                t[p[i2]] = s[p[i2]];
            }
          return t;
        }
        function __spreadArrays() {
          for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
            s += arguments[i2].length;
          for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
            for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }
        var unique = 0;
        var generate = function(prefix) {
          var date = /* @__PURE__ */ new Date();
          var time = date.getTime();
          var random = Math.floor(Math.random() * 1e9);
          unique++;
          return prefix + "_" + random + unique + String(time);
        };
        var add$3 = function(element, classes) {
          each(classes, function(x) {
            add$2(element, x);
          });
        };
        var clone = function(original, isDeep) {
          return Element2.fromDom(original.dom().cloneNode(isDeep));
        };
        var shallow = function(original) {
          return clone(original, false);
        };
        var deep = function(original) {
          return clone(original, true);
        };
        var fromHtml$1 = function(html2, scope) {
          var doc2 = scope || domGlobals.document;
          var div2 = doc2.createElement("div");
          div2.innerHTML = html2;
          return children(Element2.fromDom(div2));
        };
        var get$3 = function(element) {
          return element.dom().innerHTML;
        };
        var set$1 = function(element, content) {
          var owner$1 = owner(element);
          var docDom = owner$1.dom();
          var fragment = Element2.fromDom(docDom.createDocumentFragment());
          var contentElements = fromHtml$1(content, docDom);
          append$1(fragment, contentElements);
          empty2(element);
          append(element, fragment);
        };
        var ZWSP = "\uFEFF";
        var isZwsp = function(chr) {
          return chr === ZWSP;
        };
        var trim$3 = function(text2) {
          return text2.replace(new RegExp(ZWSP, "g"), "");
        };
        var Zwsp = {
          isZwsp,
          ZWSP,
          trim: trim$3
        };
        var isElement$2 = NodeType.isElement;
        var isText$2 = NodeType.isText;
        var isCaretContainerBlock = function(node2) {
          if (isText$2(node2)) {
            node2 = node2.parentNode;
          }
          return isElement$2(node2) && node2.hasAttribute("data-mce-caret");
        };
        var isCaretContainerInline = function(node2) {
          return isText$2(node2) && Zwsp.isZwsp(node2.data);
        };
        var isCaretContainer = function(node2) {
          return isCaretContainerBlock(node2) || isCaretContainerInline(node2);
        };
        var hasContent = function(node2) {
          return node2.firstChild !== node2.lastChild || !NodeType.isBr(node2.firstChild);
        };
        var insertInline = function(node2, before2) {
          var doc2, sibling2, textNode, parentNode;
          doc2 = node2.ownerDocument;
          textNode = doc2.createTextNode(Zwsp.ZWSP);
          parentNode = node2.parentNode;
          if (!before2) {
            sibling2 = node2.nextSibling;
            if (isText$2(sibling2)) {
              if (isCaretContainer(sibling2)) {
                return sibling2;
              }
              if (startsWithCaretContainer(sibling2)) {
                sibling2.splitText(1);
                return sibling2;
              }
            }
            if (node2.nextSibling) {
              parentNode.insertBefore(textNode, node2.nextSibling);
            } else {
              parentNode.appendChild(textNode);
            }
          } else {
            sibling2 = node2.previousSibling;
            if (isText$2(sibling2)) {
              if (isCaretContainer(sibling2)) {
                return sibling2;
              }
              if (endsWithCaretContainer(sibling2)) {
                return sibling2.splitText(sibling2.data.length - 1);
              }
            }
            parentNode.insertBefore(textNode, node2);
          }
          return textNode;
        };
        var isBeforeInline = function(pos) {
          var container = pos.container();
          if (!pos || !NodeType.isText(container)) {
            return false;
          }
          return container.data.charAt(pos.offset()) === Zwsp.ZWSP || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
        };
        var isAfterInline = function(pos) {
          var container = pos.container();
          if (!pos || !NodeType.isText(container)) {
            return false;
          }
          return container.data.charAt(pos.offset() - 1) === Zwsp.ZWSP || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
        };
        var createBogusBr = function() {
          var br = domGlobals.document.createElement("br");
          br.setAttribute("data-mce-bogus", "1");
          return br;
        };
        var insertBlock = function(blockName, node2, before2) {
          var doc2, blockNode, parentNode;
          doc2 = node2.ownerDocument;
          blockNode = doc2.createElement(blockName);
          blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
          blockNode.setAttribute("data-mce-bogus", "all");
          blockNode.appendChild(createBogusBr());
          parentNode = node2.parentNode;
          if (!before2) {
            if (node2.nextSibling) {
              parentNode.insertBefore(blockNode, node2.nextSibling);
            } else {
              parentNode.appendChild(blockNode);
            }
          } else {
            parentNode.insertBefore(blockNode, node2);
          }
          return blockNode;
        };
        var startsWithCaretContainer = function(node2) {
          return isText$2(node2) && node2.data[0] === Zwsp.ZWSP;
        };
        var endsWithCaretContainer = function(node2) {
          return isText$2(node2) && node2.data[node2.data.length - 1] === Zwsp.ZWSP;
        };
        var trimBogusBr = function(elm) {
          var brs = elm.getElementsByTagName("br");
          var lastBr = brs[brs.length - 1];
          if (NodeType.isBogus(lastBr)) {
            lastBr.parentNode.removeChild(lastBr);
          }
        };
        var showCaretContainerBlock = function(caretContainer) {
          if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute("data-mce-caret");
            caretContainer.removeAttribute("data-mce-bogus");
            caretContainer.removeAttribute("style");
            caretContainer.removeAttribute("_moz_abspos");
            return caretContainer;
          }
          return null;
        };
        var isRangeInCaretContainerBlock = function(range3) {
          return isCaretContainerBlock(range3.startContainer);
        };
        var isContentEditableTrue$1 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$1 = NodeType.isContentEditableFalse;
        var isBr$2 = NodeType.isBr;
        var isText$3 = NodeType.isText;
        var isInvalidTextElement = NodeType.matchNodeNames("script style textarea");
        var isAtomicInline = NodeType.matchNodeNames("img input textarea hr iframe video audio object");
        var isTable$1 = NodeType.matchNodeNames("table");
        var isCaretContainer$1 = isCaretContainer;
        var isCaretCandidate = function(node2) {
          if (isCaretContainer$1(node2)) {
            return false;
          }
          if (isText$3(node2)) {
            if (isInvalidTextElement(node2.parentNode)) {
              return false;
            }
            return true;
          }
          return isAtomicInline(node2) || isBr$2(node2) || isTable$1(node2) || isNonUiContentEditableFalse(node2);
        };
        var isUnselectable = function(node2) {
          return NodeType.isElement(node2) && node2.getAttribute("unselectable") === "true";
        };
        var isNonUiContentEditableFalse = function(node2) {
          return isUnselectable(node2) === false && isContentEditableFalse$1(node2);
        };
        var isInEditable = function(node2, root2) {
          for (node2 = node2.parentNode; node2 && node2 !== root2; node2 = node2.parentNode) {
            if (isNonUiContentEditableFalse(node2)) {
              return false;
            }
            if (isContentEditableTrue$1(node2)) {
              return true;
            }
          }
          return true;
        };
        var isAtomicContentEditableFalse = function(node2) {
          if (!isNonUiContentEditableFalse(node2)) {
            return false;
          }
          return foldl(from$1(node2.getElementsByTagName("*")), function(result, elm) {
            return result || isContentEditableTrue$1(elm);
          }, false) !== true;
        };
        var isAtomic = function(node2) {
          return isAtomicInline(node2) || isAtomicContentEditableFalse(node2);
        };
        var isEditableCaretCandidate = function(node2, root2) {
          return isCaretCandidate(node2) && isInEditable(node2, root2);
        };
        var round = Math.round;
        var clone$1 = function(rect2) {
          if (!rect2) {
            return {
              left: 0,
              top: 0,
              bottom: 0,
              right: 0,
              width: 0,
              height: 0
            };
          }
          return {
            left: round(rect2.left),
            top: round(rect2.top),
            bottom: round(rect2.bottom),
            right: round(rect2.right),
            width: round(rect2.width),
            height: round(rect2.height)
          };
        };
        var collapse = function(rect2, toStart) {
          rect2 = clone$1(rect2);
          if (toStart) {
            rect2.right = rect2.left;
          } else {
            rect2.left = rect2.left + rect2.width;
            rect2.right = rect2.left;
          }
          rect2.width = 0;
          return rect2;
        };
        var isEqual = function(rect1, rect2) {
          return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
        };
        var isValidOverflow = function(overflowY2, rect1, rect2) {
          return overflowY2 >= 0 && overflowY2 <= Math.min(rect1.height, rect2.height) / 2;
        };
        var isAbove = function(rect1, rect2) {
          var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
          if (rect1.bottom - halfHeight < rect2.top) {
            return true;
          }
          if (rect1.top > rect2.bottom) {
            return false;
          }
          return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
        };
        var isBelow = function(rect1, rect2) {
          if (rect1.top > rect2.bottom) {
            return true;
          }
          if (rect1.bottom < rect2.top) {
            return false;
          }
          return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
        };
        var containsXY = function(rect2, clientX, clientY) {
          return clientX >= rect2.left && clientX <= rect2.right && clientY >= rect2.top && clientY <= rect2.bottom;
        };
        var overflowX = function(outer, inner) {
          if (inner.left > outer.left && inner.right < outer.right) {
            return 0;
          } else {
            return inner.left < outer.left ? inner.left - outer.left : inner.right - outer.right;
          }
        };
        var overflowY = function(outer, inner) {
          if (inner.top > outer.top && inner.bottom < outer.bottom) {
            return 0;
          } else {
            return inner.top < outer.top ? inner.top - outer.top : inner.bottom - outer.bottom;
          }
        };
        var getOverflow = function(outer, inner) {
          return {
            x: overflowX(outer, inner),
            y: overflowY(outer, inner)
          };
        };
        var getSelectedNode = function(range3) {
          var startContainer = range3.startContainer, startOffset = range3.startOffset;
          if (startContainer.hasChildNodes() && range3.endOffset === startOffset + 1) {
            return startContainer.childNodes[startOffset];
          }
          return null;
        };
        var getNode = function(container, offset) {
          if (container.nodeType === 1 && container.hasChildNodes()) {
            if (offset >= container.childNodes.length) {
              offset = container.childNodes.length - 1;
            }
            container = container.childNodes[offset];
          }
          return container;
        };
        var extendingChars = new RegExp("[Ì€-Í¯Òƒ-Ò‡Òˆ-Ò‰Ö‘-Ö½Ö¿×-×‚×„-×…×‡Ø-ØšÙ‹-ÙŸÙ°Û–-ÛœÛŸ-Û¤Û§-Û¨Ûª-Û­Ü‘Ü°-İŠŞ¦-Ş°ß«-ß³à –-à ™à ›-à £à ¥-à §à ©-à ­à¡™-à¡›à££-à¤‚à¤ºà¤¼à¥-à¥ˆà¥à¥‘-à¥—à¥¢-à¥£à¦à¦¼à¦¾à§-à§„à§à§—à§¢-à§£à¨-à¨‚à¨¼à©-à©‚à©‡-à©ˆà©‹-à©à©‘à©°-à©±à©µàª-àª‚àª¼à«-à«…à«‡-à«ˆà«à«¢-à«£à¬à¬¼à¬¾à¬¿à­-à­„à­à­–à­—à­¢-à­£à®‚à®¾à¯€à¯à¯—à°€à°¾-à±€à±†-à±ˆà±Š-à±à±•-à±–à±¢-à±£à²à²¼à²¿à³‚à³†à³Œ-à³à³•-à³–à³¢-à³£à´à´¾àµ-àµ„àµàµ—àµ¢-àµ£à·Šà·à·’-à·”à·–à·Ÿà¸±à¸´-à¸ºà¹‡-à¹àº±àº´-àº¹àº»-àº¼à»ˆ-à»à¼˜-à¼™à¼µà¼·à¼¹à½±-à½¾à¾€-à¾„à¾†-à¾‡à¾-à¾—à¾™-à¾¼à¿†á€­-á€°á€²-á€·á€¹-á€ºá€½-á€¾á˜-á™á-á á±-á´á‚‚á‚…-á‚†á‚á‚á-áŸáœ’-áœ”áœ²-áœ´á’-á“á²-á³á´-áµá·-á½áŸ†áŸ‰-áŸ“áŸá ‹-á á¢©á¤ -á¤¢á¤§-á¤¨á¤²á¤¹-á¤»á¨—-á¨˜á¨›á©–á©˜-á©á© á©¢á©¥-á©¬á©³-á©¼á©¿áª°-áª½áª¾á¬€-á¬ƒá¬´á¬¶-á¬ºá¬¼á­‚á­«-á­³á®€-á®á®¢-á®¥á®¨-á®©á®«-á®­á¯¦á¯¨-á¯©á¯­á¯¯-á¯±á°¬-á°³á°¶-á°·á³-á³’á³”-á³ á³¢-á³¨á³­á³´á³¸-á³¹á·€-á·µá·¼-á·¿â€Œ-â€âƒ-âƒœâƒ-âƒ âƒ¡âƒ¢-âƒ¤âƒ¥-âƒ°â³¯-â³±âµ¿â· -â·¿ã€ª-ã€­ã€®-ã€¯ã‚™-ã‚šê™¯ê™°-ê™²ê™´-ê™½êš-êšŸê›°-ê›±ê ‚ê †ê ‹ê ¥-ê ¦ê£„ê£ -ê£±ê¤¦-ê¤­ê¥‡-ê¥‘ê¦€-ê¦‚ê¦³ê¦¶-ê¦¹ê¦¼ê§¥ê¨©-ê¨®ê¨±-ê¨²ê¨µ-ê¨¶ê©ƒê©Œê©¼êª°êª²-êª´êª·-êª¸êª¾-êª¿ê«ê«¬-ê«­ê«¶ê¯¥ê¯¨ê¯­ï¬ï¸€-ï¸ï¸ -ï¸¯ï¾-ï¾Ÿ]");
        var isExtendingChar = function(ch) {
          return typeof ch === "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        };
        var lift2 = function(oa, ob, f) {
          return oa.isSome() && ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
        };
        var lift3 = function(oa, ob, oc, f) {
          return oa.isSome() && ob.isSome() && oc.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Option.none();
        };
        var slice$2 = [].slice;
        var or2 = function() {
          var args = slice$2.call(arguments);
          return function(x) {
            for (var i2 = 0; i2 < args.length; i2++) {
              if (args[i2](x)) {
                return true;
              }
            }
            return false;
          };
        };
        var and2 = function() {
          var args = slice$2.call(arguments);
          return function(x) {
            for (var i2 = 0; i2 < args.length; i2++) {
              if (!args[i2](x)) {
                return false;
              }
            }
            return true;
          };
        };
        var Predicate = {
          and: and2,
          or: or2
        };
        var isElement$3 = NodeType.isElement;
        var isCaretCandidate$1 = isCaretCandidate;
        var isBlock$1 = NodeType.matchStyleValues("display", "block table");
        var isFloated = NodeType.matchStyleValues("float", "left right");
        var isValidElementCaretCandidate = Predicate.and(isElement$3, isCaretCandidate$1, not2(isFloated));
        var isNotPre = not2(NodeType.matchStyleValues("white-space", "pre pre-line pre-wrap"));
        var isText$4 = NodeType.isText;
        var isBr$3 = NodeType.isBr;
        var nodeIndex = DOMUtils$1.nodeIndex;
        var resolveIndex = getNode;
        var createRange = function(doc2) {
          return "createRange" in doc2 ? doc2.createRange() : DOMUtils$1.DOM.createRng();
        };
        var isWhiteSpace = function(chr) {
          return chr && /[\r\n\t ]/.test(chr);
        };
        var isRange = function(rng) {
          return !!rng.setStart && !!rng.setEnd;
        };
        var isHiddenWhiteSpaceRange = function(range3) {
          var container = range3.startContainer;
          var offset = range3.startOffset;
          var text2;
          if (isWhiteSpace(range3.toString()) && isNotPre(container.parentNode) && NodeType.isText(container)) {
            text2 = container.data;
            if (isWhiteSpace(text2[offset - 1]) || isWhiteSpace(text2[offset + 1])) {
              return true;
            }
          }
          return false;
        };
        var getBrClientRect = function(brNode) {
          var doc2 = brNode.ownerDocument;
          var rng = createRange(doc2);
          var nbsp3 = doc2.createTextNode("Â ");
          var parentNode = brNode.parentNode;
          var clientRect;
          parentNode.insertBefore(nbsp3, brNode);
          rng.setStart(nbsp3, 0);
          rng.setEnd(nbsp3, 1);
          clientRect = clone$1(rng.getBoundingClientRect());
          parentNode.removeChild(nbsp3);
          return clientRect;
        };
        var getBoundingClientRectWebKitText = function(rng) {
          var sc2 = rng.startContainer;
          var ec = rng.endContainer;
          var so = rng.startOffset;
          var eo = rng.endOffset;
          if (sc2 === ec && NodeType.isText(ec) && so === 0 && eo === 1) {
            var newRng = rng.cloneRange();
            newRng.setEndAfter(ec);
            return getBoundingClientRect(newRng);
          } else {
            return null;
          }
        };
        var isZeroRect = function(r) {
          return r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
        };
        var getBoundingClientRect = function(item) {
          var clientRect, clientRects;
          clientRects = item.getClientRects();
          if (clientRects.length > 0) {
            clientRect = clone$1(clientRects[0]);
          } else {
            clientRect = clone$1(item.getBoundingClientRect());
          }
          if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
            return getBrClientRect(item);
          }
          if (isZeroRect(clientRect) && isRange(item)) {
            return getBoundingClientRectWebKitText(item);
          }
          return clientRect;
        };
        var collapseAndInflateWidth = function(clientRect, toStart) {
          var newClientRect = collapse(clientRect, toStart);
          newClientRect.width = 1;
          newClientRect.right = newClientRect.left + 1;
          return newClientRect;
        };
        var getCaretPositionClientRects = function(caretPosition) {
          var clientRects = [];
          var beforeNode, node2;
          var addUniqueAndValidRect = function(clientRect) {
            if (clientRect.height === 0) {
              return;
            }
            if (clientRects.length > 0) {
              if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
                return;
              }
            }
            clientRects.push(clientRect);
          };
          var addCharacterOffset = function(container, offset) {
            var range3 = createRange(container.ownerDocument);
            if (offset < container.data.length) {
              if (isExtendingChar(container.data[offset])) {
                return clientRects;
              }
              if (isExtendingChar(container.data[offset - 1])) {
                range3.setStart(container, offset);
                range3.setEnd(container, offset + 1);
                if (!isHiddenWhiteSpaceRange(range3)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range3), false));
                  return clientRects;
                }
              }
            }
            if (offset > 0) {
              range3.setStart(container, offset - 1);
              range3.setEnd(container, offset);
              if (!isHiddenWhiteSpaceRange(range3)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range3), false));
              }
            }
            if (offset < container.data.length) {
              range3.setStart(container, offset);
              range3.setEnd(container, offset + 1);
              if (!isHiddenWhiteSpaceRange(range3)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range3), true));
              }
            }
          };
          if (isText$4(caretPosition.container())) {
            addCharacterOffset(caretPosition.container(), caretPosition.offset());
            return clientRects;
          }
          if (isElement$3(caretPosition.container())) {
            if (caretPosition.isAtEnd()) {
              node2 = resolveIndex(caretPosition.container(), caretPosition.offset());
              if (isText$4(node2)) {
                addCharacterOffset(node2, node2.data.length);
              }
              if (isValidElementCaretCandidate(node2) && !isBr$3(node2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), false));
              }
            } else {
              node2 = resolveIndex(caretPosition.container(), caretPosition.offset());
              if (isText$4(node2)) {
                addCharacterOffset(node2, 0);
              }
              if (isValidElementCaretCandidate(node2) && caretPosition.isAtEnd()) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), false));
                return clientRects;
              }
              beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
              if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
                if (isBlock$1(beforeNode) || isBlock$1(node2) || !isValidElementCaretCandidate(node2)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
                }
              }
              if (isValidElementCaretCandidate(node2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node2), true));
              }
            }
          }
          return clientRects;
        };
        function CaretPosition(container, offset, clientRects) {
          var isAtStart = function() {
            if (isText$4(container)) {
              return offset === 0;
            }
            return offset === 0;
          };
          var isAtEnd = function() {
            if (isText$4(container)) {
              return offset >= container.data.length;
            }
            return offset >= container.childNodes.length;
          };
          var toRange = function() {
            var range3;
            range3 = createRange(container.ownerDocument);
            range3.setStart(container, offset);
            range3.setEnd(container, offset);
            return range3;
          };
          var getClientRects2 = function() {
            if (!clientRects) {
              clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
            }
            return clientRects;
          };
          var isVisible = function() {
            return getClientRects2().length > 0;
          };
          var isEqual2 = function(caretPosition) {
            return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
          };
          var getNode2 = function(before2) {
            return resolveIndex(container, before2 ? offset - 1 : offset);
          };
          return {
            container: constant(container),
            offset: constant(offset),
            toRange,
            getClientRects: getClientRects2,
            isVisible,
            isAtStart,
            isAtEnd,
            isEqual: isEqual2,
            getNode: getNode2
          };
        }
        (function(CaretPosition2) {
          CaretPosition2.fromRangeStart = function(range3) {
            return CaretPosition2(range3.startContainer, range3.startOffset);
          };
          CaretPosition2.fromRangeEnd = function(range3) {
            return CaretPosition2(range3.endContainer, range3.endOffset);
          };
          CaretPosition2.after = function(node2) {
            return CaretPosition2(node2.parentNode, nodeIndex(node2) + 1);
          };
          CaretPosition2.before = function(node2) {
            return CaretPosition2(node2.parentNode, nodeIndex(node2));
          };
          CaretPosition2.isAbove = function(pos1, pos2) {
            return lift2(head(pos2.getClientRects()), last(pos1.getClientRects()), isAbove).getOr(false);
          };
          CaretPosition2.isBelow = function(pos1, pos2) {
            return lift2(last(pos2.getClientRects()), head(pos1.getClientRects()), isBelow).getOr(false);
          };
          CaretPosition2.isAtStart = function(pos) {
            return pos ? pos.isAtStart() : false;
          };
          CaretPosition2.isAtEnd = function(pos) {
            return pos ? pos.isAtEnd() : false;
          };
          CaretPosition2.isTextPosition = function(pos) {
            return pos ? NodeType.isText(pos.container()) : false;
          };
          CaretPosition2.isElementPosition = function(pos) {
            return CaretPosition2.isTextPosition(pos) === false;
          };
        })(CaretPosition || (CaretPosition = {}));
        var CaretPosition$1 = CaretPosition;
        var isText$5 = NodeType.isText;
        var isBogus$1 = NodeType.isBogus;
        var nodeIndex$1 = DOMUtils$1.nodeIndex;
        var normalizedParent = function(node2) {
          var parentNode = node2.parentNode;
          if (isBogus$1(parentNode)) {
            return normalizedParent(parentNode);
          }
          return parentNode;
        };
        var getChildNodes = function(node2) {
          if (!node2) {
            return [];
          }
          return ArrUtils.reduce(node2.childNodes, function(result, node3) {
            if (isBogus$1(node3) && node3.nodeName !== "BR") {
              result = result.concat(getChildNodes(node3));
            } else {
              result.push(node3);
            }
            return result;
          }, []);
        };
        var normalizedTextOffset = function(node2, offset) {
          while (node2 = node2.previousSibling) {
            if (!isText$5(node2)) {
              break;
            }
            offset += node2.data.length;
          }
          return offset;
        };
        var equal = function(a) {
          return function(b) {
            return a === b;
          };
        };
        var normalizedNodeIndex = function(node2) {
          var nodes, index, numTextFragments;
          nodes = getChildNodes(normalizedParent(node2));
          index = ArrUtils.findIndex(nodes, equal(node2), node2);
          nodes = nodes.slice(0, index + 1);
          numTextFragments = ArrUtils.reduce(nodes, function(result, node3, i2) {
            if (isText$5(node3) && isText$5(nodes[i2 - 1])) {
              result++;
            }
            return result;
          }, 0);
          nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(node2.nodeName));
          index = ArrUtils.findIndex(nodes, equal(node2), node2);
          return index - numTextFragments;
        };
        var createPathItem = function(node2) {
          var name2;
          if (isText$5(node2)) {
            name2 = "text()";
          } else {
            name2 = node2.nodeName.toLowerCase();
          }
          return name2 + "[" + normalizedNodeIndex(node2) + "]";
        };
        var parentsUntil = function(root2, node2, predicate) {
          var parents2 = [];
          for (node2 = node2.parentNode; node2 !== root2; node2 = node2.parentNode) {
            parents2.push(node2);
          }
          return parents2;
        };
        var create$2 = function(root2, caretPosition) {
          var container, offset, path2 = [], outputOffset, childNodes, parents2;
          container = caretPosition.container();
          offset = caretPosition.offset();
          if (isText$5(container)) {
            outputOffset = normalizedTextOffset(container, offset);
          } else {
            childNodes = container.childNodes;
            if (offset >= childNodes.length) {
              outputOffset = "after";
              offset = childNodes.length - 1;
            } else {
              outputOffset = "before";
            }
            container = childNodes[offset];
          }
          path2.push(createPathItem(container));
          parents2 = parentsUntil(root2, container);
          parents2 = ArrUtils.filter(parents2, not2(NodeType.isBogus));
          path2 = path2.concat(ArrUtils.map(parents2, function(node2) {
            return createPathItem(node2);
          }));
          return path2.reverse().join("/") + "," + outputOffset;
        };
        var resolvePathItem = function(node2, name2, index) {
          var nodes = getChildNodes(node2);
          nodes = ArrUtils.filter(nodes, function(node3, index2) {
            return !isText$5(node3) || !isText$5(nodes[index2 - 1]);
          });
          nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(name2));
          return nodes[index];
        };
        var findTextPosition = function(container, offset) {
          var node2 = container, targetOffset = 0, dataLen;
          while (isText$5(node2)) {
            dataLen = node2.data.length;
            if (offset >= targetOffset && offset <= targetOffset + dataLen) {
              container = node2;
              offset = offset - targetOffset;
              break;
            }
            if (!isText$5(node2.nextSibling)) {
              container = node2;
              offset = dataLen;
              break;
            }
            targetOffset += dataLen;
            node2 = node2.nextSibling;
          }
          if (isText$5(container) && offset > container.data.length) {
            offset = container.data.length;
          }
          return CaretPosition$1(container, offset);
        };
        var resolve$2 = function(root2, path2) {
          var parts, container, offset;
          if (!path2) {
            return null;
          }
          parts = path2.split(",");
          path2 = parts[0].split("/");
          offset = parts.length > 1 ? parts[1] : "before";
          container = ArrUtils.reduce(path2, function(result, value2) {
            value2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
            if (!value2) {
              return null;
            }
            if (value2[1] === "text()") {
              value2[1] = "#text";
            }
            return resolvePathItem(result, value2[1], parseInt(value2[2], 10));
          }, root2);
          if (!container) {
            return null;
          }
          if (!isText$5(container)) {
            if (offset === "after") {
              offset = nodeIndex$1(container) + 1;
            } else {
              offset = nodeIndex$1(container);
            }
            return CaretPosition$1(container.parentNode, offset);
          }
          return findTextPosition(container, parseInt(offset, 10));
        };
        var trimEmptyTextNode = function(dom2, node2) {
          if (NodeType.isText(node2) && node2.data.length === 0) {
            dom2.remove(node2);
          }
        };
        var insertNode = function(dom2, rng, node2) {
          rng.insertNode(node2);
          trimEmptyTextNode(dom2, node2.previousSibling);
          trimEmptyTextNode(dom2, node2.nextSibling);
        };
        var insertFragment = function(dom2, rng, frag) {
          var firstChild2 = Option.from(frag.firstChild);
          var lastChild2 = Option.from(frag.lastChild);
          rng.insertNode(frag);
          firstChild2.each(function(child2) {
            return trimEmptyTextNode(dom2, child2.previousSibling);
          });
          lastChild2.each(function(child2) {
            return trimEmptyTextNode(dom2, child2.nextSibling);
          });
        };
        var rangeInsertNode = function(dom2, rng, node2) {
          if (NodeType.isDocumentFragment(node2)) {
            insertFragment(dom2, rng, node2);
          } else {
            insertNode(dom2, rng, node2);
          }
        };
        var isContentEditableFalse$2 = NodeType.isContentEditableFalse;
        var getNormalizedTextOffset = function(trim2, container, offset) {
          var node2, trimmedOffset;
          trimmedOffset = trim2(container.data.slice(0, offset)).length;
          for (node2 = container.previousSibling; node2 && NodeType.isText(node2); node2 = node2.previousSibling) {
            trimmedOffset += trim2(node2.data).length;
          }
          return trimmedOffset;
        };
        var getPoint = function(dom2, trim2, normalized, rng, start2) {
          var container = rng[start2 ? "startContainer" : "endContainer"];
          var offset = rng[start2 ? "startOffset" : "endOffset"];
          var point = [];
          var childNodes, after2 = 0;
          var root2 = dom2.getRoot();
          if (NodeType.isText(container)) {
            point.push(normalized ? getNormalizedTextOffset(trim2, container, offset) : offset);
          } else {
            childNodes = container.childNodes;
            if (offset >= childNodes.length && childNodes.length) {
              after2 = 1;
              offset = Math.max(0, childNodes.length - 1);
            }
            point.push(dom2.nodeIndex(childNodes[offset], normalized) + after2);
          }
          for (; container && container !== root2; container = container.parentNode) {
            point.push(dom2.nodeIndex(container, normalized));
          }
          return point;
        };
        var getLocation = function(trim2, selection, normalized, rng) {
          var dom2 = selection.dom, bookmark = {};
          bookmark.start = getPoint(dom2, trim2, normalized, rng, true);
          if (!selection.isCollapsed()) {
            bookmark.end = getPoint(dom2, trim2, normalized, rng, false);
          }
          return bookmark;
        };
        var findIndex$2 = function(dom2, name2, element) {
          var count2 = 0;
          Tools.each(dom2.select(name2), function(node2) {
            if (node2.getAttribute("data-mce-bogus") === "all") {
              return;
            }
            if (node2 === element) {
              return false;
            }
            count2++;
          });
          return count2;
        };
        var moveEndPoint = function(rng, start2) {
          var container, offset, childNodes;
          var prefix = start2 ? "start" : "end";
          container = rng[prefix + "Container"];
          offset = rng[prefix + "Offset"];
          if (NodeType.isElement(container) && container.nodeName === "TR") {
            childNodes = container.childNodes;
            container = childNodes[Math.min(start2 ? offset : offset - 1, childNodes.length - 1)];
            if (container) {
              offset = start2 ? 0 : container.childNodes.length;
              rng["set" + (start2 ? "Start" : "End")](container, offset);
            }
          }
        };
        var normalizeTableCellSelection = function(rng) {
          moveEndPoint(rng, true);
          moveEndPoint(rng, false);
          return rng;
        };
        var findSibling = function(node2, offset) {
          var sibling2;
          if (NodeType.isElement(node2)) {
            node2 = getNode(node2, offset);
            if (isContentEditableFalse$2(node2)) {
              return node2;
            }
          }
          if (isCaretContainer(node2)) {
            if (NodeType.isText(node2) && isCaretContainerBlock(node2)) {
              node2 = node2.parentNode;
            }
            sibling2 = node2.previousSibling;
            if (isContentEditableFalse$2(sibling2)) {
              return sibling2;
            }
            sibling2 = node2.nextSibling;
            if (isContentEditableFalse$2(sibling2)) {
              return sibling2;
            }
          }
        };
        var findAdjacentContentEditableFalseElm = function(rng) {
          return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
        };
        var getOffsetBookmark = function(trim2, normalized, selection) {
          var element = selection.getNode();
          var name2 = element ? element.nodeName : null;
          var rng = selection.getRng();
          if (isContentEditableFalse$2(element) || name2 === "IMG") {
            return {
              name: name2,
              index: findIndex$2(selection.dom, name2, element)
            };
          }
          var sibling2 = findAdjacentContentEditableFalseElm(rng);
          if (sibling2) {
            name2 = sibling2.tagName;
            return {
              name: name2,
              index: findIndex$2(selection.dom, name2, sibling2)
            };
          }
          return getLocation(trim2, selection, normalized, rng);
        };
        var getCaretBookmark = function(selection) {
          var rng = selection.getRng();
          return {
            start: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeStart(rng)),
            end: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeEnd(rng))
          };
        };
        var getRangeBookmark = function(selection) {
          return { rng: selection.getRng() };
        };
        var createBookmarkSpan = function(dom2, id, filled) {
          var args = {
            "data-mce-type": "bookmark",
            "id": id,
            "style": "overflow:hidden;line-height:0px"
          };
          return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
        };
        var getPersistentBookmark = function(selection, filled) {
          var dom2 = selection.dom;
          var rng = selection.getRng();
          var id = dom2.uniqueId();
          var collapsed = selection.isCollapsed();
          var element = selection.getNode();
          var name2 = element.nodeName;
          if (name2 === "IMG") {
            return {
              name: name2,
              index: findIndex$2(dom2, name2, element)
            };
          }
          var rng2 = normalizeTableCellSelection(rng.cloneRange());
          if (!collapsed) {
            rng2.collapse(false);
            var endBookmarkNode = createBookmarkSpan(dom2, id + "_end", filled);
            rangeInsertNode(dom2, rng2, endBookmarkNode);
          }
          rng = normalizeTableCellSelection(rng);
          rng.collapse(true);
          var startBookmarkNode = createBookmarkSpan(dom2, id + "_start", filled);
          rangeInsertNode(dom2, rng, startBookmarkNode);
          selection.moveToBookmark({
            id,
            keep: 1
          });
          return { id };
        };
        var getBookmark = function(selection, type2, normalized) {
          if (type2 === 2) {
            return getOffsetBookmark(Zwsp.trim, normalized, selection);
          } else if (type2 === 3) {
            return getCaretBookmark(selection);
          } else if (type2) {
            return getRangeBookmark(selection);
          } else {
            return getPersistentBookmark(selection, false);
          }
        };
        var GetBookmark = {
          getBookmark,
          getUndoBookmark: curry(getOffsetBookmark, identity, true),
          getPersistentBookmark
        };
        var CARET_ID = "_mce_caret";
        var isCaretNode = function(node2) {
          return NodeType.isElement(node2) && node2.id === CARET_ID;
        };
        var getParentCaretContainer = function(body, node2) {
          while (node2 && node2 !== body) {
            if (node2.id === CARET_ID) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var isElement$4 = NodeType.isElement;
        var isText$6 = NodeType.isText;
        var removeNode = function(node2) {
          var parentNode = node2.parentNode;
          if (parentNode) {
            parentNode.removeChild(node2);
          }
        };
        var getNodeValue = function(node2) {
          try {
            return node2.nodeValue;
          } catch (ex) {
            return "";
          }
        };
        var setNodeValue = function(node2, text2) {
          if (text2.length === 0) {
            removeNode(node2);
          } else {
            node2.nodeValue = text2;
          }
        };
        var trimCount = function(text2) {
          var trimmedText = Zwsp.trim(text2);
          return {
            count: text2.length - trimmedText.length,
            text: trimmedText
          };
        };
        var removeUnchanged = function(caretContainer, pos) {
          remove$5(caretContainer);
          return pos;
        };
        var removeTextAndReposition = function(caretContainer, pos) {
          var before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
          var after2 = trimCount(caretContainer.data.substr(pos.offset()));
          var text2 = before2.text + after2.text;
          if (text2.length > 0) {
            setNodeValue(caretContainer, text2);
            return CaretPosition$1(caretContainer, pos.offset() - before2.count);
          } else {
            return pos;
          }
        };
        var removeElementAndReposition = function(caretContainer, pos) {
          var parentNode = pos.container();
          var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function(index) {
            return index < pos.offset() ? CaretPosition$1(parentNode, pos.offset() - 1) : pos;
          }).getOr(pos);
          remove$5(caretContainer);
          return newPosition;
        };
        var removeTextCaretContainer = function(caretContainer, pos) {
          return isText$6(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        };
        var removeElementCaretContainer = function(caretContainer, pos) {
          return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        };
        var removeAndReposition = function(container, pos) {
          return CaretPosition$1.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
        };
        var remove$5 = function(caretContainerNode) {
          if (isElement$4(caretContainerNode) && isCaretContainer(caretContainerNode)) {
            if (hasContent(caretContainerNode)) {
              caretContainerNode.removeAttribute("data-mce-caret");
            } else {
              removeNode(caretContainerNode);
            }
          }
          if (isText$6(caretContainerNode)) {
            var text2 = Zwsp.trim(getNodeValue(caretContainerNode));
            setNodeValue(caretContainerNode, text2);
          }
        };
        var CaretContainerRemove = {
          removeAndReposition,
          remove: remove$5
        };
        var browser$2 = PlatformDetection$1.detect().browser;
        var isContentEditableFalse$3 = NodeType.isContentEditableFalse;
        var isTableCell$1 = function(node2) {
          return NodeType.isElement(node2) && /^(TD|TH)$/i.test(node2.tagName);
        };
        var getAbsoluteClientRect = function(root2, element, before2) {
          var clientRect = collapse(element.getBoundingClientRect(), before2);
          var docElm, scrollX, scrollY, margin, rootRect;
          if (root2.tagName === "BODY") {
            docElm = root2.ownerDocument.documentElement;
            scrollX = root2.scrollLeft || docElm.scrollLeft;
            scrollY = root2.scrollTop || docElm.scrollTop;
          } else {
            rootRect = root2.getBoundingClientRect();
            scrollX = root2.scrollLeft - rootRect.left;
            scrollY = root2.scrollTop - rootRect.top;
          }
          clientRect.left += scrollX;
          clientRect.right += scrollX;
          clientRect.top += scrollY;
          clientRect.bottom += scrollY;
          clientRect.width = 1;
          margin = element.offsetWidth - element.clientWidth;
          if (margin > 0) {
            if (before2) {
              margin *= -1;
            }
            clientRect.left += margin;
            clientRect.right += margin;
          }
          return clientRect;
        };
        var trimInlineCaretContainers = function(root2) {
          var contentEditableFalseNodes, node2, sibling2, i2, data2;
          contentEditableFalseNodes = DomQuery("*[contentEditable=false]", root2);
          for (i2 = 0; i2 < contentEditableFalseNodes.length; i2++) {
            node2 = contentEditableFalseNodes[i2];
            sibling2 = node2.previousSibling;
            if (endsWithCaretContainer(sibling2)) {
              data2 = sibling2.data;
              if (data2.length === 1) {
                sibling2.parentNode.removeChild(sibling2);
              } else {
                sibling2.deleteData(data2.length - 1, 1);
              }
            }
            sibling2 = node2.nextSibling;
            if (startsWithCaretContainer(sibling2)) {
              data2 = sibling2.data;
              if (data2.length === 1) {
                sibling2.parentNode.removeChild(sibling2);
              } else {
                sibling2.deleteData(0, 1);
              }
            }
          }
        };
        var FakeCaret = function(root2, isBlock3, hasFocus2) {
          var lastVisualCaret = Cell(Option.none());
          var cursorInterval, caretContainerNode;
          var show = function(before2, element) {
            var clientRect, rng;
            hide();
            if (isTableCell$1(element)) {
              return null;
            }
            if (isBlock3(element)) {
              caretContainerNode = insertBlock("p", element, before2);
              clientRect = getAbsoluteClientRect(root2, element, before2);
              DomQuery(caretContainerNode).css("top", clientRect.top);
              var caret2 = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(root2)[0];
              lastVisualCaret.set(Option.some({
                caret: caret2,
                element,
                before: before2
              }));
              lastVisualCaret.get().each(function(caretState) {
                if (before2) {
                  DomQuery(caretState.caret).addClass("mce-visual-caret-before");
                }
              });
              startBlink();
              rng = element.ownerDocument.createRange();
              rng.setStart(caretContainerNode, 0);
              rng.setEnd(caretContainerNode, 0);
            } else {
              caretContainerNode = insertInline(element, before2);
              rng = element.ownerDocument.createRange();
              if (isContentEditableFalse$3(caretContainerNode.nextSibling)) {
                rng.setStart(caretContainerNode, 0);
                rng.setEnd(caretContainerNode, 0);
              } else {
                rng.setStart(caretContainerNode, 1);
                rng.setEnd(caretContainerNode, 1);
              }
              return rng;
            }
            return rng;
          };
          var hide = function() {
            trimInlineCaretContainers(root2);
            if (caretContainerNode) {
              CaretContainerRemove.remove(caretContainerNode);
              caretContainerNode = null;
            }
            lastVisualCaret.get().each(function(caretState) {
              DomQuery(caretState.caret).remove();
              lastVisualCaret.set(Option.none());
            });
            clearInterval(cursorInterval);
          };
          var startBlink = function() {
            cursorInterval = Delay.setInterval(function() {
              if (hasFocus2()) {
                DomQuery("div.mce-visual-caret", root2).toggleClass("mce-visual-caret-hidden");
              } else {
                DomQuery("div.mce-visual-caret", root2).addClass("mce-visual-caret-hidden");
              }
            }, 500);
          };
          var reposition2 = function() {
            lastVisualCaret.get().each(function(caretState) {
              var clientRect = getAbsoluteClientRect(root2, caretState.element, caretState.before);
              DomQuery(caretState.caret).css(clientRect);
            });
          };
          var destroy2 = function() {
            return Delay.clearInterval(cursorInterval);
          };
          var getCss = function() {
            return ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
          };
          return {
            show,
            hide,
            getCss,
            reposition: reposition2,
            destroy: destroy2
          };
        };
        var isFakeCaretTableBrowser = function() {
          return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
        };
        var isFakeCaretTarget = function(node2) {
          return isContentEditableFalse$3(node2) || NodeType.isTable(node2) && isFakeCaretTableBrowser();
        };
        var isContentEditableFalse$4 = NodeType.isContentEditableFalse;
        var isBlockLike = NodeType.matchStyleValues("display", "block table table-cell table-caption list-item");
        var isCaretContainer$2 = isCaretContainer;
        var isCaretContainerBlock$1 = isCaretContainerBlock;
        var isElement$5 = NodeType.isElement;
        var isCaretCandidate$2 = isCaretCandidate;
        var isForwards = function(direction) {
          return direction > 0;
        };
        var isBackwards = function(direction) {
          return direction < 0;
        };
        var skipCaretContainers = function(walk2, shallow2) {
          var node2;
          while (node2 = walk2(shallow2)) {
            if (!isCaretContainerBlock$1(node2)) {
              return node2;
            }
          }
          return null;
        };
        var findNode = function(node2, direction, predicateFn, rootNode, shallow2) {
          var walker = new TreeWalker(node2, rootNode);
          if (isBackwards(direction)) {
            if (isContentEditableFalse$4(node2) || isCaretContainerBlock$1(node2)) {
              node2 = skipCaretContainers(walker.prev, true);
              if (predicateFn(node2)) {
                return node2;
              }
            }
            while (node2 = skipCaretContainers(walker.prev, shallow2)) {
              if (predicateFn(node2)) {
                return node2;
              }
            }
          }
          if (isForwards(direction)) {
            if (isContentEditableFalse$4(node2) || isCaretContainerBlock$1(node2)) {
              node2 = skipCaretContainers(walker.next, true);
              if (predicateFn(node2)) {
                return node2;
              }
            }
            while (node2 = skipCaretContainers(walker.next, shallow2)) {
              if (predicateFn(node2)) {
                return node2;
              }
            }
          }
          return null;
        };
        var getParentBlock = function(node2, rootNode) {
          while (node2 && node2 !== rootNode) {
            if (isBlockLike(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var isInSameBlock = function(caretPosition1, caretPosition2, rootNode) {
          return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
        };
        var getChildNodeAtRelativeOffset = function(relativeOffset, caretPosition) {
          var container, offset;
          if (!caretPosition) {
            return null;
          }
          container = caretPosition.container();
          offset = caretPosition.offset();
          if (!isElement$5(container)) {
            return null;
          }
          return container.childNodes[offset + relativeOffset];
        };
        var beforeAfter = function(before2, node2) {
          var range3 = node2.ownerDocument.createRange();
          if (before2) {
            range3.setStartBefore(node2);
            range3.setEndBefore(node2);
          } else {
            range3.setStartAfter(node2);
            range3.setEndAfter(node2);
          }
          return range3;
        };
        var isNodesInSameBlock = function(root2, node1, node2) {
          return getParentBlock(node1, root2) === getParentBlock(node2, root2);
        };
        var lean = function(left, root2, node2) {
          var sibling2, siblingName;
          if (left) {
            siblingName = "previousSibling";
          } else {
            siblingName = "nextSibling";
          }
          while (node2 && node2 !== root2) {
            sibling2 = node2[siblingName];
            if (isCaretContainer$2(sibling2)) {
              sibling2 = sibling2[siblingName];
            }
            if (isContentEditableFalse$4(sibling2)) {
              if (isNodesInSameBlock(root2, sibling2, node2)) {
                return sibling2;
              }
              break;
            }
            if (isCaretCandidate$2(sibling2)) {
              break;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var before$2 = curry(beforeAfter, true);
        var after$1 = curry(beforeAfter, false);
        var normalizeRange = function(direction, root2, range3) {
          var node2, container, offset, location;
          var leanLeft = curry(lean, true, root2);
          var leanRight2 = curry(lean, false, root2);
          container = range3.startContainer;
          offset = range3.startOffset;
          if (isCaretContainerBlock(container)) {
            if (!isElement$5(container)) {
              container = container.parentNode;
            }
            location = container.getAttribute("data-mce-caret");
            if (location === "before") {
              node2 = container.nextSibling;
              if (isFakeCaretTarget(node2)) {
                return before$2(node2);
              }
            }
            if (location === "after") {
              node2 = container.previousSibling;
              if (isFakeCaretTarget(node2)) {
                return after$1(node2);
              }
            }
          }
          if (!range3.collapsed) {
            return range3;
          }
          if (NodeType.isText(container)) {
            if (isCaretContainer$2(container)) {
              if (direction === 1) {
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
              }
              if (direction === -1) {
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
              }
              return range3;
            }
            if (endsWithCaretContainer(container) && offset >= container.data.length - 1) {
              if (direction === 1) {
                node2 = leanRight2(container);
                if (node2) {
                  return before$2(node2);
                }
              }
              return range3;
            }
            if (startsWithCaretContainer(container) && offset <= 1) {
              if (direction === -1) {
                node2 = leanLeft(container);
                if (node2) {
                  return after$1(node2);
                }
              }
              return range3;
            }
            if (offset === container.data.length) {
              node2 = leanRight2(container);
              if (node2) {
                return before$2(node2);
              }
              return range3;
            }
            if (offset === 0) {
              node2 = leanLeft(container);
              if (node2) {
                return after$1(node2);
              }
              return range3;
            }
          }
          return range3;
        };
        var getRelativeCefElm = function(forward, caretPosition) {
          return Option.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
        };
        var getNormalizedRangeEndPoint = function(direction, root2, range3) {
          var normalizedRange = normalizeRange(direction, root2, range3);
          if (direction === -1) {
            return CaretPosition.fromRangeStart(normalizedRange);
          }
          return CaretPosition.fromRangeEnd(normalizedRange);
        };
        var getElementFromPosition = function(pos) {
          return Option.from(pos.getNode()).map(Element2.fromDom);
        };
        var getElementFromPrevPosition = function(pos) {
          return Option.from(pos.getNode(true)).map(Element2.fromDom);
        };
        var getVisualCaretPosition = function(walkFn, caretPosition) {
          while (caretPosition = walkFn(caretPosition)) {
            if (caretPosition.isVisible()) {
              return caretPosition;
            }
          }
          return caretPosition;
        };
        var isMoveInsideSameBlock = function(from2, to) {
          var inSameBlock = isInSameBlock(from2, to);
          if (!inSameBlock && NodeType.isBr(from2.getNode())) {
            return true;
          }
          return inSameBlock;
        };
        var HDirection;
        (function(HDirection2) {
          HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
          HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
        })(HDirection || (HDirection = {}));
        var isContentEditableFalse$5 = NodeType.isContentEditableFalse;
        var isText$7 = NodeType.isText;
        var isElement$6 = NodeType.isElement;
        var isBr$4 = NodeType.isBr;
        var isCaretCandidate$3 = isCaretCandidate;
        var isAtomic$1 = isAtomic;
        var isEditableCaretCandidate$1 = isEditableCaretCandidate;
        var getParents = function(node2, root2) {
          var parents2 = [];
          while (node2 && node2 !== root2) {
            parents2.push(node2);
            node2 = node2.parentNode;
          }
          return parents2;
        };
        var nodeAtIndex = function(container, offset) {
          if (container.hasChildNodes() && offset < container.childNodes.length) {
            return container.childNodes[offset];
          }
          return null;
        };
        var getCaretCandidatePosition = function(direction, node2) {
          if (isForwards(direction)) {
            if (isCaretCandidate$3(node2.previousSibling) && !isText$7(node2.previousSibling)) {
              return CaretPosition$1.before(node2);
            }
            if (isText$7(node2)) {
              return CaretPosition$1(node2, 0);
            }
          }
          if (isBackwards(direction)) {
            if (isCaretCandidate$3(node2.nextSibling) && !isText$7(node2.nextSibling)) {
              return CaretPosition$1.after(node2);
            }
            if (isText$7(node2)) {
              return CaretPosition$1(node2, node2.data.length);
            }
          }
          if (isBackwards(direction)) {
            if (isBr$4(node2)) {
              return CaretPosition$1.before(node2);
            }
            return CaretPosition$1.after(node2);
          }
          return CaretPosition$1.before(node2);
        };
        var moveForwardFromBr = function(root2, nextNode) {
          var nextSibling2 = nextNode.nextSibling;
          if (nextSibling2 && isCaretCandidate$3(nextSibling2)) {
            if (isText$7(nextSibling2)) {
              return CaretPosition$1(nextSibling2, 0);
            } else {
              return CaretPosition$1.before(nextSibling2);
            }
          } else {
            return findCaretPosition(HDirection.Forwards, CaretPosition$1.after(nextNode), root2);
          }
        };
        var findCaretPosition = function(direction, startPos, root2) {
          var node2, nextNode, innerNode;
          var rootContentEditableFalseElm, caretPosition;
          if (!isElement$6(root2) || !startPos) {
            return null;
          }
          if (startPos.isEqual(CaretPosition$1.after(root2)) && root2.lastChild) {
            caretPosition = CaretPosition$1.after(root2.lastChild);
            if (isBackwards(direction) && isCaretCandidate$3(root2.lastChild) && isElement$6(root2.lastChild)) {
              return isBr$4(root2.lastChild) ? CaretPosition$1.before(root2.lastChild) : caretPosition;
            }
          } else {
            caretPosition = startPos;
          }
          var container = caretPosition.container();
          var offset = caretPosition.offset();
          if (isText$7(container)) {
            if (isBackwards(direction) && offset > 0) {
              return CaretPosition$1(container, --offset);
            }
            if (isForwards(direction) && offset < container.length) {
              return CaretPosition$1(container, ++offset);
            }
            node2 = container;
          } else {
            if (isBackwards(direction) && offset > 0) {
              nextNode = nodeAtIndex(container, offset - 1);
              if (isCaretCandidate$3(nextNode)) {
                if (!isAtomic$1(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
                  if (innerNode) {
                    if (isText$7(innerNode)) {
                      return CaretPosition$1(innerNode, innerNode.data.length);
                    }
                    return CaretPosition$1.after(innerNode);
                  }
                }
                if (isText$7(nextNode)) {
                  return CaretPosition$1(nextNode, nextNode.data.length);
                }
                return CaretPosition$1.before(nextNode);
              }
            }
            if (isForwards(direction) && offset < container.childNodes.length) {
              nextNode = nodeAtIndex(container, offset);
              if (isCaretCandidate$3(nextNode)) {
                if (isBr$4(nextNode)) {
                  return moveForwardFromBr(root2, nextNode);
                }
                if (!isAtomic$1(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
                  if (innerNode) {
                    if (isText$7(innerNode)) {
                      return CaretPosition$1(innerNode, 0);
                    }
                    return CaretPosition$1.before(innerNode);
                  }
                }
                if (isText$7(nextNode)) {
                  return CaretPosition$1(nextNode, 0);
                }
                return CaretPosition$1.after(nextNode);
              }
            }
            node2 = nextNode ? nextNode : caretPosition.getNode();
          }
          if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
            node2 = findNode(node2, direction, constant(true), root2, true);
            if (isEditableCaretCandidate$1(node2, root2)) {
              return getCaretCandidatePosition(direction, node2);
            }
          }
          nextNode = findNode(node2, direction, isEditableCaretCandidate$1, root2);
          rootContentEditableFalseElm = ArrUtils.last(filter(getParents(container, root2), isContentEditableFalse$5));
          if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
            if (isForwards(direction)) {
              caretPosition = CaretPosition$1.after(rootContentEditableFalseElm);
            } else {
              caretPosition = CaretPosition$1.before(rootContentEditableFalseElm);
            }
            return caretPosition;
          }
          if (nextNode) {
            return getCaretCandidatePosition(direction, nextNode);
          }
          return null;
        };
        var CaretWalker = function(root2) {
          return {
            next: function(caretPosition) {
              return findCaretPosition(HDirection.Forwards, caretPosition, root2);
            },
            prev: function(caretPosition) {
              return findCaretPosition(HDirection.Backwards, caretPosition, root2);
            }
          };
        };
        var walkToPositionIn = function(forward, root2, start2) {
          var position = forward ? CaretPosition$1.before(start2) : CaretPosition$1.after(start2);
          return fromPosition(forward, root2, position);
        };
        var afterElement = function(node2) {
          return NodeType.isBr(node2) ? CaretPosition$1.before(node2) : CaretPosition$1.after(node2);
        };
        var isBeforeOrStart = function(position) {
          if (CaretPosition$1.isTextPosition(position)) {
            return position.offset() === 0;
          } else {
            return isCaretCandidate(position.getNode());
          }
        };
        var isAfterOrEnd = function(position) {
          if (CaretPosition$1.isTextPosition(position)) {
            var container = position.container();
            return position.offset() === container.data.length;
          } else {
            return isCaretCandidate(position.getNode(true));
          }
        };
        var isBeforeAfterSameElement = function(from2, to) {
          return !CaretPosition$1.isTextPosition(from2) && !CaretPosition$1.isTextPosition(to) && from2.getNode() === to.getNode(true);
        };
        var isAtBr = function(position) {
          return !CaretPosition$1.isTextPosition(position) && NodeType.isBr(position.getNode());
        };
        var shouldSkipPosition = function(forward, from2, to) {
          if (forward) {
            return !isBeforeAfterSameElement(from2, to) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to);
          } else {
            return !isBeforeAfterSameElement(to, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to);
          }
        };
        var fromPosition = function(forward, root2, pos) {
          var walker = CaretWalker(root2);
          return Option.from(forward ? walker.next(pos) : walker.prev(pos));
        };
        var navigate = function(forward, root2, from2) {
          return fromPosition(forward, root2, from2).bind(function(to) {
            if (isInSameBlock(from2, to, root2) && shouldSkipPosition(forward, from2, to)) {
              return fromPosition(forward, root2, to);
            } else {
              return Option.some(to);
            }
          });
        };
        var navigateIgnore = function(forward, root2, from2, ignoreFilter) {
          return navigate(forward, root2, from2).bind(function(pos) {
            return ignoreFilter(pos) ? navigateIgnore(forward, root2, pos, ignoreFilter) : Option.some(pos);
          });
        };
        var positionIn = function(forward, element) {
          var startNode = forward ? element.firstChild : element.lastChild;
          if (NodeType.isText(startNode)) {
            return Option.some(CaretPosition$1(startNode, forward ? 0 : startNode.data.length));
          } else if (startNode) {
            if (isCaretCandidate(startNode)) {
              return Option.some(forward ? CaretPosition$1.before(startNode) : afterElement(startNode));
            } else {
              return walkToPositionIn(forward, element, startNode);
            }
          } else {
            return Option.none();
          }
        };
        var nextPosition = curry(fromPosition, true);
        var prevPosition = curry(fromPosition, false);
        var CaretFinder = {
          fromPosition,
          nextPosition,
          prevPosition,
          navigate,
          navigateIgnore,
          positionIn,
          firstPositionIn: curry(positionIn, true),
          lastPositionIn: curry(positionIn, false)
        };
        var isStringPathBookmark = function(bookmark) {
          return typeof bookmark.start === "string";
        };
        var isRangeBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("rng");
        };
        var isIdBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("id");
        };
        var isIndexBookmark = function(bookmark) {
          return bookmark.hasOwnProperty("name");
        };
        var isPathBookmark = function(bookmark) {
          return Tools.isArray(bookmark.start);
        };
        var addBogus = function(dom2, node2) {
          if (NodeType.isElement(node2) && dom2.isBlock(node2) && !node2.innerHTML && !Env.ie) {
            node2.innerHTML = '<br data-mce-bogus="1" />';
          }
          return node2;
        };
        var resolveCaretPositionBookmark = function(dom2, bookmark) {
          var rng, pos;
          rng = dom2.createRng();
          pos = resolve$2(dom2.getRoot(), bookmark.start);
          rng.setStart(pos.container(), pos.offset());
          pos = resolve$2(dom2.getRoot(), bookmark.end);
          rng.setEnd(pos.container(), pos.offset());
          return rng;
        };
        var insertZwsp = function(node2, rng) {
          var textNode = node2.ownerDocument.createTextNode(Zwsp.ZWSP);
          node2.appendChild(textNode);
          rng.setStart(textNode, 0);
          rng.setEnd(textNode, 0);
        };
        var isEmpty = function(node2) {
          return node2.hasChildNodes() === false;
        };
        var tryFindRangePosition = function(node2, rng) {
          return CaretFinder.lastPositionIn(node2).fold(function() {
            return false;
          }, function(pos) {
            rng.setStart(pos.container(), pos.offset());
            rng.setEnd(pos.container(), pos.offset());
            return true;
          });
        };
        var padEmptyCaretContainer = function(root2, node2, rng) {
          if (isEmpty(node2) && getParentCaretContainer(root2, node2)) {
            insertZwsp(node2, rng);
            return true;
          } else {
            return false;
          }
        };
        var setEndPoint = function(dom2, start2, bookmark, rng) {
          var point = bookmark[start2 ? "start" : "end"];
          var i2, node2, offset, children2;
          var root2 = dom2.getRoot();
          if (point) {
            offset = point[0];
            for (node2 = root2, i2 = point.length - 1; i2 >= 1; i2--) {
              children2 = node2.childNodes;
              if (padEmptyCaretContainer(root2, node2, rng)) {
                return true;
              }
              if (point[i2] > children2.length - 1) {
                if (padEmptyCaretContainer(root2, node2, rng)) {
                  return true;
                }
                return tryFindRangePosition(node2, rng);
              }
              node2 = children2[point[i2]];
            }
            if (node2.nodeType === 3) {
              offset = Math.min(point[0], node2.nodeValue.length);
            }
            if (node2.nodeType === 1) {
              offset = Math.min(point[0], node2.childNodes.length);
            }
            if (start2) {
              rng.setStart(node2, offset);
            } else {
              rng.setEnd(node2, offset);
            }
          }
          return true;
        };
        var isValidTextNode = function(node2) {
          return NodeType.isText(node2) && node2.data.length > 0;
        };
        var restoreEndPoint = function(dom2, suffix, bookmark) {
          var marker2 = dom2.get(bookmark.id + "_" + suffix), node2, idx, next2, prev;
          var keep = bookmark.keep;
          var container, offset;
          if (marker2) {
            node2 = marker2.parentNode;
            if (suffix === "start") {
              if (!keep) {
                idx = dom2.nodeIndex(marker2);
              } else {
                if (marker2.hasChildNodes()) {
                  node2 = marker2.firstChild;
                  idx = 1;
                } else if (isValidTextNode(marker2.nextSibling)) {
                  node2 = marker2.nextSibling;
                  idx = 0;
                } else if (isValidTextNode(marker2.previousSibling)) {
                  node2 = marker2.previousSibling;
                  idx = marker2.previousSibling.data.length;
                } else {
                  node2 = marker2.parentNode;
                  idx = dom2.nodeIndex(marker2) + 1;
                }
              }
              container = node2;
              offset = idx;
            } else {
              if (!keep) {
                idx = dom2.nodeIndex(marker2);
              } else {
                if (marker2.hasChildNodes()) {
                  node2 = marker2.firstChild;
                  idx = 1;
                } else if (isValidTextNode(marker2.previousSibling)) {
                  node2 = marker2.previousSibling;
                  idx = marker2.previousSibling.data.length;
                } else {
                  node2 = marker2.parentNode;
                  idx = dom2.nodeIndex(marker2);
                }
              }
              container = node2;
              offset = idx;
            }
            if (!keep) {
              prev = marker2.previousSibling;
              next2 = marker2.nextSibling;
              Tools.each(Tools.grep(marker2.childNodes), function(node3) {
                if (NodeType.isText(node3)) {
                  node3.nodeValue = node3.nodeValue.replace(/\uFEFF/g, "");
                }
              });
              while (marker2 = dom2.get(bookmark.id + "_" + suffix)) {
                dom2.remove(marker2, true);
              }
              if (prev && next2 && prev.nodeType === next2.nodeType && NodeType.isText(prev) && !Env.opera) {
                idx = prev.nodeValue.length;
                prev.appendData(next2.nodeValue);
                dom2.remove(next2);
                if (suffix === "start") {
                  container = prev;
                  offset = idx;
                } else {
                  container = prev;
                  offset = idx;
                }
              }
            }
            return Option.some(CaretPosition$1(container, offset));
          } else {
            return Option.none();
          }
        };
        var alt = function(o1, o2) {
          return o1.isSome() ? o1 : o2;
        };
        var resolvePaths = function(dom2, bookmark) {
          var rng = dom2.createRng();
          if (setEndPoint(dom2, true, bookmark, rng) && setEndPoint(dom2, false, bookmark, rng)) {
            return Option.some(rng);
          } else {
            return Option.none();
          }
        };
        var resolveId = function(dom2, bookmark) {
          var startPos = restoreEndPoint(dom2, "start", bookmark);
          var endPos = restoreEndPoint(dom2, "end", bookmark);
          return lift2(startPos, alt(endPos, startPos), function(spos, epos) {
            var rng = dom2.createRng();
            rng.setStart(addBogus(dom2, spos.container()), spos.offset());
            rng.setEnd(addBogus(dom2, epos.container()), epos.offset());
            return rng;
          });
        };
        var resolveIndex$1 = function(dom2, bookmark) {
          return Option.from(dom2.select(bookmark.name)[bookmark.index]).map(function(elm) {
            var rng = dom2.createRng();
            rng.selectNode(elm);
            return rng;
          });
        };
        var resolve$3 = function(selection, bookmark) {
          var dom2 = selection.dom;
          if (bookmark) {
            if (isPathBookmark(bookmark)) {
              return resolvePaths(dom2, bookmark);
            } else if (isStringPathBookmark(bookmark)) {
              return Option.some(resolveCaretPositionBookmark(dom2, bookmark));
            } else if (isIdBookmark(bookmark)) {
              return resolveId(dom2, bookmark);
            } else if (isIndexBookmark(bookmark)) {
              return resolveIndex$1(dom2, bookmark);
            } else if (isRangeBookmark(bookmark)) {
              return Option.some(bookmark.rng);
            }
          }
          return Option.none();
        };
        var ResolveBookmark = { resolve: resolve$3 };
        var getBookmark$1 = function(selection, type2, normalized) {
          return GetBookmark.getBookmark(selection, type2, normalized);
        };
        var moveToBookmark = function(selection, bookmark) {
          ResolveBookmark.resolve(selection, bookmark).each(function(rng) {
            selection.setRng(rng);
          });
        };
        var isBookmarkNode$1 = function(node2) {
          return NodeType.isElement(node2) && node2.tagName === "SPAN" && node2.getAttribute("data-mce-type") === "bookmark";
        };
        var Bookmarks = {
          getBookmark: getBookmark$1,
          moveToBookmark,
          isBookmarkNode: isBookmarkNode$1
        };
        var isInlineBlock = function(node2) {
          return node2 && /^(IMG)$/.test(node2.nodeName);
        };
        var moveStart = function(dom2, selection, rng) {
          var offset = rng.startOffset;
          var container = rng.startContainer, walker, node2, nodes;
          if (rng.startContainer === rng.endContainer) {
            if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
              return;
            }
          }
          if (container.nodeType === 1) {
            nodes = container.childNodes;
            if (offset < nodes.length) {
              container = nodes[offset];
              walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock));
            } else {
              container = nodes[nodes.length - 1];
              walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock));
              walker.next(true);
            }
            for (node2 = walker.current(); node2; node2 = walker.next()) {
              if (node2.nodeType === 3 && !isWhiteSpaceNode(node2)) {
                rng.setStart(node2, 0);
                selection.setRng(rng);
                return;
              }
            }
          }
        };
        var getNonWhiteSpaceSibling = function(node2, next2, inc) {
          if (node2) {
            next2 = next2 ? "nextSibling" : "previousSibling";
            for (node2 = inc ? node2 : node2[next2]; node2; node2 = node2[next2]) {
              if (node2.nodeType === 1 || !isWhiteSpaceNode(node2)) {
                return node2;
              }
            }
          }
        };
        var isTextBlock$1 = function(editor, name2) {
          if (name2.nodeType) {
            name2 = name2.nodeName;
          }
          return !!editor.schema.getTextBlockElements()[name2.toLowerCase()];
        };
        var isValid = function(ed, parent2, child2) {
          return ed.schema.isValidChild(parent2, child2);
        };
        var isWhiteSpaceNode = function(node2) {
          return node2 && node2.nodeType === 3 && /^([\t \r\n]+|)$/.test(node2.nodeValue);
        };
        var replaceVars = function(value2, vars) {
          if (typeof value2 !== "string") {
            value2 = value2(vars);
          } else if (vars) {
            value2 = value2.replace(/%(\w+)/g, function(str, name2) {
              return vars[name2] || str;
            });
          }
          return value2;
        };
        var isEq = function(str1, str2) {
          str1 = str1 || "";
          str2 = str2 || "";
          str1 = "" + (str1.nodeName || str1);
          str2 = "" + (str2.nodeName || str2);
          return str1.toLowerCase() === str2.toLowerCase();
        };
        var normalizeStyleValue = function(dom2, value2, name2) {
          if (name2 === "color" || name2 === "backgroundColor") {
            value2 = dom2.toHex(value2);
          }
          if (name2 === "fontWeight" && value2 === 700) {
            value2 = "bold";
          }
          if (name2 === "fontFamily") {
            value2 = value2.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
          }
          return "" + value2;
        };
        var getStyle = function(dom2, node2, name2) {
          return normalizeStyleValue(dom2, dom2.getStyle(node2, name2), name2);
        };
        var getTextDecoration = function(dom2, node2) {
          var decoration;
          dom2.getParent(node2, function(n) {
            decoration = dom2.getStyle(n, "text-decoration");
            return decoration && decoration !== "none";
          });
          return decoration;
        };
        var getParents$1 = function(dom2, node2, selector) {
          return dom2.getParents(node2, selector, dom2.getRoot());
        };
        var FormatUtils = {
          isInlineBlock,
          moveStart,
          getNonWhiteSpaceSibling,
          isTextBlock: isTextBlock$1,
          isValid,
          isWhiteSpaceNode,
          replaceVars,
          isEq,
          normalizeStyleValue,
          getStyle,
          getTextDecoration,
          getParents: getParents$1
        };
        var isBookmarkNode$2 = Bookmarks.isBookmarkNode;
        var getParents$2 = FormatUtils.getParents, isWhiteSpaceNode$1 = FormatUtils.isWhiteSpaceNode, isTextBlock$2 = FormatUtils.isTextBlock;
        var findLeaf = function(node2, offset) {
          if (typeof offset === "undefined") {
            offset = node2.nodeType === 3 ? node2.length : node2.childNodes.length;
          }
          while (node2 && node2.hasChildNodes()) {
            node2 = node2.childNodes[offset];
            if (node2) {
              offset = node2.nodeType === 3 ? node2.length : node2.childNodes.length;
            }
          }
          return {
            node: node2,
            offset
          };
        };
        var excludeTrailingWhitespace = function(endContainer, endOffset) {
          var leaf = findLeaf(endContainer, endOffset);
          if (leaf.node) {
            while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {
              leaf = findLeaf(leaf.node.previousSibling);
            }
            if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 && leaf.node.nodeValue.charAt(leaf.offset - 1) === " ") {
              if (leaf.offset > 1) {
                endContainer = leaf.node;
                endContainer.splitText(leaf.offset - 1);
              }
            }
          }
          return endContainer;
        };
        var isBogusBr = function(node2) {
          return node2.nodeName === "BR" && node2.getAttribute("data-mce-bogus") && !node2.nextSibling;
        };
        var findParentContentEditable = function(dom2, node2) {
          var parent2 = node2;
          while (parent2) {
            if (parent2.nodeType === 1 && dom2.getContentEditable(parent2)) {
              return dom2.getContentEditable(parent2) === "false" ? parent2 : node2;
            }
            parent2 = parent2.parentNode;
          }
          return node2;
        };
        var findSpace = function(start2, remove3, node2, offset) {
          var pos, pos2;
          var str = node2.nodeValue;
          if (typeof offset === "undefined") {
            offset = start2 ? str.length : 0;
          }
          if (start2) {
            pos = str.lastIndexOf(" ", offset);
            pos2 = str.lastIndexOf("Â ", offset);
            pos = pos > pos2 ? pos : pos2;
            if (pos !== -1 && !remove3 && (pos < offset || !start2) && pos <= str.length) {
              pos++;
            }
          } else {
            pos = str.indexOf(" ", offset);
            pos2 = str.indexOf("Â ", offset);
            pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
          }
          return pos;
        };
        var findWordEndPoint = function(dom2, body, container, offset, start2, remove3) {
          var walker, node2, pos, lastTextNode;
          if (container.nodeType === 3) {
            pos = findSpace(start2, remove3, container, offset);
            if (pos !== -1) {
              return {
                container,
                offset: pos
              };
            }
            lastTextNode = container;
          }
          walker = new TreeWalker(container, dom2.getParent(container, dom2.isBlock) || body);
          while (node2 = walker[start2 ? "prev" : "next"]()) {
            if (node2.nodeType === 3 && !isBookmarkNode$2(node2.parentNode)) {
              lastTextNode = node2;
              pos = findSpace(start2, remove3, node2);
              if (pos !== -1) {
                return {
                  container: node2,
                  offset: pos
                };
              }
            } else if (dom2.isBlock(node2) || FormatUtils.isEq(node2, "BR")) {
              break;
            }
          }
          if (lastTextNode) {
            if (start2) {
              offset = 0;
            } else {
              offset = lastTextNode.length;
            }
            return {
              container: lastTextNode,
              offset
            };
          }
        };
        var findSelectorEndPoint = function(dom2, format2, rng, container, siblingName) {
          var parents2, i2, y, curFormat;
          if (container.nodeType === 3 && container.nodeValue.length === 0 && container[siblingName]) {
            container = container[siblingName];
          }
          parents2 = getParents$2(dom2, container);
          for (i2 = 0; i2 < parents2.length; i2++) {
            for (y = 0; y < format2.length; y++) {
              curFormat = format2[y];
              if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
                continue;
              }
              if (dom2.is(parents2[i2], curFormat.selector)) {
                return parents2[i2];
              }
            }
          }
          return container;
        };
        var findBlockEndPoint = function(editor, format2, container, siblingName) {
          var node2;
          var dom2 = editor.dom;
          var root2 = dom2.getRoot();
          if (!format2[0].wrapper) {
            node2 = dom2.getParent(container, format2[0].block, root2);
          }
          if (!node2) {
            var scopeRoot = dom2.getParent(container, "LI,TD,TH");
            node2 = dom2.getParent(container.nodeType === 3 ? container.parentNode : container, function(node3) {
              return node3 !== root2 && isTextBlock$2(editor, node3);
            }, scopeRoot);
          }
          if (node2 && format2[0].wrapper) {
            node2 = getParents$2(dom2, node2, "ul,ol").reverse()[0] || node2;
          }
          if (!node2) {
            node2 = container;
            while (node2[siblingName] && !dom2.isBlock(node2[siblingName])) {
              node2 = node2[siblingName];
              if (FormatUtils.isEq(node2, "br")) {
                break;
              }
            }
          }
          return node2 || container;
        };
        var findParentContainer = function(dom2, format2, startContainer, startOffset, endContainer, endOffset, start2) {
          var container, parent2, sibling2, siblingName, root2;
          container = parent2 = start2 ? startContainer : endContainer;
          siblingName = start2 ? "previousSibling" : "nextSibling";
          root2 = dom2.getRoot();
          if (container.nodeType === 3 && !isWhiteSpaceNode$1(container)) {
            if (start2 ? startOffset > 0 : endOffset < container.nodeValue.length) {
              return container;
            }
          }
          while (true) {
            if (!format2[0].block_expand && dom2.isBlock(parent2)) {
              return parent2;
            }
            for (sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
              if (!isBookmarkNode$2(sibling2) && !isWhiteSpaceNode$1(sibling2) && !isBogusBr(sibling2)) {
                return parent2;
              }
            }
            if (parent2 === root2 || parent2.parentNode === root2) {
              container = parent2;
              break;
            }
            parent2 = parent2.parentNode;
          }
          return container;
        };
        var expandRng = function(editor, rng, format2, remove3) {
          var endPoint, startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
          var dom2 = editor.dom;
          if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
            startContainer = getNode(startContainer, startOffset);
            if (startContainer.nodeType === 3) {
              startOffset = 0;
            }
          }
          if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
            endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
            if (endContainer.nodeType === 3) {
              endOffset = endContainer.nodeValue.length;
            }
          }
          startContainer = findParentContentEditable(dom2, startContainer);
          endContainer = findParentContentEditable(dom2, endContainer);
          if (isBookmarkNode$2(startContainer.parentNode) || isBookmarkNode$2(startContainer)) {
            startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
            if (rng.collapsed) {
              startContainer = startContainer.previousSibling || startContainer;
            } else {
              startContainer = startContainer.nextSibling || startContainer;
            }
            if (startContainer.nodeType === 3) {
              startOffset = rng.collapsed ? startContainer.length : 0;
            }
          }
          if (isBookmarkNode$2(endContainer.parentNode) || isBookmarkNode$2(endContainer)) {
            endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
            if (rng.collapsed) {
              endContainer = endContainer.nextSibling || endContainer;
            } else {
              endContainer = endContainer.previousSibling || endContainer;
            }
            if (endContainer.nodeType === 3) {
              endOffset = rng.collapsed ? 0 : endContainer.length;
            }
          }
          if (rng.collapsed) {
            endPoint = findWordEndPoint(dom2, editor.getBody(), startContainer, startOffset, true, remove3);
            if (endPoint) {
              startContainer = endPoint.container;
              startOffset = endPoint.offset;
            }
            endPoint = findWordEndPoint(dom2, editor.getBody(), endContainer, endOffset, false, remove3);
            if (endPoint) {
              endContainer = endPoint.container;
              endOffset = endPoint.offset;
            }
          }
          if (format2[0].inline) {
            endContainer = remove3 ? endContainer : excludeTrailingWhitespace(endContainer, endOffset);
          }
          if (format2[0].inline || format2[0].block_expand) {
            if (!format2[0].inline || (startContainer.nodeType !== 3 || startOffset === 0)) {
              startContainer = findParentContainer(dom2, format2, startContainer, startOffset, endContainer, endOffset, true);
            }
            if (!format2[0].inline || (endContainer.nodeType !== 3 || endOffset === endContainer.nodeValue.length)) {
              endContainer = findParentContainer(dom2, format2, startContainer, startOffset, endContainer, endOffset, false);
            }
          }
          if (format2[0].selector && format2[0].expand !== false && !format2[0].inline) {
            startContainer = findSelectorEndPoint(dom2, format2, rng, startContainer, "previousSibling");
            endContainer = findSelectorEndPoint(dom2, format2, rng, endContainer, "nextSibling");
          }
          if (format2[0].block || format2[0].selector) {
            startContainer = findBlockEndPoint(editor, format2, startContainer, "previousSibling");
            endContainer = findBlockEndPoint(editor, format2, endContainer, "nextSibling");
            if (format2[0].block) {
              if (!dom2.isBlock(startContainer)) {
                startContainer = findParentContainer(dom2, format2, startContainer, startOffset, endContainer, endOffset, true);
              }
              if (!dom2.isBlock(endContainer)) {
                endContainer = findParentContainer(dom2, format2, startContainer, startOffset, endContainer, endOffset, false);
              }
            }
          }
          if (startContainer.nodeType === 1) {
            startOffset = dom2.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
          }
          if (endContainer.nodeType === 1) {
            endOffset = dom2.nodeIndex(endContainer) + 1;
            endContainer = endContainer.parentNode;
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        var ExpandRange = { expandRng };
        var each$8 = Tools.each;
        var getEndChild = function(container, index) {
          var childNodes = container.childNodes;
          index--;
          if (index > childNodes.length - 1) {
            index = childNodes.length - 1;
          } else if (index < 0) {
            index = 0;
          }
          return childNodes[index] || container;
        };
        var walk$1 = function(dom2, rng, callback) {
          var startContainer = rng.startContainer;
          var startOffset = rng.startOffset;
          var endContainer = rng.endContainer;
          var endOffset = rng.endOffset;
          var ancestor2;
          var startPoint;
          var endPoint;
          var node2;
          var parent2;
          var siblings;
          var nodes;
          nodes = dom2.select("td[data-mce-selected],th[data-mce-selected]");
          if (nodes.length > 0) {
            each$8(nodes, function(node3) {
              callback([node3]);
            });
            return;
          }
          var exclude = function(nodes2) {
            var node3;
            node3 = nodes2[0];
            if (node3.nodeType === 3 && node3 === startContainer && startOffset >= node3.nodeValue.length) {
              nodes2.splice(0, 1);
            }
            node3 = nodes2[nodes2.length - 1];
            if (endOffset === 0 && nodes2.length > 0 && node3 === endContainer && node3.nodeType === 3) {
              nodes2.splice(nodes2.length - 1, 1);
            }
            return nodes2;
          };
          var collectSiblings = function(node3, name2, endNode) {
            var siblings2 = [];
            for (; node3 && node3 !== endNode; node3 = node3[name2]) {
              siblings2.push(node3);
            }
            return siblings2;
          };
          var findEndPoint = function(node3, root2) {
            do {
              if (node3.parentNode === root2) {
                return node3;
              }
              node3 = node3.parentNode;
            } while (node3);
          };
          var walkBoundary = function(startNode, endNode, next2) {
            var siblingName = next2 ? "nextSibling" : "previousSibling";
            for (node2 = startNode, parent2 = node2.parentNode; node2 && node2 !== endNode; node2 = parent2) {
              parent2 = node2.parentNode;
              siblings = collectSiblings(node2 === startNode ? node2 : node2[siblingName], siblingName);
              if (siblings.length) {
                if (!next2) {
                  siblings.reverse();
                }
                callback(exclude(siblings));
              }
            }
          };
          if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
            startContainer = startContainer.childNodes[startOffset];
          }
          if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
            endContainer = getEndChild(endContainer, endOffset);
          }
          if (startContainer === endContainer) {
            return callback(exclude([startContainer]));
          }
          ancestor2 = dom2.findCommonAncestor(startContainer, endContainer);
          for (node2 = startContainer; node2; node2 = node2.parentNode) {
            if (node2 === endContainer) {
              return walkBoundary(startContainer, ancestor2, true);
            }
            if (node2 === ancestor2) {
              break;
            }
          }
          for (node2 = endContainer; node2; node2 = node2.parentNode) {
            if (node2 === startContainer) {
              return walkBoundary(endContainer, ancestor2);
            }
            if (node2 === ancestor2) {
              break;
            }
          }
          startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
          endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
          walkBoundary(startContainer, startPoint, true);
          siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
          if (siblings.length) {
            callback(exclude(siblings));
          }
          walkBoundary(endContainer, endPoint);
        };
        var RangeWalk = { walk: walk$1 };
        var zeroWidth = function() {
          return "\uFEFF";
        };
        function NodeValue(is3, name2) {
          var get2 = function(element) {
            if (!is3(element)) {
              throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
            }
            return getOption(element).getOr("");
          };
          var getOption = function(element) {
            return is3(element) ? Option.from(element.dom().nodeValue) : Option.none();
          };
          var set2 = function(element, value2) {
            if (!is3(element)) {
              throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
            }
            element.dom().nodeValue = value2;
          };
          return {
            get: get2,
            getOption,
            set: set2
          };
        }
        var api = NodeValue(isText, "text");
        var get$4 = function(element) {
          return api.get(element);
        };
        var isZeroWidth = function(elem) {
          return isText(elem) && get$4(elem) === zeroWidth();
        };
        var context = function(editor, elem, wrapName, nodeName) {
          return parent(elem).fold(function() {
            return "skipping";
          }, function(parent2) {
            if (nodeName === "br" || isZeroWidth(elem)) {
              return "valid";
            } else if (isAnnotation(elem)) {
              return "existing";
            } else if (isCaretNode(elem)) {
              return "caret";
            } else if (!FormatUtils.isValid(editor, wrapName, nodeName) || !FormatUtils.isValid(editor, name(parent2), wrapName)) {
              return "invalid-child";
            } else {
              return "valid";
            }
          });
        };
        var shouldApplyToTrailingSpaces = function(rng) {
          return rng.startContainer.nodeType === 3 && rng.startContainer.nodeValue.length >= rng.startOffset && rng.startContainer.nodeValue[rng.startOffset] === "Â ";
        };
        var applyWordGrab = function(editor, rng) {
          var r = ExpandRange.expandRng(editor, rng, [{ inline: true }], shouldApplyToTrailingSpaces(rng));
          rng.setStart(r.startContainer, r.startOffset);
          rng.setEnd(r.endContainer, r.endOffset);
          editor.selection.setRng(rng);
        };
        var makeAnnotation = function(eDoc, _a, annotationName, decorate) {
          var _b = _a.uid, uid = _b === void 0 ? generate("mce-annotation") : _b, data2 = __rest(_a, ["uid"]);
          var master = Element2.fromTag("span", eDoc);
          add$2(master, annotation());
          set(master, "" + dataAnnotationId(), uid);
          set(master, "" + dataAnnotation(), annotationName);
          var _c = decorate(uid, data2), _d = _c.attributes, attributes2 = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
          setAll(master, attributes2);
          add$3(master, classes);
          return master;
        };
        var annotate = function(editor, rng, annotationName, decorate, data2) {
          var newWrappers = [];
          var master = makeAnnotation(editor.getDoc(), data2, annotationName, decorate);
          var wrapper = Cell(Option.none());
          var finishWrapper = function() {
            wrapper.set(Option.none());
          };
          var getOrOpenWrapper = function() {
            return wrapper.get().getOrThunk(function() {
              var nu3 = shallow(master);
              newWrappers.push(nu3);
              wrapper.set(Option.some(nu3));
              return nu3;
            });
          };
          var processElements = function(elems) {
            each(elems, processElement);
          };
          var processElement = function(elem) {
            var ctx = context(editor, elem, "span", name(elem));
            switch (ctx) {
              case "invalid-child": {
                finishWrapper();
                var children$1 = children(elem);
                processElements(children$1);
                finishWrapper();
                break;
              }
              case "valid": {
                var w = getOrOpenWrapper();
                wrap$1(elem, w);
                break;
              }
            }
          };
          var processNodes = function(nodes) {
            var elems = map2(nodes, Element2.fromDom);
            processElements(elems);
          };
          RangeWalk.walk(editor.dom, rng, function(nodes) {
            finishWrapper();
            processNodes(nodes);
          });
          return newWrappers;
        };
        var annotateWithBookmark = function(editor, name2, settings, data2) {
          editor.undoManager.transact(function() {
            var initialRng = editor.selection.getRng();
            if (initialRng.collapsed) {
              applyWordGrab(editor, initialRng);
            }
            if (editor.selection.getRng().collapsed) {
              var wrapper = makeAnnotation(editor.getDoc(), data2, name2, settings.decorate);
              set$1(wrapper, "Â ");
              editor.selection.getRng().insertNode(wrapper.dom());
              editor.selection.select(wrapper.dom());
            } else {
              var bookmark = GetBookmark.getPersistentBookmark(editor.selection, false);
              var rng = editor.selection.getRng();
              annotate(editor, rng, name2, settings.decorate, data2);
              editor.selection.moveToBookmark(bookmark);
            }
          });
        };
        function Annotator(editor) {
          var registry = create$1();
          setup$1(editor, registry);
          var changes = setup(editor);
          return {
            register: function(name2, settings) {
              registry.register(name2, settings);
            },
            annotate: function(name2, data2) {
              registry.lookup(name2).each(function(settings) {
                annotateWithBookmark(editor, name2, settings, data2);
              });
            },
            annotationChanged: function(name2, callback) {
              changes.addListener(name2, callback);
            },
            remove: function(name2) {
              identify(editor, Option.some(name2)).each(function(_a) {
                var elements = _a.elements;
                each(elements, unwrap);
              });
            },
            getAll: function(name2) {
              var directory = findAll(editor, name2);
              return map$2(directory, function(elems) {
                return map2(elems, function(elem) {
                  return elem.dom();
                });
              });
            }
          };
        }
        var hasOnlyOneChild = function(node2) {
          return node2.firstChild && node2.firstChild === node2.lastChild;
        };
        var isPaddingNode = function(node2) {
          return node2.name === "br" || node2.value === "Â ";
        };
        var isPaddedEmptyBlock = function(schema, node2) {
          var blockElements2 = schema.getBlockElements();
          return blockElements2[node2.name] && hasOnlyOneChild(node2) && isPaddingNode(node2.firstChild);
        };
        var isEmptyFragmentElement = function(schema, node2) {
          var nonEmptyElements = schema.getNonEmptyElements();
          return node2 && (node2.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node2));
        };
        var isListFragment = function(schema, fragment) {
          var firstChild2 = fragment.firstChild;
          var lastChild2 = fragment.lastChild;
          if (firstChild2 && firstChild2.name === "meta") {
            firstChild2 = firstChild2.next;
          }
          if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
            lastChild2 = lastChild2.prev;
          }
          if (isEmptyFragmentElement(schema, lastChild2)) {
            lastChild2 = lastChild2.prev;
          }
          if (!firstChild2 || firstChild2 !== lastChild2) {
            return false;
          }
          return firstChild2.name === "ul" || firstChild2.name === "ol";
        };
        var cleanupDomFragment = function(domFragment) {
          var firstChild2 = domFragment.firstChild;
          var lastChild2 = domFragment.lastChild;
          if (firstChild2 && firstChild2.nodeName === "META") {
            firstChild2.parentNode.removeChild(firstChild2);
          }
          if (lastChild2 && lastChild2.id === "mce_marker") {
            lastChild2.parentNode.removeChild(lastChild2);
          }
          return domFragment;
        };
        var toDomFragment = function(dom2, serializer, fragment) {
          var html2 = serializer.serialize(fragment);
          var domFragment = dom2.createFragment(html2);
          return cleanupDomFragment(domFragment);
        };
        var listItems$1 = function(elm) {
          return Tools.grep(elm.childNodes, function(child2) {
            return child2.nodeName === "LI";
          });
        };
        var isPadding = function(node2) {
          return node2.data === "Â " || NodeType.isBr(node2);
        };
        var isListItemPadded = function(node2) {
          return node2 && node2.firstChild && node2.firstChild === node2.lastChild && isPadding(node2.firstChild);
        };
        var isEmptyOrPadded = function(elm) {
          return !elm.firstChild || isListItemPadded(elm);
        };
        var trimListItems = function(elms) {
          return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
        };
        var getParentLi = function(dom2, node2) {
          var parentBlock = dom2.getParent(node2, dom2.isBlock);
          return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
        };
        var isParentBlockLi = function(dom2, node2) {
          return !!getParentLi(dom2, node2);
        };
        var getSplit = function(parentNode, rng) {
          var beforeRng = rng.cloneRange();
          var afterRng = rng.cloneRange();
          beforeRng.setStartBefore(parentNode);
          afterRng.setEndAfter(parentNode);
          return [
            beforeRng.cloneContents(),
            afterRng.cloneContents()
          ];
        };
        var findFirstIn = function(node2, rootNode) {
          var caretPos = CaretPosition$1.before(node2);
          var caretWalker = CaretWalker(rootNode);
          var newCaretPos = caretWalker.next(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        var findLastOf = function(node2, rootNode) {
          var caretPos = CaretPosition$1.after(node2);
          var caretWalker = CaretWalker(rootNode);
          var newCaretPos = caretWalker.prev(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        var insertMiddle = function(target2, elms, rootNode, rng) {
          var parts = getSplit(target2, rng);
          var parentElm = target2.parentNode;
          parentElm.insertBefore(parts[0], target2);
          Tools.each(elms, function(li) {
            parentElm.insertBefore(li, target2);
          });
          parentElm.insertBefore(parts[1], target2);
          parentElm.removeChild(target2);
          return findLastOf(elms[elms.length - 1], rootNode);
        };
        var insertBefore = function(target2, elms, rootNode) {
          var parentElm = target2.parentNode;
          Tools.each(elms, function(elm) {
            parentElm.insertBefore(elm, target2);
          });
          return findFirstIn(target2, rootNode);
        };
        var insertAfter = function(target2, elms, rootNode, dom2) {
          dom2.insertAfter(elms.reverse(), target2);
          return findLastOf(elms[0], rootNode);
        };
        var insertAtCaret = function(serializer, dom2, rng, fragment) {
          var domFragment = toDomFragment(dom2, serializer, fragment);
          var liTarget = getParentLi(dom2, rng.startContainer);
          var liElms = trimListItems(listItems$1(domFragment.firstChild));
          var BEGINNING = 1, END = 2;
          var rootNode = dom2.getRoot();
          var isAt = function(location) {
            var caretPos = CaretPosition$1.fromRangeStart(rng);
            var caretWalker = CaretWalker(dom2.getRoot());
            var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
            return newPos ? getParentLi(dom2, newPos.getNode()) !== liTarget : true;
          };
          if (isAt(BEGINNING)) {
            return insertBefore(liTarget, liElms, rootNode);
          } else if (isAt(END)) {
            return insertAfter(liTarget, liElms, rootNode, dom2);
          }
          return insertMiddle(liTarget, liElms, rootNode, rng);
        };
        var InsertList = {
          isListFragment,
          insertAtCaret,
          isParentBlockLi,
          trimListItems,
          listItems: listItems$1
        };
        var each$9 = Tools.each;
        var ElementUtils = function(dom2) {
          this.compare = function(node1, node2) {
            if (node1.nodeName !== node2.nodeName) {
              return false;
            }
            var getAttribs = function(node3) {
              var attribs = {};
              each$9(dom2.getAttribs(node3), function(attr) {
                var name2 = attr.nodeName.toLowerCase();
                if (name2.indexOf("_") !== 0 && name2 !== "style" && name2.indexOf("data-") !== 0) {
                  attribs[name2] = dom2.getAttrib(node3, name2);
                }
              });
              return attribs;
            };
            var compareObjects = function(obj1, obj2) {
              var value2, name2;
              for (name2 in obj1) {
                if (obj1.hasOwnProperty(name2)) {
                  value2 = obj2[name2];
                  if (typeof value2 === "undefined") {
                    return false;
                  }
                  if (obj1[name2] !== value2) {
                    return false;
                  }
                  delete obj2[name2];
                }
              }
              for (name2 in obj2) {
                if (obj2.hasOwnProperty(name2)) {
                  return false;
                }
              }
              return true;
            };
            if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
              return false;
            }
            if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
              return false;
            }
            return !Bookmarks.isBookmarkNode(node1) && !Bookmarks.isBookmarkNode(node2);
          };
        };
        var getLastChildren = function(elm) {
          var children2 = [];
          var rawNode = elm.dom();
          while (rawNode) {
            children2.push(Element2.fromDom(rawNode));
            rawNode = rawNode.lastChild;
          }
          return children2;
        };
        var removeTrailingBr = function(elm) {
          var allBrs = descendants$1(elm, "br");
          var brs = filter(getLastChildren(elm).slice(-1), isBr);
          if (allBrs.length === brs.length) {
            each(brs, remove$1);
          }
        };
        var fillWithPaddingBr = function(elm) {
          empty2(elm);
          append(elm, Element2.fromHtml('<br data-mce-bogus="1">'));
        };
        var isPaddingContents = function(elm) {
          return isText(elm) ? get$4(elm) === "Â " : isBr(elm);
        };
        var isPaddedElement = function(elm) {
          return filter(children(elm), isPaddingContents).length === 1;
        };
        var trimBlockTrailingBr = function(elm) {
          lastChild(elm).each(function(lastChild2) {
            prevSibling(lastChild2).each(function(lastChildPrevSibling) {
              if (isBlock2(elm) && isBr(lastChild2) && isBlock2(lastChildPrevSibling)) {
                remove$1(lastChild2);
              }
            });
          });
        };
        var PaddingBr = {
          removeTrailingBr,
          fillWithPaddingBr,
          isPaddedElement,
          trimBlockTrailingBr
        };
        var makeMap$3 = Tools.makeMap;
        function Writer(settings) {
          var html2 = [];
          var indent, indentBefore, indentAfter, encode2, htmlOutput;
          settings = settings || {};
          indent = settings.indent;
          indentBefore = makeMap$3(settings.indent_before || "");
          indentAfter = makeMap$3(settings.indent_after || "");
          encode2 = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
          htmlOutput = settings.element_format === "html";
          return {
            start: function(name2, attrs, empty3) {
              var i2, l, attr, value2;
              if (indent && indentBefore[name2] && html2.length > 0) {
                value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
              html2.push("<", name2);
              if (attrs) {
                for (i2 = 0, l = attrs.length; i2 < l; i2++) {
                  attr = attrs[i2];
                  html2.push(" ", attr.name, '="', encode2(attr.value, true), '"');
                }
              }
              if (!empty3 || htmlOutput) {
                html2[html2.length] = ">";
              } else {
                html2[html2.length] = " />";
              }
              if (empty3 && indent && indentAfter[name2] && html2.length > 0) {
                value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
            },
            end: function(name2) {
              var value2;
              html2.push("</", name2, ">");
              if (indent && indentAfter[name2] && html2.length > 0) {
                value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
            },
            text: function(text2, raw) {
              if (text2.length > 0) {
                html2[html2.length] = raw ? text2 : encode2(text2);
              }
            },
            cdata: function(text2) {
              html2.push("<![CDATA[", text2, "]]>");
            },
            comment: function(text2) {
              html2.push("<!--", text2, "-->");
            },
            pi: function(name2, text2) {
              if (text2) {
                html2.push("<?", name2, " ", encode2(text2), "?>");
              } else {
                html2.push("<?", name2, "?>");
              }
              if (indent) {
                html2.push("\n");
              }
            },
            doctype: function(text2) {
              html2.push("<!DOCTYPE", text2, ">", indent ? "\n" : "");
            },
            reset: function() {
              html2.length = 0;
            },
            getContent: function() {
              return html2.join("").replace(/\n$/, "");
            }
          };
        }
        function HtmlSerializer(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var writer = Writer(settings);
          settings = settings || {};
          settings.validate = "validate" in settings ? settings.validate : true;
          var serialize2 = function(node2) {
            var handlers, validate2;
            validate2 = settings.validate;
            handlers = {
              3: function(node3) {
                writer.text(node3.value, node3.raw);
              },
              8: function(node3) {
                writer.comment(node3.value);
              },
              7: function(node3) {
                writer.pi(node3.name, node3.value);
              },
              10: function(node3) {
                writer.doctype(node3.value);
              },
              4: function(node3) {
                writer.cdata(node3.value);
              },
              11: function(node3) {
                if (node3 = node3.firstChild) {
                  do {
                    walk2(node3);
                  } while (node3 = node3.next);
                }
              }
            };
            writer.reset();
            var walk2 = function(node3) {
              var handler = handlers[node3.type];
              var name2, isEmpty2, attrs, attrName, attrValue, sortedAttrs, i2, l, elementRule;
              if (!handler) {
                name2 = node3.name;
                isEmpty2 = node3.shortEnded;
                attrs = node3.attributes;
                if (validate2 && attrs && attrs.length > 1) {
                  sortedAttrs = [];
                  sortedAttrs.map = {};
                  elementRule = schema.getElementRule(node3.name);
                  if (elementRule) {
                    for (i2 = 0, l = elementRule.attributesOrder.length; i2 < l; i2++) {
                      attrName = elementRule.attributesOrder[i2];
                      if (attrName in attrs.map) {
                        attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    for (i2 = 0, l = attrs.length; i2 < l; i2++) {
                      attrName = attrs[i2].name;
                      if (!(attrName in sortedAttrs.map)) {
                        attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    attrs = sortedAttrs;
                  }
                }
                writer.start(node3.name, attrs, isEmpty2);
                if (!isEmpty2) {
                  if (node3 = node3.firstChild) {
                    do {
                      walk2(node3);
                    } while (node3 = node3.next);
                  }
                  writer.end(name2);
                }
              } else {
                handler(node3);
              }
            };
            if (node2.type === 1 && !settings.inner) {
              walk2(node2);
            } else {
              handlers[11](node2);
            }
            return writer.getContent();
          };
          return { serialize: serialize2 };
        }
        var createRange$1 = function(sc2, so, ec, eo) {
          var rng = domGlobals.document.createRange();
          rng.setStart(sc2, so);
          rng.setEnd(ec, eo);
          return rng;
        };
        var normalizeBlockSelectionRange = function(rng) {
          var startPos = CaretPosition$1.fromRangeStart(rng);
          var endPos = CaretPosition$1.fromRangeEnd(rng);
          var rootNode = rng.commonAncestorContainer;
          return CaretFinder.fromPosition(false, rootNode, endPos).map(function(newEndPos) {
            if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
              return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            } else {
              return rng;
            }
          }).getOr(rng);
        };
        var normalize2 = function(rng) {
          return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
        };
        var RangeNormalizer = { normalize: normalize2 };
        var isAfterNbsp = function(container, offset) {
          return NodeType.isText(container) && container.nodeValue[offset - 1] === "Â ";
        };
        var trimOrPadLeftRight = function(rng, html2) {
          var container, offset;
          container = rng.startContainer;
          offset = rng.startOffset;
          var hasSiblingText = function(siblingName) {
            return container[siblingName] && container[siblingName].nodeType === 3;
          };
          if (container.nodeType === 3) {
            if (offset > 0) {
              html2 = html2.replace(/^&nbsp;/, " ");
            } else if (!hasSiblingText("previousSibling")) {
              html2 = html2.replace(/^ /, "&nbsp;");
            }
            if (offset < container.length) {
              html2 = html2.replace(/&nbsp;(<br>|)$/, " ");
            } else if (!hasSiblingText("nextSibling")) {
              html2 = html2.replace(/(&nbsp;| )(<br>|)$/, "&nbsp;");
            }
          }
          return html2;
        };
        var trimNbspAfterDeleteAndPadValue = function(rng, value2) {
          var container, offset;
          container = rng.startContainer;
          offset = rng.startOffset;
          if (container.nodeType === 3 && rng.collapsed) {
            if (container.data[offset] === "Â ") {
              container.deleteData(offset, 1);
              if (!/[\u00a0| ]$/.test(value2)) {
                value2 += " ";
              }
            } else if (container.data[offset - 1] === "Â ") {
              container.deleteData(offset - 1, 1);
              if (!/[\u00a0| ]$/.test(value2)) {
                value2 = " " + value2;
              }
            }
          }
          return value2;
        };
        var isTableCell$2 = NodeType.matchNodeNames("td th");
        var selectionSetContent = function(editor, content) {
          var rng = editor.selection.getRng();
          var container = rng.startContainer;
          var offset = rng.startOffset;
          if (rng.collapsed && isAfterNbsp(container, offset) && NodeType.isText(container)) {
            container.insertData(offset - 1, " ");
            container.deleteData(offset, 1);
            rng.setStart(container, offset);
            rng.setEnd(container, offset);
            editor.selection.setRng(rng);
          }
          editor.selection.setContent(content);
        };
        var validInsertion = function(editor, value2, parentNode) {
          if (parentNode.getAttribute("data-mce-bogus") === "all") {
            parentNode.parentNode.insertBefore(editor.dom.createFragment(value2), parentNode);
          } else {
            var node2 = parentNode.firstChild;
            var node22 = parentNode.lastChild;
            if (!node2 || node2 === node22 && node2.nodeName === "BR") {
              editor.dom.setHTML(parentNode, value2);
            } else {
              selectionSetContent(editor, value2);
            }
          }
        };
        var trimBrsFromTableCell = function(dom2, elm) {
          Option.from(dom2.getParent(elm, "td,th")).map(Element2.fromDom).each(PaddingBr.trimBlockTrailingBr);
        };
        var reduceInlineTextElements = function(editor, merge2) {
          var textInlineElements = editor.schema.getTextInlineElements();
          var dom2 = editor.dom;
          if (merge2) {
            var root_1 = editor.getBody(), elementUtils_1 = new ElementUtils(dom2);
            Tools.each(dom2.select("*[data-mce-fragment]"), function(node2) {
              for (var testNode = node2.parentNode; testNode && testNode !== root_1; testNode = testNode.parentNode) {
                if (textInlineElements[node2.nodeName.toLowerCase()] && elementUtils_1.compare(testNode, node2)) {
                  dom2.remove(node2, true);
                }
              }
            });
          }
        };
        var markFragmentElements = function(fragment) {
          var node2 = fragment;
          while (node2 = node2.walk()) {
            if (node2.type === 1) {
              node2.attr("data-mce-fragment", "1");
            }
          }
        };
        var umarkFragmentElements = function(elm) {
          Tools.each(elm.getElementsByTagName("*"), function(elm2) {
            elm2.removeAttribute("data-mce-fragment");
          });
        };
        var isPartOfFragment = function(node2) {
          return !!node2.getAttribute("data-mce-fragment");
        };
        var canHaveChildren = function(editor, node2) {
          return node2 && !editor.schema.getShortEndedElements()[node2.nodeName];
        };
        var moveSelectionToMarker = function(editor, marker2) {
          var parentEditableFalseElm, parentBlock, nextRng;
          var dom2 = editor.dom, selection = editor.selection;
          var node2, node22;
          var getContentEditableFalseParent = function(node3) {
            var root2 = editor.getBody();
            for (; node3 && node3 !== root2; node3 = node3.parentNode) {
              if (editor.dom.getContentEditable(node3) === "false") {
                return node3;
              }
            }
            return null;
          };
          if (!marker2) {
            return;
          }
          editor.selection.scrollIntoView(marker2);
          parentEditableFalseElm = getContentEditableFalseParent(marker2);
          if (parentEditableFalseElm) {
            dom2.remove(marker2);
            selection.select(parentEditableFalseElm);
            return;
          }
          var rng = dom2.createRng();
          node2 = marker2.previousSibling;
          if (node2 && node2.nodeType === 3) {
            rng.setStart(node2, node2.nodeValue.length);
            if (!Env.ie) {
              node22 = marker2.nextSibling;
              if (node22 && node22.nodeType === 3) {
                node2.appendData(node22.data);
                node22.parentNode.removeChild(node22);
              }
            }
          } else {
            rng.setStartBefore(marker2);
            rng.setEndBefore(marker2);
          }
          var findNextCaretRng = function(rng2) {
            var caretPos = CaretPosition$1.fromRangeStart(rng2);
            var caretWalker = CaretWalker(editor.getBody());
            caretPos = caretWalker.next(caretPos);
            if (caretPos) {
              return caretPos.toRange();
            }
          };
          parentBlock = dom2.getParent(marker2, dom2.isBlock);
          dom2.remove(marker2);
          if (parentBlock && dom2.isEmpty(parentBlock)) {
            editor.$(parentBlock).empty();
            rng.setStart(parentBlock, 0);
            rng.setEnd(parentBlock, 0);
            if (!isTableCell$2(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
              rng = nextRng;
              dom2.remove(parentBlock);
            } else {
              dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
            }
          }
          selection.setRng(rng);
        };
        var insertHtmlAtCaret = function(editor, value2, details) {
          var parser, serializer, parentNode, rootNode, fragment, args;
          var marker2, rng, node2, bookmarkHtml, merge2;
          var selection = editor.selection, dom2 = editor.dom;
          if (/^ | $/.test(value2)) {
            value2 = trimOrPadLeftRight(selection.getRng(), value2);
          }
          parser = editor.parser;
          merge2 = details.merge;
          serializer = HtmlSerializer({ validate: editor.settings.validate }, editor.schema);
          bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';
          args = {
            content: value2,
            format: "html",
            selection: true,
            paste: details.paste
          };
          args = editor.fire("BeforeSetContent", args);
          if (args.isDefaultPrevented()) {
            editor.fire("SetContent", {
              content: args.content,
              format: "html",
              selection: true,
              paste: details.paste
            });
            return;
          }
          value2 = args.content;
          if (value2.indexOf("{$caret}") === -1) {
            value2 += "{$caret}";
          }
          value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
          rng = selection.getRng();
          var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
          var body = editor.getBody();
          if (caretElement === body && selection.isCollapsed()) {
            if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
              rng = dom2.createRng();
              rng.setStart(body.firstChild, 0);
              rng.setEnd(body.firstChild, 0);
              selection.setRng(rng);
            }
          }
          if (!selection.isCollapsed()) {
            editor.selection.setRng(RangeNormalizer.normalize(editor.selection.getRng()));
            editor.getDoc().execCommand("Delete", false, null);
            value2 = trimNbspAfterDeleteAndPadValue(editor.selection.getRng(), value2);
          }
          parentNode = selection.getNode();
          var parserArgs = {
            context: parentNode.nodeName.toLowerCase(),
            data: details.data,
            insert: true
          };
          fragment = parser.parse(value2, parserArgs);
          if (details.paste === true && InsertList.isListFragment(editor.schema, fragment) && InsertList.isParentBlockLi(dom2, parentNode)) {
            rng = InsertList.insertAtCaret(serializer, dom2, editor.selection.getRng(), fragment);
            editor.selection.setRng(rng);
            editor.fire("SetContent", args);
            return;
          }
          markFragmentElements(fragment);
          node2 = fragment.lastChild;
          if (node2.attr("id") === "mce_marker") {
            marker2 = node2;
            for (node2 = node2.prev; node2; node2 = node2.walk(true)) {
              if (node2.type === 3 || !dom2.isBlock(node2.name)) {
                if (editor.schema.isValidChild(node2.parent.name, "span")) {
                  node2.parent.insert(marker2, node2, node2.name === "br");
                }
                break;
              }
            }
          }
          editor._selectionOverrides.showBlockCaretContainer(parentNode);
          if (!parserArgs.invalid) {
            value2 = serializer.serialize(fragment);
            validInsertion(editor, value2, parentNode);
          } else {
            selectionSetContent(editor, bookmarkHtml);
            parentNode = selection.getNode();
            rootNode = editor.getBody();
            if (parentNode.nodeType === 9) {
              parentNode = node2 = rootNode;
            } else {
              node2 = parentNode;
            }
            while (node2 !== rootNode) {
              parentNode = node2;
              node2 = node2.parentNode;
            }
            value2 = parentNode === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode);
            value2 = serializer.serialize(parser.parse(value2.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
              return serializer.serialize(fragment);
            })));
            if (parentNode === rootNode) {
              dom2.setHTML(rootNode, value2);
            } else {
              dom2.setOuterHTML(parentNode, value2);
            }
          }
          reduceInlineTextElements(editor, merge2);
          moveSelectionToMarker(editor, dom2.get("mce_marker"));
          umarkFragmentElements(editor.getBody());
          trimBrsFromTableCell(editor.dom, editor.selection.getStart());
          editor.fire("SetContent", args);
          editor.addVisual();
        };
        var processValue = function(value2) {
          var details;
          if (typeof value2 !== "string") {
            details = Tools.extend({
              paste: value2.paste,
              data: { paste: value2.paste }
            }, value2);
            return {
              content: value2.content,
              details
            };
          }
          return {
            content: value2,
            details: {}
          };
        };
        var insertAtCaret$1 = function(editor, value2) {
          var result = processValue(value2);
          insertHtmlAtCaret(editor, result.content, result.details);
        };
        var InsertContent = { insertAtCaret: insertAtCaret$1 };
        var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
        var hasStrongRtl = function(text2) {
          return strongRtl.test(text2);
        };
        var getBodySetting = function(editor, name2, defaultValue) {
          var value2 = editor.getParam(name2, defaultValue);
          if (value2.indexOf("=") !== -1) {
            var bodyObj = editor.getParam(name2, "", "hash");
            return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
          } else {
            return value2;
          }
        };
        var getIframeAttrs = function(editor) {
          return editor.getParam("iframe_attrs", {});
        };
        var getDocType = function(editor) {
          return editor.getParam("doctype", "<!DOCTYPE html>");
        };
        var getDocumentBaseUrl = function(editor) {
          return editor.getParam("document_base_url", "");
        };
        var getBodyId = function(editor) {
          return getBodySetting(editor, "body_id", "tinymce");
        };
        var getBodyClass = function(editor) {
          return getBodySetting(editor, "body_class", "");
        };
        var getContentSecurityPolicy = function(editor) {
          return editor.getParam("content_security_policy", "");
        };
        var shouldPutBrInPre = function(editor) {
          return editor.getParam("br_in_pre", true);
        };
        var getForcedRootBlock = function(editor) {
          if (editor.getParam("force_p_newlines", false)) {
            return "p";
          }
          var block2 = editor.getParam("forced_root_block", "p");
          return block2 === false ? "" : block2;
        };
        var getForcedRootBlockAttrs = function(editor) {
          return editor.getParam("forced_root_block_attrs", {});
        };
        var getBrNewLineSelector = function(editor) {
          return editor.getParam("br_newline_selector", ".mce-toc h2,figcaption,caption");
        };
        var getNoNewLineSelector = function(editor) {
          return editor.getParam("no_newline_selector", "");
        };
        var shouldKeepStyles = function(editor) {
          return editor.getParam("keep_styles", true);
        };
        var shouldEndContainerOnEmptyBlock = function(editor) {
          return editor.getParam("end_container_on_empty_block", false);
        };
        var getFontStyleValues = function(editor) {
          return Tools.explode(editor.getParam("font_size_style_values", ""));
        };
        var getFontSizeClasses = function(editor) {
          return Tools.explode(editor.getParam("font_size_classes", ""));
        };
        var getImagesDataImgFilter = function(editor) {
          return editor.getParam("images_dataimg_filter", constant(true), "function");
        };
        var isAutomaticUploadsEnabled = function(editor) {
          return editor.getParam("automatic_uploads", true, "boolean");
        };
        var shouldReuseFileName = function(editor) {
          return editor.getParam("images_reuse_filename", false, "boolean");
        };
        var shouldReplaceBlobUris = function(editor) {
          return editor.getParam("images_replace_blob_uris", true, "boolean");
        };
        var getImageUploadUrl = function(editor) {
          return editor.getParam("images_upload_url", "", "string");
        };
        var getImageUploadBasePath = function(editor) {
          return editor.getParam("images_upload_base_path", "", "string");
        };
        var getImagesUploadCredentials = function(editor) {
          return editor.getParam("images_upload_credentials", false, "boolean");
        };
        var getImagesUploadHandler = function(editor) {
          return editor.getParam("images_upload_handler", null, "function");
        };
        var shouldUseContentCssCors = function(editor) {
          return editor.getParam("content_css_cors", false, "boolean");
        };
        var getInlineBoundarySelector = function(editor) {
          return editor.getParam("inline_boundaries_selector", "a[href],code,.mce-annotation", "string");
        };
        var Settings = {
          getIframeAttrs,
          getDocType,
          getDocumentBaseUrl,
          getBodyId,
          getBodyClass,
          getContentSecurityPolicy,
          shouldPutBrInPre,
          getForcedRootBlock,
          getForcedRootBlockAttrs,
          getBrNewLineSelector,
          getNoNewLineSelector,
          shouldKeepStyles,
          shouldEndContainerOnEmptyBlock,
          getFontStyleValues,
          getFontSizeClasses,
          getImagesDataImgFilter,
          isAutomaticUploadsEnabled,
          shouldReuseFileName,
          shouldReplaceBlobUris,
          getImageUploadUrl,
          getImageUploadBasePath,
          getImagesUploadCredentials,
          getImagesUploadHandler,
          shouldUseContentCssCors,
          getInlineBoundarySelector
        };
        var isInlineTarget = function(editor, elm) {
          return is$1(Element2.fromDom(elm), Settings.getInlineBoundarySelector(editor));
        };
        var isRtl = function(element) {
          return DOMUtils$1.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl(element.textContent);
        };
        var findInlineParents = function(isInlineTarget2, rootNode, pos) {
          return filter(DOMUtils$1.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
        };
        var findRootInline = function(isInlineTarget2, rootNode, pos) {
          var parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
          return Option.from(parents2[parents2.length - 1]);
        };
        var hasSameParentBlock = function(rootNode, node1, node2) {
          var block1 = getParentBlock(node1, rootNode);
          var block2 = getParentBlock(node2, rootNode);
          return block1 && block1 === block2;
        };
        var isAtZwsp = function(pos) {
          return isBeforeInline(pos) || isAfterInline(pos);
        };
        var normalizePosition = function(forward, pos) {
          if (!pos) {
            return pos;
          }
          var container = pos.container(), offset = pos.offset();
          if (forward) {
            if (isCaretContainerInline(container)) {
              if (NodeType.isText(container.nextSibling)) {
                return CaretPosition$1(container.nextSibling, 0);
              } else {
                return CaretPosition$1.after(container);
              }
            } else {
              return isBeforeInline(pos) ? CaretPosition$1(container, offset + 1) : pos;
            }
          } else {
            if (isCaretContainerInline(container)) {
              if (NodeType.isText(container.previousSibling)) {
                return CaretPosition$1(container.previousSibling, container.previousSibling.data.length);
              } else {
                return CaretPosition$1.before(container);
              }
            } else {
              return isAfterInline(pos) ? CaretPosition$1(container, offset - 1) : pos;
            }
          }
        };
        var normalizeForwards = curry(normalizePosition, true);
        var normalizeBackwards = curry(normalizePosition, false);
        var InlineUtils = {
          isInlineTarget,
          findRootInline,
          isRtl,
          isAtZwsp,
          normalizePosition,
          normalizeForwards,
          normalizeBackwards,
          hasSameParentBlock
        };
        var isBeforeRoot = function(rootNode) {
          return function(elm) {
            return eq(rootNode, Element2.fromDom(elm.dom().parentNode));
          };
        };
        var getParentBlock$1 = function(rootNode, elm) {
          return contains$3(rootNode, elm) ? closest(elm, function(element) {
            return isTextBlock(element) || isListItem(element);
          }, isBeforeRoot(rootNode)) : Option.none();
        };
        var placeCaretInEmptyBody = function(editor) {
          var body = editor.getBody();
          var node2 = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
          editor.selection.setCursorLocation(node2, 0);
        };
        var paddEmptyBody = function(editor) {
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            placeCaretInEmptyBody(editor);
          }
        };
        var willDeleteLastPositionInElement = function(forward, fromPos, elm) {
          return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function(firstPos, lastPos) {
            var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
            var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
            var normalizedFromPos = InlineUtils.normalizePosition(false, fromPos);
            if (forward) {
              return CaretFinder.nextPosition(elm, normalizedFromPos).map(function(nextPos) {
                return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
              }).getOr(false);
            } else {
              return CaretFinder.prevPosition(elm, normalizedFromPos).map(function(prevPos) {
                return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
              }).getOr(false);
            }
          }).getOr(true);
        };
        var DeleteUtils = {
          getParentBlock: getParentBlock$1,
          paddEmptyBody,
          willDeleteLastPositionInElement
        };
        var ancestor$2 = function(scope, selector, isRoot) {
          return ancestor$1(scope, selector, isRoot).isSome();
        };
        var hasWhitespacePreserveParent = function(rootNode, node2) {
          var rootElement = Element2.fromDom(rootNode);
          var startNode = Element2.fromDom(node2);
          return ancestor$2(startNode, "pre,code", curry(eq, rootElement));
        };
        var isWhitespace2 = function(rootNode, node2) {
          return NodeType.isText(node2) && /^[ \t\r\n]*$/.test(node2.data) && hasWhitespacePreserveParent(rootNode, node2) === false;
        };
        var isNamedAnchor = function(node2) {
          return NodeType.isElement(node2) && node2.nodeName === "A" && node2.hasAttribute("name");
        };
        var isContent = function(rootNode, node2) {
          return isCaretCandidate(node2) && isWhitespace2(rootNode, node2) === false || isNamedAnchor(node2) || isBookmark(node2);
        };
        var isBookmark = NodeType.hasAttribute("data-mce-bookmark");
        var isBogus$2 = NodeType.hasAttribute("data-mce-bogus");
        var isBogusAll$1 = NodeType.hasAttributeValue("data-mce-bogus", "all");
        var isEmptyNode = function(targetNode) {
          var walker, node2, brCount = 0;
          if (isContent(targetNode, targetNode)) {
            return false;
          } else {
            node2 = targetNode.firstChild;
            if (!node2) {
              return true;
            }
            walker = new TreeWalker(node2, targetNode);
            do {
              if (isBogusAll$1(node2)) {
                node2 = walker.next(true);
                continue;
              }
              if (isBogus$2(node2)) {
                node2 = walker.next();
                continue;
              }
              if (NodeType.isBr(node2)) {
                brCount++;
                node2 = walker.next();
                continue;
              }
              if (isContent(targetNode, node2)) {
                return false;
              }
              node2 = walker.next();
            } while (node2);
            return brCount <= 1;
          }
        };
        var isEmpty$1 = function(elm) {
          return isEmptyNode(elm.dom());
        };
        var Empty = { isEmpty: isEmpty$1 };
        var BlockPosition = Immutable("block", "position");
        var BlockBoundary = Immutable("from", "to");
        var getBlockPosition = function(rootNode, pos) {
          var rootElm = Element2.fromDom(rootNode);
          var containerElm = Element2.fromDom(pos.container());
          return DeleteUtils.getParentBlock(rootElm, containerElm).map(function(block2) {
            return BlockPosition(block2, pos);
          });
        };
        var isDifferentBlocks = function(blockBoundary) {
          return eq(blockBoundary.from().block(), blockBoundary.to().block()) === false;
        };
        var hasSameParent = function(blockBoundary) {
          return parent(blockBoundary.from().block()).bind(function(parent1) {
            return parent(blockBoundary.to().block()).filter(function(parent2) {
              return eq(parent1, parent2);
            });
          }).isSome();
        };
        var isEditable = function(blockBoundary) {
          return NodeType.isContentEditableFalse(blockBoundary.from().block().dom()) === false && NodeType.isContentEditableFalse(blockBoundary.to().block().dom()) === false;
        };
        var skipLastBr = function(rootNode, forward, blockPosition) {
          if (NodeType.isBr(blockPosition.position().getNode()) && Empty.isEmpty(blockPosition.block()) === false) {
            return CaretFinder.positionIn(false, blockPosition.block().dom()).bind(function(lastPositionInBlock) {
              if (lastPositionInBlock.isEqual(blockPosition.position())) {
                return CaretFinder.fromPosition(forward, rootNode, lastPositionInBlock).bind(function(to) {
                  return getBlockPosition(rootNode, to);
                });
              } else {
                return Option.some(blockPosition);
              }
            }).getOr(blockPosition);
          } else {
            return blockPosition;
          }
        };
        var readFromRange = function(rootNode, forward, rng) {
          var fromBlockPos = getBlockPosition(rootNode, CaretPosition$1.fromRangeStart(rng));
          var toBlockPos = fromBlockPos.bind(function(blockPos) {
            return CaretFinder.fromPosition(forward, rootNode, blockPos.position()).bind(function(to) {
              return getBlockPosition(rootNode, to).map(function(blockPos2) {
                return skipLastBr(rootNode, forward, blockPos2);
              });
            });
          });
          return lift2(fromBlockPos, toBlockPos, BlockBoundary).filter(function(blockBoundary) {
            return isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable(blockBoundary);
          });
        };
        var read$1 = function(rootNode, forward, rng) {
          return rng.collapsed ? readFromRange(rootNode, forward, rng) : Option.none();
        };
        var BlockMergeBoundary = { read: read$1 };
        var dropLast = function(xs) {
          return xs.slice(0, -1);
        };
        var parentsUntil$1 = function(start2, root2, predicate) {
          if (contains$3(root2, start2)) {
            return dropLast(parents(start2, function(elm) {
              return predicate(elm) || eq(elm, root2);
            }));
          } else {
            return [];
          }
        };
        var parents$1 = function(start2, root2) {
          return parentsUntil$1(start2, root2, constant(false));
        };
        var parentsAndSelf = function(start2, root2) {
          return [start2].concat(parents$1(start2, root2));
        };
        var Parents = {
          parentsUntil: parentsUntil$1,
          parents: parents$1,
          parentsAndSelf
        };
        var getChildrenUntilBlockBoundary = function(block2) {
          var children$1 = children(block2);
          return findIndex(children$1, isBlock2).fold(function() {
            return children$1;
          }, function(index) {
            return children$1.slice(0, index);
          });
        };
        var extractChildren = function(block2) {
          var children2 = getChildrenUntilBlockBoundary(block2);
          each(children2, remove$1);
          return children2;
        };
        var removeEmptyRoot = function(rootNode, block2) {
          var parents2 = Parents.parentsAndSelf(block2, rootNode);
          return find(parents2.reverse(), Empty.isEmpty).each(remove$1);
        };
        var isEmptyBefore = function(el2) {
          return filter(prevSiblings(el2), function(el3) {
            return !Empty.isEmpty(el3);
          }).length === 0;
        };
        var nestedBlockMerge = function(rootNode, fromBlock, toBlock, insertionPoint) {
          if (Empty.isEmpty(toBlock)) {
            PaddingBr.fillWithPaddingBr(toBlock);
            return CaretFinder.firstPositionIn(toBlock.dom());
          }
          if (isEmptyBefore(insertionPoint) && Empty.isEmpty(fromBlock)) {
            before(insertionPoint, Element2.fromTag("br"));
          }
          var position = CaretFinder.prevPosition(toBlock.dom(), CaretPosition$1.before(insertionPoint.dom()));
          each(extractChildren(fromBlock), function(child2) {
            before(insertionPoint, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        var sidelongBlockMerge = function(rootNode, fromBlock, toBlock) {
          if (Empty.isEmpty(toBlock)) {
            remove$1(toBlock);
            if (Empty.isEmpty(fromBlock)) {
              PaddingBr.fillWithPaddingBr(fromBlock);
            }
            return CaretFinder.firstPositionIn(fromBlock.dom());
          }
          var position = CaretFinder.lastPositionIn(toBlock.dom());
          each(extractChildren(fromBlock), function(child2) {
            append(toBlock, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        var findInsertionPoint = function(toBlock, block2) {
          var parentsAndSelf2 = Parents.parentsAndSelf(block2, toBlock);
          return Option.from(parentsAndSelf2[parentsAndSelf2.length - 1]);
        };
        var getInsertionPoint = function(fromBlock, toBlock) {
          return contains$3(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Option.none();
        };
        var trimBr = function(first2, block2) {
          CaretFinder.positionIn(first2, block2.dom()).map(function(position) {
            return position.getNode();
          }).map(Element2.fromDom).filter(isBr).each(remove$1);
        };
        var mergeBlockInto = function(rootNode, fromBlock, toBlock) {
          trimBr(true, fromBlock);
          trimBr(false, toBlock);
          return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
        };
        var mergeBlocks = function(rootNode, forward, block1, block2) {
          return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
        };
        var MergeBlocks = { mergeBlocks };
        var backspaceDelete = function(editor, forward) {
          var position;
          var rootNode = Element2.fromDom(editor.getBody());
          position = BlockMergeBoundary.read(rootNode.dom(), forward, editor.selection.getRng()).bind(function(blockBoundary) {
            return MergeBlocks.mergeBlocks(rootNode, forward, blockBoundary.from().block(), blockBoundary.to().block());
          });
          position.each(function(pos) {
            editor.selection.setRng(pos.toRange());
          });
          return position.isSome();
        };
        var BlockBoundaryDelete = { backspaceDelete };
        var deleteRangeMergeBlocks = function(rootNode, selection) {
          var rng = selection.getRng();
          return lift2(DeleteUtils.getParentBlock(rootNode, Element2.fromDom(rng.startContainer)), DeleteUtils.getParentBlock(rootNode, Element2.fromDom(rng.endContainer)), function(block1, block2) {
            if (eq(block1, block2) === false) {
              rng.deleteContents();
              MergeBlocks.mergeBlocks(rootNode, true, block1, block2).each(function(pos) {
                selection.setRng(pos.toRange());
              });
              return true;
            } else {
              return false;
            }
          }).getOr(false);
        };
        var isRawNodeInTable = function(root2, rawNode) {
          var node2 = Element2.fromDom(rawNode);
          var isRoot = curry(eq, root2);
          return ancestor(node2, isTableCell, isRoot).isSome();
        };
        var isSelectionInTable = function(root2, rng) {
          return isRawNodeInTable(root2, rng.startContainer) || isRawNodeInTable(root2, rng.endContainer);
        };
        var isEverythingSelected = function(root2, rng) {
          var noPrevious = CaretFinder.prevPosition(root2.dom(), CaretPosition$1.fromRangeStart(rng)).isNone();
          var noNext = CaretFinder.nextPosition(root2.dom(), CaretPosition$1.fromRangeEnd(rng)).isNone();
          return !isSelectionInTable(root2, rng) && noPrevious && noNext;
        };
        var emptyEditor = function(editor) {
          editor.setContent("");
          editor.selection.setCursorLocation();
          return true;
        };
        var deleteRange = function(editor) {
          var rootNode = Element2.fromDom(editor.getBody());
          var rng = editor.selection.getRng();
          return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
        };
        var backspaceDelete$1 = function(editor, forward) {
          return editor.selection.isCollapsed() ? false : deleteRange(editor);
        };
        var BlockRangeDelete = { backspaceDelete: backspaceDelete$1 };
        var generate$1 = function(cases) {
          if (!isArray(cases)) {
            throw new Error("cases must be an array");
          }
          if (cases.length === 0) {
            throw new Error("there must be at least one case");
          }
          var constructors = [];
          var adt2 = {};
          each(cases, function(acase, count2) {
            var keys$1 = keys(acase);
            if (keys$1.length !== 1) {
              throw new Error("one and only one name per case");
            }
            var key = keys$1[0];
            var value2 = acase[key];
            if (adt2[key] !== void 0) {
              throw new Error("duplicate key detected:" + key);
            } else if (key === "cata") {
              throw new Error("cannot have a case named cata (sorry)");
            } else if (!isArray(value2)) {
              throw new Error("case arguments must be an array");
            }
            constructors.push(key);
            adt2[key] = function() {
              var argLength = arguments.length;
              if (argLength !== value2.length) {
                throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
              }
              var args = new Array(argLength);
              for (var i2 = 0; i2 < args.length; i2++) {
                args[i2] = arguments[i2];
              }
              var match2 = function(branches) {
                var branchKeys = keys(branches);
                if (constructors.length !== branchKeys.length) {
                  throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
                }
                var allReqd = forall2(constructors, function(reqKey) {
                  return contains(branchKeys, reqKey);
                });
                if (!allReqd) {
                  throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
                }
                return branches[key].apply(null, args);
              };
              return {
                fold: function() {
                  if (arguments.length !== cases.length) {
                    throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + arguments.length);
                  }
                  var target2 = arguments[count2];
                  return target2.apply(null, args);
                },
                match: match2,
                log: function(label) {
                  domGlobals.console.log(label, {
                    constructors,
                    constructor: key,
                    params: args
                  });
                }
              };
            };
          });
          return adt2;
        };
        var Adt = { generate: generate$1 };
        var isBr$5 = function(pos) {
          return getElementFromPosition(pos).exists(isBr);
        };
        var findBr = function(forward, root2, pos) {
          var parentBlocks = filter(Parents.parentsAndSelf(Element2.fromDom(pos.container()), root2), isBlock2);
          var scope = head(parentBlocks).getOr(root2);
          return CaretFinder.fromPosition(forward, scope.dom(), pos).filter(isBr$5);
        };
        var isBeforeBr = function(root2, pos) {
          return getElementFromPosition(pos).exists(isBr) || findBr(true, root2, pos).isSome();
        };
        var isAfterBr = function(root2, pos) {
          return getElementFromPrevPosition(pos).exists(isBr) || findBr(false, root2, pos).isSome();
        };
        var findPreviousBr = curry(findBr, false);
        var findNextBr = curry(findBr, true);
        var is$2 = function(expected) {
          return function(actual) {
            return expected === actual;
          };
        };
        var isNbsp = is$2("Â ");
        var isWhiteSpace$1 = function(chr) {
          return /^[\r\n\t ]$/.test(chr);
        };
        var isContent$1 = function(chr) {
          return !isWhiteSpace$1(chr) && !isNbsp(chr);
        };
        var isChar = function(forward, predicate, pos) {
          return Option.from(pos.container()).filter(NodeType.isText).exists(function(text2) {
            var delta2 = forward ? 0 : -1;
            return predicate(text2.data.charAt(pos.offset() + delta2));
          });
        };
        var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
        var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
        var isEmptyText = function(pos) {
          var container = pos.container();
          return NodeType.isText(container) && container.data.length === 0;
        };
        var isNextToContentEditableFalse = function(relativeOffset, caretPosition) {
          var node2 = getChildNodeAtRelativeOffset(relativeOffset, caretPosition);
          return NodeType.isContentEditableFalse(node2) && !NodeType.isBogusAll(node2);
        };
        var isBeforeContentEditableFalse = curry(isNextToContentEditableFalse, 0);
        var isAfterContentEditableFalse = curry(isNextToContentEditableFalse, -1);
        var isNextToTable = function(relativeOffset, caretPosition) {
          return NodeType.isTable(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
        };
        var isBeforeTable = curry(isNextToTable, 0);
        var isAfterTable = curry(isNextToTable, -1);
        var isCompoundElement = function(node2) {
          return isTableCell(Element2.fromDom(node2)) || isListItem(Element2.fromDom(node2));
        };
        var DeleteAction = Adt.generate([
          { remove: ["element"] },
          { moveToElement: ["element"] },
          { moveToPosition: ["position"] }
        ]);
        var isAtContentEditableBlockCaret = function(forward, from2) {
          var elm = from2.getNode(forward === false);
          var caretLocation = forward ? "after" : "before";
          return NodeType.isElement(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
        };
        var isDeleteFromCefDifferentBlocks = function(root2, forward, from2, to) {
          var inSameBlock = function(elm) {
            return isInline(Element2.fromDom(elm)) && !isInSameBlock(from2, to, root2);
          };
          return getRelativeCefElm(!forward, from2).fold(function() {
            return getRelativeCefElm(forward, to).fold(constant(false), inSameBlock);
          }, inSameBlock);
        };
        var deleteEmptyBlockOrMoveToCef = function(root2, forward, from2, to) {
          var toCefElm = to.getNode(forward === false);
          return DeleteUtils.getParentBlock(Element2.fromDom(root2), Element2.fromDom(from2.getNode())).map(function(blockElm) {
            return Empty.isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom()) : DeleteAction.moveToElement(toCefElm);
          }).orThunk(function() {
            return Option.some(DeleteAction.moveToElement(toCefElm));
          });
        };
        var findCefPosition = function(root2, forward, from2) {
          return CaretFinder.fromPosition(forward, root2, from2).bind(function(to) {
            if (isCompoundElement(to.getNode())) {
              return Option.none();
            } else if (isDeleteFromCefDifferentBlocks(root2, forward, from2, to)) {
              return Option.none();
            } else if (forward && NodeType.isContentEditableFalse(to.getNode())) {
              return deleteEmptyBlockOrMoveToCef(root2, forward, from2, to);
            } else if (forward === false && NodeType.isContentEditableFalse(to.getNode(true))) {
              return deleteEmptyBlockOrMoveToCef(root2, forward, from2, to);
            } else if (forward && isAfterContentEditableFalse(from2)) {
              return Option.some(DeleteAction.moveToPosition(to));
            } else if (forward === false && isBeforeContentEditableFalse(from2)) {
              return Option.some(DeleteAction.moveToPosition(to));
            } else {
              return Option.none();
            }
          });
        };
        var getContentEditableBlockAction = function(forward, elm) {
          if (forward && NodeType.isContentEditableFalse(elm.nextSibling)) {
            return Option.some(DeleteAction.moveToElement(elm.nextSibling));
          } else if (forward === false && NodeType.isContentEditableFalse(elm.previousSibling)) {
            return Option.some(DeleteAction.moveToElement(elm.previousSibling));
          } else {
            return Option.none();
          }
        };
        var skipMoveToActionFromInlineCefToContent = function(root2, from2, deleteAction2) {
          return deleteAction2.fold(function(elm) {
            return Option.some(DeleteAction.remove(elm));
          }, function(elm) {
            return Option.some(DeleteAction.moveToElement(elm));
          }, function(to) {
            if (isInSameBlock(from2, to, root2)) {
              return Option.none();
            } else {
              return Option.some(DeleteAction.moveToPosition(to));
            }
          });
        };
        var getContentEditableAction = function(root2, forward, from2) {
          if (isAtContentEditableBlockCaret(forward, from2)) {
            return getContentEditableBlockAction(forward, from2.getNode(forward === false)).fold(function() {
              return findCefPosition(root2, forward, from2);
            }, Option.some);
          } else {
            return findCefPosition(root2, forward, from2).bind(function(deleteAction2) {
              return skipMoveToActionFromInlineCefToContent(root2, from2, deleteAction2);
            });
          }
        };
        var read$2 = function(root2, forward, rng) {
          var normalizedRange = normalizeRange(forward ? 1 : -1, root2, rng);
          var from2 = CaretPosition$1.fromRangeStart(normalizedRange);
          var rootElement = Element2.fromDom(root2);
          if (forward === false && isAfterContentEditableFalse(from2)) {
            return Option.some(DeleteAction.remove(from2.getNode(true)));
          } else if (forward && isBeforeContentEditableFalse(from2)) {
            return Option.some(DeleteAction.remove(from2.getNode()));
          } else if (forward === false && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
            return findPreviousBr(rootElement, from2).map(function(br) {
              return DeleteAction.remove(br.getNode());
            });
          } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr(rootElement, from2)) {
            return findNextBr(rootElement, from2).map(function(br) {
              return DeleteAction.remove(br.getNode());
            });
          } else {
            return getContentEditableAction(root2, forward, from2);
          }
        };
        var isCollapsibleWhitespace = function(c) {
          return " \f\n\r	\v".indexOf(c) !== -1;
        };
        var normalizeContent = function(content, isStartOfContent, isEndOfContent) {
          var result = foldl(content.split(""), function(acc, c) {
            if (isCollapsibleWhitespace(c) || c === "Â ") {
              if (acc.previousCharIsSpace || acc.str === "" && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
                return {
                  previousCharIsSpace: false,
                  str: acc.str + "Â "
                };
              } else {
                return {
                  previousCharIsSpace: true,
                  str: acc.str + " "
                };
              }
            } else {
              return {
                previousCharIsSpace: false,
                str: acc.str + c
              };
            }
          }, {
            previousCharIsSpace: false,
            str: ""
          });
          return result.str;
        };
        var normalize$1 = function(node2, offset, count2) {
          if (count2 === 0) {
            return;
          }
          var whitespace2 = node2.data.slice(offset, offset + count2);
          var isEndOfContent = offset + count2 >= node2.data.length;
          var isStartOfContent = offset === 0;
          node2.replaceData(offset, count2, normalizeContent(whitespace2, isStartOfContent, isEndOfContent));
        };
        var normalizeWhitespaceAfter = function(node2, offset) {
          var content = node2.data.slice(offset);
          var whitespaceCount = content.length - lTrim(content).length;
          return normalize$1(node2, offset, whitespaceCount);
        };
        var normalizeWhitespaceBefore = function(node2, offset) {
          var content = node2.data.slice(0, offset);
          var whitespaceCount = content.length - rTrim(content).length;
          return normalize$1(node2, offset - whitespaceCount, whitespaceCount);
        };
        var mergeTextNodes = function(prevNode, nextNode, normalizeWhitespace) {
          var whitespaceOffset = rTrim(prevNode.data).length;
          prevNode.appendData(nextNode.data);
          remove$1(Element2.fromDom(nextNode));
          if (normalizeWhitespace) {
            normalizeWhitespaceAfter(prevNode, whitespaceOffset);
          }
          return prevNode;
        };
        var needsReposition = function(pos, elm) {
          var container = pos.container();
          var offset = pos.offset();
          return CaretPosition$1.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition$1.before(elm).offset();
        };
        var reposition = function(elm, pos) {
          return needsReposition(pos, elm) ? CaretPosition$1(pos.container(), pos.offset() - 1) : pos;
        };
        var beforeOrStartOf = function(node2) {
          return NodeType.isText(node2) ? CaretPosition$1(node2, 0) : CaretPosition$1.before(node2);
        };
        var afterOrEndOf = function(node2) {
          return NodeType.isText(node2) ? CaretPosition$1(node2, node2.data.length) : CaretPosition$1.after(node2);
        };
        var getPreviousSiblingCaretPosition = function(elm) {
          if (isCaretCandidate(elm.previousSibling)) {
            return Option.some(afterOrEndOf(elm.previousSibling));
          } else {
            return elm.previousSibling ? CaretFinder.lastPositionIn(elm.previousSibling) : Option.none();
          }
        };
        var getNextSiblingCaretPosition = function(elm) {
          if (isCaretCandidate(elm.nextSibling)) {
            return Option.some(beforeOrStartOf(elm.nextSibling));
          } else {
            return elm.nextSibling ? CaretFinder.firstPositionIn(elm.nextSibling) : Option.none();
          }
        };
        var findCaretPositionBackwardsFromElm = function(rootElement, elm) {
          var startPosition = CaretPosition$1.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
          return CaretFinder.prevPosition(rootElement, startPosition).fold(function() {
            return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm));
          }, Option.some);
        };
        var findCaretPositionForwardsFromElm = function(rootElement, elm) {
          return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm)).fold(function() {
            return CaretFinder.prevPosition(rootElement, CaretPosition$1.before(elm));
          }, Option.some);
        };
        var findCaretPositionBackwards = function(rootElement, elm) {
          return getPreviousSiblingCaretPosition(elm).orThunk(function() {
            return getNextSiblingCaretPosition(elm);
          }).orThunk(function() {
            return findCaretPositionBackwardsFromElm(rootElement, elm);
          });
        };
        var findCaretPositionForward = function(rootElement, elm) {
          return getNextSiblingCaretPosition(elm).orThunk(function() {
            return getPreviousSiblingCaretPosition(elm);
          }).orThunk(function() {
            return findCaretPositionForwardsFromElm(rootElement, elm);
          });
        };
        var findCaretPosition$1 = function(forward, rootElement, elm) {
          return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
        };
        var findCaretPosOutsideElmAfterDelete = function(forward, rootElement, elm) {
          return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
        };
        var setSelection = function(editor, forward, pos) {
          pos.fold(function() {
            editor.focus();
          }, function(pos2) {
            editor.selection.setRng(pos2.toRange(), forward);
          });
        };
        var eqRawNode = function(rawNode) {
          return function(elm) {
            return elm.dom() === rawNode;
          };
        };
        var isBlock$2 = function(editor, elm) {
          return elm && editor.schema.getBlockElements().hasOwnProperty(name(elm));
        };
        var paddEmptyBlock = function(elm) {
          if (Empty.isEmpty(elm)) {
            var br = Element2.fromHtml('<br data-mce-bogus="1">');
            empty2(elm);
            append(elm, br);
            return Option.some(CaretPosition$1.before(br.dom()));
          } else {
            return Option.none();
          }
        };
        var deleteNormalized = function(elm, afterDeletePosOpt, normalizeWhitespace) {
          var prevTextOpt = prevSibling(elm).filter(isText);
          var nextTextOpt = nextSibling(elm).filter(isText);
          remove$1(elm);
          return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function(prev, next2, pos) {
            var prevNode = prev.dom(), nextNode = next2.dom();
            var offset = prevNode.data.length;
            mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
            return pos.container() === nextNode ? CaretPosition$1(prevNode, offset) : pos;
          }).orThunk(function() {
            if (normalizeWhitespace) {
              prevTextOpt.each(function(elm2) {
                return normalizeWhitespaceBefore(elm2.dom(), elm2.dom().length);
              });
              nextTextOpt.each(function(elm2) {
                return normalizeWhitespaceAfter(elm2.dom(), 0);
              });
            }
            return afterDeletePosOpt;
          });
        };
        var isInlineElement = function(editor, element) {
          return has2(editor.schema.getTextInlineElements(), name(element));
        };
        var deleteElement = function(editor, forward, elm, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom());
          var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
          var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            editor.selection.setCursorLocation();
          } else {
            parentBlock.bind(paddEmptyBlock).fold(function() {
              if (moveCaret2) {
                setSelection(editor, forward, normalizedAfterDeletePos);
              }
            }, function(paddPos) {
              if (moveCaret2) {
                setSelection(editor, forward, Option.some(paddPos));
              }
            });
          }
        };
        var DeleteElement = { deleteElement };
        var deleteElement$1 = function(editor, forward) {
          return function(element) {
            editor._selectionOverrides.hideFakeCaret();
            DeleteElement.deleteElement(editor, forward, Element2.fromDom(element));
            return true;
          };
        };
        var moveToElement = function(editor, forward) {
          return function(element) {
            var pos = forward ? CaretPosition$1.before(element) : CaretPosition$1.after(element);
            editor.selection.setRng(pos.toRange());
            return true;
          };
        };
        var moveToPosition = function(editor) {
          return function(pos) {
            editor.selection.setRng(pos.toRange());
            return true;
          };
        };
        var backspaceDeleteCaret = function(editor, forward) {
          var result = read$2(editor.getBody(), forward, editor.selection.getRng()).map(function(deleteAction2) {
            return deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
          });
          return result.getOr(false);
        };
        var deleteOffscreenSelection = function(rootElement) {
          each(descendants$1(rootElement, ".mce-offscreen-selection"), remove$1);
        };
        var backspaceDeleteRange = function(editor, forward) {
          var selectedElement = editor.selection.getNode();
          if (NodeType.isContentEditableFalse(selectedElement)) {
            deleteOffscreenSelection(Element2.fromDom(editor.getBody()));
            DeleteElement.deleteElement(editor, forward, Element2.fromDom(editor.selection.getNode()));
            DeleteUtils.paddEmptyBody(editor);
            return true;
          } else {
            return false;
          }
        };
        var getContentEditableRoot = function(root2, node2) {
          while (node2 && node2 !== root2) {
            if (NodeType.isContentEditableTrue(node2) || NodeType.isContentEditableFalse(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var paddEmptyElement = function(editor) {
          var br;
          var ceRoot = getContentEditableRoot(editor.getBody(), editor.selection.getNode());
          if (NodeType.isContentEditableTrue(ceRoot) && editor.dom.isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
            br = editor.dom.create("br", { "data-mce-bogus": "1" });
            editor.dom.setHTML(ceRoot, "");
            ceRoot.appendChild(br);
            editor.selection.setRng(CaretPosition$1.before(br).toRange());
          }
          return true;
        };
        var backspaceDelete$2 = function(editor, forward) {
          if (editor.selection.isCollapsed()) {
            return backspaceDeleteCaret(editor, forward);
          } else {
            return backspaceDeleteRange(editor, forward);
          }
        };
        var CefDelete = {
          backspaceDelete: backspaceDelete$2,
          paddEmptyElement
        };
        var isText$8 = NodeType.isText;
        var startsWithCaretContainer$1 = function(node2) {
          return isText$8(node2) && node2.data[0] === Zwsp.ZWSP;
        };
        var endsWithCaretContainer$1 = function(node2) {
          return isText$8(node2) && node2.data[node2.data.length - 1] === Zwsp.ZWSP;
        };
        var createZwsp = function(node2) {
          return node2.ownerDocument.createTextNode(Zwsp.ZWSP);
        };
        var insertBefore$1 = function(node2) {
          if (isText$8(node2.previousSibling)) {
            if (endsWithCaretContainer$1(node2.previousSibling)) {
              return node2.previousSibling;
            } else {
              node2.previousSibling.appendData(Zwsp.ZWSP);
              return node2.previousSibling;
            }
          } else if (isText$8(node2)) {
            if (startsWithCaretContainer$1(node2)) {
              return node2;
            } else {
              node2.insertData(0, Zwsp.ZWSP);
              return node2;
            }
          } else {
            var newNode = createZwsp(node2);
            node2.parentNode.insertBefore(newNode, node2);
            return newNode;
          }
        };
        var insertAfter$1 = function(node2) {
          if (isText$8(node2.nextSibling)) {
            if (startsWithCaretContainer$1(node2.nextSibling)) {
              return node2.nextSibling;
            } else {
              node2.nextSibling.insertData(0, Zwsp.ZWSP);
              return node2.nextSibling;
            }
          } else if (isText$8(node2)) {
            if (endsWithCaretContainer$1(node2)) {
              return node2;
            } else {
              node2.appendData(Zwsp.ZWSP);
              return node2;
            }
          } else {
            var newNode = createZwsp(node2);
            if (node2.nextSibling) {
              node2.parentNode.insertBefore(newNode, node2.nextSibling);
            } else {
              node2.parentNode.appendChild(newNode);
            }
            return newNode;
          }
        };
        var insertInline$1 = function(before2, node2) {
          return before2 ? insertBefore$1(node2) : insertAfter$1(node2);
        };
        var insertInlineBefore = curry(insertInline$1, true);
        var insertInlineAfter = curry(insertInline$1, false);
        var insertInlinePos = function(pos, before2) {
          if (NodeType.isText(pos.container())) {
            return insertInline$1(before2, pos.container());
          } else {
            return insertInline$1(before2, pos.getNode());
          }
        };
        var isPosCaretContainer = function(pos, caret2) {
          var caretNode = caret2.get();
          return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
        };
        var renderCaret = function(caret2, location) {
          return location.fold(function(element) {
            CaretContainerRemove.remove(caret2.get());
            var text2 = insertInlineBefore(element);
            caret2.set(text2);
            return Option.some(CaretPosition$1(text2, text2.length - 1));
          }, function(element) {
            return CaretFinder.firstPositionIn(element).map(function(pos) {
              if (!isPosCaretContainer(pos, caret2)) {
                CaretContainerRemove.remove(caret2.get());
                var text2 = insertInlinePos(pos, true);
                caret2.set(text2);
                return CaretPosition$1(text2, 1);
              } else {
                return CaretPosition$1(caret2.get(), 1);
              }
            });
          }, function(element) {
            return CaretFinder.lastPositionIn(element).map(function(pos) {
              if (!isPosCaretContainer(pos, caret2)) {
                CaretContainerRemove.remove(caret2.get());
                var text2 = insertInlinePos(pos, false);
                caret2.set(text2);
                return CaretPosition$1(text2, text2.length - 1);
              } else {
                return CaretPosition$1(caret2.get(), caret2.get().length - 1);
              }
            });
          }, function(element) {
            CaretContainerRemove.remove(caret2.get());
            var text2 = insertInlineAfter(element);
            caret2.set(text2);
            return Option.some(CaretPosition$1(text2, 1));
          });
        };
        var BoundaryCaret = { renderCaret };
        var evaluateUntil = function(fns, args) {
          for (var i2 = 0; i2 < fns.length; i2++) {
            var result = fns[i2].apply(null, args);
            if (result.isSome()) {
              return result;
            }
          }
          return Option.none();
        };
        var LazyEvaluator = { evaluateUntil };
        var Location = Adt.generate([
          { before: ["element"] },
          { start: ["element"] },
          { end: ["element"] },
          { after: ["element"] }
        ]);
        var rescope = function(rootNode, node2) {
          var parentBlock = getParentBlock(node2, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        var before$3 = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeForwards(pos);
          var scope = rescope(rootNode, nPos.container());
          return InlineUtils.findRootInline(isInlineTarget2, scope, nPos).fold(function() {
            return CaretFinder.nextPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget2, scope)).map(function(inline2) {
              return Location.before(inline2);
            });
          }, Option.none);
        };
        var isNotInsideFormatCaretContainer = function(rootNode, elm) {
          return getParentCaretContainer(rootNode, elm) === null;
        };
        var findInsideRootInline = function(isInlineTarget2, rootNode, pos) {
          return InlineUtils.findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
        };
        var start = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeBackwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline2) {
            var prevPos = CaretFinder.prevPosition(inline2, nPos);
            return prevPos.isNone() ? Option.some(Location.start(inline2)) : Option.none();
          });
        };
        var end = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeForwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind(function(inline2) {
            var nextPos = CaretFinder.nextPosition(inline2, nPos);
            return nextPos.isNone() ? Option.some(Location.end(inline2)) : Option.none();
          });
        };
        var after$2 = function(isInlineTarget2, rootNode, pos) {
          var nPos = InlineUtils.normalizeBackwards(pos);
          var scope = rescope(rootNode, nPos.container());
          return InlineUtils.findRootInline(isInlineTarget2, scope, nPos).fold(function() {
            return CaretFinder.prevPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget2, scope)).map(function(inline2) {
              return Location.after(inline2);
            });
          }, Option.none);
        };
        var isValidLocation = function(location) {
          return InlineUtils.isRtl(getElement(location)) === false;
        };
        var readLocation = function(isInlineTarget2, rootNode, pos) {
          var location = LazyEvaluator.evaluateUntil([
            before$3,
            start,
            end,
            after$2
          ], [
            isInlineTarget2,
            rootNode,
            pos
          ]);
          return location.filter(isValidLocation);
        };
        var getElement = function(location) {
          return location.fold(identity, identity, identity, identity);
        };
        var getName = function(location) {
          return location.fold(constant("before"), constant("start"), constant("end"), constant("after"));
        };
        var outside = function(location) {
          return location.fold(Location.before, Location.before, Location.after, Location.after);
        };
        var inside = function(location) {
          return location.fold(Location.start, Location.start, Location.end, Location.end);
        };
        var isEq$1 = function(location1, location2) {
          return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
        };
        var betweenInlines = function(forward, isInlineTarget2, rootNode, from2, to, location) {
          return lift2(InlineUtils.findRootInline(isInlineTarget2, rootNode, from2), InlineUtils.findRootInline(isInlineTarget2, rootNode, to), function(fromInline, toInline) {
            if (fromInline !== toInline && InlineUtils.hasSameParentBlock(rootNode, fromInline, toInline)) {
              return Location.after(forward ? fromInline : toInline);
            } else {
              return location;
            }
          }).getOr(location);
        };
        var skipNoMovement = function(fromLocation, toLocation) {
          return fromLocation.fold(constant(true), function(fromLocation2) {
            return !isEq$1(fromLocation2, toLocation);
          });
        };
        var findLocationTraverse = function(forward, isInlineTarget2, rootNode, fromLocation, pos) {
          var from2 = InlineUtils.normalizePosition(forward, pos);
          var to = CaretFinder.fromPosition(forward, rootNode, from2).map(curry(InlineUtils.normalizePosition, forward));
          var location = to.fold(function() {
            return fromLocation.map(outside);
          }, function(to2) {
            return readLocation(isInlineTarget2, rootNode, to2).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to2)).filter(curry(skipNoMovement, fromLocation));
          });
          return location.filter(isValidLocation);
        };
        var findLocationSimple = function(forward, location) {
          if (forward) {
            return location.fold(compose(Option.some, Location.start), Option.none, compose(Option.some, Location.after), Option.none);
          } else {
            return location.fold(Option.none, compose(Option.some, Location.before), Option.none, compose(Option.some, Location.end));
          }
        };
        var findLocation = function(forward, isInlineTarget2, rootNode, pos) {
          var from2 = InlineUtils.normalizePosition(forward, pos);
          var fromLocation = readLocation(isInlineTarget2, rootNode, from2);
          return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(function() {
            return findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos);
          });
        };
        var BoundaryLocation = {
          readLocation,
          findLocation,
          prevLocation: curry(findLocation, false),
          nextLocation: curry(findLocation, true),
          getElement,
          outside,
          inside
        };
        var hasSelectionModifyApi = function(editor) {
          return isFunction(editor.selection.getSel().modify);
        };
        var moveRel = function(forward, selection, pos) {
          var delta2 = forward ? 1 : -1;
          selection.setRng(CaretPosition$1(pos.container(), pos.offset() + delta2).toRange());
          selection.getSel().modify("move", forward ? "forward" : "backward", "word");
          return true;
        };
        var moveByWord = function(forward, editor) {
          var rng = editor.selection.getRng();
          var pos = forward ? CaretPosition$1.fromRangeEnd(rng) : CaretPosition$1.fromRangeStart(rng);
          if (!hasSelectionModifyApi(editor)) {
            return false;
          } else if (forward && isBeforeInline(pos)) {
            return moveRel(true, editor.selection, pos);
          } else if (!forward && isAfterInline(pos)) {
            return moveRel(false, editor.selection, pos);
          } else {
            return false;
          }
        };
        var WordSelection = {
          hasSelectionModifyApi,
          moveByWord
        };
        var setCaretPosition = function(editor, pos) {
          var rng = editor.dom.createRng();
          rng.setStart(pos.container(), pos.offset());
          rng.setEnd(pos.container(), pos.offset());
          editor.selection.setRng(rng);
        };
        var isFeatureEnabled = function(editor) {
          return editor.settings.inline_boundaries !== false;
        };
        var setSelected = function(state, elm) {
          if (state) {
            elm.setAttribute("data-mce-selected", "inline-boundary");
          } else {
            elm.removeAttribute("data-mce-selected");
          }
        };
        var renderCaretLocation = function(editor, caret2, location) {
          return BoundaryCaret.renderCaret(caret2, location).map(function(pos) {
            setCaretPosition(editor, pos);
            return location;
          });
        };
        var findLocation$1 = function(editor, caret2, forward) {
          var rootNode = editor.getBody();
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var location = BoundaryLocation.findLocation(forward, isInlineTarget2, rootNode, from2);
          return location.bind(function(location2) {
            return renderCaretLocation(editor, caret2, location2);
          });
        };
        var toggleInlines = function(isInlineTarget2, dom2, elms) {
          var selectedInlines = filter(dom2.select('*[data-mce-selected="inline-boundary"]'), isInlineTarget2);
          var targetInlines = filter(elms, isInlineTarget2);
          each(difference(selectedInlines, targetInlines), curry(setSelected, false));
          each(difference(targetInlines, selectedInlines), curry(setSelected, true));
        };
        var safeRemoveCaretContainer = function(editor, caret2) {
          if (editor.selection.isCollapsed() && editor.composing !== true && caret2.get()) {
            var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            if (CaretPosition$1.isTextPosition(pos) && InlineUtils.isAtZwsp(pos) === false) {
              setCaretPosition(editor, CaretContainerRemove.removeAndReposition(caret2.get(), pos));
              caret2.set(null);
            }
          }
        };
        var renderInsideInlineCaret = function(isInlineTarget2, editor, caret2, elms) {
          if (editor.selection.isCollapsed()) {
            var inlines = filter(elms, isInlineTarget2);
            each(inlines, function(inline2) {
              var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
              BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), pos).bind(function(location) {
                return renderCaretLocation(editor, caret2, location);
              });
            });
          }
        };
        var move = function(editor, caret2, forward) {
          return function() {
            return isFeatureEnabled(editor) ? findLocation$1(editor, caret2, forward).isSome() : false;
          };
        };
        var moveWord = function(forward, editor, caret2) {
          return function() {
            return isFeatureEnabled(editor) ? WordSelection.moveByWord(forward, editor) : false;
          };
        };
        var setupSelectedState = function(editor) {
          var caret2 = Cell(null);
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          editor.on("NodeChange", function(e) {
            if (isFeatureEnabled(editor)) {
              toggleInlines(isInlineTarget2, editor.dom, e.parents);
              safeRemoveCaretContainer(editor, caret2);
              renderInsideInlineCaret(isInlineTarget2, editor, caret2, e.parents);
            }
          });
          return caret2;
        };
        var moveNextWord = curry(moveWord, true);
        var movePrevWord = curry(moveWord, false);
        var BoundarySelection = {
          move,
          moveNextWord,
          movePrevWord,
          setupSelectedState,
          setCaretPosition
        };
        var isFeatureEnabled$1 = function(editor) {
          return editor.settings.inline_boundaries !== false;
        };
        var rangeFromPositions = function(from2, to) {
          var range3 = domGlobals.document.createRange();
          range3.setStart(from2.container(), from2.offset());
          range3.setEnd(to.container(), to.offset());
          return range3;
        };
        var hasOnlyTwoOrLessPositionsLeft = function(elm) {
          return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function(firstPos, lastPos) {
            var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
            var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
            return CaretFinder.nextPosition(elm, normalizedFirstPos).map(function(pos) {
              return pos.isEqual(normalizedLastPos);
            }).getOr(true);
          }).getOr(true);
        };
        var setCaretLocation = function(editor, caret2) {
          return function(location) {
            return BoundaryCaret.renderCaret(caret2, location).map(function(pos) {
              BoundarySelection.setCaretPosition(editor, pos);
              return true;
            }).getOr(false);
          };
        };
        var deleteFromTo = function(editor, caret2, from2, to) {
          var rootNode = editor.getBody();
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          editor.undoManager.ignore(function() {
            editor.selection.setRng(rangeFromPositions(from2, to));
            editor.execCommand("Delete");
            BoundaryLocation.readLocation(isInlineTarget2, rootNode, CaretPosition$1.fromRangeStart(editor.selection.getRng())).map(BoundaryLocation.inside).map(setCaretLocation(editor, caret2));
          });
          editor.nodeChanged();
        };
        var rescope$1 = function(rootNode, node2) {
          var parentBlock = getParentBlock(node2, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        var backspaceDeleteCollapsed = function(editor, caret2, forward, from2) {
          var rootNode = rescope$1(editor.getBody(), from2.container());
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var fromLocation = BoundaryLocation.readLocation(isInlineTarget2, rootNode, from2);
          return fromLocation.bind(function(location) {
            if (forward) {
              return location.fold(constant(Option.some(BoundaryLocation.inside(location))), Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none);
            } else {
              return location.fold(Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none, constant(Option.some(BoundaryLocation.inside(location))));
            }
          }).map(setCaretLocation(editor, caret2)).getOrThunk(function() {
            var toPosition = CaretFinder.navigate(forward, rootNode, from2);
            var toLocation = toPosition.bind(function(pos) {
              return BoundaryLocation.readLocation(isInlineTarget2, rootNode, pos);
            });
            if (fromLocation.isSome() && toLocation.isSome()) {
              return InlineUtils.findRootInline(isInlineTarget2, rootNode, from2).map(function(elm) {
                if (hasOnlyTwoOrLessPositionsLeft(elm)) {
                  DeleteElement.deleteElement(editor, forward, Element2.fromDom(elm));
                  return true;
                } else {
                  return false;
                }
              }).getOr(false);
            } else {
              return toLocation.bind(function(_) {
                return toPosition.map(function(to) {
                  if (forward) {
                    deleteFromTo(editor, caret2, from2, to);
                  } else {
                    deleteFromTo(editor, caret2, to, from2);
                  }
                  return true;
                });
              }).getOr(false);
            }
          });
        };
        var backspaceDelete$3 = function(editor, caret2, forward) {
          if (editor.selection.isCollapsed() && isFeatureEnabled$1(editor)) {
            var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            return backspaceDeleteCollapsed(editor, caret2, forward, from2);
          }
          return false;
        };
        var InlineBoundaryDelete = { backspaceDelete: backspaceDelete$3 };
        var tableCellRng = Immutable("start", "end");
        var tableSelection = Immutable("rng", "table", "cells");
        var deleteAction = Adt.generate([
          { removeTable: ["element"] },
          { emptyCells: ["cells"] }
        ]);
        var isRootFromElement = function(root2) {
          return curry(eq, root2);
        };
        var getClosestCell = function(container, isRoot) {
          return closest$1(Element2.fromDom(container), "td,th", isRoot);
        };
        var getClosestTable = function(cell2, isRoot) {
          return ancestor$1(cell2, "table", isRoot);
        };
        var isExpandedCellRng = function(cellRng) {
          return eq(cellRng.start(), cellRng.end()) === false;
        };
        var getTableFromCellRng = function(cellRng, isRoot) {
          return getClosestTable(cellRng.start(), isRoot).bind(function(startParentTable) {
            return getClosestTable(cellRng.end(), isRoot).bind(function(endParentTable) {
              return eq(startParentTable, endParentTable) ? Option.some(startParentTable) : Option.none();
            });
          });
        };
        var getTableCells = function(table2) {
          return descendants$1(table2, "td,th");
        };
        var getCellRangeFromStartTable = function(cellRng, isRoot) {
          return getClosestTable(cellRng.start(), isRoot).bind(function(table2) {
            return last(getTableCells(table2)).map(function(endCell) {
              return tableCellRng(cellRng.start(), endCell);
            });
          });
        };
        var partialSelection = function(isRoot, rng) {
          var startCell = getClosestCell(rng.startContainer, isRoot);
          var endCell = getClosestCell(rng.endContainer, isRoot);
          return rng.collapsed ? Option.none() : lift2(startCell, endCell, tableCellRng).fold(function() {
            return startCell.fold(function() {
              return endCell.bind(function(endCell2) {
                return getClosestTable(endCell2, isRoot).bind(function(table2) {
                  return head(getTableCells(table2)).map(function(startCell2) {
                    return tableCellRng(startCell2, endCell2);
                  });
                });
              });
            }, function(startCell2) {
              return getClosestTable(startCell2, isRoot).bind(function(table2) {
                return last(getTableCells(table2)).map(function(endCell2) {
                  return tableCellRng(startCell2, endCell2);
                });
              });
            });
          }, function(cellRng) {
            return isWithinSameTable(isRoot, cellRng) ? Option.none() : getCellRangeFromStartTable(cellRng, isRoot);
          });
        };
        var isWithinSameTable = function(isRoot, cellRng) {
          return getTableFromCellRng(cellRng, isRoot).isSome();
        };
        var getCellRng = function(rng, isRoot) {
          var startCell = getClosestCell(rng.startContainer, isRoot);
          var endCell = getClosestCell(rng.endContainer, isRoot);
          return lift2(startCell, endCell, tableCellRng).filter(isExpandedCellRng).filter(function(cellRng) {
            return isWithinSameTable(isRoot, cellRng);
          }).orThunk(function() {
            return partialSelection(isRoot, rng);
          });
        };
        var getTableSelectionFromCellRng = function(cellRng, isRoot) {
          return getTableFromCellRng(cellRng, isRoot).map(function(table2) {
            return tableSelection(cellRng, table2, getTableCells(table2));
          });
        };
        var getTableSelectionFromRng = function(root2, rng) {
          var isRoot = isRootFromElement(root2);
          return getCellRng(rng, isRoot).bind(function(cellRng) {
            return getTableSelectionFromCellRng(cellRng, isRoot);
          });
        };
        var getCellIndex = function(cells, cell2) {
          return findIndex(cells, function(x) {
            return eq(x, cell2);
          });
        };
        var getSelectedCells = function(tableSelection2) {
          return lift2(getCellIndex(tableSelection2.cells(), tableSelection2.rng().start()), getCellIndex(tableSelection2.cells(), tableSelection2.rng().end()), function(startIndex, endIndex) {
            return tableSelection2.cells().slice(startIndex, endIndex + 1);
          });
        };
        var getAction = function(tableSelection2) {
          return getSelectedCells(tableSelection2).map(function(selected) {
            var cells = tableSelection2.cells();
            return selected.length === cells.length ? deleteAction.removeTable(tableSelection2.table()) : deleteAction.emptyCells(selected);
          });
        };
        var getActionFromCells = function(cells) {
          return deleteAction.emptyCells(cells);
        };
        var getActionFromRange = function(root2, rng) {
          return getTableSelectionFromRng(root2, rng).bind(getAction);
        };
        var TableDeleteAction = {
          getActionFromRange,
          getActionFromCells
        };
        var getRanges = function(selection) {
          var ranges = [];
          if (selection) {
            for (var i2 = 0; i2 < selection.rangeCount; i2++) {
              ranges.push(selection.getRangeAt(i2));
            }
          }
          return ranges;
        };
        var getSelectedNodes = function(ranges) {
          return bind(ranges, function(range3) {
            var node2 = getSelectedNode(range3);
            return node2 ? [Element2.fromDom(node2)] : [];
          });
        };
        var hasMultipleRanges = function(selection) {
          return getRanges(selection).length > 1;
        };
        var MultiRange = {
          getRanges,
          getSelectedNodes,
          hasMultipleRanges
        };
        var getCellsFromRanges = function(ranges) {
          return filter(MultiRange.getSelectedNodes(ranges), isTableCell);
        };
        var getCellsFromElement = function(elm) {
          var selectedCells = descendants$1(elm, "td[data-mce-selected],th[data-mce-selected]");
          return selectedCells;
        };
        var getCellsFromElementOrRanges = function(ranges, element) {
          var selectedCells = getCellsFromElement(element);
          var rangeCells = getCellsFromRanges(ranges);
          return selectedCells.length > 0 ? selectedCells : rangeCells;
        };
        var getCellsFromEditor = function(editor) {
          return getCellsFromElementOrRanges(MultiRange.getRanges(editor.selection.getSel()), Element2.fromDom(editor.getBody()));
        };
        var TableCellSelection = {
          getCellsFromRanges,
          getCellsFromElement,
          getCellsFromElementOrRanges,
          getCellsFromEditor
        };
        var emptyCells = function(editor, cells) {
          each(cells, PaddingBr.fillWithPaddingBr);
          editor.selection.setCursorLocation(cells[0].dom(), 0);
          return true;
        };
        var deleteTableElement = function(editor, table2) {
          DeleteElement.deleteElement(editor, false, table2);
          return true;
        };
        var deleteCellRange = function(editor, rootElm, rng) {
          return TableDeleteAction.getActionFromRange(rootElm, rng).map(function(action2) {
            return action2.fold(curry(deleteTableElement, editor), curry(emptyCells, editor));
          });
        };
        var deleteCaptionRange = function(editor, caption) {
          return emptyElement(editor, caption);
        };
        var deleteTableRange = function(editor, rootElm, rng, startElm) {
          return getParentCaption(rootElm, startElm).fold(function() {
            return deleteCellRange(editor, rootElm, rng);
          }, function(caption) {
            return deleteCaptionRange(editor, caption);
          }).getOr(false);
        };
        var deleteRange$1 = function(editor, startElm) {
          var rootNode = Element2.fromDom(editor.getBody());
          var rng = editor.selection.getRng();
          var selectedCells = TableCellSelection.getCellsFromEditor(editor);
          return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
        };
        var getParentCell = function(rootElm, elm) {
          return find(Parents.parentsAndSelf(elm, rootElm), isTableCell);
        };
        var getParentCaption = function(rootElm, elm) {
          return find(Parents.parentsAndSelf(elm, rootElm), function(elm2) {
            return name(elm2) === "caption";
          });
        };
        var deleteBetweenCells = function(editor, rootElm, forward, fromCell, from2) {
          return CaretFinder.navigate(forward, editor.getBody(), from2).bind(function(to) {
            return getParentCell(rootElm, Element2.fromDom(to.getNode())).map(function(toCell) {
              return eq(toCell, fromCell) === false;
            });
          });
        };
        var emptyElement = function(editor, elm) {
          PaddingBr.fillWithPaddingBr(elm);
          editor.selection.setCursorLocation(elm.dom(), 0);
          return Option.some(true);
        };
        var isDeleteOfLastCharPos = function(fromCaption, forward, from2, to) {
          return CaretFinder.firstPositionIn(fromCaption.dom()).bind(function(first2) {
            return CaretFinder.lastPositionIn(fromCaption.dom()).map(function(last2) {
              return forward ? from2.isEqual(first2) && to.isEqual(last2) : from2.isEqual(last2) && to.isEqual(first2);
            });
          }).getOr(true);
        };
        var emptyCaretCaption = function(editor, elm) {
          return emptyElement(editor, elm);
        };
        var validateCaretCaption = function(rootElm, fromCaption, to) {
          return getParentCaption(rootElm, Element2.fromDom(to.getNode())).map(function(toCaption) {
            return eq(toCaption, fromCaption) === false;
          });
        };
        var deleteCaretInsideCaption = function(editor, rootElm, forward, fromCaption, from2) {
          return CaretFinder.navigate(forward, editor.getBody(), from2).bind(function(to) {
            return isDeleteOfLastCharPos(fromCaption, forward, from2, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);
          }).or(Option.some(true));
        };
        var deleteCaretCells = function(editor, forward, rootElm, startElm) {
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return getParentCell(rootElm, startElm).bind(function(fromCell) {
            return Empty.isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2);
          });
        };
        var deleteCaretCaption = function(editor, forward, rootElm, fromCaption) {
          var from2 = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return Empty.isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
        };
        var deleteCaret = function(editor, forward, startElm) {
          var rootElm = Element2.fromDom(editor.getBody());
          return getParentCaption(rootElm, startElm).fold(function() {
            return deleteCaretCells(editor, forward, rootElm, startElm);
          }, function(fromCaption) {
            return deleteCaretCaption(editor, forward, rootElm, fromCaption);
          }).getOr(false);
        };
        var backspaceDelete$4 = function(editor, forward) {
          var startElm = Element2.fromDom(editor.selection.getStart(true));
          var cells = TableCellSelection.getCellsFromEditor(editor);
          return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret(editor, forward, startElm) : deleteRange$1(editor, startElm);
        };
        var TableDelete = { backspaceDelete: backspaceDelete$4 };
        var isEq$2 = FormatUtils.isEq;
        var matchesUnInheritedFormatSelector = function(ed, node2, name2) {
          var formatList = ed.formatter.get(name2);
          if (formatList) {
            for (var i2 = 0; i2 < formatList.length; i2++) {
              if (formatList[i2].inherit === false && ed.dom.is(node2, formatList[i2].selector)) {
                return true;
              }
            }
          }
          return false;
        };
        var matchParents = function(editor, node2, name2, vars) {
          var root2 = editor.dom.getRoot();
          if (node2 === root2) {
            return false;
          }
          node2 = editor.dom.getParent(node2, function(node3) {
            if (matchesUnInheritedFormatSelector(editor, node3, name2)) {
              return true;
            }
            return node3.parentNode === root2 || !!matchNode(editor, node3, name2, vars, true);
          });
          return matchNode(editor, node2, name2, vars);
        };
        var matchName = function(dom2, node2, format2) {
          if (isEq$2(node2, format2.inline)) {
            return true;
          }
          if (isEq$2(node2, format2.block)) {
            return true;
          }
          if (format2.selector) {
            return node2.nodeType === 1 && dom2.is(node2, format2.selector);
          }
        };
        var matchItems = function(dom2, node2, format2, itemName, similar, vars) {
          var key, value2;
          var items = format2[itemName];
          var i2;
          if (format2.onmatch) {
            return format2.onmatch(node2, format2, itemName);
          }
          if (items) {
            if (typeof items.length === "undefined") {
              for (key in items) {
                if (items.hasOwnProperty(key)) {
                  if (itemName === "attributes") {
                    value2 = dom2.getAttrib(node2, key);
                  } else {
                    value2 = FormatUtils.getStyle(dom2, node2, key);
                  }
                  if (similar && !value2 && !format2.exact) {
                    return;
                  }
                  if ((!similar || format2.exact) && !isEq$2(value2, FormatUtils.normalizeStyleValue(dom2, FormatUtils.replaceVars(items[key], vars), key))) {
                    return;
                  }
                }
              }
            } else {
              for (i2 = 0; i2 < items.length; i2++) {
                if (itemName === "attributes" ? dom2.getAttrib(node2, items[i2]) : FormatUtils.getStyle(dom2, node2, items[i2])) {
                  return format2;
                }
              }
            }
          }
          return format2;
        };
        var matchNode = function(ed, node2, name2, vars, similar) {
          var formatList = ed.formatter.get(name2);
          var format2, i2, x, classes;
          var dom2 = ed.dom;
          if (formatList && node2) {
            for (i2 = 0; i2 < formatList.length; i2++) {
              format2 = formatList[i2];
              if (matchName(ed.dom, node2, format2) && matchItems(dom2, node2, format2, "attributes", similar, vars) && matchItems(dom2, node2, format2, "styles", similar, vars)) {
                if (classes = format2.classes) {
                  for (x = 0; x < classes.length; x++) {
                    if (!ed.dom.hasClass(node2, classes[x])) {
                      return;
                    }
                  }
                }
                return format2;
              }
            }
          }
        };
        var match = function(editor, name2, vars, node2) {
          var startNode;
          if (node2) {
            return matchParents(editor, node2, name2, vars);
          }
          node2 = editor.selection.getNode();
          if (matchParents(editor, node2, name2, vars)) {
            return true;
          }
          startNode = editor.selection.getStart();
          if (startNode !== node2) {
            if (matchParents(editor, startNode, name2, vars)) {
              return true;
            }
          }
          return false;
        };
        var matchAll = function(editor, names, vars) {
          var startElement;
          var matchedFormatNames = [];
          var checkedMap = {};
          startElement = editor.selection.getStart();
          editor.dom.getParent(startElement, function(node2) {
            var i2, name2;
            for (i2 = 0; i2 < names.length; i2++) {
              name2 = names[i2];
              if (!checkedMap[name2] && matchNode(editor, node2, name2, vars)) {
                checkedMap[name2] = true;
                matchedFormatNames.push(name2);
              }
            }
          }, editor.dom.getRoot());
          return matchedFormatNames;
        };
        var canApply = function(editor, name2) {
          var formatList = editor.formatter.get(name2);
          var startNode, parents2, i2, x, selector;
          var dom2 = editor.dom;
          if (formatList) {
            startNode = editor.selection.getStart();
            parents2 = FormatUtils.getParents(dom2, startNode);
            for (x = formatList.length - 1; x >= 0; x--) {
              selector = formatList[x].selector;
              if (!selector || formatList[x].defaultBlock) {
                return true;
              }
              for (i2 = parents2.length - 1; i2 >= 0; i2--) {
                if (dom2.is(parents2[i2], selector)) {
                  return true;
                }
              }
            }
          }
          return false;
        };
        var MatchFormat = {
          matchNode,
          matchName,
          match,
          matchAll,
          canApply,
          matchesUnInheritedFormatSelector
        };
        var splitText = function(node2, offset) {
          return node2.splitText(offset);
        };
        var split$1 = function(rng) {
          var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
          if (startContainer === endContainer && NodeType.isText(startContainer)) {
            if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
              endContainer = splitText(startContainer, startOffset);
              startContainer = endContainer.previousSibling;
              if (endOffset > startOffset) {
                endOffset = endOffset - startOffset;
                startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
                endOffset = endContainer.nodeValue.length;
                startOffset = 0;
              } else {
                endOffset = 0;
              }
            }
          } else {
            if (NodeType.isText(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
              startContainer = splitText(startContainer, startOffset);
              startOffset = 0;
            }
            if (NodeType.isText(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
              endContainer = splitText(endContainer, endOffset).previousSibling;
              endOffset = endContainer.nodeValue.length;
            }
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        var SplitRange = { split: split$1 };
        var ZWSP$1 = Zwsp.ZWSP, CARET_ID$1 = "_mce_caret";
        var importNode = function(ownerDocument, node2) {
          return ownerDocument.importNode(node2, true);
        };
        var getEmptyCaretContainers = function(node2) {
          var nodes = [];
          while (node2) {
            if (node2.nodeType === 3 && node2.nodeValue !== ZWSP$1 || node2.childNodes.length > 1) {
              return [];
            }
            if (node2.nodeType === 1) {
              nodes.push(node2);
            }
            node2 = node2.firstChild;
          }
          return nodes;
        };
        var isCaretContainerEmpty = function(node2) {
          return getEmptyCaretContainers(node2).length > 0;
        };
        var findFirstTextNode = function(node2) {
          var walker;
          if (node2) {
            walker = new TreeWalker(node2, node2);
            for (node2 = walker.current(); node2; node2 = walker.next()) {
              if (node2.nodeType === 3) {
                return node2;
              }
            }
          }
          return null;
        };
        var createCaretContainer = function(fill) {
          var caretContainer = Element2.fromTag("span");
          setAll(caretContainer, {
            "id": CARET_ID$1,
            "data-mce-bogus": "1",
            "data-mce-type": "format-caret"
          });
          if (fill) {
            append(caretContainer, Element2.fromText(ZWSP$1));
          }
          return caretContainer;
        };
        var trimZwspFromCaretContainer = function(caretContainerNode) {
          var textNode = findFirstTextNode(caretContainerNode);
          if (textNode && textNode.nodeValue.charAt(0) === ZWSP$1) {
            textNode.deleteData(0, 1);
          }
          return textNode;
        };
        var removeCaretContainerNode = function(editor, node2, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var dom2 = editor.dom, selection = editor.selection;
          if (isCaretContainerEmpty(node2)) {
            DeleteElement.deleteElement(editor, false, Element2.fromDom(node2), moveCaret2);
          } else {
            var rng = selection.getRng();
            var block2 = dom2.getParent(node2, dom2.isBlock);
            var textNode = trimZwspFromCaretContainer(node2);
            if (rng.startContainer === textNode && rng.startOffset > 0) {
              rng.setStart(textNode, rng.startOffset - 1);
            }
            if (rng.endContainer === textNode && rng.endOffset > 0) {
              rng.setEnd(textNode, rng.endOffset - 1);
            }
            dom2.remove(node2, true);
            if (block2 && dom2.isEmpty(block2)) {
              PaddingBr.fillWithPaddingBr(Element2.fromDom(block2));
            }
            selection.setRng(rng);
          }
        };
        var removeCaretContainer = function(editor, node2, moveCaret2) {
          if (moveCaret2 === void 0) {
            moveCaret2 = true;
          }
          var dom2 = editor.dom, selection = editor.selection;
          if (!node2) {
            node2 = getParentCaretContainer(editor.getBody(), selection.getStart());
            if (!node2) {
              while (node2 = dom2.get(CARET_ID$1)) {
                removeCaretContainerNode(editor, node2, false);
              }
            }
          } else {
            removeCaretContainerNode(editor, node2, moveCaret2);
          }
        };
        var insertCaretContainerNode = function(editor, caretContainer, formatNode) {
          var dom2 = editor.dom, block2 = dom2.getParent(formatNode, curry(FormatUtils.isTextBlock, editor));
          if (block2 && dom2.isEmpty(block2)) {
            formatNode.parentNode.replaceChild(caretContainer, formatNode);
          } else {
            PaddingBr.removeTrailingBr(Element2.fromDom(formatNode));
            if (dom2.isEmpty(formatNode)) {
              formatNode.parentNode.replaceChild(caretContainer, formatNode);
            } else {
              dom2.insertAfter(caretContainer, formatNode);
            }
          }
        };
        var appendNode = function(parentNode, node2) {
          parentNode.appendChild(node2);
          return node2;
        };
        var insertFormatNodesIntoCaretContainer = function(formatNodes, caretContainer) {
          var innerMostFormatNode = foldr(formatNodes, function(parentNode, formatNode) {
            return appendNode(parentNode, formatNode.cloneNode(false));
          }, caretContainer);
          return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
        };
        var applyCaretFormat = function(editor, name2, vars) {
          var rng, caretContainer, textNode, offset, bookmark, container, text2;
          var selection = editor.selection;
          rng = selection.getRng(true);
          offset = rng.startOffset;
          container = rng.startContainer;
          text2 = container.nodeValue;
          caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
          if (caretContainer) {
            textNode = findFirstTextNode(caretContainer);
          }
          var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
          if (text2 && offset > 0 && offset < text2.length && wordcharRegex.test(text2.charAt(offset)) && wordcharRegex.test(text2.charAt(offset - 1))) {
            bookmark = selection.getBookmark();
            rng.collapse(true);
            rng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name2));
            rng = SplitRange.split(rng);
            editor.formatter.apply(name2, vars, rng);
            selection.moveToBookmark(bookmark);
          } else {
            if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
              caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom());
              textNode = caretContainer.firstChild;
              rng.insertNode(caretContainer);
              offset = 1;
              editor.formatter.apply(name2, vars, caretContainer);
            } else {
              editor.formatter.apply(name2, vars, caretContainer);
            }
            selection.setCursorLocation(textNode, offset);
          }
        };
        var removeCaretFormat = function(editor, name2, vars, similar) {
          var dom2 = editor.dom, selection = editor.selection;
          var container, offset, bookmark;
          var hasContentAfter, node2, formatNode;
          var parents2 = [], rng = selection.getRng();
          var caretContainer;
          container = rng.startContainer;
          offset = rng.startOffset;
          node2 = container;
          if (container.nodeType === 3) {
            if (offset !== container.nodeValue.length) {
              hasContentAfter = true;
            }
            node2 = node2.parentNode;
          }
          while (node2) {
            if (MatchFormat.matchNode(editor, node2, name2, vars, similar)) {
              formatNode = node2;
              break;
            }
            if (node2.nextSibling) {
              hasContentAfter = true;
            }
            parents2.push(node2);
            node2 = node2.parentNode;
          }
          if (!formatNode) {
            return;
          }
          if (hasContentAfter) {
            bookmark = selection.getBookmark();
            rng.collapse(true);
            var expandedRng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name2), true);
            expandedRng = SplitRange.split(expandedRng);
            editor.formatter.remove(name2, vars, expandedRng);
            selection.moveToBookmark(bookmark);
          } else {
            caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
            var newCaretContainer = createCaretContainer(false).dom();
            var caretNode = insertFormatNodesIntoCaretContainer(parents2, newCaretContainer);
            if (caretContainer) {
              insertCaretContainerNode(editor, newCaretContainer, caretContainer);
            } else {
              insertCaretContainerNode(editor, newCaretContainer, formatNode);
            }
            removeCaretContainerNode(editor, caretContainer, false);
            selection.setCursorLocation(caretNode, 1);
            if (dom2.isEmpty(formatNode)) {
              dom2.remove(formatNode);
            }
          }
        };
        var disableCaretContainer = function(editor, keyCode) {
          var selection = editor.selection, body = editor.getBody();
          removeCaretContainer(editor, null, false);
          if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP$1) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
          if (keyCode === 37 || keyCode === 39) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
        };
        var setup$2 = function(editor) {
          editor.on("mouseup keydown", function(e) {
            disableCaretContainer(editor, e.keyCode);
          });
        };
        var replaceWithCaretFormat = function(targetNode, formatNodes) {
          var caretContainer = createCaretContainer(false);
          var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom());
          before(Element2.fromDom(targetNode), caretContainer);
          remove$1(Element2.fromDom(targetNode));
          return CaretPosition$1(innerMost, 0);
        };
        var isFormatElement = function(editor, element) {
          var inlineElements = editor.schema.getTextInlineElements();
          return inlineElements.hasOwnProperty(name(element)) && !isCaretNode(element.dom()) && !NodeType.isBogus(element.dom());
        };
        var isEmptyCaretFormatElement = function(element) {
          return isCaretNode(element.dom()) && isCaretContainerEmpty(element.dom());
        };
        var getParentInlines = function(rootElm, startElm) {
          var parents2 = Parents.parentsAndSelf(startElm, rootElm);
          return findIndex(parents2, isBlock2).fold(constant(parents2), function(index) {
            return parents2.slice(0, index);
          });
        };
        var hasOnlyOneChild$1 = function(elm) {
          return children(elm).length === 1;
        };
        var deleteLastPosition = function(forward, editor, target2, parentInlines) {
          var isFormatElement$1 = curry(isFormatElement, editor);
          var formatNodes = map2(filter(parentInlines, isFormatElement$1), function(elm) {
            return elm.dom();
          });
          if (formatNodes.length === 0) {
            DeleteElement.deleteElement(editor, forward, target2);
          } else {
            var pos = replaceWithCaretFormat(target2.dom(), formatNodes);
            editor.selection.setRng(pos.toRange());
          }
        };
        var deleteCaret$1 = function(editor, forward) {
          var rootElm = Element2.fromDom(editor.getBody());
          var startElm = Element2.fromDom(editor.selection.getStart());
          var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild$1);
          return last(parentInlines).map(function(target2) {
            var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            if (DeleteUtils.willDeleteLastPositionInElement(forward, fromPos, target2.dom()) && !isEmptyCaretFormatElement(target2)) {
              deleteLastPosition(forward, editor, target2, parentInlines);
              return true;
            } else {
              return false;
            }
          }).getOr(false);
        };
        var backspaceDelete$5 = function(editor, forward) {
          return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
        };
        var InlineFormatDelete = { backspaceDelete: backspaceDelete$5 };
        var getPos$1 = function(elm) {
          var x = 0, y = 0;
          var offsetParent = elm;
          while (offsetParent && offsetParent.nodeType) {
            x += offsetParent.offsetLeft || 0;
            y += offsetParent.offsetTop || 0;
            offsetParent = offsetParent.offsetParent;
          }
          return {
            x,
            y
          };
        };
        var fireScrollIntoViewEvent = function(editor, elm, alignToTop) {
          var scrollEvent = {
            elm,
            alignToTop
          };
          editor.fire("scrollIntoView", scrollEvent);
          return scrollEvent.isDefaultPrevented();
        };
        var scrollElementIntoView = function(editor, elm, alignToTop) {
          var y, viewPort;
          var dom2 = editor.dom;
          var root2 = dom2.getRoot();
          var viewPortY, viewPortH, offsetY = 0;
          if (fireScrollIntoViewEvent(editor, elm, alignToTop)) {
            return;
          }
          if (!NodeType.isElement(elm)) {
            return;
          }
          if (alignToTop === false) {
            offsetY = elm.offsetHeight;
          }
          if (root2.nodeName !== "BODY") {
            var scrollContainer = editor.selection.getScrollContainer();
            if (scrollContainer) {
              y = getPos$1(elm).y - getPos$1(scrollContainer).y + offsetY;
              viewPortH = scrollContainer.clientHeight;
              viewPortY = scrollContainer.scrollTop;
              if (y < viewPortY || y + 25 > viewPortY + viewPortH) {
                scrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;
              }
              return;
            }
          }
          viewPort = dom2.getViewPort(editor.getWin());
          y = dom2.getPos(elm).y + offsetY;
          viewPortY = viewPort.y;
          viewPortH = viewPort.h;
          if (y < viewPort.y || y + 25 > viewPortY + viewPortH) {
            editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);
          }
        };
        var getViewPortRect = function(editor) {
          if (editor.inline) {
            return editor.getBody().getBoundingClientRect();
          } else {
            var win = editor.getWin();
            return {
              left: 0,
              right: win.innerWidth,
              top: 0,
              bottom: win.innerHeight,
              width: win.innerWidth,
              height: win.innerHeight
            };
          }
        };
        var scrollBy = function(editor, dx, dy) {
          if (editor.inline) {
            editor.getBody().scrollLeft += dx;
            editor.getBody().scrollTop += dy;
          } else {
            editor.getWin().scrollBy(dx, dy);
          }
        };
        var scrollRangeIntoView = function(editor, rng) {
          head(CaretPosition.fromRangeStart(rng).getClientRects()).each(function(rngRect) {
            var bodyRect = getViewPortRect(editor);
            var overflow = getOverflow(bodyRect, rngRect);
            var margin = 4;
            var dx = overflow.x > 0 ? overflow.x + margin : overflow.x - margin;
            var dy = overflow.y > 0 ? overflow.y + margin : overflow.y - margin;
            scrollBy(editor, overflow.x !== 0 ? dx : 0, overflow.y !== 0 ? dy : 0);
          });
        };
        var ScrollIntoView = {
          scrollElementIntoView,
          scrollRangeIntoView
        };
        var isContentEditableTrue$2 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$6 = NodeType.isContentEditableFalse;
        var showCaret = function(direction, editor, node2, before2, scrollIntoView) {
          return editor._selectionOverrides.showCaret(direction, node2, before2, scrollIntoView);
        };
        var getNodeRange = function(node2) {
          var rng = node2.ownerDocument.createRange();
          rng.selectNode(node2);
          return rng;
        };
        var selectNode = function(editor, node2) {
          var e = editor.fire("BeforeObjectSelected", { target: node2 });
          if (e.isDefaultPrevented()) {
            return null;
          }
          return getNodeRange(node2);
        };
        var renderCaretAtRange = function(editor, range3, scrollIntoView) {
          var normalizedRange = normalizeRange(1, editor.getBody(), range3);
          var caretPosition = CaretPosition$1.fromRangeStart(normalizedRange);
          var caretPositionNode = caretPosition.getNode();
          if (isContentEditableFalse$6(caretPositionNode)) {
            return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
          }
          var caretPositionBeforeNode = caretPosition.getNode(true);
          if (isContentEditableFalse$6(caretPositionBeforeNode)) {
            return showCaret(1, editor, caretPositionBeforeNode, false, false);
          }
          var ceRoot = editor.dom.getParent(caretPosition.getNode(), function(node2) {
            return isContentEditableFalse$6(node2) || isContentEditableTrue$2(node2);
          });
          if (isContentEditableFalse$6(ceRoot)) {
            return showCaret(1, editor, ceRoot, false, scrollIntoView);
          }
          return null;
        };
        var renderRangeCaret = function(editor, range3, scrollIntoView) {
          if (!range3 || !range3.collapsed) {
            return range3;
          }
          var caretRange = renderCaretAtRange(editor, range3, scrollIntoView);
          if (caretRange) {
            return caretRange;
          }
          return range3;
        };
        var moveToRange = function(editor, rng) {
          editor.selection.setRng(rng);
          ScrollIntoView.scrollRangeIntoView(editor, editor.selection.getRng());
        };
        var trimEmptyTextNode$1 = function(dom2, node2) {
          if (NodeType.isText(node2) && node2.data.length === 0) {
            dom2.remove(node2);
          }
        };
        var deleteContentAndShowCaret = function(editor, range3, node2, direction, forward, peekCaretPosition) {
          var caretRange = showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true);
          if (range3.collapsed) {
            var deleteRange2 = range3.cloneRange();
            if (forward) {
              deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
            } else {
              deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
            }
            deleteRange2.deleteContents();
          } else {
            range3.deleteContents();
          }
          editor.selection.setRng(caretRange);
          trimEmptyTextNode$1(editor.dom, node2);
          return true;
        };
        var deleteCefBoundaryText = function(editor, forward) {
          var range3 = editor.selection.getRng();
          if (!NodeType.isText(range3.commonAncestorContainer)) {
            return false;
          }
          var direction = forward ? HDirection.Forwards : HDirection.Backwards;
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
          var isBeforeContentEditableFalseFn = forward ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
          var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range3);
          var nextCaretPosition = InlineUtils.normalizePosition(forward, getNextPosFn(caretPosition));
          if (!nextCaretPosition) {
            return false;
          } else if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
            return deleteContentAndShowCaret(editor, range3, caretPosition.getNode(), direction, forward, nextCaretPosition);
          }
          var peekCaretPosition = getNextPosFn(nextCaretPosition);
          if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
              return deleteContentAndShowCaret(editor, range3, caretPosition.getNode(), direction, forward, peekCaretPosition);
            }
          }
          return false;
        };
        var backspaceDelete$6 = function(editor, forward) {
          return deleteCefBoundaryText(editor, forward);
        };
        var CefBoundaryDelete = { backspaceDelete: backspaceDelete$6 };
        var nativeCommand = function(editor, command) {
          editor.getDoc().execCommand(command, false, null);
        };
        var deleteCommand = function(editor) {
          if (CefDelete.backspaceDelete(editor, false)) {
            return;
          } else if (CefBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (InlineBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (BlockBoundaryDelete.backspaceDelete(editor, false)) {
            return;
          } else if (TableDelete.backspaceDelete(editor)) {
            return;
          } else if (BlockRangeDelete.backspaceDelete(editor, false)) {
            return;
          } else if (InlineFormatDelete.backspaceDelete(editor, false)) {
            return;
          } else {
            nativeCommand(editor, "Delete");
            DeleteUtils.paddEmptyBody(editor);
          }
        };
        var forwardDeleteCommand = function(editor) {
          if (CefDelete.backspaceDelete(editor, true)) {
            return;
          } else if (CefBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (InlineBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (BlockBoundaryDelete.backspaceDelete(editor, true)) {
            return;
          } else if (TableDelete.backspaceDelete(editor)) {
            return;
          } else if (BlockRangeDelete.backspaceDelete(editor, true)) {
            return;
          } else if (InlineFormatDelete.backspaceDelete(editor, true)) {
            return;
          } else {
            nativeCommand(editor, "ForwardDelete");
          }
        };
        var DeleteCommands = {
          deleteCommand,
          forwardDeleteCommand
        };
        var getSpecifiedFontProp = function(propName, rootElm, elm) {
          var getProperty = function(elm2) {
            return getRaw(elm2, propName);
          };
          var isRoot = function(elm2) {
            return eq(Element2.fromDom(rootElm), elm2);
          };
          return closest(Element2.fromDom(elm), function(elm2) {
            return getProperty(elm2).isSome();
          }, isRoot).bind(getProperty);
        };
        var round$1 = function(number, precision) {
          var factor = Math.pow(10, precision);
          return Math.round(number * factor) / factor;
        };
        var toPt = function(fontSize, precision) {
          if (/[0-9.]+px$/.test(fontSize)) {
            return round$1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + "pt";
          }
          return fontSize;
        };
        var normalizeFontFamily = function(fontFamily) {
          return fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
        };
        var getComputedFontProp = function(propName, elm) {
          return Option.from(DOMUtils$1.DOM.getStyle(elm, propName, true));
        };
        var getFontProp = function(propName) {
          return function(rootElm, elm) {
            return Option.from(elm).map(Element2.fromDom).filter(isElement).bind(function(element) {
              return getSpecifiedFontProp(propName, rootElm, element.dom()).or(getComputedFontProp(propName, element.dom()));
            }).getOr("");
          };
        };
        var FontInfo = {
          getFontSize: getFontProp("font-size"),
          getFontFamily: compose(normalizeFontFamily, getFontProp("font-family")),
          toPt
        };
        var findFirstCaretElement = function(editor) {
          return CaretFinder.firstPositionIn(editor.getBody()).map(function(caret2) {
            var container = caret2.container();
            return NodeType.isText(container) ? container.parentNode : container;
          });
        };
        var isRangeAtStartOfNode = function(rng, root2) {
          return rng.startContainer === root2 && rng.startOffset === 0;
        };
        var getCaretElement = function(editor) {
          return Option.from(editor.selection.getRng()).bind(function(rng) {
            var root2 = editor.getBody();
            return isRangeAtStartOfNode(rng, root2) ? Option.none() : Option.from(editor.selection.getStart(true));
          });
        };
        var fromFontSizeNumber = function(editor, value2) {
          if (/^[0-9\.]+$/.test(value2)) {
            var fontSizeNumber = parseInt(value2, 10);
            if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
              var fontSizes = Settings.getFontStyleValues(editor);
              var fontClasses = Settings.getFontSizeClasses(editor);
              if (fontClasses) {
                return fontClasses[fontSizeNumber - 1] || value2;
              } else {
                return fontSizes[fontSizeNumber - 1] || value2;
              }
            } else {
              return value2;
            }
          } else {
            return value2;
          }
        };
        var fontNameAction = function(editor, value2) {
          editor.formatter.toggle("fontname", { value: fromFontSizeNumber(editor, value2) });
          editor.nodeChanged();
        };
        var fontNameQuery = function(editor) {
          return getCaretElement(editor).fold(function() {
            return findFirstCaretElement(editor).map(function(caretElement) {
              return FontInfo.getFontFamily(editor.getBody(), caretElement);
            }).getOr("");
          }, function(caretElement) {
            return FontInfo.getFontFamily(editor.getBody(), caretElement);
          });
        };
        var fontSizeAction = function(editor, value2) {
          editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
          editor.nodeChanged();
        };
        var fontSizeQuery = function(editor) {
          return getCaretElement(editor).fold(function() {
            return findFirstCaretElement(editor).map(function(caretElement) {
              return FontInfo.getFontSize(editor.getBody(), caretElement);
            }).getOr("");
          }, function(caretElement) {
            return FontInfo.getFontSize(editor.getBody(), caretElement);
          });
        };
        var isEq$3 = function(rng1, rng2) {
          return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
        };
        var RangeCompare = { isEq: isEq$3 };
        var findParent = function(node2, rootNode, predicate) {
          while (node2 && node2 !== rootNode) {
            if (predicate(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var hasParent = function(node2, rootNode, predicate) {
          return findParent(node2, rootNode, predicate) !== null;
        };
        var hasParentWithName = function(node2, rootNode, name2) {
          return hasParent(node2, rootNode, function(node3) {
            return node3.nodeName === name2;
          });
        };
        var isTable$2 = function(node2) {
          return node2 && node2.nodeName === "TABLE";
        };
        var isTableCell$3 = function(node2) {
          return node2 && /^(TD|TH|CAPTION)$/.test(node2.nodeName);
        };
        var isCeFalseCaretContainer = function(node2, rootNode) {
          return isCaretContainer(node2) && hasParent(node2, rootNode, isCaretNode) === false;
        };
        var hasBrBeforeAfter = function(dom2, node2, left) {
          var walker = new TreeWalker(node2, dom2.getParent(node2.parentNode, dom2.isBlock) || dom2.getRoot());
          while (node2 = walker[left ? "prev" : "next"]()) {
            if (NodeType.isBr(node2)) {
              return true;
            }
          }
        };
        var isPrevNode = function(node2, name2) {
          return node2.previousSibling && node2.previousSibling.nodeName === name2;
        };
        var hasContentEditableFalseParent = function(body, node2) {
          while (node2 && node2 !== body) {
            if (NodeType.isContentEditableFalse(node2)) {
              return true;
            }
            node2 = node2.parentNode;
          }
          return false;
        };
        var findTextNodeRelative = function(dom2, isAfterNode, collapsed, left, startNode) {
          var walker, lastInlineElement, parentBlockContainer;
          var body = dom2.getRoot();
          var node2;
          var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          parentBlockContainer = dom2.getParent(startNode.parentNode, dom2.isBlock) || body;
          if (left && NodeType.isBr(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
            return Option.some(CaretPosition(startNode.parentNode, dom2.nodeIndex(startNode)));
          }
          walker = new TreeWalker(startNode, parentBlockContainer);
          while (node2 = walker[left ? "prev" : "next"]()) {
            if (dom2.getContentEditableParent(node2) === "false" || isCeFalseCaretContainer(node2, body)) {
              return Option.none();
            }
            if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
              if (hasParentWithName(node2, body, "A") === false) {
                return Option.some(CaretPosition(node2, left ? node2.nodeValue.length : 0));
              }
              return Option.none();
            }
            if (dom2.isBlock(node2) || nonEmptyElementsMap[node2.nodeName.toLowerCase()]) {
              return Option.none();
            }
            lastInlineElement = node2;
          }
          if (collapsed && lastInlineElement) {
            return Option.some(CaretPosition(lastInlineElement, 0));
          }
          return Option.none();
        };
        var normalizeEndPoint = function(dom2, collapsed, start2, rng) {
          var container, offset, walker;
          var body = dom2.getRoot();
          var node2, nonEmptyElementsMap;
          var directionLeft, isAfterNode, normalized = false;
          container = rng[(start2 ? "start" : "end") + "Container"];
          offset = rng[(start2 ? "start" : "end") + "Offset"];
          isAfterNode = NodeType.isElement(container) && offset === container.childNodes.length;
          nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          directionLeft = start2;
          if (isCaretContainer(container)) {
            return Option.none();
          }
          if (NodeType.isElement(container) && offset > container.childNodes.length - 1) {
            directionLeft = false;
          }
          if (NodeType.isDocument(container)) {
            container = body;
            offset = 0;
          }
          if (container === body) {
            if (directionLeft) {
              node2 = container.childNodes[offset > 0 ? offset - 1 : 0];
              if (node2) {
                if (isCaretContainer(node2)) {
                  return Option.none();
                }
                if (nonEmptyElementsMap[node2.nodeName] || isTable$2(node2)) {
                  return Option.none();
                }
              }
            }
            if (container.hasChildNodes()) {
              offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
              container = container.childNodes[offset];
              offset = NodeType.isText(container) && isAfterNode ? container.data.length : 0;
              if (!collapsed && container === body.lastChild && isTable$2(container)) {
                return Option.none();
              }
              if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
                return Option.none();
              }
              if (container.hasChildNodes() && isTable$2(container) === false) {
                node2 = container;
                walker = new TreeWalker(container, body);
                do {
                  if (NodeType.isContentEditableFalse(node2) || isCaretContainer(node2)) {
                    normalized = false;
                    break;
                  }
                  if (NodeType.isText(node2) && node2.nodeValue.length > 0) {
                    offset = directionLeft ? 0 : node2.nodeValue.length;
                    container = node2;
                    normalized = true;
                    break;
                  }
                  if (nonEmptyElementsMap[node2.nodeName.toLowerCase()] && !isTableCell$3(node2)) {
                    offset = dom2.nodeIndex(node2);
                    container = node2.parentNode;
                    if (!directionLeft) {
                      offset++;
                    }
                    normalized = true;
                    break;
                  }
                } while (node2 = directionLeft ? walker.next() : walker.prev());
              }
            }
          }
          if (collapsed) {
            if (NodeType.isText(container) && offset === 0) {
              findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each(function(pos) {
                container = pos.container();
                offset = pos.offset();
                normalized = true;
              });
            }
            if (NodeType.isElement(container)) {
              node2 = container.childNodes[offset];
              if (!node2) {
                node2 = container.childNodes[offset - 1];
              }
              if (node2 && NodeType.isBr(node2) && !isPrevNode(node2, "A") && !hasBrBeforeAfter(dom2, node2, false) && !hasBrBeforeAfter(dom2, node2, true)) {
                findTextNodeRelative(dom2, isAfterNode, collapsed, true, node2).each(function(pos) {
                  container = pos.container();
                  offset = pos.offset();
                  normalized = true;
                });
              }
            }
          }
          if (directionLeft && !collapsed && NodeType.isText(container) && offset === container.nodeValue.length) {
            findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each(function(pos) {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
          return normalized ? Option.some(CaretPosition(container, offset)) : Option.none();
        };
        var normalize$2 = function(dom2, rng) {
          var collapsed = rng.collapsed, normRng = rng.cloneRange();
          var startPos = CaretPosition.fromRangeStart(rng);
          normalizeEndPoint(dom2, collapsed, true, normRng).each(function(pos) {
            if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
              normRng.setStart(pos.container(), pos.offset());
            }
          });
          if (!collapsed) {
            normalizeEndPoint(dom2, collapsed, false, normRng).each(function(pos) {
              normRng.setEnd(pos.container(), pos.offset());
            });
          }
          if (collapsed) {
            normRng.collapse(true);
          }
          return RangeCompare.isEq(rng, normRng) ? Option.none() : Option.some(normRng);
        };
        var NormalizeRange = { normalize: normalize$2 };
        var hasRightSideContent = function(schema, container, parentBlock) {
          var walker = new TreeWalker(container, parentBlock);
          var node2;
          var nonEmptyElementsMap = schema.getNonEmptyElements();
          while (node2 = walker.next()) {
            if (nonEmptyElementsMap[node2.nodeName.toLowerCase()] || node2.length > 0) {
              return true;
            }
          }
        };
        var scrollToBr = function(dom2, selection, brElm) {
          var marker2 = dom2.create("span", {}, "&nbsp;");
          brElm.parentNode.insertBefore(marker2, brElm);
          selection.scrollIntoView(marker2);
          dom2.remove(marker2);
        };
        var moveSelectionToBr = function(dom2, selection, brElm, extraBr) {
          var rng = dom2.createRng();
          if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
          } else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
          }
          selection.setRng(rng);
        };
        var insertBrAtCaret = function(editor, evt) {
          var selection = editor.selection;
          var dom2 = editor.dom;
          var rng = selection.getRng();
          var brElm;
          var extraBr;
          NormalizeRange.normalize(dom2, rng).each(function(normRng) {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          var offset = rng.startOffset;
          var container = rng.startContainer;
          if (container.nodeType === 1 && container.hasChildNodes()) {
            var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && container.nodeType === 3) {
              offset = container.nodeValue.length;
            } else {
              offset = 0;
            }
          }
          var parentBlock = dom2.getParent(container, dom2.isBlock);
          var containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          var isControlKey = evt && evt.ctrlKey;
          if (containerBlockName === "LI" && !isControlKey) {
            parentBlock = containerBlock;
          }
          if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
            if (!hasRightSideContent(editor.schema, container, parentBlock)) {
              brElm = dom2.create("br");
              rng.insertNode(brElm);
              rng.setStartAfter(brElm);
              rng.setEndAfter(brElm);
              extraBr = true;
            }
          }
          brElm = dom2.create("br");
          rangeInsertNode(dom2, rng, brElm);
          scrollToBr(dom2, selection, brElm);
          moveSelectionToBr(dom2, selection, brElm, extraBr);
          editor.undoManager.add();
        };
        var insertBrBefore = function(editor, inline2) {
          var br = Element2.fromTag("br");
          before(Element2.fromDom(inline2), br);
          editor.undoManager.add();
        };
        var insertBrAfter = function(editor, inline2) {
          if (!hasBrAfter(editor.getBody(), inline2)) {
            after(Element2.fromDom(inline2), Element2.fromTag("br"));
          }
          var br = Element2.fromTag("br");
          after(Element2.fromDom(inline2), br);
          scrollToBr(editor.dom, editor.selection, br.dom());
          moveSelectionToBr(editor.dom, editor.selection, br.dom(), false);
          editor.undoManager.add();
        };
        var isBeforeBr$1 = function(pos) {
          return NodeType.isBr(pos.getNode());
        };
        var hasBrAfter = function(rootNode, startNode) {
          if (isBeforeBr$1(CaretPosition$1.after(startNode))) {
            return true;
          } else {
            return CaretFinder.nextPosition(rootNode, CaretPosition$1.after(startNode)).map(function(pos) {
              return NodeType.isBr(pos.getNode());
            }).getOr(false);
          }
        };
        var isAnchorLink = function(elm) {
          return elm && elm.nodeName === "A" && "href" in elm;
        };
        var isInsideAnchor = function(location) {
          return location.fold(constant(false), isAnchorLink, isAnchorLink, constant(false));
        };
        var readInlineAnchorLocation = function(editor) {
          var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
          var position = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          return BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), position).filter(isInsideAnchor);
        };
        var insertBrOutsideAnchor = function(editor, location) {
          location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
        };
        var insert = function(editor, evt) {
          var anchorLocation = readInlineAnchorLocation(editor);
          if (anchorLocation.isSome()) {
            anchorLocation.each(curry(insertBrOutsideAnchor, editor));
          } else {
            insertBrAtCaret(editor, evt);
          }
        };
        var InsertBr = { insert };
        var create$3 = Immutable("start", "soffset", "finish", "foffset");
        var SimRange = { create: create$3 };
        var adt = Adt.generate([
          { before: ["element"] },
          {
            on: [
              "element",
              "offset"
            ]
          },
          { after: ["element"] }
        ]);
        var cata = function(subject, onBefore, onOn, onAfter) {
          return subject.fold(onBefore, onOn, onAfter);
        };
        var getStart = function(situ) {
          return situ.fold(identity, identity, identity);
        };
        var before$4 = adt.before;
        var on = adt.on;
        var after$3 = adt.after;
        var Situ = {
          before: before$4,
          on,
          after: after$3,
          cata,
          getStart
        };
        var adt$1 = Adt.generate([
          { domRange: ["rng"] },
          {
            relative: [
              "startSitu",
              "finishSitu"
            ]
          },
          {
            exact: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        var exactFromRange = function(simRange) {
          return adt$1.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
        };
        var getStart$1 = function(selection) {
          return selection.match({
            domRange: function(rng) {
              return Element2.fromDom(rng.startContainer);
            },
            relative: function(startSitu, finishSitu) {
              return Situ.getStart(startSitu);
            },
            exact: function(start2, soffset, finish, foffset) {
              return start2;
            }
          });
        };
        var domRange = adt$1.domRange;
        var relative = adt$1.relative;
        var exact = adt$1.exact;
        var getWin = function(selection) {
          var start2 = getStart$1(selection);
          return defaultView(start2);
        };
        var range2 = SimRange.create;
        var Selection = {
          domRange,
          relative,
          exact,
          exactFromRange,
          getWin,
          range: range2
        };
        var browser$3 = PlatformDetection$1.detect().browser;
        var clamp = function(offset, element) {
          var max2 = isText(element) ? get$4(element).length : children(element).length + 1;
          if (offset > max2) {
            return max2;
          } else if (offset < 0) {
            return 0;
          }
          return offset;
        };
        var normalizeRng = function(rng) {
          return Selection.range(rng.start(), clamp(rng.soffset(), rng.start()), rng.finish(), clamp(rng.foffset(), rng.finish()));
        };
        var isOrContains = function(root2, elm) {
          return !NodeType.isRestrictedNode(elm.dom()) && (contains$3(root2, elm) || eq(root2, elm));
        };
        var isRngInRoot = function(root2) {
          return function(rng) {
            return isOrContains(root2, rng.start()) && isOrContains(root2, rng.finish());
          };
        };
        var shouldStore = function(editor) {
          return editor.inline === true || browser$3.isIE();
        };
        var nativeRangeToSelectionRange = function(r) {
          return Selection.range(Element2.fromDom(r.startContainer), r.startOffset, Element2.fromDom(r.endContainer), r.endOffset);
        };
        var readRange = function(win) {
          var selection = win.getSelection();
          var rng = !selection || selection.rangeCount === 0 ? Option.none() : Option.from(selection.getRangeAt(0));
          return rng.map(nativeRangeToSelectionRange);
        };
        var getBookmark$2 = function(root2) {
          var win = defaultView(root2);
          return readRange(win.dom()).filter(isRngInRoot(root2));
        };
        var validate = function(root2, bookmark) {
          return Option.from(bookmark).filter(isRngInRoot(root2)).map(normalizeRng);
        };
        var bookmarkToNativeRng = function(bookmark) {
          var rng = domGlobals.document.createRange();
          try {
            rng.setStart(bookmark.start().dom(), bookmark.soffset());
            rng.setEnd(bookmark.finish().dom(), bookmark.foffset());
            return Option.some(rng);
          } catch (_) {
            return Option.none();
          }
        };
        var store = function(editor) {
          var newBookmark = shouldStore(editor) ? getBookmark$2(Element2.fromDom(editor.getBody())) : Option.none();
          editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
        };
        var storeNative = function(editor, rng) {
          var root2 = Element2.fromDom(editor.getBody());
          var range3 = shouldStore(editor) ? Option.from(rng) : Option.none();
          var newBookmark = range3.map(nativeRangeToSelectionRange).filter(isRngInRoot(root2));
          editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
        };
        var getRng = function(editor) {
          var bookmark = editor.bookmark ? editor.bookmark : Option.none();
          return bookmark.bind(curry(validate, Element2.fromDom(editor.getBody()))).bind(bookmarkToNativeRng);
        };
        var restore = function(editor) {
          getRng(editor).each(function(rng) {
            editor.selection.setRng(rng);
          });
        };
        var SelectionBookmark = {
          store,
          storeNative,
          readRange,
          restore,
          getRng,
          getBookmark: getBookmark$2,
          validate
        };
        var indentElement = function(dom2, command, useMargin, value2, unit, element) {
          if (dom2.getContentEditable(element) === "false") {
            return;
          }
          var indentStyleName = useMargin ? "margin" : "padding";
          indentStyleName = element.nodeName === "TABLE" ? "margin" : indentStyleName;
          indentStyleName += dom2.getStyle(element, "direction", true) === "rtl" ? "Right" : "Left";
          if (command === "outdent") {
            var styleValue = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - value2);
            dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
          } else {
            var styleValue = parseInt(element.style[indentStyleName] || 0, 10) + value2 + unit;
            dom2.setStyle(element, indentStyleName, styleValue);
          }
        };
        var isListComponent = function(el2) {
          return isList(el2) || isListItem(el2);
        };
        var parentIsListComponent = function(el2) {
          return parent(el2).map(isListComponent).getOr(false);
        };
        var getBlocksToIndent = function(editor) {
          return filter(map2(editor.selection.getSelectedBlocks(), Element2.fromDom), function(el2) {
            return !isListComponent(el2) && !parentIsListComponent(el2);
          });
        };
        var handle = function(editor, command) {
          var settings = editor.settings, dom2 = editor.dom, selection = editor.selection, formatter = editor.formatter;
          var indentUnit = /[a-z%]+$/i.exec(settings.indentation)[0];
          var indentValue = parseInt(settings.indentation, 10);
          var useMargin = editor.getParam("indent_use_margin", false);
          if (!editor.queryCommandState("InsertUnorderedList") && !editor.queryCommandState("InsertOrderedList")) {
            if (!settings.forced_root_block && !dom2.getParent(selection.getNode(), dom2.isBlock)) {
              formatter.apply("div");
            }
          }
          each(getBlocksToIndent(editor), function(block2) {
            indentElement(dom2, command, useMargin, indentValue, indentUnit, block2.dom());
          });
        };
        var each$a = Tools.each, extend$2 = Tools.extend;
        var map$3 = Tools.map, inArray$2 = Tools.inArray;
        function EditorCommands(editor) {
          var dom2, selection, formatter;
          var commands = {
            state: {},
            exec: {},
            value: {}
          };
          var settings = editor.settings, bookmark;
          editor.on("PreInit", function() {
            dom2 = editor.dom;
            selection = editor.selection;
            settings = editor.settings;
            formatter = editor.formatter;
          });
          var execCommand = function(command, ui, value2, args) {
            var func, customCommand, state = false;
            if (editor.removed) {
              return;
            }
            if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
              editor.focus();
            } else {
              SelectionBookmark.restore(editor);
            }
            args = editor.fire("BeforeExecCommand", {
              command,
              ui,
              value: value2
            });
            if (args.isDefaultPrevented()) {
              return false;
            }
            customCommand = command.toLowerCase();
            if (func = commands.exec[customCommand]) {
              func(customCommand, ui, value2);
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            each$a(editor.plugins, function(p) {
              if (p.execCommand && p.execCommand(command, ui, value2)) {
                editor.fire("ExecCommand", {
                  command,
                  ui,
                  value: value2
                });
                state = true;
                return false;
              }
            });
            if (state) {
              return state;
            }
            if (editor.theme && editor.theme.execCommand && editor.theme.execCommand(command, ui, value2)) {
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            try {
              state = editor.getDoc().execCommand(command, ui, value2);
            } catch (ex) {
            }
            if (state) {
              editor.fire("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            return false;
          };
          var queryCommandState = function(command) {
            var func;
            if (editor.quirks.isHidden() || editor.removed) {
              return;
            }
            command = command.toLowerCase();
            if (func = commands.state[command]) {
              return func(command);
            }
            try {
              return editor.getDoc().queryCommandState(command);
            } catch (ex) {
            }
            return false;
          };
          var queryCommandValue = function(command) {
            var func;
            if (editor.quirks.isHidden() || editor.removed) {
              return;
            }
            command = command.toLowerCase();
            if (func = commands.value[command]) {
              return func(command);
            }
            try {
              return editor.getDoc().queryCommandValue(command);
            } catch (ex) {
            }
          };
          var addCommands = function(commandList, type2) {
            type2 = type2 || "exec";
            each$a(commandList, function(callback, command) {
              each$a(command.toLowerCase().split(","), function(command2) {
                commands[type2][command2] = callback;
              });
            });
          };
          var addCommand = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.exec[command] = function(command2, ui, value2, args) {
              return callback.call(scope || editor, ui, value2, args);
            };
          };
          var queryCommandSupported = function(command) {
            command = command.toLowerCase();
            if (commands.exec[command]) {
              return true;
            }
            try {
              return editor.getDoc().queryCommandSupported(command);
            } catch (ex) {
            }
            return false;
          };
          var addQueryStateHandler = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.state[command] = function() {
              return callback.call(scope || editor);
            };
          };
          var addQueryValueHandler = function(command, callback, scope) {
            command = command.toLowerCase();
            commands.value[command] = function() {
              return callback.call(scope || editor);
            };
          };
          var hasCustomCommand = function(command) {
            command = command.toLowerCase();
            return !!commands.exec[command];
          };
          extend$2(this, {
            execCommand,
            queryCommandState,
            queryCommandValue,
            queryCommandSupported,
            addCommands,
            addCommand,
            addQueryStateHandler,
            addQueryValueHandler,
            hasCustomCommand
          });
          var execNativeCommand = function(command, ui, value2) {
            if (ui === void 0) {
              ui = false;
            }
            if (value2 === void 0) {
              value2 = null;
            }
            return editor.getDoc().execCommand(command, ui, value2);
          };
          var isFormatMatch = function(name2) {
            return formatter.match(name2);
          };
          var toggleFormat = function(name2, value2) {
            formatter.toggle(name2, value2 ? { value: value2 } : void 0);
            editor.nodeChanged();
          };
          var storeSelection = function(type2) {
            bookmark = selection.getBookmark(type2);
          };
          var restoreSelection = function() {
            selection.moveToBookmark(bookmark);
          };
          addCommands({
            "mceResetDesignMode,mceBeginUndoLevel": function() {
            },
            "mceEndUndoLevel,mceAddUndoLevel": function() {
              editor.undoManager.add();
            },
            "Cut,Copy,Paste": function(command) {
              var doc2 = editor.getDoc();
              var failed;
              try {
                execNativeCommand(command);
              } catch (ex) {
                failed = true;
              }
              if (command === "paste" && !doc2.queryCommandEnabled(command)) {
                failed = true;
              }
              if (failed || !doc2.queryCommandSupported(command)) {
                var msg = editor.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
                if (Env.mac) {
                  msg = msg.replace(/Ctrl\+/g, "âŒ˜+");
                }
                editor.notificationManager.open({
                  text: msg,
                  type: "error"
                });
              }
            },
            "unlink": function() {
              if (selection.isCollapsed()) {
                var elm = editor.dom.getParent(editor.selection.getStart(), "a");
                if (elm) {
                  editor.dom.remove(elm, true);
                }
                return;
              }
              formatter.remove("link");
            },
            "JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone": function(command) {
              var align = command.substring(7);
              if (align === "full") {
                align = "justify";
              }
              each$a("left,center,right,justify".split(","), function(name2) {
                if (align !== name2) {
                  formatter.remove("align" + name2);
                }
              });
              if (align !== "none") {
                toggleFormat("align" + align);
              }
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
              var listElm, listParent;
              execNativeCommand(command);
              listElm = dom2.getParent(selection.getNode(), "ol,ul");
              if (listElm) {
                listParent = listElm.parentNode;
                if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                  storeSelection();
                  dom2.split(listParent, listElm);
                  restoreSelection();
                }
              }
            },
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
              toggleFormat(command);
            },
            "ForeColor,HiliteColor": function(command, ui, value2) {
              toggleFormat(command, value2);
            },
            "FontName": function(command, ui, value2) {
              fontNameAction(editor, value2);
            },
            "FontSize": function(command, ui, value2) {
              fontSizeAction(editor, value2);
            },
            "RemoveFormat": function(command) {
              formatter.remove(command);
            },
            "mceBlockQuote": function() {
              toggleFormat("blockquote");
            },
            "FormatBlock": function(command, ui, value2) {
              return toggleFormat(value2 || "p");
            },
            "mceCleanup": function() {
              var bookmark2 = selection.getBookmark();
              editor.setContent(editor.getContent());
              selection.moveToBookmark(bookmark2);
            },
            "mceRemoveNode": function(command, ui, value2) {
              var node2 = value2 || selection.getNode();
              if (node2 !== editor.getBody()) {
                storeSelection();
                editor.dom.remove(node2, true);
                restoreSelection();
              }
            },
            "mceSelectNodeDepth": function(command, ui, value2) {
              var counter = 0;
              dom2.getParent(selection.getNode(), function(node2) {
                if (node2.nodeType === 1 && counter++ === value2) {
                  selection.select(node2);
                  return false;
                }
              }, editor.getBody());
            },
            "mceSelectNode": function(command, ui, value2) {
              selection.select(value2);
            },
            "mceInsertContent": function(command, ui, value2) {
              InsertContent.insertAtCaret(editor, value2);
            },
            "mceInsertRawHTML": function(command, ui, value2) {
              selection.setContent("tiny_mce_marker");
              var content = editor.getContent();
              editor.setContent(content.replace(/tiny_mce_marker/g, function() {
                return value2;
              }));
            },
            "mceToggleFormat": function(command, ui, value2) {
              toggleFormat(value2);
            },
            "mceSetContent": function(command, ui, value2) {
              editor.setContent(value2);
            },
            "Indent,Outdent": function(command) {
              handle(editor, command);
            },
            "mceRepaint": function() {
            },
            "InsertHorizontalRule": function() {
              editor.execCommand("mceInsertContent", false, "<hr />");
            },
            "mceToggleVisualAid": function() {
              editor.hasVisual = !editor.hasVisual;
              editor.addVisual();
            },
            "mceReplaceContent": function(command, ui, value2) {
              editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, selection.getContent({ format: "text" })));
            },
            "mceInsertLink": function(command, ui, value2) {
              var anchor;
              if (typeof value2 === "string") {
                value2 = { href: value2 };
              }
              anchor = dom2.getParent(selection.getNode(), "a");
              value2.href = value2.href.replace(" ", "%20");
              if (!anchor || !value2.href) {
                formatter.remove("link");
              }
              if (value2.href) {
                formatter.apply("link", value2, anchor);
              }
            },
            "selectAll": function() {
              var editingHost = dom2.getParent(selection.getStart(), NodeType.isContentEditableTrue);
              if (editingHost) {
                var rng = dom2.createRng();
                rng.selectNodeContents(editingHost);
                selection.setRng(rng);
              }
            },
            "delete": function() {
              DeleteCommands.deleteCommand(editor);
            },
            "forwardDelete": function() {
              DeleteCommands.forwardDeleteCommand(editor);
            },
            "mceNewDocument": function() {
              editor.setContent("");
            },
            "InsertLineBreak": function(command, ui, value2) {
              InsertBr.insert(editor, value2);
              return true;
            }
          });
          var alignStates = function(name2) {
            return function() {
              var nodes = selection.isCollapsed() ? [dom2.getParent(selection.getNode(), dom2.isBlock)] : selection.getSelectedBlocks();
              var matches2 = map$3(nodes, function(node2) {
                return !!formatter.matchNode(node2, name2);
              });
              return inArray$2(matches2, true) !== -1;
            };
          };
          addCommands({
            "JustifyLeft": alignStates("alignleft"),
            "JustifyCenter": alignStates("aligncenter"),
            "JustifyRight": alignStates("alignright"),
            "JustifyFull": alignStates("alignjustify"),
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": function(command) {
              return isFormatMatch(command);
            },
            "mceBlockQuote": function() {
              return isFormatMatch("blockquote");
            },
            "Outdent": function() {
              var node2;
              if (settings.inline_styles) {
                if ((node2 = dom2.getParent(selection.getStart(), dom2.isBlock)) && parseInt(node2.style.paddingLeft, 10) > 0) {
                  return true;
                }
                if ((node2 = dom2.getParent(selection.getEnd(), dom2.isBlock)) && parseInt(node2.style.paddingLeft, 10) > 0) {
                  return true;
                }
              }
              return queryCommandState("InsertUnorderedList") || queryCommandState("InsertOrderedList") || !settings.inline_styles && !!dom2.getParent(selection.getNode(), "BLOCKQUOTE");
            },
            "InsertUnorderedList,InsertOrderedList": function(command) {
              var list2 = dom2.getParent(selection.getNode(), "ul,ol");
              return list2 && (command === "insertunorderedlist" && list2.tagName === "UL" || command === "insertorderedlist" && list2.tagName === "OL");
            }
          }, "state");
          addCommands({
            Undo: function() {
              editor.undoManager.undo();
            },
            Redo: function() {
              editor.undoManager.redo();
            }
          });
          addQueryValueHandler("FontName", function() {
            return fontNameQuery(editor);
          }, this);
          addQueryValueHandler("FontSize", function() {
            return fontSizeQuery(editor);
          }, this);
        }
        var nativeEvents = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend", " ");
        var Dispatcher = function(settings) {
          var self2 = this;
          var scope, bindings = {}, toggleEvent;
          var returnFalse2 = function() {
            return false;
          };
          var returnTrue2 = function() {
            return true;
          };
          settings = settings || {};
          scope = settings.scope || self2;
          toggleEvent = settings.toggleEvent || returnFalse2;
          var fire = function(name2, args) {
            var handlers, i2, l, callback;
            name2 = name2.toLowerCase();
            args = args || {};
            args.type = name2;
            if (!args.target) {
              args.target = scope;
            }
            if (!args.preventDefault) {
              args.preventDefault = function() {
                args.isDefaultPrevented = returnTrue2;
              };
              args.stopPropagation = function() {
                args.isPropagationStopped = returnTrue2;
              };
              args.stopImmediatePropagation = function() {
                args.isImmediatePropagationStopped = returnTrue2;
              };
              args.isDefaultPrevented = returnFalse2;
              args.isPropagationStopped = returnFalse2;
              args.isImmediatePropagationStopped = returnFalse2;
            }
            if (settings.beforeFire) {
              settings.beforeFire(args);
            }
            handlers = bindings[name2];
            if (handlers) {
              for (i2 = 0, l = handlers.length; i2 < l; i2++) {
                callback = handlers[i2];
                if (callback.once) {
                  off(name2, callback.func);
                }
                if (args.isImmediatePropagationStopped()) {
                  args.stopPropagation();
                  return args;
                }
                if (callback.func.call(scope, args) === false) {
                  args.preventDefault();
                  return args;
                }
              }
            }
            return args;
          };
          var on2 = function(name2, callback, prepend2, extra) {
            var handlers, names, i2;
            if (callback === false) {
              callback = returnFalse2;
            }
            if (callback) {
              callback = { func: callback };
              if (extra) {
                Tools.extend(callback, extra);
              }
              names = name2.toLowerCase().split(" ");
              i2 = names.length;
              while (i2--) {
                name2 = names[i2];
                handlers = bindings[name2];
                if (!handlers) {
                  handlers = bindings[name2] = [];
                  toggleEvent(name2, true);
                }
                if (prepend2) {
                  handlers.unshift(callback);
                } else {
                  handlers.push(callback);
                }
              }
            }
            return self2;
          };
          var off = function(name2, callback) {
            var i2, handlers, bindingName, names, hi;
            if (name2) {
              names = name2.toLowerCase().split(" ");
              i2 = names.length;
              while (i2--) {
                name2 = names[i2];
                handlers = bindings[name2];
                if (!name2) {
                  for (bindingName in bindings) {
                    toggleEvent(bindingName, false);
                    delete bindings[bindingName];
                  }
                  return self2;
                }
                if (handlers) {
                  if (!callback) {
                    handlers.length = 0;
                  } else {
                    hi = handlers.length;
                    while (hi--) {
                      if (handlers[hi].func === callback) {
                        handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
                        bindings[name2] = handlers;
                      }
                    }
                  }
                  if (!handlers.length) {
                    toggleEvent(name2, false);
                    delete bindings[name2];
                  }
                }
              }
            } else {
              for (name2 in bindings) {
                toggleEvent(name2, false);
              }
              bindings = {};
            }
            return self2;
          };
          var once = function(name2, callback, prepend2) {
            return on2(name2, callback, prepend2, { once: true });
          };
          var has3 = function(name2) {
            name2 = name2.toLowerCase();
            return !(!bindings[name2] || bindings[name2].length === 0);
          };
          self2.fire = fire;
          self2.on = on2;
          self2.off = off;
          self2.once = once;
          self2.has = has3;
        };
        Dispatcher.isNative = function(name2) {
          return !!nativeEvents[name2.toLowerCase()];
        };
        var getEventDispatcher = function(obj) {
          if (!obj._eventDispatcher) {
            obj._eventDispatcher = new Dispatcher({
              scope: obj,
              toggleEvent: function(name2, state) {
                if (Dispatcher.isNative(name2) && obj.toggleNativeEvent) {
                  obj.toggleNativeEvent(name2, state);
                }
              }
            });
          }
          return obj._eventDispatcher;
        };
        var Observable = {
          fire: function(name2, args, bubble) {
            var self2 = this;
            if (self2.removed && name2 !== "remove" && name2 !== "detach") {
              return args;
            }
            args = getEventDispatcher(self2).fire(name2, args, bubble);
            if (bubble !== false && self2.parent) {
              var parent2 = self2.parent();
              while (parent2 && !args.isPropagationStopped()) {
                parent2.fire(name2, args, false);
                parent2 = parent2.parent();
              }
            }
            return args;
          },
          on: function(name2, callback, prepend2) {
            return getEventDispatcher(this).on(name2, callback, prepend2);
          },
          off: function(name2, callback) {
            return getEventDispatcher(this).off(name2, callback);
          },
          once: function(name2, callback) {
            return getEventDispatcher(this).once(name2, callback);
          },
          hasEventListeners: function(name2) {
            return getEventDispatcher(this).has(name2);
          }
        };
        var firePreProcess = function(editor, args) {
          return editor.fire("PreProcess", args);
        };
        var firePostProcess = function(editor, args) {
          return editor.fire("PostProcess", args);
        };
        var fireRemove = function(editor) {
          return editor.fire("remove");
        };
        var fireDetach = function(editor) {
          return editor.fire("detach");
        };
        var fireSwitchMode = function(editor, mode) {
          return editor.fire("SwitchMode", { mode });
        };
        var fireObjectResizeStart = function(editor, target2, width, height) {
          editor.fire("ObjectResizeStart", {
            target: target2,
            width,
            height
          });
        };
        var fireObjectResized = function(editor, target2, width, height) {
          editor.fire("ObjectResized", {
            target: target2,
            width,
            height
          });
        };
        var Events = {
          firePreProcess,
          firePostProcess,
          fireRemove,
          fireDetach,
          fireSwitchMode,
          fireObjectResizeStart,
          fireObjectResized
        };
        var setEditorCommandState = function(editor, cmd, state) {
          try {
            editor.getDoc().execCommand(cmd, false, state);
          } catch (ex) {
          }
        };
        var toggleClass = function(elm, cls, state) {
          if (has$2(elm, cls) && state === false) {
            remove$4(elm, cls);
          } else if (state) {
            add$2(elm, cls);
          }
        };
        var toggleReadOnly = function(editor, state) {
          toggleClass(Element2.fromDom(editor.getBody()), "mce-content-readonly", state);
          if (state) {
            editor.selection.controlSelection.hideResizeRect();
            editor.readonly = true;
            editor.getBody().contentEditable = "false";
          } else {
            editor.readonly = false;
            editor.getBody().contentEditable = "true";
            setEditorCommandState(editor, "StyleWithCSS", false);
            setEditorCommandState(editor, "enableInlineTableEditing", false);
            setEditorCommandState(editor, "enableObjectResizing", false);
            editor.focus();
            editor.nodeChanged();
          }
        };
        var setMode = function(editor, mode) {
          if (mode === getMode(editor)) {
            return;
          }
          if (editor.initialized) {
            toggleReadOnly(editor, mode === "readonly");
          } else {
            editor.on("init", function() {
              toggleReadOnly(editor, mode === "readonly");
            });
          }
          Events.fireSwitchMode(editor, mode);
        };
        var getMode = function(editor) {
          return editor.readonly ? "readonly" : "design";
        };
        var isReadOnly = function(editor) {
          return editor.readonly === true;
        };
        var DOM$1 = DOMUtils$1.DOM;
        var customEventRootDelegates;
        var getEventTarget = function(editor, eventName) {
          if (eventName === "selectionchange") {
            return editor.getDoc();
          }
          if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
            return editor.getDoc().documentElement;
          }
          if (editor.settings.event_root) {
            if (!editor.eventRoot) {
              editor.eventRoot = DOM$1.select(editor.settings.event_root)[0];
            }
            return editor.eventRoot;
          }
          return editor.getBody();
        };
        var isListening = function(editor) {
          return !editor.hidden && !editor.readonly;
        };
        var fireEvent = function(editor, eventName, e) {
          if (isListening(editor)) {
            editor.fire(eventName, e);
          } else if (isReadOnly(editor)) {
            e.preventDefault();
          }
        };
        var bindEventDelegate = function(editor, eventName) {
          var eventRootElm, delegate;
          if (!editor.delegates) {
            editor.delegates = {};
          }
          if (editor.delegates[eventName] || editor.removed) {
            return;
          }
          eventRootElm = getEventTarget(editor, eventName);
          if (editor.settings.event_root) {
            if (!customEventRootDelegates) {
              customEventRootDelegates = {};
              editor.editorManager.on("removeEditor", function() {
                var name2;
                if (!editor.editorManager.activeEditor) {
                  if (customEventRootDelegates) {
                    for (name2 in customEventRootDelegates) {
                      editor.dom.unbind(getEventTarget(editor, name2));
                    }
                    customEventRootDelegates = null;
                  }
                }
              });
            }
            if (customEventRootDelegates[eventName]) {
              return;
            }
            delegate = function(e) {
              var target2 = e.target;
              var editors3 = editor.editorManager.get();
              var i2 = editors3.length;
              while (i2--) {
                var body = editors3[i2].getBody();
                if (body === target2 || DOM$1.isChildOf(target2, body)) {
                  fireEvent(editors3[i2], eventName, e);
                }
              }
            };
            customEventRootDelegates[eventName] = delegate;
            DOM$1.bind(eventRootElm, eventName, delegate);
          } else {
            delegate = function(e) {
              fireEvent(editor, eventName, e);
            };
            DOM$1.bind(eventRootElm, eventName, delegate);
            editor.delegates[eventName] = delegate;
          }
        };
        var EditorObservable = {
          bindPendingEventDelegates: function() {
            var self2 = this;
            Tools.each(self2._pendingNativeEvents, function(name2) {
              bindEventDelegate(self2, name2);
            });
          },
          toggleNativeEvent: function(name2, state) {
            var self2 = this;
            if (name2 === "focus" || name2 === "blur") {
              return;
            }
            if (state) {
              if (self2.initialized) {
                bindEventDelegate(self2, name2);
              } else {
                if (!self2._pendingNativeEvents) {
                  self2._pendingNativeEvents = [name2];
                } else {
                  self2._pendingNativeEvents.push(name2);
                }
              }
            } else if (self2.initialized) {
              self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
              delete self2.delegates[name2];
            }
          },
          unbindAllNativeEvents: function() {
            var self2 = this;
            var body = self2.getBody();
            var dom2 = self2.dom;
            var name2;
            if (self2.delegates) {
              for (name2 in self2.delegates) {
                self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
              }
              delete self2.delegates;
            }
            if (!self2.inline && body && dom2) {
              body.onload = null;
              dom2.unbind(self2.getWin());
              dom2.unbind(self2.getDoc());
            }
            if (dom2) {
              dom2.unbind(body);
              dom2.unbind(self2.getContainer());
            }
          }
        };
        EditorObservable = Tools.extend({}, Observable, EditorObservable);
        var EditorObservable$1 = EditorObservable;
        var sectionResult = Immutable("sections", "settings");
        var detection = PlatformDetection$1.detect();
        var isTouch = detection.deviceType.isTouch();
        var mobilePlugins = [
          "lists",
          "autolink",
          "autosave"
        ];
        var defaultMobileSettings = { theme: "mobile" };
        var normalizePlugins = function(plugins) {
          var pluginNames = isArray(plugins) ? plugins.join(" ") : plugins;
          var trimmedPlugins = map2(isString(pluginNames) ? pluginNames.split(" ") : [], trim$2);
          return filter(trimmedPlugins, function(item) {
            return item.length > 0;
          });
        };
        var filterMobilePlugins = function(plugins) {
          return filter(plugins, curry(contains, mobilePlugins));
        };
        var extractSections = function(keys2, settings) {
          var result = bifilter(settings, function(value2, key) {
            return contains(keys2, key);
          });
          return sectionResult(result.t, result.f);
        };
        var getSection = function(sectionResult2, name2, defaults) {
          var sections = sectionResult2.sections();
          var sectionSettings = sections.hasOwnProperty(name2) ? sections[name2] : {};
          return Tools.extend({}, defaults, sectionSettings);
        };
        var hasSection = function(sectionResult2, name2) {
          return sectionResult2.sections().hasOwnProperty(name2);
        };
        var getDefaultSettings = function(id, documentBaseUrl, editor) {
          return {
            id,
            theme: "modern",
            delta_width: 0,
            delta_height: 0,
            popup_css: "",
            plugins: "",
            document_base_url: documentBaseUrl,
            add_form_submit_trigger: true,
            submit_patch: true,
            add_unload_trigger: true,
            convert_urls: true,
            relative_urls: true,
            remove_script_host: true,
            object_resizing: true,
            doctype: "<!DOCTYPE html>",
            visual: true,
            font_size_style_values: "xx-small,x-small,small,medium,large,x-large,xx-large",
            font_size_legacy_values: "xx-small,small,medium,large,x-large,xx-large,300%",
            forced_root_block: "p",
            hidden_input: true,
            render_ui: true,
            indentation: "40px",
            inline_styles: true,
            convert_fonts_to_spans: true,
            indent: "simple",
            indent_before: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            indent_after: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist",
            entity_encoding: "named",
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            ie7_compat: true
          };
        };
        var getExternalPlugins = function(overrideSettings, settings) {
          var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
          if (overrideSettings && overrideSettings.external_plugins) {
            return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
          } else {
            return userDefinedExternalPlugins;
          }
        };
        var combinePlugins = function(forcedPlugins, plugins) {
          return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
        };
        var processPlugins = function(isTouchDevice, sectionResult2, defaultOverrideSettings, settings) {
          var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
          var plugins = normalizePlugins(settings.plugins);
          var platformPlugins = isTouchDevice && hasSection(sectionResult2, "mobile") ? filterMobilePlugins(plugins) : plugins;
          var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
          return Tools.extend(settings, { plugins: combinedPlugins.join(" ") });
        };
        var isOnMobile = function(isTouchDevice, sectionResult2) {
          var isInline2 = sectionResult2.settings().inline;
          return isTouchDevice && hasSection(sectionResult2, "mobile") && !isInline2;
        };
        var combineSettings = function(isTouchDevice, defaultSettings, defaultOverrideSettings, settings) {
          var sectionResult2 = extractSections(["mobile"], settings);
          var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult2.settings(), isOnMobile(isTouchDevice, sectionResult2) ? getSection(sectionResult2, "mobile", defaultMobileSettings) : {}, {
            validate: true,
            content_editable: sectionResult2.settings().inline,
            external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult2.settings())
          });
          return processPlugins(isTouchDevice, sectionResult2, defaultOverrideSettings, extendedSettings);
        };
        var getEditorSettings = function(editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
          var defaultSettings = getDefaultSettings(id, documentBaseUrl, editor);
          return combineSettings(isTouch, defaultSettings, defaultOverrideSettings, settings);
        };
        var getFiltered = function(predicate, editor, name2) {
          return Option.from(editor.settings[name2]).filter(predicate);
        };
        var getParamObject = function(value2) {
          var output2 = {};
          if (typeof value2 === "string") {
            each(value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(","), function(val) {
              var arr2 = val.split("=");
              if (arr2.length > 1) {
                output2[Tools.trim(arr2[0])] = Tools.trim(arr2[1]);
              } else {
                output2[Tools.trim(arr2[0])] = Tools.trim(arr2);
              }
            });
          } else {
            output2 = value2;
          }
          return output2;
        };
        var isArrayOf = function(p) {
          return function(a) {
            return isArray(a) && forall2(a, p);
          };
        };
        var getParam = function(editor, name2, defaultVal, type2) {
          var value2 = name2 in editor.settings ? editor.settings[name2] : defaultVal;
          if (type2 === "hash") {
            return getParamObject(value2);
          } else if (type2 === "string") {
            return getFiltered(isString, editor, name2).getOr(defaultVal);
          } else if (type2 === "number") {
            return getFiltered(isNumber, editor, name2).getOr(defaultVal);
          } else if (type2 === "boolean") {
            return getFiltered(isBoolean, editor, name2).getOr(defaultVal);
          } else if (type2 === "object") {
            return getFiltered(isObject, editor, name2).getOr(defaultVal);
          } else if (type2 === "array") {
            return getFiltered(isArray, editor, name2).getOr(defaultVal);
          } else if (type2 === "string[]") {
            return getFiltered(isArrayOf(isString), editor, name2).getOr(defaultVal);
          } else if (type2 === "function") {
            return getFiltered(isFunction, editor, name2).getOr(defaultVal);
          } else {
            return value2;
          }
        };
        var each$b = Tools.each, explode$2 = Tools.explode;
        var keyCodeLookup = {
          f1: 112,
          f2: 113,
          f3: 114,
          f4: 115,
          f5: 116,
          f6: 117,
          f7: 118,
          f8: 119,
          f9: 120,
          f10: 121,
          f11: 122,
          f12: 123
        };
        var modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
        function Shortcuts(editor) {
          var self2 = this;
          var shortcuts = {};
          var pendingPatterns = [];
          var parseShortcut = function(pattern2) {
            var id, key;
            var shortcut = {};
            each$b(explode$2(pattern2, "+"), function(value2) {
              if (value2 in modifierNames) {
                shortcut[value2] = true;
              } else {
                if (/^[0-9]{2,}$/.test(value2)) {
                  shortcut.keyCode = parseInt(value2, 10);
                } else {
                  shortcut.charCode = value2.charCodeAt(0);
                  shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
                }
              }
            });
            id = [shortcut.keyCode];
            for (key in modifierNames) {
              if (shortcut[key]) {
                id.push(key);
              } else {
                shortcut[key] = false;
              }
            }
            shortcut.id = id.join(",");
            if (shortcut.access) {
              shortcut.alt = true;
              if (Env.mac) {
                shortcut.ctrl = true;
              } else {
                shortcut.shift = true;
              }
            }
            if (shortcut.meta) {
              if (Env.mac) {
                shortcut.meta = true;
              } else {
                shortcut.ctrl = true;
                shortcut.meta = false;
              }
            }
            return shortcut;
          };
          var createShortcut = function(pattern2, desc, cmdFunc, scope) {
            var shortcuts2;
            shortcuts2 = Tools.map(explode$2(pattern2, ">"), parseShortcut);
            shortcuts2[shortcuts2.length - 1] = Tools.extend(shortcuts2[shortcuts2.length - 1], {
              func: cmdFunc,
              scope: scope || editor
            });
            return Tools.extend(shortcuts2[0], {
              desc: editor.translate(desc),
              subpatterns: shortcuts2.slice(1)
            });
          };
          var hasModifier = function(e) {
            return e.altKey || e.ctrlKey || e.metaKey;
          };
          var isFunctionKey = function(e) {
            return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
          };
          var matchShortcut = function(e, shortcut) {
            if (!shortcut) {
              return false;
            }
            if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
              return false;
            }
            if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
              return false;
            }
            if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
              e.preventDefault();
              return true;
            }
            return false;
          };
          var executeShortcutAction = function(shortcut) {
            return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
          };
          editor.on("keyup keypress keydown", function(e) {
            if ((hasModifier(e) || isFunctionKey(e)) && !e.isDefaultPrevented()) {
              each$b(shortcuts, function(shortcut) {
                if (matchShortcut(e, shortcut)) {
                  pendingPatterns = shortcut.subpatterns.slice(0);
                  if (e.type === "keydown") {
                    executeShortcutAction(shortcut);
                  }
                  return true;
                }
              });
              if (matchShortcut(e, pendingPatterns[0])) {
                if (pendingPatterns.length === 1) {
                  if (e.type === "keydown") {
                    executeShortcutAction(pendingPatterns[0]);
                  }
                }
                pendingPatterns.shift();
              }
            }
          });
          self2.add = function(pattern2, desc, cmdFunc, scope) {
            var cmd;
            cmd = cmdFunc;
            if (typeof cmdFunc === "string") {
              cmdFunc = function() {
                editor.execCommand(cmd, false, null);
              };
            } else if (Tools.isArray(cmd)) {
              cmdFunc = function() {
                editor.execCommand(cmd[0], cmd[1], cmd[2]);
              };
            }
            each$b(explode$2(Tools.trim(pattern2.toLowerCase())), function(pattern3) {
              var shortcut = createShortcut(pattern3, desc, cmdFunc, scope);
              shortcuts[shortcut.id] = shortcut;
            });
            return true;
          };
          self2.remove = function(pattern2) {
            var shortcut = createShortcut(pattern2);
            if (shortcuts[shortcut.id]) {
              delete shortcuts[shortcut.id];
              return true;
            }
            return false;
          };
        }
        var hasFocus = function(element) {
          var doc2 = owner(element).dom();
          return element.dom() === doc2.activeElement;
        };
        var active = function(_doc) {
          var doc2 = _doc !== void 0 ? _doc.dom() : domGlobals.document;
          return Option.from(doc2.activeElement).map(Element2.fromDom);
        };
        var search = function(element) {
          return active(owner(element)).filter(function(e) {
            return element.dom().contains(e.dom());
          });
        };
        var getContentEditableHost = function(editor, node2) {
          return editor.dom.getParent(node2, function(node3) {
            return editor.dom.getContentEditable(node3) === "true";
          });
        };
        var getCollapsedNode = function(rng) {
          return rng.collapsed ? Option.from(getNode(rng.startContainer, rng.startOffset)).map(Element2.fromDom) : Option.none();
        };
        var getFocusInElement = function(root2, rng) {
          return getCollapsedNode(rng).bind(function(node2) {
            if (isTableSection(node2)) {
              return Option.some(node2);
            } else if (contains$3(root2, node2) === false) {
              return Option.some(root2);
            } else {
              return Option.none();
            }
          });
        };
        var normalizeSelection = function(editor, rng) {
          getFocusInElement(Element2.fromDom(editor.getBody()), rng).bind(function(elm) {
            return CaretFinder.firstPositionIn(elm.dom());
          }).fold(function() {
            editor.selection.normalize();
            return;
          }, function(caretPos) {
            return editor.selection.setRng(caretPos.toRange());
          });
        };
        var focusBody = function(body) {
          if (body.setActive) {
            try {
              body.setActive();
            } catch (ex) {
              body.focus();
            }
          } else {
            body.focus();
          }
        };
        var hasElementFocus = function(elm) {
          return hasFocus(elm) || search(elm).isSome();
        };
        var hasIframeFocus = function(editor) {
          return editor.iframeElement && hasFocus(Element2.fromDom(editor.iframeElement));
        };
        var hasInlineFocus = function(editor) {
          var rawBody = editor.getBody();
          return rawBody && hasElementFocus(Element2.fromDom(rawBody));
        };
        var hasFocus$1 = function(editor) {
          return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
        };
        var focusEditor = function(editor) {
          var selection = editor.selection, contentEditable2 = editor.settings.content_editable;
          var body = editor.getBody();
          var rng = selection.getRng();
          editor.quirks.refreshContentEditable();
          var contentEditableHost = getContentEditableHost(editor, selection.getNode());
          if (editor.$.contains(body, contentEditableHost)) {
            focusBody(contentEditableHost);
            normalizeSelection(editor, rng);
            activateEditor(editor);
            return;
          }
          if (editor.bookmark !== void 0 && hasFocus$1(editor) === false) {
            SelectionBookmark.getRng(editor).each(function(bookmarkRng) {
              editor.selection.setRng(bookmarkRng);
              rng = bookmarkRng;
            });
          }
          if (!contentEditable2) {
            if (!Env.opera) {
              focusBody(body);
            }
            editor.getWin().focus();
          }
          if (Env.gecko || contentEditable2) {
            focusBody(body);
            normalizeSelection(editor, rng);
          }
          activateEditor(editor);
        };
        var activateEditor = function(editor) {
          return editor.editorManager.setActive(editor);
        };
        var focus = function(editor, skipFocus) {
          if (editor.removed) {
            return;
          }
          skipFocus ? activateEditor(editor) : focusEditor(editor);
        };
        var EditorFocus = {
          focus,
          hasFocus: hasFocus$1
        };
        var getProp = function(propName, elm) {
          var rawElm = elm.dom();
          return rawElm[propName];
        };
        var getComputedSizeProp = function(propName, elm) {
          return parseInt(get$1(elm, propName), 10);
        };
        var getClientWidth = curry(getProp, "clientWidth");
        var getClientHeight = curry(getProp, "clientHeight");
        var getMarginTop = curry(getComputedSizeProp, "margin-top");
        var getMarginLeft = curry(getComputedSizeProp, "margin-left");
        var getBoundingClientRect$1 = function(elm) {
          return elm.dom().getBoundingClientRect();
        };
        var isInsideElementContentArea = function(bodyElm, clientX, clientY) {
          var clientWidth = getClientWidth(bodyElm);
          var clientHeight = getClientHeight(bodyElm);
          return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
        };
        var transpose = function(inline2, elm, clientX, clientY) {
          var clientRect = getBoundingClientRect$1(elm);
          var deltaX = inline2 ? clientRect.left + elm.dom().clientLeft + getMarginLeft(elm) : 0;
          var deltaY = inline2 ? clientRect.top + elm.dom().clientTop + getMarginTop(elm) : 0;
          var x = clientX - deltaX;
          var y = clientY - deltaY;
          return {
            x,
            y
          };
        };
        var isXYInContentArea = function(editor, clientX, clientY) {
          var bodyElm = Element2.fromDom(editor.getBody());
          var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
          var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
          return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
        };
        var fromDomSafe = function(node2) {
          return Option.from(node2).map(Element2.fromDom);
        };
        var isEditorAttachedToDom = function(editor) {
          var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
          return fromDomSafe(rawContainer).map(function(container) {
            return contains$3(owner(container), container);
          }).getOr(false);
        };
        var EditorView = {
          isXYInContentArea,
          isEditorAttachedToDom
        };
        function NotificationManagerImpl() {
          var unimplemented = function() {
            throw new Error("Theme did not provide a NotificationManager implementation.");
          };
          return {
            open: unimplemented,
            close: unimplemented,
            reposition: unimplemented,
            getArgs: unimplemented
          };
        }
        function NotificationManager(editor) {
          var notifications = [];
          var getImplementation = function() {
            var theme2 = editor.theme;
            return theme2 && theme2.getNotificationManagerImpl ? theme2.getNotificationManagerImpl() : NotificationManagerImpl();
          };
          var getTopNotification = function() {
            return Option.from(notifications[0]);
          };
          var isEqual2 = function(a, b) {
            return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
          };
          var reposition2 = function() {
            if (notifications.length > 0) {
              getImplementation().reposition(notifications);
            }
          };
          var addNotification = function(notification) {
            notifications.push(notification);
          };
          var closeNotification = function(notification) {
            findIndex(notifications, function(otherNotification) {
              return otherNotification === notification;
            }).each(function(index) {
              notifications.splice(index, 1);
            });
          };
          var open = function(args) {
            if (editor.removed || !EditorView.isEditorAttachedToDom(editor)) {
              return;
            }
            return find(notifications, function(notification) {
              return isEqual2(getImplementation().getArgs(notification), args);
            }).getOrThunk(function() {
              editor.editorManager.setActive(editor);
              var notification = getImplementation().open(args, function() {
                closeNotification(notification);
                reposition2();
              });
              addNotification(notification);
              reposition2();
              return notification;
            });
          };
          var close = function() {
            getTopNotification().each(function(notification) {
              getImplementation().close(notification);
              closeNotification(notification);
              reposition2();
            });
          };
          var getNotifications = function() {
            return notifications;
          };
          var registerEvents2 = function(editor2) {
            editor2.on("SkinLoaded", function() {
              var serviceMessage = editor2.settings.service_message;
              if (serviceMessage) {
                open({
                  text: serviceMessage,
                  type: "warning",
                  timeout: 0,
                  icon: ""
                });
              }
            });
            editor2.on("ResizeEditor ResizeWindow", function() {
              Delay.requestAnimationFrame(reposition2);
            });
            editor2.on("remove", function() {
              each(notifications.slice(), function(notification) {
                getImplementation().close(notification);
              });
            });
          };
          registerEvents2(editor);
          return {
            open,
            close,
            getNotifications
          };
        }
        function WindowManagerImpl() {
          var unimplemented = function() {
            throw new Error("Theme did not provide a WindowManager implementation.");
          };
          return {
            open: unimplemented,
            alert: unimplemented,
            confirm: unimplemented,
            close: unimplemented,
            getParams: unimplemented,
            setParams: unimplemented
          };
        }
        function WindowManager(editor) {
          var windows2 = [];
          var getImplementation = function() {
            var theme2 = editor.theme;
            return theme2 && theme2.getWindowManagerImpl ? theme2.getWindowManagerImpl() : WindowManagerImpl();
          };
          var funcBind = function(scope, f) {
            return function() {
              return f ? f.apply(scope, arguments) : void 0;
            };
          };
          var fireOpenEvent = function(win) {
            editor.fire("OpenWindow", { win });
          };
          var fireCloseEvent = function(win) {
            editor.fire("CloseWindow", { win });
          };
          var addWindow = function(win) {
            windows2.push(win);
            fireOpenEvent(win);
          };
          var closeWindow = function(win) {
            findIndex(windows2, function(otherWindow) {
              return otherWindow === win;
            }).each(function(index) {
              windows2.splice(index, 1);
              fireCloseEvent(win);
              if (windows2.length === 0) {
                editor.focus();
              }
            });
          };
          var getTopWindow = function() {
            return Option.from(windows2[windows2.length - 1]);
          };
          var open = function(args, params2) {
            editor.editorManager.setActive(editor);
            SelectionBookmark.store(editor);
            var win = getImplementation().open(args, params2, closeWindow);
            addWindow(win);
            return win;
          };
          var alert = function(message, callback, scope) {
            var win = getImplementation().alert(message, funcBind(scope ? scope : this, callback), closeWindow);
            addWindow(win);
          };
          var confirm = function(message, callback, scope) {
            var win = getImplementation().confirm(message, funcBind(scope ? scope : this, callback), closeWindow);
            addWindow(win);
          };
          var close = function() {
            getTopWindow().each(function(win) {
              getImplementation().close(win);
              closeWindow(win);
            });
          };
          var getParams = function() {
            return getTopWindow().map(getImplementation().getParams).getOr(null);
          };
          var setParams = function(params2) {
            getTopWindow().each(function(win) {
              getImplementation().setParams(win, params2);
            });
          };
          var getWindows = function() {
            return windows2;
          };
          editor.on("remove", function() {
            each(windows2.slice(0), function(win) {
              getImplementation().close(win);
            });
          });
          return {
            windows: windows2,
            open,
            alert,
            confirm,
            close,
            getParams,
            setParams,
            getWindows
          };
        }
        var data = {};
        var code2 = "en";
        var I18n = {
          setCode: function(newCode) {
            if (newCode) {
              code2 = newCode;
              this.rtl = this.data[newCode] ? this.data[newCode]._dir === "rtl" : false;
            }
          },
          getCode: function() {
            return code2;
          },
          rtl: false,
          add: function(code3, items) {
            var langData = data[code3];
            if (!langData) {
              data[code3] = langData = {};
            }
            for (var name2 in items) {
              langData[name2] = items[name2];
            }
            this.setCode(code3);
          },
          translate: function(text2) {
            var langData = data[code2] || {};
            var toString = function(obj) {
              if (Tools.is(obj, "function")) {
                return Object.prototype.toString.call(obj);
              }
              return !isEmpty2(obj) ? "" + obj : "";
            };
            var isEmpty2 = function(text3) {
              return text3 === "" || text3 === null || Tools.is(text3, "undefined");
            };
            var getLangData = function(text3) {
              text3 = toString(text3);
              return Tools.hasOwn(langData, text3) ? toString(langData[text3]) : text3;
            };
            if (isEmpty2(text2)) {
              return "";
            }
            if (Tools.is(text2, "object") && Tools.hasOwn(text2, "raw")) {
              return toString(text2.raw);
            }
            if (Tools.is(text2, "array")) {
              var values_1 = text2.slice(1);
              text2 = getLangData(text2[0]).replace(/\{([0-9]+)\}/g, function($1, $2) {
                return Tools.hasOwn(values_1, $2) ? toString(values_1[$2]) : $1;
              });
            }
            return getLangData(text2).replace(/{context:\w+}$/, "");
          },
          data
        };
        var PluginManager = AddOnManager.PluginManager;
        var resolvePluginName = function(targetUrl, suffix) {
          for (var name2 in PluginManager.urls) {
            var matchUrl = PluginManager.urls[name2] + "/plugin" + suffix + ".js";
            if (matchUrl === targetUrl) {
              return name2;
            }
          }
          return null;
        };
        var pluginUrlToMessage = function(editor, url2) {
          var plugin2 = resolvePluginName(url2, editor.suffix);
          return plugin2 ? I18n.translate([
            "Failed to load plugin: {0} from url {1}",
            plugin2,
            url2
          ]) : I18n.translate([
            "Failed to load plugin url: {0}",
            url2
          ]);
        };
        var displayNotification = function(editor, message) {
          editor.notificationManager.open({
            type: "error",
            text: message
          });
        };
        var displayError = function(editor, message) {
          if (editor._skinLoaded) {
            displayNotification(editor, message);
          } else {
            editor.on("SkinLoaded", function() {
              displayNotification(editor, message);
            });
          }
        };
        var uploadError = function(editor, message) {
          displayError(editor, I18n.translate([
            "Failed to upload image: {0}",
            message
          ]));
        };
        var pluginLoadError = function(editor, url2) {
          displayError(editor, pluginUrlToMessage(editor, url2));
        };
        var pluginInitError = function(editor, name2, err) {
          var message = I18n.translate([
            "Failed to initialize plugin: {0}",
            name2
          ]);
          initError(message, err);
          displayError(editor, message);
        };
        var initError = function(message) {
          var console2 = domGlobals.window.console;
          if (console2) {
            if (console2.error) {
              console2.error.apply(console2, arguments);
            } else {
              console2.log.apply(console2, arguments);
            }
          }
        };
        var ErrorReporter = {
          pluginLoadError,
          pluginInitError,
          uploadError,
          displayError,
          initError
        };
        var PluginManager$1 = AddOnManager.PluginManager;
        var ThemeManager = AddOnManager.ThemeManager;
        function XMLHttpRequest() {
          var f = Global$1.getOrDie("XMLHttpRequest");
          return new f();
        }
        function Uploader(uploadStatus, settings) {
          var pendingPromises = {};
          var pathJoin = function(path1, path2) {
            if (path1) {
              return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
            }
            return path2;
          };
          var defaultHandler = function(blobInfo, success, failure, progress) {
            var xhr, formData;
            xhr = XMLHttpRequest();
            xhr.open("POST", settings.url);
            xhr.withCredentials = settings.credentials;
            xhr.upload.onprogress = function(e) {
              progress(e.loaded / e.total * 100);
            };
            xhr.onerror = function() {
              failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
            };
            xhr.onload = function() {
              var json;
              if (xhr.status < 200 || xhr.status >= 300) {
                failure("HTTP Error: " + xhr.status);
                return;
              }
              json = JSON.parse(xhr.responseText);
              if (!json || typeof json.location !== "string") {
                failure("Invalid JSON: " + xhr.responseText);
                return;
              }
              success(pathJoin(settings.basePath, json.location));
            };
            formData = new domGlobals.FormData();
            formData.append("file", blobInfo.blob(), blobInfo.filename());
            xhr.send(formData);
          };
          var noUpload = function() {
            return new promiseObj(function(resolve2) {
              resolve2([]);
            });
          };
          var handlerSuccess = function(blobInfo, url2) {
            return {
              url: url2,
              blobInfo,
              status: true
            };
          };
          var handlerFailure = function(blobInfo, error3) {
            return {
              url: "",
              blobInfo,
              status: false,
              error: error3
            };
          };
          var resolvePending = function(blobUri, result) {
            Tools.each(pendingPromises[blobUri], function(resolve2) {
              resolve2(result);
            });
            delete pendingPromises[blobUri];
          };
          var uploadBlobInfo = function(blobInfo, handler, openNotification) {
            uploadStatus.markPending(blobInfo.blobUri());
            return new promiseObj(function(resolve2) {
              var notification, progress;
              var noop2 = function() {
              };
              try {
                var closeNotification_1 = function() {
                  if (notification) {
                    notification.close();
                    progress = noop2;
                  }
                };
                var success = function(url2) {
                  closeNotification_1();
                  uploadStatus.markUploaded(blobInfo.blobUri(), url2);
                  resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url2));
                  resolve2(handlerSuccess(blobInfo, url2));
                };
                var failure = function(error3) {
                  closeNotification_1();
                  uploadStatus.removeFailed(blobInfo.blobUri());
                  resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error3));
                  resolve2(handlerFailure(blobInfo, error3));
                };
                progress = function(percent) {
                  if (percent < 0 || percent > 100) {
                    return;
                  }
                  if (!notification) {
                    notification = openNotification();
                  }
                  notification.progressBar.value(percent);
                };
                handler(blobInfo, success, failure, progress);
              } catch (ex) {
                resolve2(handlerFailure(blobInfo, ex.message));
              }
            });
          };
          var isDefaultHandler = function(handler) {
            return handler === defaultHandler;
          };
          var pendingUploadBlobInfo = function(blobInfo) {
            var blobUri = blobInfo.blobUri();
            return new promiseObj(function(resolve2) {
              pendingPromises[blobUri] = pendingPromises[blobUri] || [];
              pendingPromises[blobUri].push(resolve2);
            });
          };
          var uploadBlobs = function(blobInfos, openNotification) {
            blobInfos = Tools.grep(blobInfos, function(blobInfo) {
              return !uploadStatus.isUploaded(blobInfo.blobUri());
            });
            return promiseObj.all(Tools.map(blobInfos, function(blobInfo) {
              return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
            }));
          };
          var upload = function(blobInfos, openNotification) {
            return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
          };
          if (isFunction(settings.handler) === false) {
            settings.handler = defaultHandler;
          }
          return { upload };
        }
        function FileReader() {
          var f = Global$1.getOrDie("FileReader");
          return new f();
        }
        function Uint8Array2(arr2) {
          var f = Global$1.getOrDie("Uint8Array");
          return new f(arr2);
        }
        var requestAnimationFrame$1 = function(callback) {
          var f = Global$1.getOrDie("requestAnimationFrame");
          f(callback);
        };
        var atob = function(base64) {
          var f = Global$1.getOrDie("atob");
          return f(base64);
        };
        var Window = {
          atob,
          requestAnimationFrame: requestAnimationFrame$1
        };
        var blobUriToBlob = function(url2) {
          return new promiseObj(function(resolve2, reject) {
            var rejectWithError = function() {
              reject("Cannot convert " + url2 + " to Blob. Resource might not exist or is inaccessible.");
            };
            try {
              var xhr = XMLHttpRequest();
              xhr.open("GET", url2, true);
              xhr.responseType = "blob";
              xhr.onload = function() {
                if (this.status === 200) {
                  resolve2(this.response);
                } else {
                  rejectWithError();
                }
              };
              xhr.onerror = rejectWithError;
              xhr.send();
            } catch (ex) {
              rejectWithError();
            }
          });
        };
        var parseDataUri = function(uri) {
          var type2, matches2;
          var uriParts = decodeURIComponent(uri).split(",");
          matches2 = /data:([^;]+)/.exec(uriParts[0]);
          if (matches2) {
            type2 = matches2[1];
          }
          return {
            type: type2,
            data: uriParts[1]
          };
        };
        var dataUriToBlob = function(uri) {
          return new promiseObj(function(resolve2) {
            var str, arr2, i2;
            var uriParts = parseDataUri(uri);
            try {
              str = Window.atob(uriParts.data);
            } catch (e) {
              resolve2(new domGlobals.Blob([]));
              return;
            }
            arr2 = Uint8Array2(str.length);
            for (i2 = 0; i2 < arr2.length; i2++) {
              arr2[i2] = str.charCodeAt(i2);
            }
            resolve2(new domGlobals.Blob([arr2], { type: uriParts.type }));
          });
        };
        var uriToBlob = function(url2) {
          if (url2.indexOf("blob:") === 0) {
            return blobUriToBlob(url2);
          }
          if (url2.indexOf("data:") === 0) {
            return dataUriToBlob(url2);
          }
          return null;
        };
        var blobToDataUri = function(blob) {
          return new promiseObj(function(resolve2) {
            var reader = FileReader();
            reader.onloadend = function() {
              resolve2(reader.result);
            };
            reader.readAsDataURL(blob);
          });
        };
        var Conversions = {
          uriToBlob,
          blobToDataUri,
          parseDataUri
        };
        var count = 0;
        var uniqueId = function(prefix) {
          return "blobid" + count++;
        };
        var imageToBlobInfo = function(blobCache, img, resolve2, reject) {
          var base64, blobInfo;
          if (img.src.indexOf("blob:") === 0) {
            blobInfo = blobCache.getByUri(img.src);
            if (blobInfo) {
              resolve2({
                image: img,
                blobInfo
              });
            } else {
              Conversions.uriToBlob(img.src).then(function(blob) {
                Conversions.blobToDataUri(blob).then(function(dataUri) {
                  base64 = Conversions.parseDataUri(dataUri).data;
                  blobInfo = blobCache.create(uniqueId(), blob, base64);
                  blobCache.add(blobInfo);
                  resolve2({
                    image: img,
                    blobInfo
                  });
                });
              }, function(err) {
                reject(err);
              });
            }
            return;
          }
          base64 = Conversions.parseDataUri(img.src).data;
          blobInfo = blobCache.findFirst(function(cachedBlobInfo) {
            return cachedBlobInfo.base64() === base64;
          });
          if (blobInfo) {
            resolve2({
              image: img,
              blobInfo
            });
          } else {
            Conversions.uriToBlob(img.src).then(function(blob) {
              blobInfo = blobCache.create(uniqueId(), blob, base64);
              blobCache.add(blobInfo);
              resolve2({
                image: img,
                blobInfo
              });
            }, function(err) {
              reject(err);
            });
          }
        };
        var getAllImages = function(elm) {
          return elm ? from$1(elm.getElementsByTagName("img")) : [];
        };
        function ImageScanner(uploadStatus, blobCache) {
          var cachedPromises = {};
          var findAll2 = function(elm, predicate) {
            var images;
            if (!predicate) {
              predicate = constant(true);
            }
            images = filter(getAllImages(elm), function(img) {
              var src2 = img.src;
              if (!Env.fileApi) {
                return false;
              }
              if (img.hasAttribute("data-mce-bogus")) {
                return false;
              }
              if (img.hasAttribute("data-mce-placeholder")) {
                return false;
              }
              if (!src2 || src2 === Env.transparentSrc) {
                return false;
              }
              if (src2.indexOf("blob:") === 0) {
                return !uploadStatus.isUploaded(src2) && predicate(img);
              }
              if (src2.indexOf("data:") === 0) {
                return predicate(img);
              }
              return false;
            });
            var promises = map2(images, function(img) {
              if (cachedPromises[img.src]) {
                return new promiseObj(function(resolve2) {
                  cachedPromises[img.src].then(function(imageInfo) {
                    if (typeof imageInfo === "string") {
                      return imageInfo;
                    }
                    resolve2({
                      image: img,
                      blobInfo: imageInfo.blobInfo
                    });
                  });
                });
              }
              var newPromise = new promiseObj(function(resolve2, reject) {
                imageToBlobInfo(blobCache, img, resolve2, reject);
              }).then(function(result) {
                delete cachedPromises[result.image.src];
                return result;
              }).catch(function(error3) {
                delete cachedPromises[img.src];
                return error3;
              });
              cachedPromises[img.src] = newPromise;
              return newPromise;
            });
            return promiseObj.all(promises);
          };
          return { findAll: findAll2 };
        }
        var count$1 = 0;
        var seed = function() {
          var rnd = function() {
            return Math.round(Math.random() * 4294967295).toString(36);
          };
          var now = (/* @__PURE__ */ new Date()).getTime();
          return "s" + now.toString(36) + rnd() + rnd() + rnd();
        };
        var uuid = function(prefix) {
          return prefix + count$1++ + seed();
        };
        var Uuid = { uuid };
        function BlobCache() {
          var cache = [];
          var mimeToExt = function(mime) {
            var mimes = {
              "image/jpeg": "jpg",
              "image/jpg": "jpg",
              "image/gif": "gif",
              "image/png": "png"
            };
            return mimes[mime.toLowerCase()] || "dat";
          };
          var create2 = function(o, blob, base64, filename) {
            if (isString(o)) {
              var id = o;
              return toBlobInfo({
                id,
                name: filename,
                blob,
                base64
              });
            } else if (isObject(o)) {
              return toBlobInfo(o);
            } else {
              throw new Error("Unknown input type");
            }
          };
          var toBlobInfo = function(o) {
            var id, name2;
            if (!o.blob || !o.base64) {
              throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
            }
            id = o.id || Uuid.uuid("blobid");
            name2 = o.name || id;
            return {
              id: constant(id),
              name: constant(name2),
              filename: constant(name2 + "." + mimeToExt(o.blob.type)),
              blob: constant(o.blob),
              base64: constant(o.base64),
              blobUri: constant(o.blobUri || URL.createObjectURL(o.blob)),
              uri: constant(o.uri)
            };
          };
          var add2 = function(blobInfo) {
            if (!get2(blobInfo.id())) {
              cache.push(blobInfo);
            }
          };
          var get2 = function(id) {
            return findFirst(function(cachedBlobInfo) {
              return cachedBlobInfo.id() === id;
            });
          };
          var findFirst = function(predicate) {
            return filter(cache, predicate)[0];
          };
          var getByUri = function(blobUri) {
            return findFirst(function(blobInfo) {
              return blobInfo.blobUri() === blobUri;
            });
          };
          var removeByUri = function(blobUri) {
            cache = filter(cache, function(blobInfo) {
              if (blobInfo.blobUri() === blobUri) {
                URL.revokeObjectURL(blobInfo.blobUri());
                return false;
              }
              return true;
            });
          };
          var destroy2 = function() {
            each(cache, function(cachedBlobInfo) {
              URL.revokeObjectURL(cachedBlobInfo.blobUri());
            });
            cache = [];
          };
          return {
            create: create2,
            add: add2,
            get: get2,
            getByUri,
            findFirst,
            removeByUri,
            destroy: destroy2
          };
        }
        function UploadStatus() {
          var PENDING = 1, UPLOADED = 2;
          var blobUriStatuses = {};
          var createStatus = function(status, resultUri) {
            return {
              status,
              resultUri
            };
          };
          var hasBlobUri = function(blobUri) {
            return blobUri in blobUriStatuses;
          };
          var getResultUri = function(blobUri) {
            var result = blobUriStatuses[blobUri];
            return result ? result.resultUri : null;
          };
          var isPending = function(blobUri) {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
          };
          var isUploaded = function(blobUri) {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
          };
          var markPending = function(blobUri) {
            blobUriStatuses[blobUri] = createStatus(PENDING, null);
          };
          var markUploaded = function(blobUri, resultUri) {
            blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
          };
          var removeFailed = function(blobUri) {
            delete blobUriStatuses[blobUri];
          };
          var destroy2 = function() {
            blobUriStatuses = {};
          };
          return {
            hasBlobUri,
            getResultUri,
            isPending,
            isUploaded,
            markPending,
            markUploaded,
            removeFailed,
            destroy: destroy2
          };
        }
        function EditorUpload(editor) {
          var blobCache = BlobCache();
          var uploader, imageScanner;
          var uploadStatus = UploadStatus();
          var urlFilters = [];
          var aliveGuard = function(callback) {
            return function(result) {
              if (editor.selection) {
                return callback(result);
              }
              return [];
            };
          };
          var cacheInvalidator = function() {
            return "?" + (/* @__PURE__ */ new Date()).getTime();
          };
          var replaceString = function(content, search2, replace) {
            var index = 0;
            do {
              index = content.indexOf(search2, index);
              if (index !== -1) {
                content = content.substring(0, index) + replace + content.substr(index + search2.length);
                index += replace.length - search2.length + 1;
              }
            } while (index !== -1);
            return content;
          };
          var replaceImageUrl = function(content, targetUrl, replacementUrl) {
            content = replaceString(content, 'src="' + targetUrl + '"', 'src="' + replacementUrl + '"');
            content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
            return content;
          };
          var replaceUrlInUndoStack = function(targetUrl, replacementUrl) {
            each(editor.undoManager.data, function(level) {
              if (level.type === "fragmented") {
                level.fragments = map2(level.fragments, function(fragment) {
                  return replaceImageUrl(fragment, targetUrl, replacementUrl);
                });
              } else {
                level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
              }
            });
          };
          var openNotification = function() {
            return editor.notificationManager.open({
              text: editor.translate("Image uploading..."),
              type: "info",
              timeout: -1,
              progressBar: true
            });
          };
          var replaceImageUri = function(image2, resultUri) {
            blobCache.removeByUri(image2.src);
            replaceUrlInUndoStack(image2.src, resultUri);
            editor.$(image2).attr({
              "src": Settings.shouldReuseFileName(editor) ? resultUri + cacheInvalidator() : resultUri,
              "data-mce-src": editor.convertURL(resultUri, "src")
            });
          };
          var uploadImages = function(callback) {
            if (!uploader) {
              uploader = Uploader(uploadStatus, {
                url: Settings.getImageUploadUrl(editor),
                basePath: Settings.getImageUploadBasePath(editor),
                credentials: Settings.getImagesUploadCredentials(editor),
                handler: Settings.getImagesUploadHandler(editor)
              });
            }
            return scanForImages().then(aliveGuard(function(imageInfos) {
              var blobInfos;
              blobInfos = map2(imageInfos, function(imageInfo) {
                return imageInfo.blobInfo;
              });
              return uploader.upload(blobInfos, openNotification).then(aliveGuard(function(result) {
                var filteredResult = map2(result, function(uploadInfo, index) {
                  var image2 = imageInfos[index].image;
                  if (uploadInfo.status && Settings.shouldReplaceBlobUris(editor)) {
                    replaceImageUri(image2, uploadInfo.url);
                  } else if (uploadInfo.error) {
                    ErrorReporter.uploadError(editor, uploadInfo.error);
                  }
                  return {
                    element: image2,
                    status: uploadInfo.status
                  };
                });
                if (callback) {
                  callback(filteredResult);
                }
                return filteredResult;
              }));
            }));
          };
          var uploadImagesAuto = function(callback) {
            if (Settings.isAutomaticUploadsEnabled(editor)) {
              return uploadImages(callback);
            }
          };
          var isValidDataUriImage = function(imgElm) {
            if (forall2(urlFilters, function(filter2) {
              return filter2(imgElm);
            }) === false) {
              return false;
            }
            if (imgElm.getAttribute("src").indexOf("data:") === 0) {
              var dataImgFilter = Settings.getImagesDataImgFilter(editor);
              return dataImgFilter(imgElm);
            }
            return true;
          };
          var addFilter = function(filter2) {
            urlFilters.push(filter2);
          };
          var scanForImages = function() {
            if (!imageScanner) {
              imageScanner = ImageScanner(uploadStatus, blobCache);
            }
            return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
              result = filter(result, function(resultItem) {
                if (typeof resultItem === "string") {
                  ErrorReporter.displayError(editor, resultItem);
                  return false;
                }
                return true;
              });
              each(result, function(resultItem) {
                replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
                resultItem.image.src = resultItem.blobInfo.blobUri();
                resultItem.image.removeAttribute("data-mce-src");
              });
              return result;
            }));
          };
          var destroy2 = function() {
            blobCache.destroy();
            uploadStatus.destroy();
            imageScanner = uploader = null;
          };
          var replaceBlobUris = function(content) {
            return content.replace(/src="(blob:[^"]+)"/g, function(match2, blobUri) {
              var resultUri = uploadStatus.getResultUri(blobUri);
              if (resultUri) {
                return 'src="' + resultUri + '"';
              }
              var blobInfo = blobCache.getByUri(blobUri);
              if (!blobInfo) {
                blobInfo = foldl(editor.editorManager.get(), function(result, editor2) {
                  return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
                }, null);
              }
              if (blobInfo) {
                var blob = blobInfo.blob();
                return 'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"';
              }
              return match2;
            });
          };
          editor.on("setContent", function() {
            if (Settings.isAutomaticUploadsEnabled(editor)) {
              uploadImagesAuto();
            } else {
              scanForImages();
            }
          });
          editor.on("RawSaveContent", function(e) {
            e.content = replaceBlobUris(e.content);
          });
          editor.on("getContent", function(e) {
            if (e.source_view || e.format === "raw") {
              return;
            }
            e.content = replaceBlobUris(e.content);
          });
          editor.on("PostRender", function() {
            editor.parser.addNodeFilter("img", function(images) {
              each(images, function(img) {
                var src2 = img.attr("src");
                if (blobCache.getByUri(src2)) {
                  return;
                }
                var resultUri = uploadStatus.getResultUri(src2);
                if (resultUri) {
                  img.attr("src", resultUri);
                }
              });
            });
          });
          return {
            blobCache,
            addFilter,
            uploadImages,
            uploadImagesAuto,
            scanForImages,
            destroy: destroy2
          };
        }
        var isBlockElement = function(blockElements2, node2) {
          return blockElements2.hasOwnProperty(node2.nodeName);
        };
        var isValidTarget = function(blockElements2, node2) {
          if (NodeType.isText(node2)) {
            return true;
          } else if (NodeType.isElement(node2)) {
            return !isBlockElement(blockElements2, node2) && !Bookmarks.isBookmarkNode(node2);
          } else {
            return false;
          }
        };
        var hasBlockParent = function(blockElements2, root2, node2) {
          return exists(Parents.parents(Element2.fromDom(node2), Element2.fromDom(root2)), function(elm) {
            return isBlockElement(blockElements2, elm.dom());
          });
        };
        var shouldRemoveTextNode = function(blockElements2, node2) {
          if (NodeType.isText(node2)) {
            if (node2.nodeValue.length === 0) {
              return true;
            } else if (/^\s+$/.test(node2.nodeValue) && (!node2.nextSibling || isBlockElement(blockElements2, node2.nextSibling))) {
              return true;
            }
          }
          return false;
        };
        var addRootBlocks = function(editor) {
          var settings = editor.settings, dom2 = editor.dom, selection = editor.selection;
          var schema = editor.schema, blockElements2 = schema.getBlockElements();
          var node2 = selection.getStart();
          var rootNode = editor.getBody();
          var rng;
          var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
          var tempNode, wrapped, restoreSelection;
          var rootNodeName, forcedRootBlock;
          forcedRootBlock = settings.forced_root_block;
          if (!node2 || !NodeType.isElement(node2) || !forcedRootBlock) {
            return;
          }
          rootNodeName = rootNode.nodeName.toLowerCase();
          if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements2, rootNode, node2)) {
            return;
          }
          rng = selection.getRng();
          startContainer = rng.startContainer;
          startOffset = rng.startOffset;
          endContainer = rng.endContainer;
          endOffset = rng.endOffset;
          restoreSelection = EditorFocus.hasFocus(editor);
          node2 = rootNode.firstChild;
          while (node2) {
            if (isValidTarget(blockElements2, node2)) {
              if (shouldRemoveTextNode(blockElements2, node2)) {
                tempNode = node2;
                node2 = node2.nextSibling;
                dom2.remove(tempNode);
                continue;
              }
              if (!rootBlockNode) {
                rootBlockNode = dom2.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
                node2.parentNode.insertBefore(rootBlockNode, node2);
                wrapped = true;
              }
              tempNode = node2;
              node2 = node2.nextSibling;
              rootBlockNode.appendChild(tempNode);
            } else {
              rootBlockNode = null;
              node2 = node2.nextSibling;
            }
          }
          if (wrapped && restoreSelection) {
            rng.setStart(startContainer, startOffset);
            rng.setEnd(endContainer, endOffset);
            selection.setRng(rng);
            editor.nodeChanged();
          }
        };
        var setup$3 = function(editor) {
          if (editor.settings.forced_root_block) {
            editor.on("NodeChange", curry(addRootBlocks, editor));
          }
        };
        var ForceBlocks = { setup: setup$3 };
        var getStartNode = function(rng) {
          var sc2 = rng.startContainer, so = rng.startOffset;
          if (NodeType.isText(sc2)) {
            return so === 0 ? Option.some(Element2.fromDom(sc2)) : Option.none();
          } else {
            return Option.from(sc2.childNodes[so]).map(Element2.fromDom);
          }
        };
        var getEndNode = function(rng) {
          var ec = rng.endContainer, eo = rng.endOffset;
          if (NodeType.isText(ec)) {
            return eo === ec.data.length ? Option.some(Element2.fromDom(ec)) : Option.none();
          } else {
            return Option.from(ec.childNodes[eo - 1]).map(Element2.fromDom);
          }
        };
        var getFirstChildren = function(node2) {
          return firstChild(node2).fold(constant([node2]), function(child2) {
            return [node2].concat(getFirstChildren(child2));
          });
        };
        var getLastChildren$1 = function(node2) {
          return lastChild(node2).fold(constant([node2]), function(child2) {
            if (name(child2) === "br") {
              return prevSibling(child2).map(function(sibling2) {
                return [node2].concat(getLastChildren$1(sibling2));
              }).getOr([]);
            } else {
              return [node2].concat(getLastChildren$1(child2));
            }
          });
        };
        var hasAllContentsSelected = function(elm, rng) {
          return lift2(getStartNode(rng), getEndNode(rng), function(startNode, endNode) {
            var start2 = find(getFirstChildren(elm), curry(eq, startNode));
            var end2 = find(getLastChildren$1(elm), curry(eq, endNode));
            return start2.isSome() && end2.isSome();
          }).getOr(false);
        };
        var moveEndPoint$1 = function(dom2, rng, node2, start2) {
          var root2 = node2, walker = new TreeWalker(node2, root2);
          var nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          do {
            if (node2.nodeType === 3 && Tools.trim(node2.nodeValue).length !== 0) {
              if (start2) {
                rng.setStart(node2, 0);
              } else {
                rng.setEnd(node2, node2.nodeValue.length);
              }
              return;
            }
            if (nonEmptyElementsMap[node2.nodeName] && !/^(TD|TH)$/.test(node2.nodeName)) {
              if (start2) {
                rng.setStartBefore(node2);
              } else {
                if (node2.nodeName === "BR") {
                  rng.setEndBefore(node2);
                } else {
                  rng.setEndAfter(node2);
                }
              }
              return;
            }
            if (Env.ie && Env.ie < 11 && dom2.isBlock(node2) && dom2.isEmpty(node2)) {
              if (start2) {
                rng.setStart(node2, 0);
              } else {
                rng.setEnd(node2, 0);
              }
              return;
            }
          } while (node2 = start2 ? walker.next() : walker.prev());
          if (root2.nodeName === "BODY") {
            if (start2) {
              rng.setStart(root2, 0);
            } else {
              rng.setEnd(root2, root2.childNodes.length);
            }
          }
        };
        var hasAnyRanges = function(editor) {
          var sel = editor.selection.getSel();
          return sel && sel.rangeCount > 0;
        };
        function NodeChange(editor) {
          var lastRng, lastPath = [];
          var isSameElementPath = function(startElm) {
            var i2, currentPath;
            currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
            if (currentPath.length === lastPath.length) {
              for (i2 = currentPath.length; i2 >= 0; i2--) {
                if (currentPath[i2] !== lastPath[i2]) {
                  break;
                }
              }
              if (i2 === -1) {
                lastPath = currentPath;
                return true;
              }
            }
            lastPath = currentPath;
            return false;
          };
          if (!("onselectionchange" in editor.getDoc())) {
            editor.on("NodeChange Click MouseUp KeyUp Focus", function(e) {
              var nativeRng, fakeRng;
              nativeRng = editor.selection.getRng();
              fakeRng = {
                startContainer: nativeRng.startContainer,
                startOffset: nativeRng.startOffset,
                endContainer: nativeRng.endContainer,
                endOffset: nativeRng.endOffset
              };
              if (e.type === "nodechange" || !RangeCompare.isEq(fakeRng, lastRng)) {
                editor.fire("SelectionChange");
              }
              lastRng = fakeRng;
            });
          }
          editor.on("contextmenu", function() {
            editor.fire("SelectionChange");
          });
          editor.on("SelectionChange", function() {
            var startElm = editor.selection.getStart(true);
            if (!startElm || !Env.range && editor.selection.isCollapsed()) {
              return;
            }
            if (hasAnyRanges(editor) && !isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
              editor.nodeChanged({ selectionChange: true });
            }
          });
          editor.on("MouseUp", function(e) {
            if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
              if (editor.selection.getNode().nodeName === "IMG") {
                Delay.setEditorTimeout(editor, function() {
                  editor.nodeChanged();
                });
              } else {
                editor.nodeChanged();
              }
            }
          });
          this.nodeChanged = function(args) {
            var selection = editor.selection;
            var node2, parents2, root2;
            if (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.readonly) {
              root2 = editor.getBody();
              node2 = selection.getStart(true) || root2;
              if (node2.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node2, root2)) {
                node2 = root2;
              }
              parents2 = [];
              editor.dom.getParent(node2, function(node3) {
                if (node3 === root2) {
                  return true;
                }
                parents2.push(node3);
              });
              args = args || {};
              args.element = node2;
              args.parents = parents2;
              editor.fire("NodeChange", args);
            }
          };
        }
        var VK = {
          BACKSPACE: 8,
          DELETE: 46,
          DOWN: 40,
          ENTER: 13,
          LEFT: 37,
          RIGHT: 39,
          SPACEBAR: 32,
          TAB: 9,
          UP: 38,
          END: 35,
          HOME: 36,
          modifierPressed: function(e) {
            return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
          },
          metaKeyPressed: function(e) {
            return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
          }
        };
        var getNodeClientRects = function(node2) {
          var toArrayWithNode = function(clientRects) {
            return map2(clientRects, function(clientRect) {
              clientRect = clone$1(clientRect);
              clientRect.node = node2;
              return clientRect;
            });
          };
          if (NodeType.isElement(node2)) {
            return toArrayWithNode(node2.getClientRects());
          }
          if (NodeType.isText(node2)) {
            var rng = node2.ownerDocument.createRange();
            rng.setStart(node2, 0);
            rng.setEnd(node2, node2.data.length);
            return toArrayWithNode(rng.getClientRects());
          }
        };
        var getClientRects = function(node2) {
          return foldl(node2, function(result, node3) {
            return result.concat(getNodeClientRects(node3));
          }, []);
        };
        var VDirection;
        (function(VDirection2) {
          VDirection2[VDirection2["Up"] = -1] = "Up";
          VDirection2[VDirection2["Down"] = 1] = "Down";
        })(VDirection || (VDirection = {}));
        var findUntil = function(direction, root2, predicateFn, node2) {
          while (node2 = findNode(node2, direction, isEditableCaretCandidate, root2)) {
            if (predicateFn(node2)) {
              return;
            }
          }
        };
        var walkUntil = function(direction, isAboveFn, isBeflowFn, root2, predicateFn, caretPosition) {
          var line = 0, node2;
          var result = [];
          var targetClientRect;
          var add2 = function(node3) {
            var i2, clientRect, clientRects;
            clientRects = getClientRects([node3]);
            if (direction === -1) {
              clientRects = clientRects.reverse();
            }
            for (i2 = 0; i2 < clientRects.length; i2++) {
              clientRect = clientRects[i2];
              if (isBeflowFn(clientRect, targetClientRect)) {
                continue;
              }
              if (result.length > 0 && isAboveFn(clientRect, ArrUtils.last(result))) {
                line++;
              }
              clientRect.line = line;
              if (predicateFn(clientRect)) {
                return true;
              }
              result.push(clientRect);
            }
          };
          targetClientRect = ArrUtils.last(caretPosition.getClientRects());
          if (!targetClientRect) {
            return result;
          }
          node2 = caretPosition.getNode();
          add2(node2);
          findUntil(direction, root2, add2, node2);
          return result;
        };
        var aboveLineNumber = function(lineNumber, clientRect) {
          return clientRect.line > lineNumber;
        };
        var isLineNumber = function(lineNumber, clientRect) {
          return clientRect.line === lineNumber;
        };
        var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
        var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
        var positionsUntil = function(direction, root2, predicateFn, node2) {
          var caretWalker = CaretWalker(root2);
          var walkFn, isBelowFn, isAboveFn, caretPosition;
          var result = [];
          var line = 0, clientRect, targetClientRect;
          var getClientRect = function(caretPosition2) {
            if (direction === 1) {
              return ArrUtils.last(caretPosition2.getClientRects());
            }
            return ArrUtils.last(caretPosition2.getClientRects());
          };
          if (direction === 1) {
            walkFn = caretWalker.next;
            isBelowFn = isBelow;
            isAboveFn = isAbove;
            caretPosition = CaretPosition$1.after(node2);
          } else {
            walkFn = caretWalker.prev;
            isBelowFn = isAbove;
            isAboveFn = isBelow;
            caretPosition = CaretPosition$1.before(node2);
          }
          targetClientRect = getClientRect(caretPosition);
          do {
            if (!caretPosition.isVisible()) {
              continue;
            }
            clientRect = getClientRect(caretPosition);
            if (isAboveFn(clientRect, targetClientRect)) {
              continue;
            }
            if (result.length > 0 && isBelowFn(clientRect, ArrUtils.last(result))) {
              line++;
            }
            clientRect = clone$1(clientRect);
            clientRect.position = caretPosition;
            clientRect.line = line;
            if (predicateFn(clientRect)) {
              return result;
            }
            result.push(clientRect);
          } while (caretPosition = walkFn(caretPosition));
          return result;
        };
        var isAboveLine = function(lineNumber) {
          return function(clientRect) {
            return aboveLineNumber(lineNumber, clientRect);
          };
        };
        var isLine = function(lineNumber) {
          return function(clientRect) {
            return isLineNumber(lineNumber, clientRect);
          };
        };
        var isContentEditableFalse$7 = NodeType.isContentEditableFalse;
        var findNode$1 = findNode;
        var distanceToRectLeft = function(clientRect, clientX) {
          return Math.abs(clientRect.left - clientX);
        };
        var distanceToRectRight = function(clientRect, clientX) {
          return Math.abs(clientRect.right - clientX);
        };
        var isInside = function(clientX, clientRect) {
          return clientX >= clientRect.left && clientX <= clientRect.right;
        };
        var findClosestClientRect = function(clientRects, clientX) {
          return ArrUtils.reduce(clientRects, function(oldClientRect, clientRect) {
            var oldDistance, newDistance;
            oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
            newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
            if (isInside(clientX, clientRect)) {
              return clientRect;
            }
            if (isInside(clientX, oldClientRect)) {
              return oldClientRect;
            }
            if (newDistance === oldDistance && isContentEditableFalse$7(clientRect.node)) {
              return clientRect;
            }
            if (newDistance < oldDistance) {
              return clientRect;
            }
            return oldClientRect;
          });
        };
        var walkUntil$1 = function(direction, root2, predicateFn, node2) {
          while (node2 = findNode$1(node2, direction, isEditableCaretCandidate, root2)) {
            if (predicateFn(node2)) {
              return;
            }
          }
        };
        var findLineNodeRects = function(root2, targetNodeRect) {
          var clientRects = [];
          var collect = function(checkPosFn, node2) {
            var lineRects;
            lineRects = filter(getClientRects([node2]), function(clientRect) {
              return !checkPosFn(clientRect, targetNodeRect);
            });
            clientRects = clientRects.concat(lineRects);
            return lineRects.length === 0;
          };
          clientRects.push(targetNodeRect);
          walkUntil$1(VDirection.Up, root2, curry(collect, isAbove), targetNodeRect.node);
          walkUntil$1(VDirection.Down, root2, curry(collect, isBelow), targetNodeRect.node);
          return clientRects;
        };
        var getFakeCaretTargets = function(root2) {
          return filter(from$1(root2.getElementsByTagName("*")), isFakeCaretTarget);
        };
        var caretInfo = function(clientRect, clientX) {
          return {
            node: clientRect.node,
            before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
          };
        };
        var closestCaret = function(root2, clientX, clientY) {
          var closestNodeRect;
          var contentEditableFalseNodeRects = getClientRects(getFakeCaretTargets(root2));
          var targetNodeRects = filter(contentEditableFalseNodeRects, function(rect2) {
            return clientY >= rect2.top && clientY <= rect2.bottom;
          });
          closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
          if (closestNodeRect) {
            closestNodeRect = findClosestClientRect(findLineNodeRects(root2, closestNodeRect), clientX);
            if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
              return caretInfo(closestNodeRect, clientX);
            }
          }
          return null;
        };
        var isXYWithinRange = function(clientX, clientY, range3) {
          if (range3.collapsed) {
            return false;
          }
          if (Env.ie && Env.ie <= 11 && range3.startOffset === range3.endOffset - 1 && range3.startContainer === range3.endContainer) {
            var elm = range3.startContainer.childNodes[range3.startOffset];
            if (NodeType.isElement(elm)) {
              return exists(elm.getClientRects(), function(rect2) {
                return containsXY(rect2, clientX, clientY);
              });
            }
          }
          return exists(range3.getClientRects(), function(rect2) {
            return containsXY(rect2, clientX, clientY);
          });
        };
        var RangePoint = { isXYWithinRange };
        var getAbsolutePosition = function(elm) {
          var doc2, docElem2, win, clientRect;
          clientRect = elm.getBoundingClientRect();
          doc2 = elm.ownerDocument;
          docElem2 = doc2.documentElement;
          win = doc2.defaultView;
          return {
            top: clientRect.top + win.pageYOffset - docElem2.clientTop,
            left: clientRect.left + win.pageXOffset - docElem2.clientLeft
          };
        };
        var getBodyPosition = function(editor) {
          return editor.inline ? getAbsolutePosition(editor.getBody()) : {
            left: 0,
            top: 0
          };
        };
        var getScrollPosition = function(editor) {
          var body = editor.getBody();
          return editor.inline ? {
            left: body.scrollLeft,
            top: body.scrollTop
          } : {
            left: 0,
            top: 0
          };
        };
        var getBodyScroll = function(editor) {
          var body = editor.getBody(), docElm = editor.getDoc().documentElement;
          var inlineScroll = {
            left: body.scrollLeft,
            top: body.scrollTop
          };
          var iframeScroll = {
            left: body.scrollLeft || docElm.scrollLeft,
            top: body.scrollTop || docElm.scrollTop
          };
          return editor.inline ? inlineScroll : iframeScroll;
        };
        var getMousePosition = function(editor, event) {
          if (event.target.ownerDocument !== editor.getDoc()) {
            var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
            var scrollPosition = getBodyScroll(editor);
            return {
              left: event.pageX - iframePosition.left + scrollPosition.left,
              top: event.pageY - iframePosition.top + scrollPosition.top
            };
          }
          return {
            left: event.pageX,
            top: event.pageY
          };
        };
        var calculatePosition = function(bodyPosition, scrollPosition, mousePosition) {
          return {
            pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
            pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
          };
        };
        var calc = function(editor, event) {
          return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
        };
        var MousePosition = { calc };
        var isContentEditableFalse$8 = NodeType.isContentEditableFalse, isContentEditableTrue$3 = NodeType.isContentEditableTrue;
        var isDraggable = function(rootElm, elm) {
          return isContentEditableFalse$8(elm) && elm !== rootElm;
        };
        var isValidDropTarget = function(editor, targetElement, dragElement) {
          if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
            return false;
          }
          if (isContentEditableFalse$8(targetElement)) {
            return false;
          }
          return true;
        };
        var cloneElement = function(elm) {
          var cloneElm = elm.cloneNode(true);
          cloneElm.removeAttribute("data-mce-selected");
          return cloneElm;
        };
        var createGhost = function(editor, elm, width, height) {
          var clonedElm = elm.cloneNode(true);
          editor.dom.setStyles(clonedElm, {
            width,
            height
          });
          editor.dom.setAttrib(clonedElm, "data-mce-selected", null);
          var ghostElm = editor.dom.create("div", {
            "class": "mce-drag-container",
            "data-mce-bogus": "all",
            "unselectable": "on",
            "contenteditable": "false"
          });
          editor.dom.setStyles(ghostElm, {
            position: "absolute",
            opacity: 0.5,
            overflow: "hidden",
            border: 0,
            padding: 0,
            margin: 0,
            width,
            height
          });
          editor.dom.setStyles(clonedElm, {
            margin: 0,
            boxSizing: "border-box"
          });
          ghostElm.appendChild(clonedElm);
          return ghostElm;
        };
        var appendGhostToBody = function(ghostElm, bodyElm) {
          if (ghostElm.parentNode !== bodyElm) {
            bodyElm.appendChild(ghostElm);
          }
        };
        var moveGhost = function(ghostElm, position, width, height, maxX, maxY) {
          var overflowX2 = 0, overflowY2 = 0;
          ghostElm.style.left = position.pageX + "px";
          ghostElm.style.top = position.pageY + "px";
          if (position.pageX + width > maxX) {
            overflowX2 = position.pageX + width - maxX;
          }
          if (position.pageY + height > maxY) {
            overflowY2 = position.pageY + height - maxY;
          }
          ghostElm.style.width = width - overflowX2 + "px";
          ghostElm.style.height = height - overflowY2 + "px";
        };
        var removeElement = function(elm) {
          if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
          }
        };
        var isLeftMouseButtonPressed = function(e) {
          return e.button === 0;
        };
        var hasDraggableElement = function(state) {
          return state.element;
        };
        var applyRelPos = function(state, position) {
          return {
            pageX: position.pageX - state.relX,
            pageY: position.pageY + 5
          };
        };
        var start$1 = function(state, editor) {
          return function(e) {
            if (isLeftMouseButtonPressed(e)) {
              var ceElm = find(editor.dom.getParents(e.target), Predicate.or(isContentEditableFalse$8, isContentEditableTrue$3)).getOr(null);
              if (isDraggable(editor.getBody(), ceElm)) {
                var elmPos = editor.dom.getPos(ceElm);
                var bodyElm = editor.getBody();
                var docElm = editor.getDoc().documentElement;
                state.element = ceElm;
                state.screenX = e.screenX;
                state.screenY = e.screenY;
                state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
                state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
                state.relX = e.pageX - elmPos.x;
                state.relY = e.pageY - elmPos.y;
                state.width = ceElm.offsetWidth;
                state.height = ceElm.offsetHeight;
                state.ghost = createGhost(editor, ceElm, state.width, state.height);
              }
            }
          };
        };
        var move$1 = function(state, editor) {
          var throttledPlaceCaretAt = Delay.throttle(function(clientX, clientY) {
            editor._selectionOverrides.hideFakeCaret();
            editor.selection.placeCaretAt(clientX, clientY);
          }, 0);
          return function(e) {
            var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
            if (hasDraggableElement(state) && !state.dragging && movement > 10) {
              var args = editor.fire("dragstart", { target: state.element });
              if (args.isDefaultPrevented()) {
                return;
              }
              state.dragging = true;
              editor.focus();
            }
            if (state.dragging) {
              var targetPos = applyRelPos(state, MousePosition.calc(editor, e));
              appendGhostToBody(state.ghost, editor.getBody());
              moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
              throttledPlaceCaretAt(e.clientX, e.clientY);
            }
          };
        };
        var getRawTarget = function(selection) {
          var rng = selection.getSel().getRangeAt(0);
          var startContainer = rng.startContainer;
          return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
        };
        var drop = function(state, editor) {
          return function(e) {
            if (state.dragging) {
              if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
                var targetClone_1 = cloneElement(state.element);
                var args = editor.fire("drop", {
                  targetClone: targetClone_1,
                  clientX: e.clientX,
                  clientY: e.clientY
                });
                if (!args.isDefaultPrevented()) {
                  targetClone_1 = args.targetClone;
                  editor.undoManager.transact(function() {
                    removeElement(state.element);
                    editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
                    editor._selectionOverrides.hideFakeCaret();
                  });
                }
              }
            }
            removeDragState(state);
          };
        };
        var stop = function(state, editor) {
          return function() {
            if (state.dragging) {
              editor.fire("dragend");
            }
            removeDragState(state);
          };
        };
        var removeDragState = function(state) {
          state.dragging = false;
          state.element = null;
          removeElement(state.ghost);
        };
        var bindFakeDragEvents = function(editor) {
          var state = {};
          var pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;
          pageDom = DOMUtils$1.DOM;
          rootDocument = domGlobals.document;
          dragStartHandler = start$1(state, editor);
          dragHandler = move$1(state, editor);
          dropHandler = drop(state, editor);
          dragEndHandler = stop(state, editor);
          editor.on("mousedown", dragStartHandler);
          editor.on("mousemove", dragHandler);
          editor.on("mouseup", dropHandler);
          pageDom.bind(rootDocument, "mousemove", dragHandler);
          pageDom.bind(rootDocument, "mouseup", dragEndHandler);
          editor.on("remove", function() {
            pageDom.unbind(rootDocument, "mousemove", dragHandler);
            pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
          });
        };
        var blockIeDrop = function(editor) {
          editor.on("drop", function(e) {
            var realTarget = typeof e.clientX !== "undefined" ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
            if (isContentEditableFalse$8(realTarget) || isContentEditableFalse$8(editor.dom.getContentEditableParent(realTarget))) {
              e.preventDefault();
            }
          });
        };
        var init2 = function(editor) {
          bindFakeDragEvents(editor);
          blockIeDrop(editor);
        };
        var DragDropOverrides = { init: init2 };
        var setup$4 = function(editor) {
          var renderFocusCaret = first(function() {
            if (!editor.removed) {
              var rng = editor.selection.getRng();
              if (rng.collapsed) {
                var caretRange = renderRangeCaret(editor, editor.selection.getRng(), false);
                editor.selection.setRng(caretRange);
              }
            }
          }, 0);
          editor.on("focus", function() {
            renderFocusCaret.throttle();
          });
          editor.on("blur", function() {
            renderFocusCaret.cancel();
          });
        };
        var CefFocus = { setup: setup$4 };
        var isContentEditableTrue$4 = NodeType.isContentEditableTrue;
        var isContentEditableFalse$9 = NodeType.isContentEditableFalse;
        var getContentEditableRoot$1 = function(editor, node2) {
          var root2 = editor.getBody();
          while (node2 && node2 !== root2) {
            if (isContentEditableTrue$4(node2) || isContentEditableFalse$9(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var SelectionOverrides = function(editor) {
          var isBlock3 = function(node2) {
            return editor.dom.isBlock(node2);
          };
          var rootNode = editor.getBody();
          var fakeCaret = FakeCaret(editor.getBody(), isBlock3, function() {
            return EditorFocus.hasFocus(editor);
          });
          var realSelectionId = "sel-" + editor.dom.uniqueId();
          var selectedContentEditableNode;
          var isFakeSelectionElement = function(elm) {
            return editor.dom.hasClass(elm, "mce-offscreen-selection");
          };
          var getRealSelectionElement = function() {
            var container = editor.dom.get(realSelectionId);
            return container ? container.getElementsByTagName("*")[0] : container;
          };
          var setRange = function(range3) {
            if (range3) {
              editor.selection.setRng(range3);
            }
          };
          var getRange = function() {
            return editor.selection.getRng();
          };
          var showCaret2 = function(direction, node2, before2, scrollIntoView) {
            if (scrollIntoView === void 0) {
              scrollIntoView = true;
            }
            var e;
            e = editor.fire("ShowCaret", {
              target: node2,
              direction,
              before: before2
            });
            if (e.isDefaultPrevented()) {
              return null;
            }
            if (scrollIntoView) {
              editor.selection.scrollIntoView(node2, direction === -1);
            }
            return fakeCaret.show(before2, node2);
          };
          var getNormalizedRangeEndPoint2 = function(direction, range3) {
            range3 = normalizeRange(direction, rootNode, range3);
            if (direction === -1) {
              return CaretPosition$1.fromRangeStart(range3);
            }
            return CaretPosition$1.fromRangeEnd(range3);
          };
          var showBlockCaretContainer2 = function(blockCaretContainer) {
            if (blockCaretContainer.hasAttribute("data-mce-caret")) {
              showCaretContainerBlock(blockCaretContainer);
              setRange(getRange());
              editor.selection.scrollIntoView(blockCaretContainer[0]);
            }
          };
          var registerEvents2 = function() {
            editor.on("mouseup", function(e) {
              var range3 = getRange();
              if (range3.collapsed && EditorView.isXYInContentArea(editor, e.clientX, e.clientY)) {
                setRange(renderCaretAtRange(editor, range3, false));
              }
            });
            editor.on("click", function(e) {
              var contentEditableRoot;
              contentEditableRoot = getContentEditableRoot$1(editor, e.target);
              if (contentEditableRoot) {
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  e.preventDefault();
                  editor.focus();
                }
                if (isContentEditableTrue$4(contentEditableRoot)) {
                  if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
                    removeContentEditableSelection();
                  }
                }
              }
            });
            editor.on("blur NewBlock", function() {
              removeContentEditableSelection();
            });
            editor.on("ResizeWindow FullscreenStateChanged", function() {
              return fakeCaret.reposition();
            });
            var handleTouchSelect = function(editor2) {
              var moved = false;
              editor2.on("touchstart", function() {
                moved = false;
              });
              editor2.on("touchmove", function() {
                moved = true;
              });
              editor2.on("touchend", function(e) {
                var contentEditableRoot = getContentEditableRoot$1(editor2, e.target);
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  if (!moved) {
                    e.preventDefault();
                    setContentEditableSelection(selectNode(editor2, contentEditableRoot));
                  }
                }
              });
            };
            var hasNormalCaretPosition = function(elm) {
              var caretWalker = CaretWalker(elm);
              if (!elm.firstChild) {
                return false;
              }
              var startPos = CaretPosition$1.before(elm.firstChild);
              var newPos = caretWalker.next(startPos);
              return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
            };
            var isInSameBlock2 = function(node1, node2) {
              var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
              var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
              return block1 === block2;
            };
            var hasBetterMouseTarget = function(targetNode, caretNode) {
              var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
              var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
              if (targetBlock && editor.dom.isChildOf(targetBlock, caretBlock) && isContentEditableFalse$9(getContentEditableRoot$1(editor, targetBlock)) === false) {
                return true;
              }
              return targetBlock && !isInSameBlock2(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
            };
            handleTouchSelect(editor);
            editor.on("mousedown", function(e) {
              var contentEditableRoot;
              var targetElm = e.target;
              if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !editor.dom.isChildOf(targetElm, rootNode)) {
                return;
              }
              if (EditorView.isXYInContentArea(editor, e.clientX, e.clientY) === false) {
                return;
              }
              contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
              if (contentEditableRoot) {
                if (isContentEditableFalse$9(contentEditableRoot)) {
                  e.preventDefault();
                  setContentEditableSelection(selectNode(editor, contentEditableRoot));
                } else {
                  removeContentEditableSelection();
                  if (!(isContentEditableTrue$4(contentEditableRoot) && e.shiftKey) && !RangePoint.isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
                    hideFakeCaret();
                    editor.selection.placeCaretAt(e.clientX, e.clientY);
                  }
                }
              } else if (isFakeCaretTarget(targetElm) === false) {
                removeContentEditableSelection();
                hideFakeCaret();
                var caretInfo2 = closestCaret(rootNode, e.clientX, e.clientY);
                if (caretInfo2) {
                  if (!hasBetterMouseTarget(e.target, caretInfo2.node)) {
                    e.preventDefault();
                    var range3 = showCaret2(1, caretInfo2.node, caretInfo2.before, false);
                    editor.getBody().focus();
                    setRange(range3);
                  }
                }
              }
            });
            editor.on("keypress", function(e) {
              if (VK.modifierPressed(e)) {
                return;
              }
              switch (e.keyCode) {
                default:
                  if (isContentEditableFalse$9(editor.selection.getNode())) {
                    e.preventDefault();
                  }
                  break;
              }
            });
            editor.on("getSelectionRange", function(e) {
              var rng = e.range;
              if (selectedContentEditableNode) {
                if (!selectedContentEditableNode.parentNode) {
                  selectedContentEditableNode = null;
                  return;
                }
                rng = rng.cloneRange();
                rng.selectNode(selectedContentEditableNode);
                e.range = rng;
              }
            });
            editor.on("setSelectionRange", function(e) {
              e.range = normalizeShortEndedElementSelection(e.range);
              var rng = setContentEditableSelection(e.range, e.forward);
              if (rng) {
                e.range = rng;
              }
            });
            var isPasteBin = function(node2) {
              return node2.id === "mcepastebin";
            };
            editor.on("AfterSetSelectionRange", function(e) {
              var rng = e.range;
              if (!isRangeInCaretContainer(rng) && !isPasteBin(rng.startContainer.parentNode)) {
                hideFakeCaret();
              }
              if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
                removeContentEditableSelection();
              }
            });
            editor.on("copy", function(e) {
              var clipboardData = e.clipboardData;
              if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
                var realSelectionElement = getRealSelectionElement();
                if (realSelectionElement) {
                  e.preventDefault();
                  clipboardData.clearData();
                  clipboardData.setData("text/html", realSelectionElement.outerHTML);
                  clipboardData.setData("text/plain", realSelectionElement.outerText);
                }
              }
            });
            DragDropOverrides.init(editor);
            CefFocus.setup(editor);
          };
          var addCss = function() {
            var styles = editor.contentStyles, rootClass = ".mce-content-body";
            styles.push(fakeCaret.getCss());
            styles.push(rootClass + " .mce-offscreen-selection {position: absolute;left: -9999999999px;max-width: 1000000px;}" + rootClass + " *[contentEditable=false] {cursor: default;}" + rootClass + " *[contentEditable=true] {cursor: text;}");
          };
          var isWithinCaretContainer = function(node2) {
            return isCaretContainer(node2) || startsWithCaretContainer(node2) || endsWithCaretContainer(node2);
          };
          var isRangeInCaretContainer = function(rng) {
            return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
          };
          var normalizeShortEndedElementSelection = function(rng) {
            var shortEndedElements = editor.schema.getShortEndedElements();
            var newRng = editor.dom.createRng();
            var startContainer = rng.startContainer;
            var startOffset = rng.startOffset;
            var endContainer = rng.endContainer;
            var endOffset = rng.endOffset;
            if (has2(shortEndedElements, startContainer.nodeName.toLowerCase())) {
              if (startOffset === 0) {
                newRng.setStartBefore(startContainer);
              } else {
                newRng.setStartAfter(startContainer);
              }
            } else {
              newRng.setStart(startContainer, startOffset);
            }
            if (has2(shortEndedElements, endContainer.nodeName.toLowerCase())) {
              if (endOffset === 0) {
                newRng.setEndBefore(endContainer);
              } else {
                newRng.setEndAfter(endContainer);
              }
            } else {
              newRng.setEnd(endContainer, endOffset);
            }
            return newRng;
          };
          var setContentEditableSelection = function(range3, forward) {
            var node2;
            var $ = editor.$;
            var dom2 = editor.dom;
            var $realSelectionContainer, sel, startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
            if (!range3) {
              return null;
            }
            if (range3.collapsed) {
              if (!isRangeInCaretContainer(range3)) {
                if (forward === false) {
                  caretPosition = getNormalizedRangeEndPoint2(-1, range3);
                  if (isFakeCaretTarget(caretPosition.getNode(true))) {
                    return showCaret2(-1, caretPosition.getNode(true), false, false);
                  }
                  if (isFakeCaretTarget(caretPosition.getNode())) {
                    return showCaret2(-1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
                  }
                } else {
                  caretPosition = getNormalizedRangeEndPoint2(1, range3);
                  if (isFakeCaretTarget(caretPosition.getNode())) {
                    return showCaret2(1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
                  }
                  if (isFakeCaretTarget(caretPosition.getNode(true))) {
                    return showCaret2(1, caretPosition.getNode(true), false, false);
                  }
                }
              }
              return null;
            }
            startContainer = range3.startContainer;
            startOffset = range3.startOffset;
            endOffset = range3.endOffset;
            if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse$9(startContainer.parentNode)) {
              startContainer = startContainer.parentNode;
              startOffset = dom2.nodeIndex(startContainer);
              startContainer = startContainer.parentNode;
            }
            if (startContainer.nodeType !== 1) {
              return null;
            }
            if (endOffset === startOffset + 1 && startContainer === range3.endContainer) {
              node2 = startContainer.childNodes[startOffset];
            }
            if (!isContentEditableFalse$9(node2)) {
              return null;
            }
            targetClone = origTargetClone = node2.cloneNode(true);
            e = editor.fire("ObjectSelected", {
              target: node2,
              targetClone
            });
            if (e.isDefaultPrevented()) {
              return null;
            }
            $realSelectionContainer = descendant(Element2.fromDom(editor.getBody()), "#" + realSelectionId).fold(function() {
              return $([]);
            }, function(elm) {
              return $([elm.dom()]);
            });
            targetClone = e.targetClone;
            if ($realSelectionContainer.length === 0) {
              $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr("id", realSelectionId);
              $realSelectionContainer.appendTo(editor.getBody());
            }
            range3 = editor.dom.createRng();
            if (targetClone === origTargetClone && Env.ie) {
              $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">Â </p>').append(targetClone);
              range3.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
              range3.setEndAfter(targetClone);
            } else {
              $realSelectionContainer.empty().append("Â ").append(targetClone).append("Â ");
              range3.setStart($realSelectionContainer[0].firstChild, 1);
              range3.setEnd($realSelectionContainer[0].lastChild, 0);
            }
            $realSelectionContainer.css({ top: dom2.getPos(node2, editor.getBody()).y });
            $realSelectionContainer[0].focus();
            sel = editor.selection.getSel();
            sel.removeAllRanges();
            sel.addRange(range3);
            each(descendants$1(Element2.fromDom(editor.getBody()), "*[data-mce-selected]"), function(elm) {
              remove2(elm, "data-mce-selected");
            });
            node2.setAttribute("data-mce-selected", "1");
            selectedContentEditableNode = node2;
            hideFakeCaret();
            return range3;
          };
          var removeContentEditableSelection = function() {
            if (selectedContentEditableNode) {
              selectedContentEditableNode.removeAttribute("data-mce-selected");
              descendant(Element2.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$1);
              selectedContentEditableNode = null;
            }
            descendant(Element2.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$1);
            selectedContentEditableNode = null;
          };
          var destroy2 = function() {
            fakeCaret.destroy();
            selectedContentEditableNode = null;
          };
          var hideFakeCaret = function() {
            fakeCaret.hide();
          };
          if (Env.ceFalse) {
            registerEvents2();
            addCss();
          }
          return {
            showCaret: showCaret2,
            showBlockCaretContainer: showBlockCaretContainer2,
            hideFakeCaret,
            destroy: destroy2
          };
        };
        var isValidPrefixAttrName = function(name2) {
          return name2.indexOf("data-") === 0 || name2.indexOf("aria-") === 0;
        };
        var trimComments = function(text2) {
          var sanitizedText = text2;
          while (/<!--|--!?>/g.test(sanitizedText)) {
            sanitizedText = sanitizedText.replace(/<!--|--!?>/g, "");
          }
          return sanitizedText;
        };
        var isInvalidUri = function(settings, uri) {
          if (settings.allow_html_data_urls) {
            return false;
          } else if (/^data:image\//i.test(uri)) {
            return settings.allow_svg_data_urls === false && /^data:image\/svg\+xml/i.test(uri);
          } else {
            return /^data:/i.test(uri);
          }
        };
        var findEndTagIndex = function(schema, html2, startIndex) {
          var count2 = 1, index, matches2, tokenRegExp, shortEndedElements;
          shortEndedElements = schema.getShortEndedElements();
          tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
          tokenRegExp.lastIndex = index = startIndex;
          while (matches2 = tokenRegExp.exec(html2)) {
            index = tokenRegExp.lastIndex;
            if (matches2[1] === "/") {
              count2--;
            } else if (!matches2[1]) {
              if (matches2[2] in shortEndedElements) {
                continue;
              }
              count2++;
            }
            if (count2 === 0) {
              break;
            }
          }
          return index;
        };
        var checkBogusAttribute = function(regExp, attrString) {
          var matches2 = regExp.exec(attrString);
          if (matches2) {
            var name2 = matches2[1];
            var value2 = matches2[2];
            return typeof name2 === "string" && name2.toLowerCase() === "data-mce-bogus" ? value2 : null;
          } else {
            return null;
          }
        };
        function SaxParser(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var noop2 = function() {
          };
          settings = settings || {};
          if (settings.fix_self_closing !== false) {
            settings.fix_self_closing = true;
          }
          var comment = settings.comment ? settings.comment : noop2;
          var cdata = settings.cdata ? settings.cdata : noop2;
          var text2 = settings.text ? settings.text : noop2;
          var start2 = settings.start ? settings.start : noop2;
          var end2 = settings.end ? settings.end : noop2;
          var pi2 = settings.pi ? settings.pi : noop2;
          var doctype = settings.doctype ? settings.doctype : noop2;
          var parse2 = function(html2) {
            var matches2, index = 0, value2, endRegExp;
            var stack = [];
            var attrList, i2, textData, name2;
            var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
            var validate2, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
            var attributesRequired, attributesDefault, attributesForced, processHtml;
            var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
            var decode3 = Entities.decode;
            var fixSelfClosing;
            var filteredUrlAttrs = Tools.makeMap("src,href,data,background,formaction,poster,xlink:href");
            var scriptUriRegExp = /((java|vb)script|mhtml):/i;
            var processEndTag = function(name3) {
              var pos, i3;
              pos = stack.length;
              while (pos--) {
                if (stack[pos].name === name3) {
                  break;
                }
              }
              if (pos >= 0) {
                for (i3 = stack.length - 1; i3 >= pos; i3--) {
                  name3 = stack[i3];
                  if (name3.valid) {
                    end2(name3.name);
                  }
                }
                stack.length = pos;
              }
            };
            var parseAttribute = function(match2, name3, value3, val2, val3) {
              var attrRule, i3;
              var trimRegExp = /[\s\u0000-\u001F]+/g;
              name3 = name3.toLowerCase();
              value3 = name3 in fillAttrsMap ? name3 : decode3(value3 || val2 || val3 || "");
              if (validate2 && !isInternalElement && isValidPrefixAttrName(name3) === false) {
                attrRule = validAttributesMap[name3];
                if (!attrRule && validAttributePatterns) {
                  i3 = validAttributePatterns.length;
                  while (i3--) {
                    attrRule = validAttributePatterns[i3];
                    if (attrRule.pattern.test(name3)) {
                      break;
                    }
                  }
                  if (i3 === -1) {
                    attrRule = null;
                  }
                }
                if (!attrRule) {
                  return;
                }
                if (attrRule.validValues && !(value3 in attrRule.validValues)) {
                  return;
                }
              }
              if (filteredUrlAttrs[name3] && !settings.allow_script_urls) {
                var uri = value3.replace(trimRegExp, "");
                try {
                  uri = decodeURIComponent(uri);
                } catch (ex) {
                  uri = unescape(uri);
                }
                if (scriptUriRegExp.test(uri)) {
                  return;
                }
                if (isInvalidUri(settings, uri)) {
                  return;
                }
              }
              if (isInternalElement && (name3 in filteredUrlAttrs || name3.indexOf("on") === 0)) {
                return;
              }
              attrList.map[name3] = value3;
              attrList.push({
                name: name3,
                value: value3
              });
            };
            tokenRegExp = new RegExp(`<(?:(?:!--([\\w\\W]*?)--!?>)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:!DOCTYPE([\\w\\W]*?)>)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^"'>]+(?:(?:"[^"]*")|(?:'[^']*')|[^>]*))*|\\/|\\s+)>))`, "g");
            attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
            shortEndedElements = schema.getShortEndedElements();
            selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
            fillAttrsMap = schema.getBoolAttrs();
            validate2 = settings.validate;
            removeInternalElements = settings.remove_internals;
            fixSelfClosing = settings.fix_self_closing;
            specialElements = schema.getSpecialElements();
            processHtml = html2 + ">";
            while (matches2 = tokenRegExp.exec(processHtml)) {
              if (index < matches2.index) {
                text2(decode3(html2.substr(index, matches2.index - index)));
              }
              if (value2 = matches2[6]) {
                value2 = value2.toLowerCase();
                if (value2.charAt(0) === ":") {
                  value2 = value2.substr(1);
                }
                processEndTag(value2);
              } else if (value2 = matches2[7]) {
                if (matches2.index + matches2[0].length > html2.length) {
                  text2(decode3(html2.substr(matches2.index)));
                  index = matches2.index + matches2[0].length;
                  continue;
                }
                value2 = value2.toLowerCase();
                if (value2.charAt(0) === ":") {
                  value2 = value2.substr(1);
                }
                isShortEnded = value2 in shortEndedElements;
                if (fixSelfClosing && selfClosing[value2] && stack.length > 0 && stack[stack.length - 1].name === value2) {
                  processEndTag(value2);
                }
                var bogusValue = checkBogusAttribute(attrRegExp, matches2[8]);
                if (bogusValue !== null) {
                  if (bogusValue === "all") {
                    index = findEndTagIndex(schema, html2, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    continue;
                  }
                  isValidElement = false;
                }
                if (!validate2 || (elementRule = schema.getElementRule(value2))) {
                  isValidElement = true;
                  if (validate2) {
                    validAttributesMap = elementRule.attributes;
                    validAttributePatterns = elementRule.attributePatterns;
                  }
                  if (attribsValue = matches2[8]) {
                    isInternalElement = attribsValue.indexOf("data-mce-type") !== -1;
                    if (isInternalElement && removeInternalElements) {
                      isValidElement = false;
                    }
                    attrList = [];
                    attrList.map = {};
                    attribsValue.replace(attrRegExp, parseAttribute);
                  } else {
                    attrList = [];
                    attrList.map = {};
                  }
                  if (validate2 && !isInternalElement) {
                    attributesRequired = elementRule.attributesRequired;
                    attributesDefault = elementRule.attributesDefault;
                    attributesForced = elementRule.attributesForced;
                    anyAttributesRequired = elementRule.removeEmptyAttrs;
                    if (anyAttributesRequired && !attrList.length) {
                      isValidElement = false;
                    }
                    if (attributesForced) {
                      i2 = attributesForced.length;
                      while (i2--) {
                        attr = attributesForced[i2];
                        name2 = attr.name;
                        attrValue = attr.value;
                        if (attrValue === "{$uid}") {
                          attrValue = "mce_" + idCount++;
                        }
                        attrList.map[name2] = attrValue;
                        attrList.push({
                          name: name2,
                          value: attrValue
                        });
                      }
                    }
                    if (attributesDefault) {
                      i2 = attributesDefault.length;
                      while (i2--) {
                        attr = attributesDefault[i2];
                        name2 = attr.name;
                        if (!(name2 in attrList.map)) {
                          attrValue = attr.value;
                          if (attrValue === "{$uid}") {
                            attrValue = "mce_" + idCount++;
                          }
                          attrList.map[name2] = attrValue;
                          attrList.push({
                            name: name2,
                            value: attrValue
                          });
                        }
                      }
                    }
                    if (attributesRequired) {
                      i2 = attributesRequired.length;
                      while (i2--) {
                        if (attributesRequired[i2] in attrList.map) {
                          break;
                        }
                      }
                      if (i2 === -1) {
                        isValidElement = false;
                      }
                    }
                    if (attr = attrList.map["data-mce-bogus"]) {
                      if (attr === "all") {
                        index = findEndTagIndex(schema, html2, tokenRegExp.lastIndex);
                        tokenRegExp.lastIndex = index;
                        continue;
                      }
                      isValidElement = false;
                    }
                  }
                  if (isValidElement) {
                    start2(value2, attrList, isShortEnded);
                  }
                } else {
                  isValidElement = false;
                }
                if (endRegExp = specialElements[value2]) {
                  endRegExp.lastIndex = index = matches2.index + matches2[0].length;
                  if (matches2 = endRegExp.exec(html2)) {
                    if (isValidElement) {
                      textData = html2.substr(index, matches2.index - index);
                    }
                    index = matches2.index + matches2[0].length;
                  } else {
                    textData = html2.substr(index);
                    index = html2.length;
                  }
                  if (isValidElement) {
                    if (textData.length > 0) {
                      text2(textData, true);
                    }
                    end2(value2);
                  }
                  tokenRegExp.lastIndex = index;
                  continue;
                }
                if (!isShortEnded) {
                  if (!attribsValue || attribsValue.indexOf("/") !== attribsValue.length - 1) {
                    stack.push({
                      name: value2,
                      valid: isValidElement
                    });
                  } else if (isValidElement) {
                    end2(value2);
                  }
                }
              } else if (value2 = matches2[1]) {
                if (value2.charAt(0) === ">") {
                  value2 = " " + value2;
                }
                if (!settings.allow_conditional_comments && value2.substr(0, 3).toLowerCase() === "[if") {
                  value2 = " " + value2;
                }
                comment(value2);
              } else if (value2 = matches2[2]) {
                cdata(trimComments(value2));
              } else if (value2 = matches2[3]) {
                doctype(value2);
              } else if (value2 = matches2[4]) {
                pi2(value2, matches2[5]);
              }
              index = matches2.index + matches2[0].length;
            }
            if (index < html2.length) {
              text2(decode3(html2.substr(index)));
            }
            for (i2 = stack.length - 1; i2 >= 0; i2--) {
              value2 = stack[i2];
              if (value2.valid) {
                end2(value2.name);
              }
            }
          };
          return { parse: parse2 };
        }
        (function(SaxParser2) {
          SaxParser2.findEndTag = findEndTagIndex;
        })(SaxParser || (SaxParser = {}));
        var SaxParser$1 = SaxParser;
        var trimHtml = function(tempAttrs, html2) {
          var trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
          return html2.replace(trimContentRegExp, "");
        };
        var trimInternal = function(serializer, html2) {
          var content = html2;
          var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
          var endTagIndex, index, matchLength, matches2, shortEndedElements;
          var schema = serializer.schema;
          content = trimHtml(serializer.getTempAttrs(), content);
          shortEndedElements = schema.getShortEndedElements();
          while (matches2 = bogusAllRegExp.exec(content)) {
            index = bogusAllRegExp.lastIndex;
            matchLength = matches2[0].length;
            if (shortEndedElements[matches2[1]]) {
              endTagIndex = index;
            } else {
              endTagIndex = SaxParser$1.findEndTag(schema, content, index);
            }
            content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
            bogusAllRegExp.lastIndex = index - matchLength;
          }
          return Zwsp.trim(content);
        };
        var trimExternal = trimInternal;
        var TrimHtml = {
          trimExternal,
          trimInternal
        };
        var KEEP = 0, INSERT = 1, DELETE = 2;
        var diff = function(left, right) {
          var size = left.length + right.length + 2;
          var vDown = new Array(size);
          var vUp = new Array(size);
          var snake = function(start2, end2, diag) {
            return {
              start: start2,
              end: end2,
              diag
            };
          };
          var buildScript = function(start1, end1, start2, end2, script2) {
            var middle = getMiddleSnake(start1, end1, start2, end2);
            if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
              var i2 = start1;
              var j = start2;
              while (i2 < end1 || j < end2) {
                if (i2 < end1 && j < end2 && left[i2] === right[j]) {
                  script2.push([
                    KEEP,
                    left[i2]
                  ]);
                  ++i2;
                  ++j;
                } else {
                  if (end1 - start1 > end2 - start2) {
                    script2.push([
                      DELETE,
                      left[i2]
                    ]);
                    ++i2;
                  } else {
                    script2.push([
                      INSERT,
                      right[j]
                    ]);
                    ++j;
                  }
                }
              }
            } else {
              buildScript(start1, middle.start, start2, middle.start - middle.diag, script2);
              for (var i22 = middle.start; i22 < middle.end; ++i22) {
                script2.push([
                  KEEP,
                  left[i22]
                ]);
              }
              buildScript(middle.end, end1, middle.end - middle.diag, end2, script2);
            }
          };
          var buildSnake = function(start2, diag, end1, end2) {
            var end3 = start2;
            while (end3 - diag < end2 && end3 < end1 && left[end3] === right[end3 - diag]) {
              ++end3;
            }
            return snake(start2, end3, diag);
          };
          var getMiddleSnake = function(start1, end1, start2, end2) {
            var m = end1 - start1;
            var n = end2 - start2;
            if (m === 0 || n === 0) {
              return null;
            }
            var delta2 = m - n;
            var sum2 = n + m;
            var offset = (sum2 % 2 === 0 ? sum2 : sum2 + 1) / 2;
            vDown[1 + offset] = start1;
            vUp[1 + offset] = end1 + 1;
            var d, k, i2, x, y;
            for (d = 0; d <= offset; ++d) {
              for (k = -d; k <= d; k += 2) {
                i2 = k + offset;
                if (k === -d || k !== d && vDown[i2 - 1] < vDown[i2 + 1]) {
                  vDown[i2] = vDown[i2 + 1];
                } else {
                  vDown[i2] = vDown[i2 - 1] + 1;
                }
                x = vDown[i2];
                y = x - start1 + start2 - k;
                while (x < end1 && y < end2 && left[x] === right[y]) {
                  vDown[i2] = ++x;
                  ++y;
                }
                if (delta2 % 2 !== 0 && delta2 - d <= k && k <= delta2 + d) {
                  if (vUp[i2 - delta2] <= vDown[i2]) {
                    return buildSnake(vUp[i2 - delta2], k + start1 - start2, end1, end2);
                  }
                }
              }
              for (k = delta2 - d; k <= delta2 + d; k += 2) {
                i2 = k + offset - delta2;
                if (k === delta2 - d || k !== delta2 + d && vUp[i2 + 1] <= vUp[i2 - 1]) {
                  vUp[i2] = vUp[i2 + 1] - 1;
                } else {
                  vUp[i2] = vUp[i2 - 1];
                }
                x = vUp[i2] - 1;
                y = x - start1 + start2 - k;
                while (x >= start1 && y >= start2 && left[x] === right[y]) {
                  vUp[i2] = x--;
                  y--;
                }
                if (delta2 % 2 === 0 && -d <= k && k <= d) {
                  if (vUp[i2] <= vDown[i2 + delta2]) {
                    return buildSnake(vUp[i2], k + start1 - start2, end1, end2);
                  }
                }
              }
            }
          };
          var script = [];
          buildScript(0, left.length, 0, right.length, script);
          return script;
        };
        var Diff = {
          KEEP,
          DELETE,
          INSERT,
          diff
        };
        var getOuterHtml = function(elm) {
          if (NodeType.isElement(elm)) {
            return elm.outerHTML;
          } else if (NodeType.isText(elm)) {
            return Entities.encodeRaw(elm.data, false);
          } else if (NodeType.isComment(elm)) {
            return "<!--" + elm.data + "-->";
          }
          return "";
        };
        var createFragment$1 = function(html2) {
          var frag, node2, container;
          container = domGlobals.document.createElement("div");
          frag = domGlobals.document.createDocumentFragment();
          if (html2) {
            container.innerHTML = html2;
          }
          while (node2 = container.firstChild) {
            frag.appendChild(node2);
          }
          return frag;
        };
        var insertAt = function(elm, html2, index) {
          var fragment = createFragment$1(html2);
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            var target2 = elm.childNodes[index];
            target2.parentNode.insertBefore(fragment, target2);
          } else {
            elm.appendChild(fragment);
          }
        };
        var removeAt = function(elm, index) {
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            var target2 = elm.childNodes[index];
            target2.parentNode.removeChild(target2);
          }
        };
        var applyDiff = function(diff2, elm) {
          var index = 0;
          each(diff2, function(action2) {
            if (action2[0] === Diff.KEEP) {
              index++;
            } else if (action2[0] === Diff.INSERT) {
              insertAt(elm, action2[1], index);
              index++;
            } else if (action2[0] === Diff.DELETE) {
              removeAt(elm, index);
            }
          });
        };
        var read$3 = function(elm) {
          return filter(map2(from$1(elm.childNodes), getOuterHtml), function(item) {
            return item.length > 0;
          });
        };
        var write = function(fragments, elm) {
          var currentFragments = map2(from$1(elm.childNodes), getOuterHtml);
          applyDiff(Diff.diff(currentFragments, fragments), elm);
          return elm;
        };
        var Fragments = {
          read: read$3,
          write
        };
        var undoLevelDocument = Cell(Option.none());
        var lazyTempDocument = function() {
          return undoLevelDocument.get().getOrThunk(function() {
            var doc2 = domGlobals.document.implementation.createHTMLDocument("undo");
            undoLevelDocument.set(Option.some(doc2));
            return doc2;
          });
        };
        var hasIframes = function(html2) {
          return html2.indexOf("</iframe>") !== -1;
        };
        var createFragmentedLevel = function(fragments) {
          return {
            type: "fragmented",
            fragments,
            content: "",
            bookmark: null,
            beforeBookmark: null
          };
        };
        var createCompleteLevel = function(content) {
          return {
            type: "complete",
            fragments: null,
            content,
            bookmark: null,
            beforeBookmark: null
          };
        };
        var createFromEditor = function(editor) {
          var fragments, content, trimmedFragments;
          fragments = Fragments.read(editor.getBody());
          trimmedFragments = bind(fragments, function(html2) {
            var trimmed = TrimHtml.trimInternal(editor.serializer, html2);
            return trimmed.length > 0 ? [trimmed] : [];
          });
          content = trimmedFragments.join("");
          return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
        };
        var applyToEditor = function(editor, level, before2) {
          if (level.type === "fragmented") {
            Fragments.write(level.fragments, editor.getBody());
          } else {
            editor.setContent(level.content, { format: "raw" });
          }
          editor.selection.moveToBookmark(before2 ? level.beforeBookmark : level.bookmark);
        };
        var getLevelContent = function(level) {
          return level.type === "fragmented" ? level.fragments.join("") : level.content;
        };
        var getCleanLevelContent = function(level) {
          var elm = Element2.fromTag("body", lazyTempDocument());
          set$1(elm, getLevelContent(level));
          each(descendants$1(elm, "*[data-mce-bogus]"), unwrap);
          return get$3(elm);
        };
        var hasEqualContent = function(level1, level2) {
          return getLevelContent(level1) === getLevelContent(level2);
        };
        var hasEqualCleanedContent = function(level1, level2) {
          return getCleanLevelContent(level1) === getCleanLevelContent(level2);
        };
        var isEq$4 = function(level1, level2) {
          if (!level1 || !level2) {
            return false;
          } else if (hasEqualContent(level1, level2)) {
            return true;
          } else {
            return hasEqualCleanedContent(level1, level2);
          }
        };
        var Levels = {
          createFragmentedLevel,
          createCompleteLevel,
          createFromEditor,
          applyToEditor,
          isEq: isEq$4
        };
        function UndoManager(editor) {
          var self2 = this, index = 0, data2 = [], beforeBookmark, isFirstTypedCharacter, locks = 0;
          var isUnlocked = function() {
            return locks === 0;
          };
          var setTyping = function(typing) {
            if (isUnlocked()) {
              self2.typing = typing;
            }
          };
          var setDirty = function(state) {
            editor.setDirty(state);
          };
          var addNonTypingUndoLevel = function(e) {
            setTyping(false);
            self2.add({}, e);
          };
          var endTyping = function() {
            if (self2.typing) {
              setTyping(false);
              self2.add();
            }
          };
          editor.on("init", function() {
            self2.add();
          });
          editor.on("BeforeExecCommand", function(e) {
            var cmd = e.command;
            if (cmd !== "Undo" && cmd !== "Redo" && cmd !== "mceRepaint") {
              endTyping();
              self2.beforeChange();
            }
          });
          editor.on("ExecCommand", function(e) {
            var cmd = e.command;
            if (cmd !== "Undo" && cmd !== "Redo" && cmd !== "mceRepaint") {
              addNonTypingUndoLevel(e);
            }
          });
          editor.on("ObjectResizeStart Cut", function() {
            self2.beforeChange();
          });
          editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
          editor.on("DragEnd", addNonTypingUndoLevel);
          editor.on("KeyUp", function(e) {
            var keyCode = e.keyCode;
            if (e.isDefaultPrevented()) {
              return;
            }
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
              addNonTypingUndoLevel();
              editor.nodeChanged();
            }
            if (keyCode === 46 || keyCode === 8) {
              editor.nodeChanged();
            }
            if (isFirstTypedCharacter && self2.typing && Levels.isEq(Levels.createFromEditor(editor), data2[0]) === false) {
              if (editor.isDirty() === false) {
                setDirty(true);
                editor.fire("change", {
                  level: data2[0],
                  lastLevel: null
                });
              }
              editor.fire("TypingUndo");
              isFirstTypedCharacter = false;
              editor.nodeChanged();
            }
          });
          editor.on("KeyDown", function(e) {
            var keyCode = e.keyCode;
            if (e.isDefaultPrevented()) {
              return;
            }
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
              if (self2.typing) {
                addNonTypingUndoLevel(e);
              }
              return;
            }
            var modKey = e.ctrlKey && !e.altKey || e.metaKey;
            if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !self2.typing && !modKey) {
              self2.beforeChange();
              setTyping(true);
              self2.add({}, e);
              isFirstTypedCharacter = true;
            }
          });
          editor.on("MouseDown", function(e) {
            if (self2.typing) {
              addNonTypingUndoLevel(e);
            }
          });
          var isInsertReplacementText = function(event) {
            return event.inputType === "insertReplacementText";
          };
          var isInsertTextDataNull = function(event) {
            return event.inputType === "insertText" && event.data === null;
          };
          editor.on("input", function(e) {
            if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e))) {
              addNonTypingUndoLevel(e);
            }
          });
          editor.addShortcut("meta+z", "", "Undo");
          editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
          editor.on("AddUndo Undo Redo ClearUndos", function(e) {
            if (!e.isDefaultPrevented()) {
              editor.nodeChanged();
            }
          });
          self2 = {
            data: data2,
            typing: false,
            beforeChange: function() {
              if (isUnlocked()) {
                beforeBookmark = GetBookmark.getUndoBookmark(editor.selection);
              }
            },
            add: function(level, event) {
              var i2;
              var settings = editor.settings;
              var lastLevel, currentLevel;
              currentLevel = Levels.createFromEditor(editor);
              level = level || {};
              level = Tools.extend(level, currentLevel);
              if (isUnlocked() === false || editor.removed) {
                return null;
              }
              lastLevel = data2[index];
              if (editor.fire("BeforeAddUndo", {
                level,
                lastLevel,
                originalEvent: event
              }).isDefaultPrevented()) {
                return null;
              }
              if (lastLevel && Levels.isEq(lastLevel, level)) {
                return null;
              }
              if (data2[index]) {
                data2[index].beforeBookmark = beforeBookmark;
              }
              if (settings.custom_undo_redo_levels) {
                if (data2.length > settings.custom_undo_redo_levels) {
                  for (i2 = 0; i2 < data2.length - 1; i2++) {
                    data2[i2] = data2[i2 + 1];
                  }
                  data2.length--;
                  index = data2.length;
                }
              }
              level.bookmark = GetBookmark.getUndoBookmark(editor.selection);
              if (index < data2.length - 1) {
                data2.length = index + 1;
              }
              data2.push(level);
              index = data2.length - 1;
              var args = {
                level,
                lastLevel,
                originalEvent: event
              };
              editor.fire("AddUndo", args);
              if (index > 0) {
                setDirty(true);
                editor.fire("change", args);
              }
              return level;
            },
            undo: function() {
              var level;
              if (self2.typing) {
                self2.add();
                self2.typing = false;
                setTyping(false);
              }
              if (index > 0) {
                level = data2[--index];
                Levels.applyToEditor(editor, level, true);
                setDirty(true);
                editor.fire("undo", { level });
              }
              return level;
            },
            redo: function() {
              var level;
              if (index < data2.length - 1) {
                level = data2[++index];
                Levels.applyToEditor(editor, level, false);
                setDirty(true);
                editor.fire("redo", { level });
              }
              return level;
            },
            clear: function() {
              data2 = [];
              index = 0;
              self2.typing = false;
              self2.data = data2;
              editor.fire("ClearUndos");
            },
            hasUndo: function() {
              return index > 0 || self2.typing && data2[0] && !Levels.isEq(Levels.createFromEditor(editor), data2[0]);
            },
            hasRedo: function() {
              return index < data2.length - 1 && !self2.typing;
            },
            transact: function(callback) {
              endTyping();
              self2.beforeChange();
              self2.ignore(callback);
              return self2.add();
            },
            ignore: function(callback) {
              try {
                locks++;
                callback();
              } finally {
                locks--;
              }
            },
            extra: function(callback1, callback2) {
              var lastLevel, bookmark;
              if (self2.transact(callback1)) {
                bookmark = data2[index].bookmark;
                lastLevel = data2[index - 1];
                Levels.applyToEditor(editor, lastLevel, true);
                if (self2.transact(callback2)) {
                  data2[index - 1].beforeBookmark = bookmark;
                }
              }
            }
          };
          return self2;
        }
        var postProcessHooks = {}, filter$2 = ArrUtils.filter, each$c = ArrUtils.each;
        var addPostProcessHook = function(name2, hook) {
          var hooks = postProcessHooks[name2];
          if (!hooks) {
            postProcessHooks[name2] = hooks = [];
          }
          postProcessHooks[name2].push(hook);
        };
        var postProcess2 = function(name2, editor) {
          each$c(postProcessHooks[name2], function(hook) {
            hook(editor);
          });
        };
        addPostProcessHook("pre", function(editor) {
          var rng = editor.selection.getRng();
          var isPre, blocks2;
          var hasPreSibling = function(pre2) {
            return isPre(pre2.previousSibling) && ArrUtils.indexOf(blocks2, pre2.previousSibling) !== -1;
          };
          var joinPre = function(pre1, pre2) {
            DomQuery(pre2).remove();
            DomQuery(pre1).append("<br><br>").append(pre2.childNodes);
          };
          isPre = NodeType.matchNodeNames("pre");
          if (!rng.collapsed) {
            blocks2 = editor.selection.getSelectedBlocks();
            each$c(filter$2(filter$2(blocks2, isPre), hasPreSibling), function(pre2) {
              joinPre(pre2.previousSibling, pre2);
            });
          }
        });
        var Hooks = { postProcess: postProcess2 };
        var MCE_ATTR_RE = /^(src|href|style)$/;
        var each$d = Tools.each;
        var isEq$5 = FormatUtils.isEq;
        var isTableCell$4 = function(node2) {
          return /^(TH|TD)$/.test(node2.nodeName);
        };
        var isChildOfInlineParent = function(dom2, node2, parent2) {
          return dom2.isChildOf(node2, parent2) && node2 !== parent2 && !dom2.isBlock(parent2);
        };
        var getContainer = function(ed, rng, start2) {
          var container, offset, lastIdx;
          container = rng[start2 ? "startContainer" : "endContainer"];
          offset = rng[start2 ? "startOffset" : "endOffset"];
          if (NodeType.isElement(container)) {
            lastIdx = container.childNodes.length - 1;
            if (!start2 && offset) {
              offset--;
            }
            container = container.childNodes[offset > lastIdx ? lastIdx : offset];
          }
          if (NodeType.isText(container) && start2 && offset >= container.nodeValue.length) {
            container = new TreeWalker(container, ed.getBody()).next() || container;
          }
          if (NodeType.isText(container) && !start2 && offset === 0) {
            container = new TreeWalker(container, ed.getBody()).prev() || container;
          }
          return container;
        };
        var wrap$2 = function(dom2, node2, name2, attrs) {
          var wrapper = dom2.create(name2, attrs);
          node2.parentNode.insertBefore(wrapper, node2);
          wrapper.appendChild(node2);
          return wrapper;
        };
        var wrapWithSiblings = function(dom2, node2, next2, name2, attrs) {
          var start2 = Element2.fromDom(node2);
          var wrapper = Element2.fromDom(dom2.create(name2, attrs));
          var siblings = next2 ? nextSiblings(start2) : prevSiblings(start2);
          append$1(wrapper, siblings);
          if (next2) {
            before(start2, wrapper);
            prepend(wrapper, start2);
          } else {
            after(start2, wrapper);
            append(wrapper, start2);
          }
          return wrapper.dom();
        };
        var matchName$1 = function(dom2, node2, format2) {
          if (isEq$5(node2, format2.inline)) {
            return true;
          }
          if (isEq$5(node2, format2.block)) {
            return true;
          }
          if (format2.selector) {
            return NodeType.isElement(node2) && dom2.is(node2, format2.selector);
          }
        };
        var isColorFormatAndAnchor = function(node2, format2) {
          return format2.links && node2.tagName === "A";
        };
        var find$3 = function(dom2, node2, next2, inc) {
          node2 = FormatUtils.getNonWhiteSpaceSibling(node2, next2, inc);
          return !node2 || (node2.nodeName === "BR" || dom2.isBlock(node2));
        };
        var removeNode$1 = function(ed, node2, format2) {
          var parentNode = node2.parentNode;
          var rootBlockElm;
          var dom2 = ed.dom, forcedRootBlock = ed.settings.forced_root_block;
          if (format2.block) {
            if (!forcedRootBlock) {
              if (dom2.isBlock(node2) && !dom2.isBlock(parentNode)) {
                if (!find$3(dom2, node2, false) && !find$3(dom2, node2.firstChild, true, 1)) {
                  node2.insertBefore(dom2.create("br"), node2.firstChild);
                }
                if (!find$3(dom2, node2, true) && !find$3(dom2, node2.lastChild, false, 1)) {
                  node2.appendChild(dom2.create("br"));
                }
              }
            } else {
              if (parentNode === dom2.getRoot()) {
                if (!format2.list_block || !isEq$5(node2, format2.list_block)) {
                  each$d(Tools.grep(node2.childNodes), function(node3) {
                    if (FormatUtils.isValid(ed, forcedRootBlock, node3.nodeName.toLowerCase())) {
                      if (!rootBlockElm) {
                        rootBlockElm = wrap$2(dom2, node3, forcedRootBlock);
                        dom2.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                      } else {
                        rootBlockElm.appendChild(node3);
                      }
                    } else {
                      rootBlockElm = 0;
                    }
                  });
                }
              }
            }
          }
          if (format2.selector && format2.inline && !isEq$5(format2.inline, node2)) {
            return;
          }
          dom2.remove(node2, 1);
        };
        var removeFormat = function(ed, format2, vars, node2, compareNode) {
          var i2, attrs, stylesModified;
          var dom2 = ed.dom;
          if (!matchName$1(dom2, node2, format2) && !isColorFormatAndAnchor(node2, format2)) {
            return false;
          }
          if (format2.remove !== "all") {
            each$d(format2.styles, function(value2, name2) {
              value2 = FormatUtils.normalizeStyleValue(dom2, FormatUtils.replaceVars(value2, vars), name2);
              if (typeof name2 === "number") {
                name2 = value2;
                compareNode = 0;
              }
              if (format2.remove_similar || (!compareNode || isEq$5(FormatUtils.getStyle(dom2, compareNode, name2), value2))) {
                dom2.setStyle(node2, name2, "");
              }
              stylesModified = 1;
            });
            if (stylesModified && dom2.getAttrib(node2, "style") === "") {
              node2.removeAttribute("style");
              node2.removeAttribute("data-mce-style");
            }
            each$d(format2.attributes, function(value2, name2) {
              var valueOut;
              value2 = FormatUtils.replaceVars(value2, vars);
              if (typeof name2 === "number") {
                name2 = value2;
                compareNode = 0;
              }
              if (!compareNode || isEq$5(dom2.getAttrib(compareNode, name2), value2)) {
                if (name2 === "class") {
                  value2 = dom2.getAttrib(node2, name2);
                  if (value2) {
                    valueOut = "";
                    each$d(value2.split(/\s+/), function(cls) {
                      if (/mce\-\w+/.test(cls)) {
                        valueOut += (valueOut ? " " : "") + cls;
                      }
                    });
                    if (valueOut) {
                      dom2.setAttrib(node2, name2, valueOut);
                      return;
                    }
                  }
                }
                if (name2 === "class") {
                  node2.removeAttribute("className");
                }
                if (MCE_ATTR_RE.test(name2)) {
                  node2.removeAttribute("data-mce-" + name2);
                }
                node2.removeAttribute(name2);
              }
            });
            each$d(format2.classes, function(value2) {
              value2 = FormatUtils.replaceVars(value2, vars);
              if (!compareNode || dom2.hasClass(compareNode, value2)) {
                dom2.removeClass(node2, value2);
              }
            });
            attrs = dom2.getAttribs(node2);
            for (i2 = 0; i2 < attrs.length; i2++) {
              var attrName = attrs[i2].nodeName;
              if (attrName.indexOf("_") !== 0 && attrName.indexOf("data-") !== 0) {
                return false;
              }
            }
          }
          if (format2.remove !== "none") {
            removeNode$1(ed, node2, format2);
            return true;
          }
        };
        var findFormatRoot = function(editor, container, name2, vars, similar) {
          var formatRoot;
          each$d(FormatUtils.getParents(editor.dom, container.parentNode).reverse(), function(parent2) {
            var format2;
            if (!formatRoot && parent2.id !== "_start" && parent2.id !== "_end") {
              format2 = MatchFormat.matchNode(editor, parent2, name2, vars, similar);
              if (format2 && format2.split !== false) {
                formatRoot = parent2;
              }
            }
          });
          return formatRoot;
        };
        var wrapAndSplit = function(editor, formatList, formatRoot, container, target2, split2, format2, vars) {
          var parent2, clone2, lastClone, firstClone, i2, formatRootParent;
          var dom2 = editor.dom;
          if (formatRoot) {
            formatRootParent = formatRoot.parentNode;
            for (parent2 = container.parentNode; parent2 && parent2 !== formatRootParent; parent2 = parent2.parentNode) {
              clone2 = dom2.clone(parent2, false);
              for (i2 = 0; i2 < formatList.length; i2++) {
                if (removeFormat(editor, formatList[i2], vars, clone2, clone2)) {
                  clone2 = 0;
                  break;
                }
              }
              if (clone2) {
                if (lastClone) {
                  clone2.appendChild(lastClone);
                }
                if (!firstClone) {
                  firstClone = clone2;
                }
                lastClone = clone2;
              }
            }
            if (!format2.mixed || !dom2.isBlock(formatRoot)) {
              container = dom2.split(formatRoot, container);
            }
            if (lastClone) {
              target2.parentNode.insertBefore(lastClone, target2);
              firstClone.appendChild(target2);
            }
          }
          return container;
        };
        var remove$6 = function(ed, name2, vars, node2, similar) {
          var formatList = ed.formatter.get(name2), format2 = formatList[0];
          var bookmark, rng, contentEditable2 = true;
          var dom2 = ed.dom;
          var selection = ed.selection;
          var splitToFormatRoot = function(container) {
            var formatRoot = findFormatRoot(ed, container, name2, vars, similar);
            return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format2, vars);
          };
          var isRemoveBookmarkNode = function(node3) {
            return Bookmarks.isBookmarkNode(node3) && NodeType.isElement(node3) && (node3.id === "_start" || node3.id === "_end");
          };
          var process3 = function(node3) {
            var children2, i3, l2, lastContentEditable, hasContentEditableState2;
            if (NodeType.isElement(node3) && dom2.getContentEditable(node3)) {
              lastContentEditable = contentEditable2;
              contentEditable2 = dom2.getContentEditable(node3) === "true";
              hasContentEditableState2 = true;
            }
            children2 = Tools.grep(node3.childNodes);
            if (contentEditable2 && !hasContentEditableState2) {
              for (i3 = 0, l2 = formatList.length; i3 < l2; i3++) {
                if (removeFormat(ed, formatList[i3], vars, node3, node3)) {
                  break;
                }
              }
            }
            if (format2.deep) {
              if (children2.length) {
                for (i3 = 0, l2 = children2.length; i3 < l2; i3++) {
                  process3(children2[i3]);
                }
                if (hasContentEditableState2) {
                  contentEditable2 = lastContentEditable;
                }
              }
            }
          };
          var unwrap2 = function(start2) {
            var node3 = dom2.get(start2 ? "_start" : "_end");
            var out = node3[start2 ? "firstChild" : "lastChild"];
            if (isRemoveBookmarkNode(out)) {
              out = out[start2 ? "firstChild" : "lastChild"];
            }
            if (NodeType.isText(out) && out.data.length === 0) {
              out = start2 ? node3.previousSibling || node3.nextSibling : node3.nextSibling || node3.previousSibling;
            }
            dom2.remove(node3, true);
            return out;
          };
          var removeRngStyle = function(rng2) {
            var startContainer, endContainer;
            var commonAncestorContainer = rng2.commonAncestorContainer;
            rng2 = ExpandRange.expandRng(ed, rng2, formatList, true);
            if (format2.split) {
              rng2 = SplitRange.split(rng2);
              startContainer = getContainer(ed, rng2, true);
              endContainer = getContainer(ed, rng2);
              if (startContainer !== endContainer) {
                if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
                  if (startContainer.nodeName === "TR") {
                    startContainer = startContainer.firstChild.firstChild || startContainer;
                  } else {
                    startContainer = startContainer.firstChild || startContainer;
                  }
                }
                if (commonAncestorContainer && /^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) && isTableCell$4(endContainer) && endContainer.firstChild) {
                  endContainer = endContainer.firstChild || endContainer;
                }
                if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
                  var marker2 = Option.from(startContainer.firstChild).getOr(startContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker2, true, "span", {
                    "id": "_start",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(true);
                  return;
                }
                if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
                  var marker2 = Option.from(endContainer.lastChild).getOr(endContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker2, false, "span", {
                    "id": "_end",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(false);
                  return;
                }
                startContainer = wrap$2(dom2, startContainer, "span", {
                  "id": "_start",
                  "data-mce-type": "bookmark"
                });
                endContainer = wrap$2(dom2, endContainer, "span", {
                  "id": "_end",
                  "data-mce-type": "bookmark"
                });
                splitToFormatRoot(startContainer);
                splitToFormatRoot(endContainer);
                startContainer = unwrap2(true);
                endContainer = unwrap2();
              } else {
                startContainer = endContainer = splitToFormatRoot(startContainer);
              }
              rng2.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
              rng2.startOffset = dom2.nodeIndex(startContainer);
              rng2.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
              rng2.endOffset = dom2.nodeIndex(endContainer) + 1;
            }
            RangeWalk.walk(dom2, rng2, function(nodes) {
              each$d(nodes, function(node3) {
                process3(node3);
                if (NodeType.isElement(node3) && ed.dom.getStyle(node3, "text-decoration") === "underline" && node3.parentNode && FormatUtils.getTextDecoration(dom2, node3.parentNode) === "underline") {
                  removeFormat(ed, {
                    inline: "span",
                    styles: { textDecoration: "underline" }
                  }, null, node3);
                }
              });
            });
          };
          if (node2) {
            if (node2.nodeType) {
              rng = dom2.createRng();
              rng.setStartBefore(node2);
              rng.setEndAfter(node2);
              removeRngStyle(rng);
            } else {
              removeRngStyle(node2);
            }
            return;
          }
          if (dom2.getContentEditable(selection.getNode()) === "false") {
            node2 = selection.getNode();
            for (var i2 = 0, l = formatList.length; i2 < l; i2++) {
              if (formatList[i2].ceFalseOverride) {
                if (removeFormat(ed, formatList[i2], vars, node2, node2)) {
                  break;
                }
              }
            }
            return;
          }
          if (!selection.isCollapsed() || !format2.inline || dom2.select("td[data-mce-selected],th[data-mce-selected]").length) {
            bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
            removeRngStyle(selection.getRng());
            selection.moveToBookmark(bookmark);
            if (format2.inline && MatchFormat.match(ed, name2, vars, selection.getStart())) {
              FormatUtils.moveStart(dom2, selection, selection.getRng());
            }
            ed.nodeChanged();
          } else {
            removeCaretFormat(ed, name2, vars, similar);
          }
        };
        var RemoveFormat = {
          removeFormat,
          remove: remove$6
        };
        var each$e = Tools.each;
        var isElementNode = function(node2) {
          return node2 && node2.nodeType === 1 && !Bookmarks.isBookmarkNode(node2) && !isCaretNode(node2) && !NodeType.isBogus(node2);
        };
        var findElementSibling = function(node2, siblingName) {
          var sibling2;
          for (sibling2 = node2; sibling2; sibling2 = sibling2[siblingName]) {
            if (sibling2.nodeType === 3 && sibling2.nodeValue.length !== 0) {
              return node2;
            }
            if (sibling2.nodeType === 1 && !Bookmarks.isBookmarkNode(sibling2)) {
              return sibling2;
            }
          }
          return node2;
        };
        var mergeSiblingsNodes = function(dom2, prev, next2) {
          var sibling2, tmpSibling;
          var elementUtils = new ElementUtils(dom2);
          if (prev && next2) {
            prev = findElementSibling(prev, "previousSibling");
            next2 = findElementSibling(next2, "nextSibling");
            if (elementUtils.compare(prev, next2)) {
              for (sibling2 = prev.nextSibling; sibling2 && sibling2 !== next2; ) {
                tmpSibling = sibling2;
                sibling2 = sibling2.nextSibling;
                prev.appendChild(tmpSibling);
              }
              dom2.remove(next2);
              Tools.each(Tools.grep(next2.childNodes), function(node2) {
                prev.appendChild(node2);
              });
              return prev;
            }
          }
          return next2;
        };
        var processChildElements = function(node2, filter2, process3) {
          each$e(node2.childNodes, function(node3) {
            if (isElementNode(node3)) {
              if (filter2(node3)) {
                process3(node3);
              }
              if (node3.hasChildNodes()) {
                processChildElements(node3, filter2, process3);
              }
            }
          });
        };
        var hasStyle = function(dom2, name2) {
          return curry(function(name3, node2) {
            return !!(node2 && FormatUtils.getStyle(dom2, node2, name3));
          }, name2);
        };
        var applyStyle = function(dom2, name2, value2) {
          return curry(function(name3, value3, node2) {
            dom2.setStyle(node2, name3, value3);
            if (node2.getAttribute("style") === "") {
              node2.removeAttribute("style");
            }
            unwrapEmptySpan(dom2, node2);
          }, name2, value2);
        };
        var unwrapEmptySpan = function(dom2, node2) {
          if (node2.nodeName === "SPAN" && dom2.getAttribs(node2).length === 0) {
            dom2.remove(node2, true);
          }
        };
        var processUnderlineAndColor = function(dom2, node2) {
          var textDecoration;
          if (node2.nodeType === 1 && node2.parentNode && node2.parentNode.nodeType === 1) {
            textDecoration = FormatUtils.getTextDecoration(dom2, node2.parentNode);
            if (dom2.getStyle(node2, "color") && textDecoration) {
              dom2.setStyle(node2, "text-decoration", textDecoration);
            } else if (dom2.getStyle(node2, "text-decoration") === textDecoration) {
              dom2.setStyle(node2, "text-decoration", null);
            }
          }
        };
        var mergeUnderlineAndColor = function(dom2, format2, vars, node2) {
          if (format2.styles.color || format2.styles.textDecoration) {
            Tools.walk(node2, curry(processUnderlineAndColor, dom2), "childNodes");
            processUnderlineAndColor(dom2, node2);
          }
        };
        var mergeBackgroundColorAndFontSize = function(dom2, format2, vars, node2) {
          if (format2.styles && format2.styles.backgroundColor) {
            processChildElements(node2, hasStyle(dom2, "fontSize"), applyStyle(dom2, "backgroundColor", FormatUtils.replaceVars(format2.styles.backgroundColor, vars)));
          }
        };
        var mergeSubSup = function(dom2, format2, vars, node2) {
          if (format2.inline === "sub" || format2.inline === "sup") {
            processChildElements(node2, hasStyle(dom2, "fontSize"), applyStyle(dom2, "fontSize", ""));
            dom2.remove(dom2.select(format2.inline === "sup" ? "sub" : "sup", node2), true);
          }
        };
        var mergeSiblings = function(dom2, format2, vars, node2) {
          if (node2 && format2.merge_siblings !== false) {
            node2 = mergeSiblingsNodes(dom2, FormatUtils.getNonWhiteSpaceSibling(node2), node2);
            node2 = mergeSiblingsNodes(dom2, node2, FormatUtils.getNonWhiteSpaceSibling(node2, true));
          }
        };
        var clearChildStyles = function(dom2, format2, node2) {
          if (format2.clear_child_styles) {
            var selector = format2.links ? "*:not(a)" : "*";
            each$e(dom2.select(selector, node2), function(node3) {
              if (isElementNode(node3)) {
                each$e(format2.styles, function(value2, name2) {
                  dom2.setStyle(node3, name2, "");
                });
              }
            });
          }
        };
        var mergeWithChildren = function(editor, formatList, vars, node2) {
          each$e(formatList, function(format2) {
            each$e(editor.dom.select(format2.inline, node2), function(child2) {
              if (!isElementNode(child2)) {
                return;
              }
              RemoveFormat.removeFormat(editor, format2, vars, child2, format2.exact ? child2 : null);
            });
            clearChildStyles(editor.dom, format2, node2);
          });
        };
        var mergeWithParents = function(editor, format2, name2, vars, node2) {
          if (MatchFormat.matchNode(editor, node2.parentNode, name2, vars)) {
            if (RemoveFormat.removeFormat(editor, format2, vars, node2)) {
              return;
            }
          }
          if (format2.merge_with_parents) {
            editor.dom.getParent(node2.parentNode, function(parent2) {
              if (MatchFormat.matchNode(editor, parent2, name2, vars)) {
                RemoveFormat.removeFormat(editor, format2, vars, node2);
                return true;
              }
            });
          }
        };
        var MergeFormats = {
          mergeWithChildren,
          mergeUnderlineAndColor,
          mergeBackgroundColorAndFontSize,
          mergeSubSup,
          mergeSiblings,
          mergeWithParents
        };
        var each$f = Tools.each;
        var isElementNode$1 = function(node2) {
          return node2 && node2.nodeType === 1 && !Bookmarks.isBookmarkNode(node2) && !isCaretNode(node2) && !NodeType.isBogus(node2);
        };
        var applyFormat = function(ed, name2, vars, node2) {
          var formatList = ed.formatter.get(name2);
          var format2 = formatList[0];
          var bookmark, rng;
          var isCollapsed = !node2 && ed.selection.isCollapsed();
          var dom2 = ed.dom, selection = ed.selection;
          var setElementFormat = function(elm, fmt) {
            fmt = fmt || format2;
            if (elm) {
              if (fmt.onformat) {
                fmt.onformat(elm, fmt, vars, node2);
              }
              each$f(fmt.styles, function(value2, name3) {
                dom2.setStyle(elm, name3, FormatUtils.replaceVars(value2, vars));
              });
              if (fmt.styles) {
                var styleVal = dom2.getAttrib(elm, "style");
                if (styleVal) {
                  elm.setAttribute("data-mce-style", styleVal);
                }
              }
              each$f(fmt.attributes, function(value2, name3) {
                dom2.setAttrib(elm, name3, FormatUtils.replaceVars(value2, vars));
              });
              each$f(fmt.classes, function(value2) {
                value2 = FormatUtils.replaceVars(value2, vars);
                if (!dom2.hasClass(elm, value2)) {
                  dom2.addClass(elm, value2);
                }
              });
            }
          };
          var applyNodeStyle = function(formatList2, node3) {
            var found = false;
            if (!format2.selector) {
              return false;
            }
            each$f(formatList2, function(format3) {
              if ("collapsed" in format3 && format3.collapsed !== isCollapsed) {
                return;
              }
              if (dom2.is(node3, format3.selector) && !isCaretNode(node3)) {
                setElementFormat(node3, format3);
                found = true;
                return false;
              }
            });
            return found;
          };
          var applyRngStyle = function(dom3, rng2, bookmark2, nodeSpecific) {
            var newWrappers = [];
            var wrapName, wrapElm, contentEditable2 = true;
            wrapName = format2.inline || format2.block;
            wrapElm = dom3.create(wrapName);
            setElementFormat(wrapElm);
            RangeWalk.walk(dom3, rng2, function(nodes) {
              var currentWrapElm;
              var process3 = function(node3) {
                var nodeName, parentName, hasContentEditableState2, lastContentEditable;
                lastContentEditable = contentEditable2;
                nodeName = node3.nodeName.toLowerCase();
                parentName = node3.parentNode.nodeName.toLowerCase();
                if (node3.nodeType === 1 && dom3.getContentEditable(node3)) {
                  lastContentEditable = contentEditable2;
                  contentEditable2 = dom3.getContentEditable(node3) === "true";
                  hasContentEditableState2 = true;
                }
                if (FormatUtils.isEq(nodeName, "br")) {
                  currentWrapElm = 0;
                  if (format2.block) {
                    dom3.remove(node3);
                  }
                  return;
                }
                if (format2.wrapper && MatchFormat.matchNode(ed, node3, name2, vars)) {
                  currentWrapElm = 0;
                  return;
                }
                if (contentEditable2 && !hasContentEditableState2 && format2.block && !format2.wrapper && FormatUtils.isTextBlock(ed, nodeName) && FormatUtils.isValid(ed, parentName, wrapName)) {
                  node3 = dom3.rename(node3, wrapName);
                  setElementFormat(node3);
                  newWrappers.push(node3);
                  currentWrapElm = 0;
                  return;
                }
                if (format2.selector) {
                  var found = applyNodeStyle(formatList, node3);
                  if (!format2.inline || found) {
                    currentWrapElm = 0;
                    return;
                  }
                }
                if (contentEditable2 && !hasContentEditableState2 && FormatUtils.isValid(ed, wrapName, nodeName) && FormatUtils.isValid(ed, parentName, wrapName) && !(!nodeSpecific && node3.nodeType === 3 && node3.nodeValue.length === 1 && node3.nodeValue.charCodeAt(0) === 65279) && !isCaretNode(node3) && (!format2.inline || !dom3.isBlock(node3))) {
                  if (!currentWrapElm) {
                    currentWrapElm = dom3.clone(wrapElm, false);
                    node3.parentNode.insertBefore(currentWrapElm, node3);
                    newWrappers.push(currentWrapElm);
                  }
                  currentWrapElm.appendChild(node3);
                } else {
                  currentWrapElm = 0;
                  each$f(Tools.grep(node3.childNodes), process3);
                  if (hasContentEditableState2) {
                    contentEditable2 = lastContentEditable;
                  }
                  currentWrapElm = 0;
                }
              };
              each$f(nodes, process3);
            });
            if (format2.links === true) {
              each$f(newWrappers, function(node3) {
                var process3 = function(node4) {
                  if (node4.nodeName === "A") {
                    setElementFormat(node4, format2);
                  }
                  each$f(Tools.grep(node4.childNodes), process3);
                };
                process3(node3);
              });
            }
            each$f(newWrappers, function(node3) {
              var childCount;
              var getChildCount = function(node4) {
                var count2 = 0;
                each$f(node4.childNodes, function(node5) {
                  if (!FormatUtils.isWhiteSpaceNode(node5) && !Bookmarks.isBookmarkNode(node5)) {
                    count2++;
                  }
                });
                return count2;
              };
              var getChildElementNode = function(root2) {
                var child2 = false;
                each$f(root2.childNodes, function(node4) {
                  if (isElementNode$1(node4)) {
                    child2 = node4;
                    return false;
                  }
                });
                return child2;
              };
              var mergeStyles = function(node4) {
                var child2, clone2;
                child2 = getChildElementNode(node4);
                if (child2 && !Bookmarks.isBookmarkNode(child2) && MatchFormat.matchName(dom3, child2, format2)) {
                  clone2 = dom3.clone(child2, false);
                  setElementFormat(clone2);
                  dom3.replace(clone2, node4, true);
                  dom3.remove(child2, 1);
                }
                return clone2 || node4;
              };
              childCount = getChildCount(node3);
              if ((newWrappers.length > 1 || !dom3.isBlock(node3)) && childCount === 0) {
                dom3.remove(node3, 1);
                return;
              }
              if (format2.inline || format2.wrapper) {
                if (!format2.exact && childCount === 1) {
                  node3 = mergeStyles(node3);
                }
                MergeFormats.mergeWithChildren(ed, formatList, vars, node3);
                MergeFormats.mergeWithParents(ed, format2, name2, vars, node3);
                MergeFormats.mergeBackgroundColorAndFontSize(dom3, format2, vars, node3);
                MergeFormats.mergeSubSup(dom3, format2, vars, node3);
                MergeFormats.mergeSiblings(dom3, format2, vars, node3);
              }
            });
          };
          if (dom2.getContentEditable(selection.getNode()) === "false") {
            node2 = selection.getNode();
            for (var i2 = 0, l = formatList.length; i2 < l; i2++) {
              if (formatList[i2].ceFalseOverride && dom2.is(node2, formatList[i2].selector)) {
                setElementFormat(node2, formatList[i2]);
                return;
              }
            }
            return;
          }
          if (format2) {
            if (node2) {
              if (node2.nodeType) {
                if (!applyNodeStyle(formatList, node2)) {
                  rng = dom2.createRng();
                  rng.setStartBefore(node2);
                  rng.setEndAfter(node2);
                  applyRngStyle(dom2, ExpandRange.expandRng(ed, rng, formatList), null, true);
                }
              } else {
                applyRngStyle(dom2, node2, null, true);
              }
            } else {
              if (!isCollapsed || !format2.inline || dom2.select("td[data-mce-selected],th[data-mce-selected]").length) {
                var curSelNode = ed.selection.getNode();
                if (!ed.settings.forced_root_block && formatList[0].defaultBlock && !dom2.getParent(curSelNode, dom2.isBlock)) {
                  applyFormat(ed, formatList[0].defaultBlock);
                }
                ed.selection.setRng(RangeNormalizer.normalize(ed.selection.getRng()));
                bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
                applyRngStyle(dom2, ExpandRange.expandRng(ed, selection.getRng(), formatList));
                if (format2.styles) {
                  MergeFormats.mergeUnderlineAndColor(dom2, format2, vars, curSelNode);
                }
                selection.moveToBookmark(bookmark);
                FormatUtils.moveStart(dom2, selection, selection.getRng());
                ed.nodeChanged();
              } else {
                applyCaretFormat(ed, name2, vars);
              }
            }
            Hooks.postProcess(name2, ed);
          }
        };
        var ApplyFormat = { applyFormat };
        var each$g = Tools.each;
        var setup$5 = function(formatChangeData, editor) {
          var currentFormats = {};
          formatChangeData.set({});
          editor.on("NodeChange", function(e) {
            var parents2 = FormatUtils.getParents(editor.dom, e.element);
            var matchedFormats = {};
            parents2 = Tools.grep(parents2, function(node2) {
              return node2.nodeType === 1 && !node2.getAttribute("data-mce-bogus");
            });
            each$g(formatChangeData.get(), function(callbacks, format2) {
              each$g(parents2, function(node2) {
                if (editor.formatter.matchNode(node2, format2, {}, callbacks.similar)) {
                  if (!currentFormats[format2]) {
                    each$g(callbacks, function(callback) {
                      callback(true, {
                        node: node2,
                        format: format2,
                        parents: parents2
                      });
                    });
                    currentFormats[format2] = callbacks;
                  }
                  matchedFormats[format2] = callbacks;
                  return false;
                }
                if (MatchFormat.matchesUnInheritedFormatSelector(editor, node2, format2)) {
                  return false;
                }
              });
            });
            each$g(currentFormats, function(callbacks, format2) {
              if (!matchedFormats[format2]) {
                delete currentFormats[format2];
                each$g(callbacks, function(callback) {
                  callback(false, {
                    node: e.element,
                    format: format2,
                    parents: parents2
                  });
                });
              }
            });
          });
        };
        var addListeners = function(formatChangeData, formats, callback, similar) {
          var formatChangeItems = formatChangeData.get();
          each$g(formats.split(","), function(format2) {
            if (!formatChangeItems[format2]) {
              formatChangeItems[format2] = [];
              formatChangeItems[format2].similar = similar;
            }
            formatChangeItems[format2].push(callback);
          });
          formatChangeData.set(formatChangeItems);
        };
        var formatChanged = function(editor, formatChangeState, formats, callback, similar) {
          if (formatChangeState.get() === null) {
            setup$5(formatChangeState, editor);
          }
          addListeners(formatChangeState, formats, callback, similar);
        };
        var FormatChanged = { formatChanged };
        var get$5 = function(dom2) {
          var formats = {
            valigntop: [{
              selector: "td,th",
              styles: { verticalAlign: "top" }
            }],
            valignmiddle: [{
              selector: "td,th",
              styles: { verticalAlign: "middle" }
            }],
            valignbottom: [{
              selector: "td,th",
              styles: { verticalAlign: "bottom" }
            }],
            alignleft: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-left",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "left" },
                inherit: false,
                preview: false,
                defaultBlock: "div"
              },
              {
                selector: "img,table",
                collapsed: false,
                styles: { float: "left" },
                preview: "font-family font-size"
              }
            ],
            aligncenter: [
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "center" },
                inherit: false,
                preview: "font-family font-size",
                defaultBlock: "div"
              },
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-center",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "img",
                collapsed: false,
                styles: {
                  display: "block",
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: false
              },
              {
                selector: "table",
                collapsed: false,
                styles: {
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: "font-family font-size"
              }
            ],
            alignright: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-right",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
                styles: { textAlign: "right" },
                inherit: false,
                preview: "font-family font-size",
                defaultBlock: "div"
              },
              {
                selector: "img,table",
                collapsed: false,
                styles: { float: "right" },
                preview: "font-family font-size"
              }
            ],
            alignjustify: [{
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
              styles: { textAlign: "justify" },
              inherit: false,
              defaultBlock: "div",
              preview: "font-family font-size"
            }],
            bold: [
              {
                inline: "strong",
                remove: "all"
              },
              {
                inline: "span",
                styles: { fontWeight: "bold" }
              },
              {
                inline: "b",
                remove: "all"
              }
            ],
            italic: [
              {
                inline: "em",
                remove: "all"
              },
              {
                inline: "span",
                styles: { fontStyle: "italic" }
              },
              {
                inline: "i",
                remove: "all"
              }
            ],
            underline: [
              {
                inline: "span",
                styles: { textDecoration: "underline" },
                exact: true
              },
              {
                inline: "u",
                remove: "all"
              }
            ],
            strikethrough: [
              {
                inline: "span",
                styles: { textDecoration: "line-through" },
                exact: true
              },
              {
                inline: "strike",
                remove: "all"
              }
            ],
            forecolor: {
              inline: "span",
              styles: { color: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            hilitecolor: {
              inline: "span",
              styles: { backgroundColor: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            fontname: {
              inline: "span",
              toggle: false,
              styles: { fontFamily: "%value" },
              clear_child_styles: true
            },
            fontsize: {
              inline: "span",
              toggle: false,
              styles: { fontSize: "%value" },
              clear_child_styles: true
            },
            fontsize_class: {
              inline: "span",
              attributes: { class: "%value" }
            },
            blockquote: {
              block: "blockquote",
              wrapper: 1,
              remove: "all"
            },
            subscript: { inline: "sub" },
            superscript: { inline: "sup" },
            code: { inline: "code" },
            link: {
              inline: "a",
              selector: "a",
              remove: "all",
              split: true,
              deep: true,
              onmatch: function() {
                return true;
              },
              onformat: function(elm, fmt, vars) {
                Tools.each(vars, function(value2, key) {
                  dom2.setAttrib(elm, key, value2);
                });
              }
            },
            removeformat: [
              {
                selector: "b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins",
                remove: "all",
                split: true,
                expand: false,
                block_expand: true,
                deep: true
              },
              {
                selector: "span",
                attributes: [
                  "style",
                  "class"
                ],
                remove: "empty",
                split: true,
                expand: false,
                deep: true
              },
              {
                selector: "*",
                attributes: [
                  "style",
                  "class"
                ],
                split: false,
                expand: false,
                deep: true
              }
            ]
          };
          Tools.each("p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp".split(/\s/), function(name2) {
            formats[name2] = {
              block: name2,
              remove: "all"
            };
          });
          return formats;
        };
        var DefaultFormats = { get: get$5 };
        function FormatRegistry(editor) {
          var formats = {};
          var get2 = function(name2) {
            return name2 ? formats[name2] : formats;
          };
          var register2 = function(name2, format2) {
            if (name2) {
              if (typeof name2 !== "string") {
                Tools.each(name2, function(format3, name3) {
                  register2(name3, format3);
                });
              } else {
                format2 = format2.length ? format2 : [format2];
                Tools.each(format2, function(format3) {
                  if (typeof format3.deep === "undefined") {
                    format3.deep = !format3.selector;
                  }
                  if (typeof format3.split === "undefined") {
                    format3.split = !format3.selector || format3.inline;
                  }
                  if (typeof format3.remove === "undefined" && format3.selector && !format3.inline) {
                    format3.remove = "none";
                  }
                  if (format3.selector && format3.inline) {
                    format3.mixed = true;
                    format3.block_expand = true;
                  }
                  if (typeof format3.classes === "string") {
                    format3.classes = format3.classes.split(/\s+/);
                  }
                });
                formats[name2] = format2;
              }
            }
          };
          var unregister = function(name2) {
            if (name2 && formats[name2]) {
              delete formats[name2];
            }
            return formats;
          };
          register2(DefaultFormats.get(editor.dom));
          register2(editor.settings.formats);
          return {
            get: get2,
            register: register2,
            unregister
          };
        }
        var each$h = Tools.each;
        var dom = DOMUtils$1.DOM;
        var parsedSelectorToHtml = function(ancestry, editor) {
          var elm, item, fragment;
          var schema = editor && editor.schema || Schema({});
          var decorate = function(elm2, item2) {
            if (item2.classes.length) {
              dom.addClass(elm2, item2.classes.join(" "));
            }
            dom.setAttribs(elm2, item2.attrs);
          };
          var createElement = function(sItem) {
            var elm2;
            item = typeof sItem === "string" ? {
              name: sItem,
              classes: [],
              attrs: {}
            } : sItem;
            elm2 = dom.create(item.name);
            decorate(elm2, item);
            return elm2;
          };
          var getRequiredParent = function(elm2, candidate) {
            var name2 = typeof elm2 !== "string" ? elm2.nodeName.toLowerCase() : elm2;
            var elmRule = schema.getElementRule(name2);
            var parentsRequired = elmRule && elmRule.parentsRequired;
            if (parentsRequired && parentsRequired.length) {
              return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
            } else {
              return false;
            }
          };
          var wrapInHtml = function(elm2, ancestry2, siblings) {
            var parent2, parentCandidate, parentRequired;
            var ancestor2 = ancestry2.length > 0 && ancestry2[0];
            var ancestorName = ancestor2 && ancestor2.name;
            parentRequired = getRequiredParent(elm2, ancestorName);
            if (parentRequired) {
              if (ancestorName === parentRequired) {
                parentCandidate = ancestry2[0];
                ancestry2 = ancestry2.slice(1);
              } else {
                parentCandidate = parentRequired;
              }
            } else if (ancestor2) {
              parentCandidate = ancestry2[0];
              ancestry2 = ancestry2.slice(1);
            } else if (!siblings) {
              return elm2;
            }
            if (parentCandidate) {
              parent2 = createElement(parentCandidate);
              parent2.appendChild(elm2);
            }
            if (siblings) {
              if (!parent2) {
                parent2 = dom.create("div");
                parent2.appendChild(elm2);
              }
              Tools.each(siblings, function(sibling2) {
                var siblingElm = createElement(sibling2);
                parent2.insertBefore(siblingElm, elm2);
              });
            }
            return wrapInHtml(parent2, ancestry2, parentCandidate && parentCandidate.siblings);
          };
          if (ancestry && ancestry.length) {
            item = ancestry[0];
            elm = createElement(item);
            fragment = dom.create("div");
            fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
            return fragment;
          } else {
            return "";
          }
        };
        var parseSelectorItem = function(item) {
          var tagName;
          var obj = {
            classes: [],
            attrs: {}
          };
          item = obj.selector = Tools.trim(item);
          if (item !== "*") {
            tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function($0, $1, $2, $3, $4) {
              switch ($1) {
                case "#":
                  obj.attrs.id = $2;
                  break;
                case ".":
                  obj.classes.push($2);
                  break;
                case ":":
                  if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) {
                    obj.attrs[$2] = $2;
                  }
                  break;
              }
              if ($3 === "[") {
                var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                if (m) {
                  obj.attrs[m[1]] = m[2];
                }
              }
              return "";
            });
          }
          obj.name = tagName || "div";
          return obj;
        };
        var parseSelector = function(selector) {
          if (!selector || typeof selector !== "string") {
            return [];
          }
          selector = selector.split(/\s*,\s*/)[0];
          selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
          return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function(item) {
            var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
            var obj = siblings.pop();
            if (siblings.length) {
              obj.siblings = siblings;
            }
            return obj;
          }).reverse();
        };
        var getCssText = function(editor, format2) {
          var name2, previewFrag, previewElm, items;
          var previewCss = "", parentFontSize, previewStyles;
          previewStyles = editor.settings.preview_styles;
          if (previewStyles === false) {
            return "";
          }
          if (typeof previewStyles !== "string") {
            previewStyles = "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow";
          }
          var removeVars = function(val) {
            return val.replace(/%(\w+)/g, "");
          };
          if (typeof format2 === "string") {
            format2 = editor.formatter.get(format2);
            if (!format2) {
              return;
            }
            format2 = format2[0];
          }
          if ("preview" in format2) {
            previewStyles = format2.preview;
            if (previewStyles === false) {
              return "";
            }
          }
          name2 = format2.block || format2.inline || "span";
          items = parseSelector(format2.selector);
          if (items.length) {
            if (!items[0].name) {
              items[0].name = name2;
            }
            name2 = format2.selector;
            previewFrag = parsedSelectorToHtml(items, editor);
          } else {
            previewFrag = parsedSelectorToHtml([name2], editor);
          }
          previewElm = dom.select(name2, previewFrag)[0] || previewFrag.firstChild;
          each$h(format2.styles, function(value2, name3) {
            value2 = removeVars(value2);
            if (value2) {
              dom.setStyle(previewElm, name3, value2);
            }
          });
          each$h(format2.attributes, function(value2, name3) {
            value2 = removeVars(value2);
            if (value2) {
              dom.setAttrib(previewElm, name3, value2);
            }
          });
          each$h(format2.classes, function(value2) {
            value2 = removeVars(value2);
            if (!dom.hasClass(previewElm, value2)) {
              dom.addClass(previewElm, value2);
            }
          });
          editor.fire("PreviewFormats");
          dom.setStyles(previewFrag, {
            position: "absolute",
            left: -65535
          });
          editor.getBody().appendChild(previewFrag);
          parentFontSize = dom.getStyle(editor.getBody(), "fontSize", true);
          parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
          each$h(previewStyles.split(" "), function(name3) {
            var value2 = dom.getStyle(previewElm, name3, true);
            if (name3 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
              value2 = dom.getStyle(editor.getBody(), name3, true);
              if (dom.toHex(value2).toLowerCase() === "#ffffff") {
                return;
              }
            }
            if (name3 === "color") {
              if (dom.toHex(value2).toLowerCase() === "#000000") {
                return;
              }
            }
            if (name3 === "font-size") {
              if (/em|%$/.test(value2)) {
                if (parentFontSize === 0) {
                  return;
                }
                var numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
                value2 = numValue * parentFontSize + "px";
              }
            }
            if (name3 === "border" && value2) {
              previewCss += "padding:0 2px;";
            }
            previewCss += name3 + ":" + value2 + ";";
          });
          editor.fire("AfterPreviewFormats");
          dom.remove(previewFrag);
          return previewCss;
        };
        var Preview = {
          getCssText
        };
        var toggle = function(editor, formats, name2, vars, node2) {
          var fmt = formats.get(name2);
          if (MatchFormat.match(editor, name2, vars, node2) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
            RemoveFormat.remove(editor, name2, vars, node2);
          } else {
            ApplyFormat.applyFormat(editor, name2, vars, node2);
          }
        };
        var ToggleFormat = { toggle };
        var setup$6 = function(editor) {
          editor.addShortcut("meta+b", "", "Bold");
          editor.addShortcut("meta+i", "", "Italic");
          editor.addShortcut("meta+u", "", "Underline");
          for (var i2 = 1; i2 <= 6; i2++) {
            editor.addShortcut("access+" + i2, "", [
              "FormatBlock",
              false,
              "h" + i2
            ]);
          }
          editor.addShortcut("access+7", "", [
            "FormatBlock",
            false,
            "p"
          ]);
          editor.addShortcut("access+8", "", [
            "FormatBlock",
            false,
            "div"
          ]);
          editor.addShortcut("access+9", "", [
            "FormatBlock",
            false,
            "address"
          ]);
        };
        var FormatShortcuts = { setup: setup$6 };
        function Formatter(editor) {
          var formats = FormatRegistry(editor);
          var formatChangeState = Cell(null);
          FormatShortcuts.setup(editor);
          setup$2(editor);
          return {
            get: formats.get,
            register: formats.register,
            unregister: formats.unregister,
            apply: curry(ApplyFormat.applyFormat, editor),
            remove: curry(RemoveFormat.remove, editor),
            toggle: curry(ToggleFormat.toggle, editor, formats),
            match: curry(MatchFormat.match, editor),
            matchAll: curry(MatchFormat.matchAll, editor),
            matchNode: curry(MatchFormat.matchNode, editor),
            canApply: curry(MatchFormat.canApply, editor),
            formatChanged: curry(FormatChanged.formatChanged, editor, formatChangeState),
            getCssText: curry(Preview.getCssText, editor)
          };
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var shallow$1 = function(old, nu3) {
          return nu3;
        };
        var baseMerge = function(merger) {
          return function() {
            var objects = new Array(arguments.length);
            for (var i2 = 0; i2 < objects.length; i2++) {
              objects[i2] = arguments[i2];
            }
            if (objects.length === 0) {
              throw new Error("Can't merge zero objects");
            }
            var ret = {};
            for (var j = 0; j < objects.length; j++) {
              var curObject = objects[j];
              for (var key in curObject) {
                if (hasOwnProperty$2.call(curObject, key)) {
                  ret[key] = merger(ret[key], curObject[key]);
                }
              }
            }
            return ret;
          };
        };
        var merge = baseMerge(shallow$1);
        var register = function(htmlParser2, settings, dom2) {
          htmlParser2.addAttributeFilter("data-mce-tabindex", function(nodes, name2) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              node2.attr("tabindex", node2.attributes.map["data-mce-tabindex"]);
              node2.attr(name2, null);
            }
          });
          htmlParser2.addAttributeFilter("src,href,style", function(nodes, name2) {
            var i2 = nodes.length, node2, value2;
            var internalName = "data-mce-" + name2;
            var urlConverter = settings.url_converter;
            var urlConverterScope = settings.url_converter_scope;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attributes.map[internalName];
              if (value2 !== void 0) {
                node2.attr(name2, value2.length > 0 ? value2 : null);
                node2.attr(internalName, null);
              } else {
                value2 = node2.attributes.map[name2];
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node2.name);
                } else if (urlConverter) {
                  value2 = urlConverter.call(urlConverterScope, value2, name2, node2.name);
                }
                node2.attr(name2, value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser2.addAttributeFilter("class", function(nodes) {
            var i2 = nodes.length, node2, value2;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attr("class");
              if (value2) {
                value2 = node2.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
                node2.attr("class", value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser2.addAttributeFilter("data-mce-type", function(nodes, name2, args) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.attributes.map["data-mce-type"] === "bookmark" && !args.cleanup) {
                var hasChildren = Option.from(node2.firstChild).exists(function(firstChild2) {
                  return !Zwsp.isZwsp(firstChild2.value);
                });
                if (hasChildren) {
                  node2.unwrap();
                } else {
                  node2.remove();
                }
              }
            }
          });
          htmlParser2.addNodeFilter("noscript", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2].firstChild;
              if (node2) {
                node2.value = Entities.decode(node2.value);
              }
            }
          });
          htmlParser2.addNodeFilter("script,style", function(nodes, name2) {
            var i2 = nodes.length, node2, value2, type2;
            var trim2 = function(value3) {
              return value3.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
            };
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.firstChild ? node2.firstChild.value : "";
              if (name2 === "script") {
                type2 = node2.attr("type");
                if (type2) {
                  node2.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
                }
                if (settings.element_format === "xhtml" && value2.length > 0) {
                  node2.firstChild.value = "// <![CDATA[\n" + trim2(value2) + "\n// ]]>";
                }
              } else {
                if (settings.element_format === "xhtml" && value2.length > 0) {
                  node2.firstChild.value = "<!--\n" + trim2(value2) + "\n-->";
                }
              }
            }
          });
          htmlParser2.addNodeFilter("#comment", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.value.indexOf("[CDATA[") === 0) {
                node2.name = "#cdata";
                node2.type = 4;
                node2.value = node2.value.replace(/^\[CDATA\[|\]\]$/g, "");
              } else if (node2.value.indexOf("mce:protected ") === 0) {
                node2.name = "#text";
                node2.type = 3;
                node2.raw = true;
                node2.value = unescape(node2.value).substr(14);
              }
            }
          });
          htmlParser2.addNodeFilter("xml:namespace,input", function(nodes, name2) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              if (node2.type === 7) {
                node2.remove();
              } else if (node2.type === 1) {
                if (name2 === "input" && !("type" in node2.attributes.map)) {
                  node2.attr("type", "text");
                }
              }
            }
          });
          htmlParser2.addAttributeFilter("data-mce-type", function(nodes) {
            each(nodes, function(node2) {
              if (node2.attr("data-mce-type") === "format-caret") {
                if (node2.isEmpty(htmlParser2.schema.getNonEmptyElements())) {
                  node2.remove();
                } else {
                  node2.unwrap();
                }
              }
            });
          });
          htmlParser2.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize", function(nodes, name2) {
            var i2 = nodes.length;
            while (i2--) {
              nodes[i2].attr(name2, null);
            }
          });
        };
        var trimTrailingBr = function(rootNode) {
          var brNode1, brNode2;
          var isBr2 = function(node2) {
            return node2 && node2.name === "br";
          };
          brNode1 = rootNode.lastChild;
          if (isBr2(brNode1)) {
            brNode2 = brNode1.prev;
            if (isBr2(brNode2)) {
              brNode1.remove();
              brNode2.remove();
            }
          }
        };
        var DomSerializerFilters = {
          register,
          trimTrailingBr
        };
        var preProcess = function(editor, node2, args) {
          var impl, doc2, oldDoc;
          var dom2 = editor.dom;
          node2 = node2.cloneNode(true);
          impl = domGlobals.document.implementation;
          if (impl.createHTMLDocument) {
            doc2 = impl.createHTMLDocument("");
            Tools.each(node2.nodeName === "BODY" ? node2.childNodes : [node2], function(node3) {
              doc2.body.appendChild(doc2.importNode(node3, true));
            });
            if (node2.nodeName !== "BODY") {
              node2 = doc2.body.firstChild;
            } else {
              node2 = doc2.body;
            }
            oldDoc = dom2.doc;
            dom2.doc = doc2;
          }
          Events.firePreProcess(editor, merge(args, { node: node2 }));
          if (oldDoc) {
            dom2.doc = oldDoc;
          }
          return node2;
        };
        var shouldFireEvent = function(editor, args) {
          return editor && editor.hasEventListeners("PreProcess") && !args.no_events;
        };
        var process2 = function(editor, node2, args) {
          return shouldFireEvent(editor, args) ? preProcess(editor, node2, args) : node2;
        };
        var DomSerializerPreProcess = { process: process2 };
        var removeAttrs = function(node2, names) {
          each(names, function(name2) {
            node2.attr(name2, null);
          });
        };
        var addFontToSpansFilter = function(domParser, styles, fontSizes) {
          domParser.addNodeFilter("font", function(nodes) {
            each(nodes, function(node2) {
              var props = styles.parse(node2.attr("style"));
              var color = node2.attr("color");
              var face = node2.attr("face");
              var size = node2.attr("size");
              if (color) {
                props.color = color;
              }
              if (face) {
                props["font-family"] = face;
              }
              if (size) {
                props["font-size"] = fontSizes[parseInt(node2.attr("size"), 10) - 1];
              }
              node2.name = "span";
              node2.attr("style", styles.serialize(props));
              removeAttrs(node2, [
                "color",
                "face",
                "size"
              ]);
            });
          });
        };
        var addStrikeToSpanFilter = function(domParser, styles) {
          domParser.addNodeFilter("strike", function(nodes) {
            each(nodes, function(node2) {
              var props = styles.parse(node2.attr("style"));
              props["text-decoration"] = "line-through";
              node2.name = "span";
              node2.attr("style", styles.serialize(props));
            });
          });
        };
        var addFilters = function(domParser, settings) {
          var styles = Styles();
          if (settings.convert_fonts_to_spans) {
            addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
          }
          addStrikeToSpanFilter(domParser, styles);
        };
        var register$1 = function(domParser, settings) {
          if (settings.inline_styles) {
            addFilters(domParser, settings);
          }
        };
        var LegacyFilter = { register: register$1 };
        var whiteSpaceRegExp$3 = /^[ \t\r\n]*$/;
        var typeLookup = {
          "#text": 3,
          "#comment": 8,
          "#cdata": 4,
          "#pi": 7,
          "#doctype": 10,
          "#document-fragment": 11
        };
        var walk$2 = function(node2, root2, prev) {
          var sibling2;
          var parent2;
          var startName = prev ? "lastChild" : "firstChild";
          var siblingName = prev ? "prev" : "next";
          if (node2[startName]) {
            return node2[startName];
          }
          if (node2 !== root2) {
            sibling2 = node2[siblingName];
            if (sibling2) {
              return sibling2;
            }
            for (parent2 = node2.parent; parent2 && parent2 !== root2; parent2 = parent2.parent) {
              sibling2 = parent2[siblingName];
              if (sibling2) {
                return sibling2;
              }
            }
          }
        };
        var Node$1 = (function() {
          function Node3(name2, type2) {
            this.name = name2;
            this.type = type2;
            if (type2 === 1) {
              this.attributes = [];
              this.attributes.map = {};
            }
          }
          Node3.create = function(name2, attrs) {
            var node2, attrName;
            node2 = new Node3(name2, typeLookup[name2] || 1);
            if (attrs) {
              for (attrName in attrs) {
                node2.attr(attrName, attrs[attrName]);
              }
            }
            return node2;
          };
          Node3.prototype.replace = function(node2) {
            var self2 = this;
            if (node2.parent) {
              node2.remove();
            }
            self2.insert(node2, self2);
            self2.remove();
            return self2;
          };
          Node3.prototype.attr = function(name2, value2) {
            var self2 = this;
            var attrs, i2;
            if (typeof name2 !== "string") {
              for (i2 in name2) {
                self2.attr(i2, name2[i2]);
              }
              return self2;
            }
            if (attrs = self2.attributes) {
              if (value2 !== void 0) {
                if (value2 === null) {
                  if (name2 in attrs.map) {
                    delete attrs.map[name2];
                    i2 = attrs.length;
                    while (i2--) {
                      if (attrs[i2].name === name2) {
                        attrs = attrs.splice(i2, 1);
                        return self2;
                      }
                    }
                  }
                  return self2;
                }
                if (name2 in attrs.map) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2].name === name2) {
                      attrs[i2].value = value2;
                      break;
                    }
                  }
                } else {
                  attrs.push({
                    name: name2,
                    value: value2
                  });
                }
                attrs.map[name2] = value2;
                return self2;
              }
              return attrs.map[name2];
            }
          };
          Node3.prototype.clone = function() {
            var self2 = this;
            var clone2 = new Node3(self2.name, self2.type);
            var i2, l, selfAttrs, selfAttr, cloneAttrs;
            if (selfAttrs = self2.attributes) {
              cloneAttrs = [];
              cloneAttrs.map = {};
              for (i2 = 0, l = selfAttrs.length; i2 < l; i2++) {
                selfAttr = selfAttrs[i2];
                if (selfAttr.name !== "id") {
                  cloneAttrs[cloneAttrs.length] = {
                    name: selfAttr.name,
                    value: selfAttr.value
                  };
                  cloneAttrs.map[selfAttr.name] = selfAttr.value;
                }
              }
              clone2.attributes = cloneAttrs;
            }
            clone2.value = self2.value;
            clone2.shortEnded = self2.shortEnded;
            return clone2;
          };
          Node3.prototype.wrap = function(wrapper) {
            var self2 = this;
            self2.parent.insert(wrapper, self2);
            wrapper.append(self2);
            return self2;
          };
          Node3.prototype.unwrap = function() {
            var self2 = this;
            var node2, next2;
            for (node2 = self2.firstChild; node2; ) {
              next2 = node2.next;
              self2.insert(node2, self2, true);
              node2 = next2;
            }
            self2.remove();
          };
          Node3.prototype.remove = function() {
            var self2 = this, parent2 = self2.parent, next2 = self2.next, prev = self2.prev;
            if (parent2) {
              if (parent2.firstChild === self2) {
                parent2.firstChild = next2;
                if (next2) {
                  next2.prev = null;
                }
              } else {
                prev.next = next2;
              }
              if (parent2.lastChild === self2) {
                parent2.lastChild = prev;
                if (prev) {
                  prev.next = null;
                }
              } else {
                next2.prev = prev;
              }
              self2.parent = self2.next = self2.prev = null;
            }
            return self2;
          };
          Node3.prototype.append = function(node2) {
            var self2 = this;
            var last2;
            if (node2.parent) {
              node2.remove();
            }
            last2 = self2.lastChild;
            if (last2) {
              last2.next = node2;
              node2.prev = last2;
              self2.lastChild = node2;
            } else {
              self2.lastChild = self2.firstChild = node2;
            }
            node2.parent = self2;
            return node2;
          };
          Node3.prototype.insert = function(node2, refNode, before2) {
            var parent2;
            if (node2.parent) {
              node2.remove();
            }
            parent2 = refNode.parent || this;
            if (before2) {
              if (refNode === parent2.firstChild) {
                parent2.firstChild = node2;
              } else {
                refNode.prev.next = node2;
              }
              node2.prev = refNode.prev;
              node2.next = refNode;
              refNode.prev = node2;
            } else {
              if (refNode === parent2.lastChild) {
                parent2.lastChild = node2;
              } else {
                refNode.next.prev = node2;
              }
              node2.next = refNode.next;
              node2.prev = refNode;
              refNode.next = node2;
            }
            node2.parent = parent2;
            return node2;
          };
          Node3.prototype.getAll = function(name2) {
            var self2 = this;
            var node2;
            var collection = [];
            for (node2 = self2.firstChild; node2; node2 = walk$2(node2, self2)) {
              if (node2.name === name2) {
                collection.push(node2);
              }
            }
            return collection;
          };
          Node3.prototype.empty = function() {
            var self2 = this;
            var nodes, i2, node2;
            if (self2.firstChild) {
              nodes = [];
              for (node2 = self2.firstChild; node2; node2 = walk$2(node2, self2)) {
                nodes.push(node2);
              }
              i2 = nodes.length;
              while (i2--) {
                node2 = nodes[i2];
                node2.parent = node2.firstChild = node2.lastChild = node2.next = node2.prev = null;
              }
            }
            self2.firstChild = self2.lastChild = null;
            return self2;
          };
          Node3.prototype.isEmpty = function(elements, whitespace2, predicate) {
            var self2 = this;
            var node2 = self2.firstChild, i2, name2;
            whitespace2 = whitespace2 || {};
            if (node2) {
              do {
                if (node2.type === 1) {
                  if (node2.attributes.map["data-mce-bogus"]) {
                    continue;
                  }
                  if (elements[node2.name]) {
                    return false;
                  }
                  i2 = node2.attributes.length;
                  while (i2--) {
                    name2 = node2.attributes[i2].name;
                    if (name2 === "name" || name2.indexOf("data-mce-bookmark") === 0) {
                      return false;
                    }
                  }
                }
                if (node2.type === 8) {
                  return false;
                }
                if (node2.type === 3 && !whiteSpaceRegExp$3.test(node2.value)) {
                  return false;
                }
                if (node2.type === 3 && node2.parent && whitespace2[node2.parent.name] && whiteSpaceRegExp$3.test(node2.value)) {
                  return false;
                }
                if (predicate && predicate(node2)) {
                  return false;
                }
              } while (node2 = walk$2(node2, self2));
            }
            return true;
          };
          Node3.prototype.walk = function(prev) {
            return walk$2(this, null, prev);
          };
          return Node3;
        })();
        var paddEmptyNode = function(settings, args, blockElements2, node2) {
          var brPreferred = settings.padd_empty_with_br || args.insert;
          if (brPreferred && blockElements2[node2.name]) {
            node2.empty().append(new Node$1("br", 1)).shortEnded = true;
          } else {
            node2.empty().append(new Node$1("#text", 3)).value = "Â ";
          }
        };
        var isPaddedWithNbsp = function(node2) {
          return hasOnlyChild(node2, "#text") && node2.firstChild.value === "Â ";
        };
        var hasOnlyChild = function(node2, name2) {
          return node2 && node2.firstChild && node2.firstChild === node2.lastChild && node2.firstChild.name === name2;
        };
        var isPadded = function(schema, node2) {
          var rule = schema.getElementRule(node2.name);
          return rule && rule.paddEmpty;
        };
        var isEmpty$2 = function(schema, nonEmptyElements, whitespaceElements, node2) {
          return node2.isEmpty(nonEmptyElements, whitespaceElements, function(node3) {
            return isPadded(schema, node3);
          });
        };
        var isLineBreakNode = function(node2, blockElements2) {
          return node2 && (blockElements2[node2.name] || node2.name === "br");
        };
        var register$2 = function(parser, settings) {
          var schema = parser.schema;
          if (settings.remove_trailing_brs) {
            parser.addNodeFilter("br", function(nodes, _, args) {
              var i2;
              var l = nodes.length;
              var node2;
              var blockElements2 = Tools.extend({}, schema.getBlockElements());
              var nonEmptyElements = schema.getNonEmptyElements();
              var parent2, lastParent, prev, prevName;
              var whiteSpaceElements = schema.getWhiteSpaceElements();
              var elementRule, textNode;
              blockElements2.body = 1;
              for (i2 = 0; i2 < l; i2++) {
                node2 = nodes[i2];
                parent2 = node2.parent;
                if (blockElements2[node2.parent.name] && node2 === parent2.lastChild) {
                  prev = node2.prev;
                  while (prev) {
                    prevName = prev.name;
                    if (prevName !== "span" || prev.attr("data-mce-type") !== "bookmark") {
                      if (prevName !== "br") {
                        break;
                      }
                      if (prevName === "br") {
                        node2 = null;
                        break;
                      }
                    }
                    prev = prev.prev;
                  }
                  if (node2) {
                    node2.remove();
                    if (isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, parent2)) {
                      elementRule = schema.getElementRule(parent2.name);
                      if (elementRule) {
                        if (elementRule.removeEmpty) {
                          parent2.remove();
                        } else if (elementRule.paddEmpty) {
                          paddEmptyNode(settings, args, blockElements2, parent2);
                        }
                      }
                    }
                  }
                } else {
                  lastParent = node2;
                  while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
                    lastParent = parent2;
                    if (blockElements2[parent2.name]) {
                      break;
                    }
                    parent2 = parent2.parent;
                  }
                  if (lastParent === parent2 && settings.padd_empty_with_br !== true) {
                    textNode = new Node$1("#text", 3);
                    textNode.value = "Â ";
                    node2.replace(textNode);
                  }
                }
              }
            });
          }
          parser.addAttributeFilter("href", function(nodes) {
            var i2 = nodes.length, node2;
            var appendRel = function(rel) {
              var parts = rel.split(" ").filter(function(p) {
                return p.length > 0;
              });
              return parts.concat(["noopener"]).sort().join(" ");
            };
            var addNoOpener = function(rel) {
              var newRel = rel ? Tools.trim(rel) : "";
              if (!/\b(noopener)\b/g.test(newRel)) {
                return appendRel(newRel);
              } else {
                return newRel;
              }
            };
            if (!settings.allow_unsafe_link_target) {
              while (i2--) {
                node2 = nodes[i2];
                if (node2.name === "a" && node2.attr("target") === "_blank") {
                  node2.attr("rel", addNoOpener(node2.attr("rel")));
                }
              }
            }
          });
          if (!settings.allow_html_in_named_anchor) {
            parser.addAttributeFilter("id,name", function(nodes) {
              var i2 = nodes.length, sibling2, prevSibling2, parent2, node2;
              while (i2--) {
                node2 = nodes[i2];
                if (node2.name === "a" && node2.firstChild && !node2.attr("href")) {
                  parent2 = node2.parent;
                  sibling2 = node2.lastChild;
                  do {
                    prevSibling2 = sibling2.prev;
                    parent2.insert(sibling2, node2);
                    sibling2 = prevSibling2;
                  } while (sibling2);
                }
              }
            });
          }
          if (settings.fix_list_elements) {
            parser.addNodeFilter("ul,ol", function(nodes) {
              var i2 = nodes.length, node2, parentNode;
              while (i2--) {
                node2 = nodes[i2];
                parentNode = node2.parent;
                if (parentNode.name === "ul" || parentNode.name === "ol") {
                  if (node2.prev && node2.prev.name === "li") {
                    node2.prev.append(node2);
                  } else {
                    var li = new Node$1("li", 1);
                    li.attr("style", "list-style-type: none");
                    node2.wrap(li);
                  }
                }
              }
            });
          }
          if (settings.validate && schema.getValidClasses()) {
            parser.addAttributeFilter("class", function(nodes) {
              var i2 = nodes.length, node2, classList, ci, className, classValue;
              var validClasses = schema.getValidClasses();
              var validClassesMap, valid;
              while (i2--) {
                node2 = nodes[i2];
                classList = node2.attr("class").split(" ");
                classValue = "";
                for (ci = 0; ci < classList.length; ci++) {
                  className = classList[ci];
                  valid = false;
                  validClassesMap = validClasses["*"];
                  if (validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  validClassesMap = validClasses[node2.name];
                  if (!valid && validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  if (valid) {
                    if (classValue) {
                      classValue += " ";
                    }
                    classValue += className;
                  }
                }
                if (!classValue.length) {
                  classValue = null;
                }
                node2.attr("class", classValue);
              }
            });
          }
        };
        var makeMap$4 = Tools.makeMap, each$i = Tools.each, explode$3 = Tools.explode, extend$3 = Tools.extend;
        function DomParser(settings, schema) {
          if (schema === void 0) {
            schema = Schema();
          }
          var nodeFilters = {};
          var attributeFilters = [];
          var matchedNodes = {};
          var matchedAttributes = {};
          settings = settings || {};
          settings.validate = "validate" in settings ? settings.validate : true;
          settings.root_name = settings.root_name || "body";
          var fixInvalidChildren = function(nodes) {
            var ni2, node2, parent2, parents2, newParent, currentNode, tempNode, childNode, i2;
            var nonEmptyElements, whitespaceElements, nonSplitableElements, textBlockElements, specialElements, sibling2, nextNode;
            nonSplitableElements = makeMap$4("tr,td,th,tbody,thead,tfoot,table");
            nonEmptyElements = schema.getNonEmptyElements();
            whitespaceElements = schema.getWhiteSpaceElements();
            textBlockElements = schema.getTextBlockElements();
            specialElements = schema.getSpecialElements();
            for (ni2 = 0; ni2 < nodes.length; ni2++) {
              node2 = nodes[ni2];
              if (!node2.parent || node2.fixed) {
                continue;
              }
              if (textBlockElements[node2.name] && node2.parent.name === "li") {
                sibling2 = node2.next;
                while (sibling2) {
                  if (textBlockElements[sibling2.name]) {
                    sibling2.name = "li";
                    sibling2.fixed = true;
                    node2.parent.insert(sibling2, node2.parent);
                  } else {
                    break;
                  }
                  sibling2 = sibling2.next;
                }
                node2.unwrap(node2);
                continue;
              }
              parents2 = [node2];
              for (parent2 = node2.parent; parent2 && !schema.isValidChild(parent2.name, node2.name) && !nonSplitableElements[parent2.name]; parent2 = parent2.parent) {
                parents2.push(parent2);
              }
              if (parent2 && parents2.length > 1) {
                parents2.reverse();
                newParent = currentNode = filterNode(parents2[0].clone());
                for (i2 = 0; i2 < parents2.length - 1; i2++) {
                  if (schema.isValidChild(currentNode.name, parents2[i2].name)) {
                    tempNode = filterNode(parents2[i2].clone());
                    currentNode.append(tempNode);
                  } else {
                    tempNode = currentNode;
                  }
                  for (childNode = parents2[i2].firstChild; childNode && childNode !== parents2[i2 + 1]; ) {
                    nextNode = childNode.next;
                    tempNode.append(childNode);
                    childNode = nextNode;
                  }
                  currentNode = tempNode;
                }
                if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
                  parent2.insert(newParent, parents2[0], true);
                  parent2.insert(node2, newParent);
                } else {
                  parent2.insert(node2, parents2[0], true);
                }
                parent2 = parents2[0];
                if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
                  parent2.empty().remove();
                }
              } else if (node2.parent) {
                if (node2.name === "li") {
                  sibling2 = node2.prev;
                  if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ul")) {
                    sibling2.append(node2);
                    continue;
                  }
                  sibling2 = node2.next;
                  if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ul")) {
                    sibling2.insert(node2, sibling2.firstChild, true);
                    continue;
                  }
                  node2.wrap(filterNode(new Node$1("ul", 1)));
                  continue;
                }
                if (schema.isValidChild(node2.parent.name, "div") && schema.isValidChild("div", node2.name)) {
                  node2.wrap(filterNode(new Node$1("div", 1)));
                } else {
                  if (specialElements[node2.name]) {
                    node2.empty().remove();
                  } else {
                    node2.unwrap();
                  }
                }
              }
            }
          };
          var filterNode = function(node2) {
            var i2, name2, list2;
            name2 = node2.name;
            if (name2 in nodeFilters) {
              list2 = matchedNodes[name2];
              if (list2) {
                list2.push(node2);
              } else {
                matchedNodes[name2] = [node2];
              }
            }
            i2 = attributeFilters.length;
            while (i2--) {
              name2 = attributeFilters[i2].name;
              if (name2 in node2.attributes.map) {
                list2 = matchedAttributes[name2];
                if (list2) {
                  list2.push(node2);
                } else {
                  matchedAttributes[name2] = [node2];
                }
              }
            }
            return node2;
          };
          var addNodeFilter = function(name2, callback) {
            each$i(explode$3(name2), function(name3) {
              var list2 = nodeFilters[name3];
              if (!list2) {
                nodeFilters[name3] = list2 = [];
              }
              list2.push(callback);
            });
          };
          var getNodeFilters = function() {
            var out = [];
            for (var name2 in nodeFilters) {
              if (nodeFilters.hasOwnProperty(name2)) {
                out.push({
                  name: name2,
                  callbacks: nodeFilters[name2]
                });
              }
            }
            return out;
          };
          var addAttributeFilter = function(name2, callback) {
            each$i(explode$3(name2), function(name3) {
              var i2;
              for (i2 = 0; i2 < attributeFilters.length; i2++) {
                if (attributeFilters[i2].name === name3) {
                  attributeFilters[i2].callbacks.push(callback);
                  return;
                }
              }
              attributeFilters.push({
                name: name3,
                callbacks: [callback]
              });
            });
          };
          var getAttributeFilters = function() {
            return [].concat(attributeFilters);
          };
          var parse2 = function(html2, args) {
            var parser, nodes, i2, l, fi, fl, list2, name2;
            var blockElements2;
            var invalidChildren = [];
            var isInWhiteSpacePreservedElement;
            var node2;
            args = args || {};
            matchedNodes = {};
            matchedAttributes = {};
            blockElements2 = extend$3(makeMap$4("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
            var nonEmptyElements = schema.getNonEmptyElements();
            var children2 = schema.children;
            var validate2 = settings.validate;
            var rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
            var whiteSpaceElements = schema.getWhiteSpaceElements();
            var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
            var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
            isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
            var addRootBlocks2 = function() {
              var node3 = rootNode.firstChild, next2, rootBlockNode;
              var trim2 = function(rootBlockNode2) {
                if (rootBlockNode2) {
                  node3 = rootBlockNode2.firstChild;
                  if (node3 && node3.type === 3) {
                    node3.value = node3.value.replace(startWhiteSpaceRegExp, "");
                  }
                  node3 = rootBlockNode2.lastChild;
                  if (node3 && node3.type === 3) {
                    node3.value = node3.value.replace(endWhiteSpaceRegExp, "");
                  }
                }
              };
              if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
                return;
              }
              while (node3) {
                next2 = node3.next;
                if (node3.type === 3 || node3.type === 1 && node3.name !== "p" && !blockElements2[node3.name] && !node3.attr("data-mce-type")) {
                  if (!rootBlockNode) {
                    rootBlockNode = createNode(rootBlockName, 1);
                    rootBlockNode.attr(settings.forced_root_block_attrs);
                    rootNode.insert(rootBlockNode, node3);
                    rootBlockNode.append(node3);
                  } else {
                    rootBlockNode.append(node3);
                  }
                } else {
                  trim2(rootBlockNode);
                  rootBlockNode = null;
                }
                node3 = next2;
              }
              trim2(rootBlockNode);
            };
            var createNode = function(name3, type2) {
              var node3 = new Node$1(name3, type2);
              var list3;
              if (name3 in nodeFilters) {
                list3 = matchedNodes[name3];
                if (list3) {
                  list3.push(node3);
                } else {
                  matchedNodes[name3] = [node3];
                }
              }
              return node3;
            };
            var removeWhitespaceBefore = function(node3) {
              var textNode, textNodeNext, textVal, sibling2;
              var blockElements3 = schema.getBlockElements();
              for (textNode = node3.prev; textNode && textNode.type === 3; ) {
                textVal = textNode.value.replace(endWhiteSpaceRegExp, "");
                if (textVal.length > 0) {
                  textNode.value = textVal;
                  return;
                }
                textNodeNext = textNode.next;
                if (textNodeNext) {
                  if (textNodeNext.type === 3 && textNodeNext.value.length) {
                    textNode = textNode.prev;
                    continue;
                  }
                  if (!blockElements3[textNodeNext.name] && textNodeNext.name !== "script" && textNodeNext.name !== "style") {
                    textNode = textNode.prev;
                    continue;
                  }
                }
                sibling2 = textNode.prev;
                textNode.remove();
                textNode = sibling2;
              }
            };
            var cloneAndExcludeBlocks = function(input) {
              var name3;
              var output2 = {};
              for (name3 in input) {
                if (name3 !== "li" && name3 !== "p") {
                  output2[name3] = input[name3];
                }
              }
              return output2;
            };
            parser = SaxParser$1({
              validate: validate2,
              allow_script_urls: settings.allow_script_urls,
              allow_conditional_comments: settings.allow_conditional_comments,
              self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
              cdata: function(text2) {
                node2.append(createNode("#cdata", 4)).value = text2;
              },
              text: function(text2, raw) {
                var textNode;
                if (!isInWhiteSpacePreservedElement) {
                  text2 = text2.replace(allWhiteSpaceRegExp, " ");
                  if (isLineBreakNode(node2.lastChild, blockElements2)) {
                    text2 = text2.replace(startWhiteSpaceRegExp, "");
                  }
                }
                if (text2.length !== 0) {
                  textNode = createNode("#text", 3);
                  textNode.raw = !!raw;
                  node2.append(textNode).value = text2;
                }
              },
              comment: function(text2) {
                node2.append(createNode("#comment", 8)).value = text2;
              },
              pi: function(name3, text2) {
                node2.append(createNode(name3, 7)).value = text2;
                removeWhitespaceBefore(node2);
              },
              doctype: function(text2) {
                var newNode;
                newNode = node2.append(createNode("#doctype", 10));
                newNode.value = text2;
                removeWhitespaceBefore(node2);
              },
              start: function(name3, attrs, empty3) {
                var newNode, attrFiltersLen, elementRule, attrName, parent2;
                elementRule = validate2 ? schema.getElementRule(name3) : {};
                if (elementRule) {
                  newNode = createNode(elementRule.outputName || name3, 1);
                  newNode.attributes = attrs;
                  newNode.shortEnded = empty3;
                  node2.append(newNode);
                  parent2 = children2[node2.name];
                  if (parent2 && children2[newNode.name] && !parent2[newNode.name]) {
                    invalidChildren.push(newNode);
                  }
                  attrFiltersLen = attributeFilters.length;
                  while (attrFiltersLen--) {
                    attrName = attributeFilters[attrFiltersLen].name;
                    if (attrName in attrs.map) {
                      list2 = matchedAttributes[attrName];
                      if (list2) {
                        list2.push(newNode);
                      } else {
                        matchedAttributes[attrName] = [newNode];
                      }
                    }
                  }
                  if (blockElements2[name3]) {
                    removeWhitespaceBefore(newNode);
                  }
                  if (!empty3) {
                    node2 = newNode;
                  }
                  if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                    isInWhiteSpacePreservedElement = true;
                  }
                }
              },
              end: function(name3) {
                var textNode, elementRule, text2, sibling2, tempNode;
                elementRule = validate2 ? schema.getElementRule(name3) : {};
                if (elementRule) {
                  if (blockElements2[name3]) {
                    if (!isInWhiteSpacePreservedElement) {
                      textNode = node2.firstChild;
                      if (textNode && textNode.type === 3) {
                        text2 = textNode.value.replace(startWhiteSpaceRegExp, "");
                        if (text2.length > 0) {
                          textNode.value = text2;
                          textNode = textNode.next;
                        } else {
                          sibling2 = textNode.next;
                          textNode.remove();
                          textNode = sibling2;
                          while (textNode && textNode.type === 3) {
                            text2 = textNode.value;
                            sibling2 = textNode.next;
                            if (text2.length === 0 || isAllWhiteSpaceRegExp.test(text2)) {
                              textNode.remove();
                              textNode = sibling2;
                            }
                            textNode = sibling2;
                          }
                        }
                      }
                      textNode = node2.lastChild;
                      if (textNode && textNode.type === 3) {
                        text2 = textNode.value.replace(endWhiteSpaceRegExp, "");
                        if (text2.length > 0) {
                          textNode.value = text2;
                          textNode = textNode.prev;
                        } else {
                          sibling2 = textNode.prev;
                          textNode.remove();
                          textNode = sibling2;
                          while (textNode && textNode.type === 3) {
                            text2 = textNode.value;
                            sibling2 = textNode.prev;
                            if (text2.length === 0 || isAllWhiteSpaceRegExp.test(text2)) {
                              textNode.remove();
                              textNode = sibling2;
                            }
                            textNode = sibling2;
                          }
                        }
                      }
                    }
                  }
                  if (isInWhiteSpacePreservedElement && whiteSpaceElements[name3]) {
                    isInWhiteSpacePreservedElement = false;
                  }
                  if (elementRule.removeEmpty && isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node2)) {
                    if (!node2.attributes.map.name && !node2.attr("id")) {
                      tempNode = node2.parent;
                      if (blockElements2[node2.name]) {
                        node2.empty().remove();
                      } else {
                        node2.unwrap();
                      }
                      node2 = tempNode;
                      return;
                    }
                  }
                  if (elementRule.paddEmpty && (isPaddedWithNbsp(node2) || isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node2))) {
                    paddEmptyNode(settings, args, blockElements2, node2);
                  }
                  node2 = node2.parent;
                }
              }
            }, schema);
            var rootNode = node2 = new Node$1(args.context || settings.root_name, 11);
            parser.parse(html2);
            if (validate2 && invalidChildren.length) {
              if (!args.context) {
                fixInvalidChildren(invalidChildren);
              } else {
                args.invalid = true;
              }
            }
            if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
              addRootBlocks2();
            }
            if (!args.invalid) {
              for (name2 in matchedNodes) {
                list2 = nodeFilters[name2];
                nodes = matchedNodes[name2];
                fi = nodes.length;
                while (fi--) {
                  if (!nodes[fi].parent) {
                    nodes.splice(fi, 1);
                  }
                }
                for (i2 = 0, l = list2.length; i2 < l; i2++) {
                  list2[i2](nodes, name2, args);
                }
              }
              for (i2 = 0, l = attributeFilters.length; i2 < l; i2++) {
                list2 = attributeFilters[i2];
                if (list2.name in matchedAttributes) {
                  nodes = matchedAttributes[list2.name];
                  fi = nodes.length;
                  while (fi--) {
                    if (!nodes[fi].parent) {
                      nodes.splice(fi, 1);
                    }
                  }
                  for (fi = 0, fl = list2.callbacks.length; fi < fl; fi++) {
                    list2.callbacks[fi](nodes, list2.name, args);
                  }
                }
              }
            }
            return rootNode;
          };
          var exports$12 = {
            schema,
            addAttributeFilter,
            getAttributeFilters,
            addNodeFilter,
            getNodeFilters,
            filterNode,
            parse: parse2
          };
          register$2(exports$12, settings);
          LegacyFilter.register(exports$12, settings);
          return exports$12;
        }
        var addTempAttr = function(htmlParser2, tempAttrs, name2) {
          if (Tools.inArray(tempAttrs, name2) === -1) {
            htmlParser2.addAttributeFilter(name2, function(nodes, name3) {
              var i2 = nodes.length;
              while (i2--) {
                nodes[i2].attr(name3, null);
              }
            });
            tempAttrs.push(name2);
          }
        };
        var postProcess$1 = function(editor, args, content) {
          if (!args.no_events && editor) {
            var outArgs = Events.firePostProcess(editor, merge(args, { content }));
            return outArgs.content;
          } else {
            return content;
          }
        };
        var getHtmlFromNode = function(dom2, node2, args) {
          var html2 = Zwsp.trim(args.getInner ? node2.innerHTML : dom2.getOuterHTML(node2));
          return args.selection || isWsPreserveElement(Element2.fromDom(node2)) ? html2 : Tools.trim(html2);
        };
        var parseHtml = function(htmlParser2, html2, args) {
          var parserArgs = args.selection ? merge({ forced_root_block: false }, args) : args;
          var rootNode = htmlParser2.parse(html2, parserArgs);
          DomSerializerFilters.trimTrailingBr(rootNode);
          return rootNode;
        };
        var serializeNode = function(settings, schema, node2) {
          var htmlSerializer = HtmlSerializer(settings, schema);
          return htmlSerializer.serialize(node2);
        };
        var toHtml = function(editor, settings, schema, rootNode, args) {
          var content = serializeNode(settings, schema, rootNode);
          return postProcess$1(editor, args, content);
        };
        function DomSerializer(settings, editor) {
          var dom2, schema, htmlParser2;
          var tempAttrs = ["data-mce-selected"];
          dom2 = editor && editor.dom ? editor.dom : DOMUtils$1.DOM;
          schema = editor && editor.schema ? editor.schema : Schema(settings);
          settings.entity_encoding = settings.entity_encoding || "named";
          settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
          htmlParser2 = DomParser(settings, schema);
          DomSerializerFilters.register(htmlParser2, settings, dom2);
          var serialize2 = function(node2, parserArgs) {
            var args = merge({ format: "html" }, parserArgs ? parserArgs : {});
            var targetNode = DomSerializerPreProcess.process(editor, node2, args);
            var html2 = getHtmlFromNode(dom2, targetNode, args);
            var rootNode = parseHtml(htmlParser2, html2, args);
            return args.format === "tree" ? rootNode : toHtml(editor, settings, schema, rootNode, args);
          };
          return {
            schema,
            addNodeFilter: htmlParser2.addNodeFilter,
            addAttributeFilter: htmlParser2.addAttributeFilter,
            serialize: serialize2,
            addRules: function(rules2) {
              schema.addValidElements(rules2);
            },
            setRules: function(rules2) {
              schema.setValidElements(rules2);
            },
            addTempAttr: curry(addTempAttr, htmlParser2, tempAttrs),
            getTempAttrs: function() {
              return tempAttrs;
            }
          };
        }
        function DomSerializer$1(settings, editor) {
          var domSerializer = DomSerializer(settings, editor);
          return {
            schema: domSerializer.schema,
            addNodeFilter: domSerializer.addNodeFilter,
            addAttributeFilter: domSerializer.addAttributeFilter,
            serialize: domSerializer.serialize,
            addRules: domSerializer.addRules,
            setRules: domSerializer.setRules,
            addTempAttr: domSerializer.addTempAttr,
            getTempAttrs: domSerializer.getTempAttrs
          };
        }
        function BookmarkManager(selection) {
          return {
            getBookmark: curry(Bookmarks.getBookmark, selection),
            moveToBookmark: curry(Bookmarks.moveToBookmark, selection)
          };
        }
        (function(BookmarkManager2) {
          BookmarkManager2.isBookmarkNode = Bookmarks.isBookmarkNode;
        })(BookmarkManager || (BookmarkManager = {}));
        var BookmarkManager$1 = BookmarkManager;
        var isContentEditableFalse$a = NodeType.isContentEditableFalse;
        var isContentEditableTrue$5 = NodeType.isContentEditableTrue;
        var getContentEditableRoot$2 = function(root2, node2) {
          while (node2 && node2 !== root2) {
            if (isContentEditableTrue$5(node2) || isContentEditableFalse$a(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var ControlSelection = function(selection, editor) {
          var dom2 = editor.dom, each2 = Tools.each;
          var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle;
          var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio2, resizeStarted;
          var width, height;
          var editableDoc = editor.getDoc(), rootDocument = domGlobals.document;
          var abs = Math.abs, round2 = Math.round, rootElement = editor.getBody();
          var startScrollWidth, startScrollHeight;
          resizeHandles = {
            nw: [
              0,
              0,
              -1,
              -1
            ],
            ne: [
              1,
              0,
              1,
              -1
            ],
            se: [
              1,
              1,
              1,
              1
            ],
            sw: [
              0,
              1,
              -1,
              1
            ]
          };
          var rootClass = ".mce-content-body";
          editor.contentStyles.push(rootClass + " div.mce-resizehandle {position: absolute;border: 1px solid black;box-sizing: content-box;background: #FFF;width: 7px;height: 7px;z-index: 10000}" + rootClass + " .mce-resizehandle:hover {background: #000}" + rootClass + " img[data-mce-selected]," + rootClass + " hr[data-mce-selected] {outline: 1px solid black;resize: none}" + rootClass + " .mce-clonedresizable {position: absolute;" + (Env.gecko ? "" : "outline: 1px dashed black;") + "opacity: .5;filter: alpha(opacity=50);z-index: 10000}" + rootClass + " .mce-resize-helper {background: #555;background: rgba(0,0,0,0.75);border-radius: 3px;border: 1px;color: white;display: none;font-family: sans-serif;font-size: 12px;white-space: nowrap;line-height: 14px;margin: 5px 10px;padding: 5px;position: absolute;z-index: 10001}");
          var isImage = function(elm) {
            return elm && (elm.nodeName === "IMG" || editor.dom.is(elm, "figure.image"));
          };
          var isEventOnImageOutsideRange = function(evt, range3) {
            return isImage(evt.target) && !RangePoint.isXYWithinRange(evt.clientX, evt.clientY, range3);
          };
          var contextMenuSelectImage = function(evt) {
            var target2 = evt.target;
            if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
              editor.selection.select(target2);
            }
          };
          var getResizeTarget = function(elm) {
            return editor.dom.is(elm, "figure.image") ? elm.querySelector("img") : elm;
          };
          var isResizable = function(elm) {
            var selector = editor.settings.object_resizing;
            if (selector === false || Env.iOS) {
              return false;
            }
            if (typeof selector !== "string") {
              selector = "table,img,figure.image,div";
            }
            if (elm.getAttribute("data-mce-resize") === "false") {
              return false;
            }
            if (elm === editor.getBody()) {
              return false;
            }
            return is$1(Element2.fromDom(elm), selector);
          };
          var resizeGhostElement = function(e) {
            var deltaX, deltaY, proportional;
            var resizeHelperX, resizeHelperY;
            deltaX = e.screenX - startX;
            deltaY = e.screenY - startY;
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if (isImage(selectedElm) && editor.settings.resize_img_proportional !== false) {
              proportional = !VK.modifierPressed(e);
            } else {
              proportional = VK.modifierPressed(e) || isImage(selectedElm) && selectedHandle[2] * selectedHandle[3] !== 0;
            }
            if (proportional) {
              if (abs(deltaX) > abs(deltaY)) {
                height = round2(width * ratio2);
                width = round2(height / ratio2);
              } else {
                width = round2(height / ratio2);
                height = round2(width * ratio2);
              }
            }
            dom2.setStyles(getResizeTarget(selectedElmGhost), {
              width,
              height
            });
            resizeHelperX = selectedHandle.startPos.x + deltaX;
            resizeHelperY = selectedHandle.startPos.y + deltaY;
            resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
            resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
            dom2.setStyles(resizeHelper, {
              left: resizeHelperX,
              top: resizeHelperY,
              display: "block"
            });
            resizeHelper.innerHTML = width + " &times; " + height;
            if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
              dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
            }
            if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
              dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
            }
            deltaX = rootElement.scrollWidth - startScrollWidth;
            deltaY = rootElement.scrollHeight - startScrollHeight;
            if (deltaX + deltaY !== 0) {
              dom2.setStyles(resizeHelper, {
                left: resizeHelperX - deltaX,
                top: resizeHelperY - deltaY
              });
            }
            if (!resizeStarted) {
              Events.fireObjectResizeStart(editor, selectedElm, startW, startH);
              resizeStarted = true;
            }
          };
          var endGhostResize = function() {
            resizeStarted = false;
            var setSizeProp = function(name2, value2) {
              if (value2) {
                if (selectedElm.style[name2] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name2)) {
                  dom2.setStyle(getResizeTarget(selectedElm), name2, value2);
                } else {
                  dom2.setAttrib(getResizeTarget(selectedElm), name2, value2);
                }
              }
            };
            setSizeProp("width", width);
            setSizeProp("height", height);
            dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
            dom2.unbind(editableDoc, "mouseup", endGhostResize);
            if (rootDocument !== editableDoc) {
              dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
              dom2.unbind(rootDocument, "mouseup", endGhostResize);
            }
            dom2.remove(selectedElmGhost);
            dom2.remove(resizeHelper);
            showResizeRect(selectedElm);
            Events.fireObjectResized(editor, selectedElm, width, height);
            dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
            editor.nodeChanged();
          };
          var showResizeRect = function(targetElm) {
            var position, targetWidth, targetHeight, e, rect2;
            hideResizeRect();
            unbindResizeHandleEvents();
            position = dom2.getPos(targetElm, rootElement);
            selectedElmX = position.x;
            selectedElmY = position.y;
            rect2 = targetElm.getBoundingClientRect();
            targetWidth = rect2.width || rect2.right - rect2.left;
            targetHeight = rect2.height || rect2.bottom - rect2.top;
            if (selectedElm !== targetElm) {
              selectedElm = targetElm;
              width = height = 0;
            }
            e = editor.fire("ObjectSelected", { target: targetElm });
            if (isResizable(targetElm) && !e.isDefaultPrevented()) {
              each2(resizeHandles, function(handle2, name2) {
                var handleElm;
                var startDrag = function(e2) {
                  startX = e2.screenX;
                  startY = e2.screenY;
                  startW = getResizeTarget(selectedElm).clientWidth;
                  startH = getResizeTarget(selectedElm).clientHeight;
                  ratio2 = startH / startW;
                  selectedHandle = handle2;
                  handle2.startPos = {
                    x: targetWidth * handle2[0] + selectedElmX,
                    y: targetHeight * handle2[1] + selectedElmY
                  };
                  startScrollWidth = rootElement.scrollWidth;
                  startScrollHeight = rootElement.scrollHeight;
                  selectedElmGhost = selectedElm.cloneNode(true);
                  dom2.addClass(selectedElmGhost, "mce-clonedresizable");
                  dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
                  selectedElmGhost.contentEditable = false;
                  selectedElmGhost.unSelectabe = true;
                  dom2.setStyles(selectedElmGhost, {
                    left: selectedElmX,
                    top: selectedElmY,
                    margin: 0
                  });
                  selectedElmGhost.removeAttribute("data-mce-selected");
                  rootElement.appendChild(selectedElmGhost);
                  dom2.bind(editableDoc, "mousemove", resizeGhostElement);
                  dom2.bind(editableDoc, "mouseup", endGhostResize);
                  if (rootDocument !== editableDoc) {
                    dom2.bind(rootDocument, "mousemove", resizeGhostElement);
                    dom2.bind(rootDocument, "mouseup", endGhostResize);
                  }
                  resizeHelper = dom2.add(rootElement, "div", {
                    "class": "mce-resize-helper",
                    "data-mce-bogus": "all"
                  }, startW + " &times; " + startH);
                };
                handleElm = dom2.get("mceResizeHandle" + name2);
                if (handleElm) {
                  dom2.remove(handleElm);
                }
                handleElm = dom2.add(rootElement, "div", {
                  "id": "mceResizeHandle" + name2,
                  "data-mce-bogus": "all",
                  "class": "mce-resizehandle",
                  "unselectable": true,
                  "style": "cursor:" + name2 + "-resize; margin:0; padding:0"
                });
                if (Env.ie === 11) {
                  handleElm.contentEditable = false;
                }
                dom2.bind(handleElm, "mousedown", function(e2) {
                  e2.stopImmediatePropagation();
                  e2.preventDefault();
                  startDrag(e2);
                });
                handle2.elm = handleElm;
                dom2.setStyles(handleElm, {
                  left: targetWidth * handle2[0] + selectedElmX - handleElm.offsetWidth / 2,
                  top: targetHeight * handle2[1] + selectedElmY - handleElm.offsetHeight / 2
                });
              });
            } else {
              hideResizeRect();
            }
            selectedElm.setAttribute("data-mce-selected", "1");
          };
          var hideResizeRect = function() {
            var name2, handleElm;
            unbindResizeHandleEvents();
            if (selectedElm) {
              selectedElm.removeAttribute("data-mce-selected");
            }
            for (name2 in resizeHandles) {
              handleElm = dom2.get("mceResizeHandle" + name2);
              if (handleElm) {
                dom2.unbind(handleElm);
                dom2.remove(handleElm);
              }
            }
          };
          var updateResizeRect = function(e) {
            var startElm, controlElm;
            var isChildOrEqual = function(node2, parent2) {
              if (node2) {
                do {
                  if (node2 === parent2) {
                    return true;
                  }
                } while (node2 = node2.parentNode);
              }
            };
            if (resizeStarted || editor.removed) {
              return;
            }
            each2(dom2.select("img[data-mce-selected],hr[data-mce-selected]"), function(img) {
              img.removeAttribute("data-mce-selected");
            });
            controlElm = e.type === "mousedown" ? e.target : selection.getNode();
            controlElm = dom2.$(controlElm).closest("table,img,figure.image,hr")[0];
            if (isChildOrEqual(controlElm, rootElement)) {
              disableGeckoResize();
              startElm = selection.getStart(true);
              if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
                showResizeRect(controlElm);
                return;
              }
            }
            hideResizeRect();
          };
          var isWithinContentEditableFalse = function(elm) {
            return isContentEditableFalse$a(getContentEditableRoot$2(editor.getBody(), elm));
          };
          var unbindResizeHandleEvents = function() {
            for (var name2 in resizeHandles) {
              var handle2 = resizeHandles[name2];
              if (handle2.elm) {
                dom2.unbind(handle2.elm);
                delete handle2.elm;
              }
            }
          };
          var disableGeckoResize = function() {
            try {
              editor.getDoc().execCommand("enableObjectResizing", false, false);
            } catch (ex) {
            }
          };
          editor.on("init", function() {
            disableGeckoResize();
            if (Env.ie && Env.ie >= 11) {
              editor.on("mousedown click", function(e) {
                var target2 = e.target, nodeName = target2.nodeName;
                if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target2)) {
                  if (e.button !== 2) {
                    editor.selection.select(target2, nodeName === "TABLE");
                  }
                  if (e.type === "mousedown") {
                    editor.nodeChanged();
                  }
                }
              });
              editor.dom.bind(rootElement, "mscontrolselect", function(e) {
                var delayedSelect = function(node2) {
                  Delay.setEditorTimeout(editor, function() {
                    editor.selection.select(node2);
                  });
                };
                if (isWithinContentEditableFalse(e.target)) {
                  e.preventDefault();
                  delayedSelect(e.target);
                  return;
                }
                if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
                  e.preventDefault();
                  if (e.target.tagName === "IMG") {
                    delayedSelect(e.target);
                  }
                }
              });
            }
            var throttledUpdateResizeRect = Delay.throttle(function(e) {
              if (!editor.composing) {
                updateResizeRect(e);
              }
            });
            editor.on("nodechange ResizeEditor ResizeWindow drop FullscreenStateChanged", throttledUpdateResizeRect);
            editor.on("keyup compositionend", function(e) {
              if (selectedElm && selectedElm.nodeName === "TABLE") {
                throttledUpdateResizeRect(e);
              }
            });
            editor.on("hide blur", hideResizeRect);
            editor.on("contextmenu", contextMenuSelectImage);
          });
          editor.on("remove", unbindResizeHandleEvents);
          var destroy2 = function() {
            selectedElm = selectedElmGhost = null;
          };
          return {
            isResizable,
            showResizeRect,
            hideResizeRect,
            updateResizeRect,
            destroy: destroy2
          };
        };
        var hasCeProperty = function(node2) {
          return NodeType.isContentEditableTrue(node2) || NodeType.isContentEditableFalse(node2);
        };
        var findParent$1 = function(node2, rootNode, predicate) {
          while (node2 && node2 !== rootNode) {
            if (predicate(node2)) {
              return node2;
            }
            node2 = node2.parentNode;
          }
          return null;
        };
        var findClosestIeRange = function(clientX, clientY, doc2) {
          var element, rng, rects;
          element = doc2.elementFromPoint(clientX, clientY);
          rng = doc2.body.createTextRange();
          if (!element || element.tagName === "HTML") {
            element = doc2.body;
          }
          rng.moveToElementText(element);
          rects = Tools.toArray(rng.getClientRects());
          rects = rects.sort(function(a, b) {
            a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
            b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
            return a - b;
          });
          if (rects.length > 0) {
            clientY = (rects[0].bottom + rects[0].top) / 2;
            try {
              rng.moveToPoint(clientX, clientY);
              rng.collapse(true);
              return rng;
            } catch (ex) {
            }
          }
          return null;
        };
        var moveOutOfContentEditableFalse = function(rng, rootNode) {
          var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
          return NodeType.isContentEditableFalse(findParent$1(parentElement, rootNode, hasCeProperty)) ? null : rng;
        };
        var fromPoint$1 = function(clientX, clientY, doc2) {
          var rng, point;
          var pointDoc = doc2;
          if (pointDoc.caretPositionFromPoint) {
            point = pointDoc.caretPositionFromPoint(clientX, clientY);
            if (point) {
              rng = doc2.createRange();
              rng.setStart(point.offsetNode, point.offset);
              rng.collapse(true);
            }
          } else if (doc2.caretRangeFromPoint) {
            rng = doc2.caretRangeFromPoint(clientX, clientY);
          } else if (pointDoc.body.createTextRange) {
            rng = pointDoc.body.createTextRange();
            try {
              rng.moveToPoint(clientX, clientY);
              rng.collapse(true);
            } catch (ex) {
              rng = findClosestIeRange(clientX, clientY, doc2);
            }
            return moveOutOfContentEditableFalse(rng, doc2.body);
          }
          return rng;
        };
        var CaretRangeFromPoint = { fromPoint: fromPoint$1 };
        var processRanges = function(editor, ranges) {
          return map2(ranges, function(range3) {
            var evt = editor.fire("GetSelectionRange", { range: range3 });
            return evt.range !== range3 ? evt.range : range3;
          });
        };
        var EventProcessRanges = { processRanges };
        var fromElements = function(elements, scope) {
          var doc2 = domGlobals.document;
          var fragment = doc2.createDocumentFragment();
          each(elements, function(element) {
            fragment.appendChild(element.dom());
          });
          return Element2.fromDom(fragment);
        };
        var tableModel = Immutable("element", "width", "rows");
        var tableRow = Immutable("element", "cells");
        var cellPosition = Immutable("x", "y");
        var getSpan = function(td, key) {
          var value2 = parseInt(get(td, key), 10);
          return isNaN(value2) ? 1 : value2;
        };
        var fillout = function(table2, x, y, tr, td) {
          var rowspan = getSpan(td, "rowspan");
          var colspan = getSpan(td, "colspan");
          var rows = table2.rows();
          for (var y2 = y; y2 < y + rowspan; y2++) {
            if (!rows[y2]) {
              rows[y2] = tableRow(deep(tr), []);
            }
            for (var x2 = x; x2 < x + colspan; x2++) {
              var cells = rows[y2].cells();
              cells[x2] = y2 === y && x2 === x ? td : shallow(td);
            }
          }
        };
        var cellExists = function(table2, x, y) {
          var rows = table2.rows();
          var cells = rows[y] ? rows[y].cells() : [];
          return !!cells[x];
        };
        var skipCellsX = function(table2, x, y) {
          while (cellExists(table2, x, y)) {
            x++;
          }
          return x;
        };
        var getWidth = function(rows) {
          return foldl(rows, function(acc, row) {
            return row.cells().length > acc ? row.cells().length : acc;
          }, 0);
        };
        var findElementPos = function(table2, element) {
          var rows = table2.rows();
          for (var y = 0; y < rows.length; y++) {
            var cells = rows[y].cells();
            for (var x = 0; x < cells.length; x++) {
              if (eq(cells[x], element)) {
                return Option.some(cellPosition(x, y));
              }
            }
          }
          return Option.none();
        };
        var extractRows = function(table2, sx, sy, ex, ey) {
          var newRows = [];
          var rows = table2.rows();
          for (var y = sy; y <= ey; y++) {
            var cells = rows[y].cells();
            var slice2 = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
            newRows.push(tableRow(rows[y].element(), slice2));
          }
          return newRows;
        };
        var subTable = function(table2, startPos, endPos) {
          var sx = startPos.x(), sy = startPos.y();
          var ex = endPos.x(), ey = endPos.y();
          var newRows = sy < ey ? extractRows(table2, sx, sy, ex, ey) : extractRows(table2, sx, ey, ex, sy);
          return tableModel(table2.element(), getWidth(newRows), newRows);
        };
        var createDomTable = function(table2, rows) {
          var tableElement = shallow(table2.element());
          var tableBody = Element2.fromTag("tbody");
          append$1(tableBody, rows);
          append(tableElement, tableBody);
          return tableElement;
        };
        var modelRowsToDomRows = function(table2) {
          return map2(table2.rows(), function(row) {
            var cells = map2(row.cells(), function(cell2) {
              var td = deep(cell2);
              remove2(td, "colspan");
              remove2(td, "rowspan");
              return td;
            });
            var tr = shallow(row.element());
            append$1(tr, cells);
            return tr;
          });
        };
        var fromDom$1 = function(tableElm) {
          var table2 = tableModel(shallow(tableElm), 0, []);
          each(descendants$1(tableElm, "tr"), function(tr, y) {
            each(descendants$1(tr, "td,th"), function(td, x) {
              fillout(table2, skipCellsX(table2, x, y), y, tr, td);
            });
          });
          return tableModel(table2.element(), getWidth(table2.rows()), table2.rows());
        };
        var toDom = function(table2) {
          return createDomTable(table2, modelRowsToDomRows(table2));
        };
        var subsection = function(table2, startElement, endElement) {
          return findElementPos(table2, startElement).bind(function(startPos) {
            return findElementPos(table2, endElement).map(function(endPos) {
              return subTable(table2, startPos, endPos);
            });
          });
        };
        var SimpleTableModel = {
          fromDom: fromDom$1,
          toDom,
          subsection
        };
        var findParentListContainer = function(parents2) {
          return find(parents2, function(elm) {
            return name(elm) === "ul" || name(elm) === "ol";
          });
        };
        var getFullySelectedListWrappers = function(parents2, rng) {
          return find(parents2, function(elm) {
            return name(elm) === "li" && hasAllContentsSelected(elm, rng);
          }).fold(constant([]), function(li) {
            return findParentListContainer(parents2).map(function(listCont) {
              return [
                Element2.fromTag("li"),
                Element2.fromTag(name(listCont))
              ];
            }).getOr([]);
          });
        };
        var wrap$3 = function(innerElm, elms) {
          var wrapped = foldl(elms, function(acc, elm) {
            append(elm, acc);
            return elm;
          }, innerElm);
          return elms.length > 0 ? fromElements([wrapped]) : wrapped;
        };
        var directListWrappers = function(commonAnchorContainer) {
          if (isListItem(commonAnchorContainer)) {
            return parent(commonAnchorContainer).filter(isList).fold(constant([]), function(listElm) {
              return [
                commonAnchorContainer,
                listElm
              ];
            });
          } else {
            return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
          }
        };
        var getWrapElements = function(rootNode, rng) {
          var commonAnchorContainer = Element2.fromDom(rng.commonAncestorContainer);
          var parents2 = Parents.parentsAndSelf(commonAnchorContainer, rootNode);
          var wrapElements = filter(parents2, function(elm) {
            return isInline(elm) || isHeading(elm);
          });
          var listWrappers = getFullySelectedListWrappers(parents2, rng);
          var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
          return map2(allWrappers, shallow);
        };
        var emptyFragment = function() {
          return fromElements([]);
        };
        var getFragmentFromRange = function(rootNode, rng) {
          return wrap$3(Element2.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
        };
        var getParentTable = function(rootElm, cell2) {
          return ancestor$1(cell2, "table", curry(eq, rootElm));
        };
        var getTableFragment = function(rootNode, selectedTableCells) {
          return getParentTable(rootNode, selectedTableCells[0]).bind(function(tableElm) {
            var firstCell = selectedTableCells[0];
            var lastCell = selectedTableCells[selectedTableCells.length - 1];
            var fullTableModel = SimpleTableModel.fromDom(tableElm);
            return SimpleTableModel.subsection(fullTableModel, firstCell, lastCell).map(function(sectionedTableModel) {
              return fromElements([SimpleTableModel.toDom(sectionedTableModel)]);
            });
          }).getOrThunk(emptyFragment);
        };
        var getSelectionFragment = function(rootNode, ranges) {
          return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
        };
        var read$4 = function(rootNode, ranges) {
          var selectedCells = TableCellSelection.getCellsFromElementOrRanges(ranges, rootNode);
          return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
        };
        var FragmentReader = { read: read$4 };
        var getTextContent = function(editor) {
          return Option.from(editor.selection.getRng()).map(function(rng) {
            var bin = editor.dom.add(editor.getBody(), "div", {
              "data-mce-bogus": "all",
              "style": "overflow: hidden; opacity: 0;"
            }, rng.cloneContents());
            var text2 = Zwsp.trim(bin.innerText);
            editor.dom.remove(bin);
            return text2;
          }).getOr("");
        };
        var getHtmlContent = function(editor, args) {
          var rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
          var sel = editor.selection.getSel();
          var fragment;
          var ranges = EventProcessRanges.processRanges(editor, MultiRange.getRanges(sel));
          fragment = args.contextual ? FragmentReader.read(Element2.fromDom(editor.getBody()), ranges).dom() : rng.cloneContents();
          if (fragment) {
            tmpElm.appendChild(fragment);
          }
          return editor.selection.serializer.serialize(tmpElm, args);
        };
        var getContent = function(editor, args) {
          if (args === void 0) {
            args = {};
          }
          args.get = true;
          args.format = args.format || "html";
          args.selection = true;
          args = editor.fire("BeforeGetContent", args);
          if (args.isDefaultPrevented()) {
            editor.fire("GetContent", args);
            return args.content;
          }
          if (args.format === "text") {
            return getTextContent(editor);
          } else {
            args.getInner = true;
            var content = getHtmlContent(editor, args);
            if (args.format === "tree") {
              return content;
            } else {
              args.content = editor.selection.isCollapsed() ? "" : content;
              editor.fire("GetContent", args);
              return args.content;
            }
          }
        };
        var GetSelectionContent = { getContent };
        var setupArgs = function(args, content) {
          return __assign(__assign({ format: "html" }, args), {
            set: true,
            selection: true,
            content
          });
        };
        var cleanContent = function(editor, args) {
          if (args.format !== "raw") {
            var node2 = editor.parser.parse(args.content, __assign({
              isRootContent: true,
              forced_root_block: false
            }, args));
            return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node2);
          } else {
            return args.content;
          }
        };
        var setContent = function(editor, content, args) {
          var contentArgs = setupArgs(args, content);
          var rng = editor.selection.getRng(), caretNode;
          var doc2 = editor.getDoc();
          var frag, temp;
          if (!contentArgs.no_events) {
            contentArgs = editor.fire("BeforeSetContent", contentArgs);
            if (contentArgs.isDefaultPrevented()) {
              editor.fire("SetContent", contentArgs);
              return;
            }
          }
          content = cleanContent(editor, contentArgs);
          if (rng.insertNode) {
            content += '<span id="__caret">_</span>';
            if (rng.startContainer === doc2 && rng.endContainer === doc2) {
              doc2.body.innerHTML = content;
            } else {
              rng.deleteContents();
              if (doc2.body.childNodes.length === 0) {
                doc2.body.innerHTML = content;
              } else {
                if (rng.createContextualFragment) {
                  rng.insertNode(rng.createContextualFragment(content));
                } else {
                  frag = doc2.createDocumentFragment();
                  temp = doc2.createElement("div");
                  frag.appendChild(temp);
                  temp.outerHTML = content;
                  rng.insertNode(frag);
                }
              }
            }
            caretNode = editor.dom.get("__caret");
            rng = doc2.createRange();
            rng.setStartBefore(caretNode);
            rng.setEndBefore(caretNode);
            editor.selection.setRng(rng);
            editor.dom.remove("__caret");
            try {
              editor.selection.setRng(rng);
            } catch (ex) {
            }
          } else {
            var anyRng = rng;
            if (anyRng.item) {
              doc2.execCommand("Delete", false, null);
              anyRng = editor.selection.getRng();
            }
            if (/^\s+/.test(content)) {
              anyRng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
              editor.dom.remove("__mce_tmp");
            } else {
              anyRng.pasteHTML(content);
            }
          }
          if (!contentArgs.no_events) {
            editor.fire("SetContent", contentArgs);
          }
        };
        var SetSelectionContent = { setContent };
        var getEndpointElement = function(root2, rng, start2, real2, resolve2) {
          var container = start2 ? rng.startContainer : rng.endContainer;
          var offset = start2 ? rng.startOffset : rng.endOffset;
          return Option.from(container).map(Element2.fromDom).map(function(elm) {
            return !real2 || !rng.collapsed ? child(elm, resolve2(elm, offset)).getOr(elm) : elm;
          }).bind(function(elm) {
            return isElement(elm) ? Option.some(elm) : parent(elm);
          }).map(function(elm) {
            return elm.dom();
          }).getOr(root2);
        };
        var getStart$2 = function(root2, rng, real2) {
          return getEndpointElement(root2, rng, true, real2, function(elm, offset) {
            return Math.min(childNodesCount(elm), offset);
          });
        };
        var getEnd = function(root2, rng, real2) {
          return getEndpointElement(root2, rng, false, real2, function(elm, offset) {
            return offset > 0 ? offset - 1 : offset;
          });
        };
        var skipEmptyTextNodes = function(node2, forwards) {
          var orig = node2;
          while (node2 && NodeType.isText(node2) && node2.length === 0) {
            node2 = forwards ? node2.nextSibling : node2.previousSibling;
          }
          return node2 || orig;
        };
        var getNode$1 = function(root2, rng) {
          var elm, startContainer, endContainer, startOffset, endOffset;
          if (!rng) {
            return root2;
          }
          startContainer = rng.startContainer;
          endContainer = rng.endContainer;
          startOffset = rng.startOffset;
          endOffset = rng.endOffset;
          elm = rng.commonAncestorContainer;
          if (!rng.collapsed) {
            if (startContainer === endContainer) {
              if (endOffset - startOffset < 2) {
                if (startContainer.hasChildNodes()) {
                  elm = startContainer.childNodes[startOffset];
                }
              }
            }
            if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
              if (startContainer.length === startOffset) {
                startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
              } else {
                startContainer = startContainer.parentNode;
              }
              if (endOffset === 0) {
                endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
              } else {
                endContainer = endContainer.parentNode;
              }
              if (startContainer && startContainer === endContainer) {
                return startContainer;
              }
            }
          }
          if (elm && elm.nodeType === 3) {
            return elm.parentNode;
          }
          return elm;
        };
        var getSelectedBlocks = function(dom2, rng, startElm, endElm) {
          var node2, root2;
          var selectedBlocks = [];
          root2 = dom2.getRoot();
          startElm = dom2.getParent(startElm || getStart$2(root2, rng, rng.collapsed), dom2.isBlock);
          endElm = dom2.getParent(endElm || getEnd(root2, rng, rng.collapsed), dom2.isBlock);
          if (startElm && startElm !== root2) {
            selectedBlocks.push(startElm);
          }
          if (startElm && endElm && startElm !== endElm) {
            node2 = startElm;
            var walker = new TreeWalker(startElm, root2);
            while ((node2 = walker.next()) && node2 !== endElm) {
              if (dom2.isBlock(node2)) {
                selectedBlocks.push(node2);
              }
            }
          }
          if (endElm && startElm !== endElm && endElm !== root2) {
            selectedBlocks.push(endElm);
          }
          return selectedBlocks;
        };
        var select$1 = function(dom2, node2, content) {
          return Option.from(node2).map(function(node3) {
            var idx = dom2.nodeIndex(node3);
            var rng = dom2.createRng();
            rng.setStart(node3.parentNode, idx);
            rng.setEnd(node3.parentNode, idx + 1);
            if (content) {
              moveEndPoint$1(dom2, rng, node3, true);
              moveEndPoint$1(dom2, rng, node3, false);
            }
            return rng;
          });
        };
        var each$j = Tools.each;
        var isNativeIeSelection = function(rng) {
          return !!rng.select;
        };
        var isAttachedToDom = function(node2) {
          return !!(node2 && node2.ownerDocument) && contains$3(Element2.fromDom(node2.ownerDocument), Element2.fromDom(node2));
        };
        var isValidRange = function(rng) {
          if (!rng) {
            return false;
          } else if (isNativeIeSelection(rng)) {
            return true;
          } else {
            return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
          }
        };
        var Selection$1 = function(dom2, win, serializer, editor) {
          var bookmarkManager, controlSelection;
          var selectedRange, explicitRange, selectorChangedData;
          var setCursorLocation = function(node2, offset) {
            var rng = dom2.createRng();
            if (!node2) {
              moveEndPoint$1(dom2, rng, editor.getBody(), true);
              setRng(rng);
            } else {
              rng.setStart(node2, offset);
              rng.setEnd(node2, offset);
              setRng(rng);
              collapse2(false);
            }
          };
          var getContent2 = function(args) {
            return GetSelectionContent.getContent(editor, args);
          };
          var setContent2 = function(content, args) {
            return SetSelectionContent.setContent(editor, content, args);
          };
          var getStart2 = function(real2) {
            return getStart$2(editor.getBody(), getRng2(), real2);
          };
          var getEnd$1 = function(real2) {
            return getEnd(editor.getBody(), getRng2(), real2);
          };
          var getBookmark2 = function(type2, normalized) {
            return bookmarkManager.getBookmark(type2, normalized);
          };
          var moveToBookmark2 = function(bookmark) {
            return bookmarkManager.moveToBookmark(bookmark);
          };
          var select2 = function(node2, content) {
            select$1(dom2, node2, content).each(setRng);
            return node2;
          };
          var isCollapsed = function() {
            var rng = getRng2(), sel = getSel();
            if (!rng || rng.item) {
              return false;
            }
            if (rng.compareEndPoints) {
              return rng.compareEndPoints("StartToEnd", rng) === 0;
            }
            return !sel || rng.collapsed;
          };
          var collapse2 = function(toStart) {
            var rng = getRng2();
            rng.collapse(!!toStart);
            setRng(rng);
          };
          var getSel = function() {
            return win.getSelection ? win.getSelection() : win.document.selection;
          };
          var getRng2 = function() {
            var selection, rng, elm, doc2;
            var tryCompareBoundaryPoints = function(how, sourceRange, destinationRange) {
              try {
                return sourceRange.compareBoundaryPoints(how, destinationRange);
              } catch (ex) {
                return -1;
              }
            };
            if (!win) {
              return null;
            }
            doc2 = win.document;
            if (typeof doc2 === "undefined" || doc2 === null) {
              return null;
            }
            if (editor.bookmark !== void 0 && EditorFocus.hasFocus(editor) === false) {
              var bookmark = SelectionBookmark.getRng(editor);
              if (bookmark.isSome()) {
                return bookmark.map(function(r) {
                  return EventProcessRanges.processRanges(editor, [r])[0];
                }).getOr(doc2.createRange());
              }
            }
            try {
              if ((selection = getSel()) && !NodeType.isRestrictedNode(selection.anchorNode)) {
                if (selection.rangeCount > 0) {
                  rng = selection.getRangeAt(0);
                } else {
                  rng = selection.createRange ? selection.createRange() : doc2.createRange();
                }
              }
            } catch (ex) {
            }
            rng = EventProcessRanges.processRanges(editor, [rng])[0];
            if (!rng) {
              rng = doc2.createRange ? doc2.createRange() : doc2.body.createTextRange();
            }
            if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
              elm = dom2.getRoot();
              rng.setStart(elm, 0);
              rng.setEnd(elm, 0);
            }
            if (selectedRange && explicitRange) {
              if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
                rng = explicitRange;
              } else {
                selectedRange = null;
                explicitRange = null;
              }
            }
            return rng;
          };
          var setRng = function(rng, forward) {
            var sel, node2, evt;
            if (!isValidRange(rng)) {
              return;
            }
            var ieRange = isNativeIeSelection(rng) ? rng : null;
            if (ieRange) {
              explicitRange = null;
              try {
                ieRange.select();
              } catch (ex) {
              }
              return;
            }
            sel = getSel();
            evt = editor.fire("SetSelectionRange", {
              range: rng,
              forward
            });
            rng = evt.range;
            if (sel) {
              explicitRange = rng;
              try {
                sel.removeAllRanges();
                sel.addRange(rng);
              } catch (ex) {
              }
              if (forward === false && sel.extend) {
                sel.collapse(rng.endContainer, rng.endOffset);
                sel.extend(rng.startContainer, rng.startOffset);
              }
              selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            }
            if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
              if (rng.endOffset - rng.startOffset < 2) {
                if (rng.startContainer.hasChildNodes()) {
                  node2 = rng.startContainer.childNodes[rng.startOffset];
                  if (node2 && node2.tagName === "IMG") {
                    sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                    if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                      sel.setBaseAndExtent(node2, 0, node2, 1);
                    }
                  }
                }
              }
            }
            editor.fire("AfterSetSelectionRange", {
              range: rng,
              forward
            });
          };
          var setNode = function(elm) {
            setContent2(dom2.getOuterHTML(elm));
            return elm;
          };
          var getNode2 = function() {
            return getNode$1(editor.getBody(), getRng2());
          };
          var getSelectedBlocks$1 = function(startElm, endElm) {
            return getSelectedBlocks(dom2, getRng2(), startElm, endElm);
          };
          var isForward = function() {
            var sel = getSel();
            var anchorRange, focusRange;
            if (!sel || !sel.anchorNode || !sel.focusNode) {
              return true;
            }
            anchorRange = dom2.createRng();
            anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
            anchorRange.collapse(true);
            focusRange = dom2.createRng();
            focusRange.setStart(sel.focusNode, sel.focusOffset);
            focusRange.collapse(true);
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
          };
          var normalize3 = function() {
            var rng = getRng2();
            var sel = getSel();
            if (!MultiRange.hasMultipleRanges(sel) && hasAnyRanges(editor)) {
              var normRng = NormalizeRange.normalize(dom2, rng);
              normRng.each(function(normRng2) {
                setRng(normRng2, isForward());
              });
              return normRng.getOr(rng);
            }
            return rng;
          };
          var selectorChanged = function(selector, callback) {
            var currentSelectors;
            if (!selectorChangedData) {
              selectorChangedData = {};
              currentSelectors = {};
              editor.on("NodeChange", function(e) {
                var node2 = e.element, parents2 = dom2.getParents(node2, null, dom2.getRoot()), matchedSelectors = {};
                each$j(selectorChangedData, function(callbacks, selector2) {
                  each$j(parents2, function(node3) {
                    if (dom2.is(node3, selector2)) {
                      if (!currentSelectors[selector2]) {
                        each$j(callbacks, function(callback2) {
                          callback2(true, {
                            node: node3,
                            selector: selector2,
                            parents: parents2
                          });
                        });
                        currentSelectors[selector2] = callbacks;
                      }
                      matchedSelectors[selector2] = callbacks;
                      return false;
                    }
                  });
                });
                each$j(currentSelectors, function(callbacks, selector2) {
                  if (!matchedSelectors[selector2]) {
                    delete currentSelectors[selector2];
                    each$j(callbacks, function(callback2) {
                      callback2(false, {
                        node: node2,
                        selector: selector2,
                        parents: parents2
                      });
                    });
                  }
                });
              });
            }
            if (!selectorChangedData[selector]) {
              selectorChangedData[selector] = [];
            }
            selectorChangedData[selector].push(callback);
            return exports$12;
          };
          var getScrollContainer = function() {
            var scrollContainer;
            var node2 = dom2.getRoot();
            while (node2 && node2.nodeName !== "BODY") {
              if (node2.scrollHeight > node2.clientHeight) {
                scrollContainer = node2;
                break;
              }
              node2 = node2.parentNode;
            }
            return scrollContainer;
          };
          var scrollIntoView = function(elm, alignToTop) {
            return ScrollIntoView.scrollElementIntoView(editor, elm, alignToTop);
          };
          var placeCaretAt = function(clientX, clientY) {
            return setRng(CaretRangeFromPoint.fromPoint(clientX, clientY, editor.getDoc()));
          };
          var getBoundingClientRect2 = function() {
            var rng = getRng2();
            return rng.collapsed ? CaretPosition$1.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
          };
          var destroy2 = function() {
            win = selectedRange = explicitRange = null;
            controlSelection.destroy();
          };
          var exports$12 = {
            bookmarkManager: null,
            controlSelection: null,
            dom: dom2,
            win,
            serializer,
            editor,
            collapse: collapse2,
            setCursorLocation,
            getContent: getContent2,
            setContent: setContent2,
            getBookmark: getBookmark2,
            moveToBookmark: moveToBookmark2,
            select: select2,
            isCollapsed,
            isForward,
            setNode,
            getNode: getNode2,
            getSel,
            setRng,
            getRng: getRng2,
            getStart: getStart2,
            getEnd: getEnd$1,
            getSelectedBlocks: getSelectedBlocks$1,
            normalize: normalize3,
            selectorChanged,
            getScrollContainer,
            scrollIntoView,
            placeCaretAt,
            getBoundingClientRect: getBoundingClientRect2,
            destroy: destroy2
          };
          bookmarkManager = BookmarkManager$1(exports$12);
          controlSelection = ControlSelection(exports$12, editor);
          exports$12.bookmarkManager = bookmarkManager;
          exports$12.controlSelection = controlSelection;
          return exports$12;
        };
        var BreakType;
        (function(BreakType2) {
          BreakType2[BreakType2["Br"] = 0] = "Br";
          BreakType2[BreakType2["Block"] = 1] = "Block";
          BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
          BreakType2[BreakType2["Eol"] = 3] = "Eol";
        })(BreakType || (BreakType = {}));
        var flip = function(direction, positions) {
          return direction === HDirection.Backwards ? positions.reverse() : positions;
        };
        var walk$3 = function(direction, caretWalker, pos) {
          return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
        };
        var getBreakType = function(scope, direction, currentPos, nextPos) {
          if (NodeType.isBr(nextPos.getNode(direction === HDirection.Forwards))) {
            return BreakType.Br;
          } else if (isInSameBlock(currentPos, nextPos) === false) {
            return BreakType.Block;
          } else {
            return BreakType.Wrap;
          }
        };
        var getPositionsUntil = function(predicate, direction, scope, start2) {
          var caretWalker = CaretWalker(scope);
          var currentPos = start2, nextPos;
          var positions = [];
          while (currentPos) {
            nextPos = walk$3(direction, caretWalker, currentPos);
            if (!nextPos) {
              break;
            }
            if (NodeType.isBr(nextPos.getNode(false))) {
              if (direction === HDirection.Forwards) {
                return {
                  positions: flip(direction, positions).concat([nextPos]),
                  breakType: BreakType.Br,
                  breakAt: Option.some(nextPos)
                };
              } else {
                return {
                  positions: flip(direction, positions),
                  breakType: BreakType.Br,
                  breakAt: Option.some(nextPos)
                };
              }
            }
            if (!nextPos.isVisible()) {
              currentPos = nextPos;
              continue;
            }
            if (predicate(currentPos, nextPos)) {
              var breakType = getBreakType(scope, direction, currentPos, nextPos);
              return {
                positions: flip(direction, positions),
                breakType,
                breakAt: Option.some(nextPos)
              };
            }
            positions.push(nextPos);
            currentPos = nextPos;
          }
          return {
            positions: flip(direction, positions),
            breakType: BreakType.Eol,
            breakAt: Option.none()
          };
        };
        var getAdjacentLinePositions = function(direction, getPositionsUntilBreak, scope, start2) {
          return getPositionsUntilBreak(scope, start2).breakAt.map(function(pos) {
            var positions = getPositionsUntilBreak(scope, pos).positions;
            return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
          }).getOr([]);
        };
        var findClosestHorizontalPositionFromPoint = function(positions, x) {
          return foldl(positions, function(acc, newPos) {
            return acc.fold(function() {
              return Option.some(newPos);
            }, function(lastPos) {
              return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function(lastRect, newRect) {
                var lastDist = Math.abs(x - lastRect.left);
                var newDist = Math.abs(x - newRect.left);
                return newDist <= lastDist ? newPos : lastPos;
              }).or(acc);
            });
          }, Option.none());
        };
        var findClosestHorizontalPosition = function(positions, pos) {
          return head(pos.getClientRects()).bind(function(targetRect) {
            return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
          });
        };
        var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
        var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
        var isAtFirstLine = function(scope, pos) {
          return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
        };
        var isAtLastLine = function(scope, pos) {
          return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
        };
        var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
        var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
        var getFirstLinePositions = function(scope) {
          return CaretFinder.firstPositionIn(scope).map(function(pos) {
            return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
          }).getOr([]);
        };
        var getLastLinePositions = function(scope) {
          return CaretFinder.lastPositionIn(scope).map(function(pos) {
            return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
          }).getOr([]);
        };
        var isContentEditableFalse$b = NodeType.isContentEditableFalse;
        var getSelectedNode$1 = getSelectedNode;
        var moveToCeFalseHorizontally = function(direction, editor, getNextPosFn, range3) {
          var forwards = direction === HDirection.Forwards;
          var isBeforeContentEditableFalseFn = forwards ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
          if (!range3.collapsed) {
            var node2 = getSelectedNode$1(range3);
            if (isContentEditableFalse$b(node2)) {
              return showCaret(direction, editor, node2, direction === HDirection.Backwards, true);
            }
          }
          var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range3);
          var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range3);
          if (isBeforeContentEditableFalseFn(caretPosition)) {
            return selectNode(editor, caretPosition.getNode(!forwards));
          }
          var nextCaretPosition = InlineUtils.normalizePosition(forwards, getNextPosFn(caretPosition));
          if (!nextCaretPosition) {
            if (rangeIsInContainerBlock) {
              return range3;
            }
            return null;
          }
          if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
            return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, true);
          }
          var peekCaretPosition = getNextPosFn(nextCaretPosition);
          if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
              return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, true);
            }
          }
          if (rangeIsInContainerBlock) {
            return renderRangeCaret(editor, nextCaretPosition.toRange(), true);
          }
          return null;
        };
        var moveToCeFalseVertically = function(direction, editor, walkerFn, range3) {
          var caretPosition, linePositions, nextLinePositions;
          var closestNextLineRect, caretClientRect, clientX;
          var dist1, dist2, contentEditableFalseNode;
          contentEditableFalseNode = getSelectedNode$1(range3);
          caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range3);
          linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
          nextLinePositions = filter(linePositions, isLine(1));
          caretClientRect = ArrUtils.last(caretPosition.getClientRects());
          if (isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition)) {
            contentEditableFalseNode = caretPosition.getNode();
          }
          if (isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition)) {
            contentEditableFalseNode = caretPosition.getNode(true);
          }
          if (!caretClientRect) {
            return null;
          }
          clientX = caretClientRect.left;
          closestNextLineRect = findClosestClientRect(nextLinePositions, clientX);
          if (closestNextLineRect) {
            if (isContentEditableFalse$b(closestNextLineRect.node)) {
              dist1 = Math.abs(clientX - closestNextLineRect.left);
              dist2 = Math.abs(clientX - closestNextLineRect.right);
              return showCaret(direction, editor, closestNextLineRect.node, dist1 < dist2, true);
            }
          }
          if (contentEditableFalseNode) {
            var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), contentEditableFalseNode);
            closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
            if (closestNextLineRect) {
              return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
            }
            closestNextLineRect = ArrUtils.last(filter(caretPositions, isLine(0)));
            if (closestNextLineRect) {
              return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
            }
          }
        };
        var createTextBlock = function(editor) {
          var textBlock = editor.dom.create(Settings.getForcedRootBlock(editor));
          if (!Env.ie || Env.ie >= 11) {
            textBlock.innerHTML = '<br data-mce-bogus="1">';
          }
          return textBlock;
        };
        var exitPreBlock = function(editor, direction, range3) {
          var pre2, caretPos, newBlock;
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          if (range3.collapsed && editor.settings.forced_root_block) {
            pre2 = editor.dom.getParent(range3.startContainer, "PRE");
            if (!pre2) {
              return;
            }
            if (direction === 1) {
              caretPos = getNextVisualCaretPosition(CaretPosition$1.fromRangeStart(range3));
            } else {
              caretPos = getPrevVisualCaretPosition(CaretPosition$1.fromRangeStart(range3));
            }
            if (!caretPos) {
              newBlock = createTextBlock(editor);
              if (direction === 1) {
                editor.$(pre2).after(newBlock);
              } else {
                editor.$(pre2).before(newBlock);
              }
              editor.selection.select(newBlock, true);
              editor.selection.collapse();
            }
          }
        };
        var getHorizontalRange = function(editor, forward) {
          var caretWalker = CaretWalker(editor.getBody());
          var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
          var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
          var newRange;
          var direction = forward ? HDirection.Forwards : HDirection.Backwards;
          var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
          var range3 = editor.selection.getRng();
          newRange = moveToCeFalseHorizontally(direction, editor, getNextPosFn, range3);
          if (newRange) {
            return newRange;
          }
          newRange = exitPreBlock(editor, direction, range3);
          if (newRange) {
            return newRange;
          }
          return null;
        };
        var getVerticalRange = function(editor, down) {
          var newRange;
          var direction = down ? 1 : -1;
          var walkerFn = down ? downUntil : upUntil;
          var range3 = editor.selection.getRng();
          newRange = moveToCeFalseVertically(direction, editor, walkerFn, range3);
          if (newRange) {
            return newRange;
          }
          newRange = exitPreBlock(editor, direction, range3);
          if (newRange) {
            return newRange;
          }
          return null;
        };
        var moveH = function(editor, forward) {
          return function() {
            var newRng = getHorizontalRange(editor, forward);
            if (newRng) {
              moveToRange(editor, newRng);
              return true;
            } else {
              return false;
            }
          };
        };
        var moveV = function(editor, down) {
          return function() {
            var newRng = getVerticalRange(editor, down);
            if (newRng) {
              moveToRange(editor, newRng);
              return true;
            } else {
              return false;
            }
          };
        };
        var isCefPosition = function(forward) {
          return function(pos) {
            return forward ? isAfterContentEditableFalse(pos) : isBeforeContentEditableFalse(pos);
          };
        };
        var moveToLineEndPoint = function(editor, forward) {
          return function() {
            var from2 = forward ? CaretPosition$1.fromRangeEnd(editor.selection.getRng()) : CaretPosition$1.fromRangeStart(editor.selection.getRng());
            var result = forward ? getPositionsUntilNextLine(editor.getBody(), from2) : getPositionsUntilPreviousLine(editor.getBody(), from2);
            var to = forward ? last(result.positions) : head(result.positions);
            return to.filter(isCefPosition(forward)).fold(constant(false), function(pos) {
              editor.selection.setRng(pos.toRange());
              return true;
            });
          };
        };
        var deflate = function(rect2, delta2) {
          return {
            left: rect2.left - delta2,
            top: rect2.top - delta2,
            right: rect2.right + delta2 * 2,
            bottom: rect2.bottom + delta2 * 2,
            width: rect2.width + delta2,
            height: rect2.height + delta2
          };
        };
        var getCorners = function(getYAxisValue, tds) {
          return bind(tds, function(td) {
            var rect2 = deflate(clone$1(td.getBoundingClientRect()), -1);
            return [
              {
                x: rect2.left,
                y: getYAxisValue(rect2),
                cell: td
              },
              {
                x: rect2.right,
                y: getYAxisValue(rect2),
                cell: td
              }
            ];
          });
        };
        var findClosestCorner = function(corners, x, y) {
          return foldl(corners, function(acc, newCorner) {
            return acc.fold(function() {
              return Option.some(newCorner);
            }, function(oldCorner) {
              var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
              var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
              return Option.some(newDist < oldDist ? newCorner : oldCorner);
            });
          }, Option.none());
        };
        var getClosestCell$1 = function(getYAxisValue, isTargetCorner, table2, x, y) {
          var cells = descendants$1(Element2.fromDom(table2), "td,th,caption").map(function(e) {
            return e.dom();
          });
          var corners = filter(getCorners(getYAxisValue, cells), function(corner) {
            return isTargetCorner(corner, y);
          });
          return findClosestCorner(corners, x, y).map(function(corner) {
            return corner.cell;
          });
        };
        var getBottomValue = function(rect2) {
          return rect2.bottom;
        };
        var getTopValue = function(rect2) {
          return rect2.top;
        };
        var isAbove$1 = function(corner, y) {
          return corner.y < y;
        };
        var isBelow$1 = function(corner, y) {
          return corner.y > y;
        };
        var getClosestCellAbove = curry(getClosestCell$1, getBottomValue, isAbove$1);
        var getClosestCellBelow = curry(getClosestCell$1, getTopValue, isBelow$1);
        var findClosestPositionInAboveCell = function(table2, pos) {
          return head(pos.getClientRects()).bind(function(rect2) {
            return getClosestCellAbove(table2, rect2.left, rect2.top);
          }).bind(function(cell2) {
            return findClosestHorizontalPosition(getLastLinePositions(cell2), pos);
          });
        };
        var findClosestPositionInBelowCell = function(table2, pos) {
          return last(pos.getClientRects()).bind(function(rect2) {
            return getClosestCellBelow(table2, rect2.left, rect2.top);
          }).bind(function(cell2) {
            return findClosestHorizontalPosition(getFirstLinePositions(cell2), pos);
          });
        };
        var hasNextBreak = function(getPositionsUntil2, scope, lineInfo) {
          return lineInfo.breakAt.map(function(breakPos) {
            return getPositionsUntil2(scope, breakPos).breakAt.isSome();
          }).getOr(false);
        };
        var startsWithWrapBreak = function(lineInfo) {
          return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
        };
        var startsWithBrBreak = function(lineInfo) {
          return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
        };
        var isAtTableCellLine = function(getPositionsUntil2, scope, pos) {
          var lineInfo = getPositionsUntil2(scope, pos);
          if (startsWithWrapBreak(lineInfo) || !NodeType.isBr(pos.getNode()) && startsWithBrBreak(lineInfo)) {
            return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
          } else {
            return lineInfo.breakAt.isNone();
          }
        };
        var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
        var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
        var isCaretAtStartOrEndOfTable = function(forward, rng, table2) {
          var caretPos = CaretPosition$1.fromRangeStart(rng);
          return CaretFinder.positionIn(!forward, table2).map(function(pos) {
            return pos.isEqual(caretPos);
          }).getOr(false);
        };
        var navigateHorizontally = function(editor, forward, table2, td) {
          var rng = editor.selection.getRng();
          var direction = forward ? 1 : -1;
          if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table2)) {
            var newRng = showCaret(direction, editor, table2, !forward, true);
            moveToRange(editor, newRng);
            return true;
          }
          return false;
        };
        var getClosestAbovePosition = function(root2, table2, start2) {
          return findClosestPositionInAboveCell(table2, start2).orThunk(function() {
            return head(start2.getClientRects()).bind(function(rect2) {
              return findClosestHorizontalPositionFromPoint(getPositionsAbove(root2, CaretPosition$1.before(table2)), rect2.left);
            });
          }).getOr(CaretPosition$1.before(table2));
        };
        var getClosestBelowPosition = function(root2, table2, start2) {
          return findClosestPositionInBelowCell(table2, start2).orThunk(function() {
            return head(start2.getClientRects()).bind(function(rect2) {
              return findClosestHorizontalPositionFromPoint(getPositionsBelow(root2, CaretPosition$1.after(table2)), rect2.left);
            });
          }).getOr(CaretPosition$1.after(table2));
        };
        var getTable = function(previous, pos) {
          var node2 = pos.getNode(previous);
          return NodeType.isElement(node2) && node2.nodeName === "TABLE" ? Option.some(node2) : Option.none();
        };
        var renderBlock = function(down, editor, table2, pos) {
          var forcedRootBlock = Settings.getForcedRootBlock(editor);
          if (forcedRootBlock) {
            editor.undoManager.transact(function() {
              var element = Element2.fromTag(forcedRootBlock);
              setAll(element, Settings.getForcedRootBlockAttrs(editor));
              append(element, Element2.fromTag("br"));
              if (down) {
                after(Element2.fromDom(table2), element);
              } else {
                before(Element2.fromDom(table2), element);
              }
              var rng = editor.dom.createRng();
              rng.setStart(element.dom(), 0);
              rng.setEnd(element.dom(), 0);
              moveToRange(editor, rng);
            });
          } else {
            moveToRange(editor, pos.toRange());
          }
        };
        var moveCaret = function(editor, down, pos) {
          var table2 = down ? getTable(true, pos) : getTable(false, pos);
          var last2 = down === false;
          table2.fold(function() {
            return moveToRange(editor, pos.toRange());
          }, function(table3) {
            return CaretFinder.positionIn(last2, editor.getBody()).filter(function(lastPos) {
              return lastPos.isEqual(pos);
            }).fold(function() {
              return moveToRange(editor, pos.toRange());
            }, function(_) {
              return renderBlock(down, editor, table3, pos);
            });
          });
        };
        var navigateVertically = function(editor, down, table2, td) {
          var rng = editor.selection.getRng();
          var pos = CaretPosition$1.fromRangeStart(rng);
          var root2 = editor.getBody();
          if (!down && isAtFirstTableCellLine(td, pos)) {
            var newPos = getClosestAbovePosition(root2, table2, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else if (down && isAtLastTableCellLine(td, pos)) {
            var newPos = getClosestBelowPosition(root2, table2, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else {
            return false;
          }
        };
        var moveH$1 = function(editor, forward) {
          return function() {
            return Option.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td) {
              return Option.from(editor.dom.getParent(td, "table")).map(function(table2) {
                return navigateHorizontally(editor, forward, table2);
              });
            }).getOr(false);
          };
        };
        var moveV$1 = function(editor, forward) {
          return function() {
            return Option.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind(function(td) {
              return Option.from(editor.dom.getParent(td, "table")).map(function(table2) {
                return navigateVertically(editor, forward, table2, td);
              });
            }).getOr(false);
          };
        };
        var isTarget = function(node2) {
          return contains(["figcaption"], name(node2));
        };
        var rangeBefore = function(target2) {
          var rng = domGlobals.document.createRange();
          rng.setStartBefore(target2.dom());
          rng.setEndBefore(target2.dom());
          return rng;
        };
        var insertElement = function(root2, elm, forward) {
          if (forward) {
            append(root2, elm);
          } else {
            prepend(root2, elm);
          }
        };
        var insertBr = function(root2, forward) {
          var br = Element2.fromTag("br");
          insertElement(root2, br, forward);
          return rangeBefore(br);
        };
        var insertBlock$1 = function(root2, forward, blockName, attrs) {
          var block2 = Element2.fromTag(blockName);
          var br = Element2.fromTag("br");
          setAll(block2, attrs);
          append(block2, br);
          insertElement(root2, block2, forward);
          return rangeBefore(br);
        };
        var insertEmptyLine = function(root2, rootBlockName, attrs, forward) {
          if (rootBlockName === "") {
            return insertBr(root2, forward);
          } else {
            return insertBlock$1(root2, forward, rootBlockName, attrs);
          }
        };
        var getClosestTargetBlock = function(pos, root2) {
          var isRoot = curry(eq, root2);
          return closest(Element2.fromDom(pos.container()), isBlock2, isRoot).filter(isTarget);
        };
        var isAtFirstOrLastLine = function(root2, forward, pos) {
          return forward ? isAtLastLine(root2.dom(), pos) : isAtFirstLine(root2.dom(), pos);
        };
        var moveCaretToNewEmptyLine = function(editor, forward) {
          var root2 = Element2.fromDom(editor.getBody());
          var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var rootBlock = Settings.getForcedRootBlock(editor);
          var rootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
          return getClosestTargetBlock(pos, root2).exists(function() {
            if (isAtFirstOrLastLine(root2, forward, pos)) {
              var rng = insertEmptyLine(root2, rootBlock, rootBlockAttrs, forward);
              editor.selection.setRng(rng);
              return true;
            } else {
              return false;
            }
          });
        };
        var moveV$2 = function(editor, forward) {
          return function() {
            if (editor.selection.isCollapsed()) {
              return moveCaretToNewEmptyLine(editor, forward);
            } else {
              return false;
            }
          };
        };
        var defaultPatterns = function(patterns) {
          return map2(patterns, function(pattern2) {
            return merge({
              shiftKey: false,
              altKey: false,
              ctrlKey: false,
              metaKey: false,
              keyCode: 0,
              action: noop
            }, pattern2);
          });
        };
        var matchesEvent = function(pattern2, evt) {
          return evt.keyCode === pattern2.keyCode && evt.shiftKey === pattern2.shiftKey && evt.altKey === pattern2.altKey && evt.ctrlKey === pattern2.ctrlKey && evt.metaKey === pattern2.metaKey;
        };
        var match$1 = function(patterns, evt) {
          return bind(defaultPatterns(patterns), function(pattern2) {
            return matchesEvent(pattern2, evt) ? [pattern2] : [];
          });
        };
        var action = function(f) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f.apply(null, args);
          };
        };
        var execute = function(patterns, evt) {
          return find(match$1(patterns, evt), function(pattern2) {
            return pattern2.action();
          });
        };
        var MatchKeys = {
          match: match$1,
          action,
          execute
        };
        var executeKeydownOverride = function(editor, caret2, evt) {
          var os = PlatformDetection$1.detect().os;
          MatchKeys.execute([
            {
              keyCode: VK.RIGHT,
              action: moveH(editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: moveH(editor, false)
            },
            {
              keyCode: VK.UP,
              action: moveV(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV(editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: moveH$1(editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: moveH$1(editor, false)
            },
            {
              keyCode: VK.UP,
              action: moveV$1(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV$1(editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: BoundarySelection.move(editor, caret2, true)
            },
            {
              keyCode: VK.LEFT,
              action: BoundarySelection.move(editor, caret2, false)
            },
            {
              keyCode: VK.RIGHT,
              ctrlKey: !os.isOSX(),
              altKey: os.isOSX(),
              action: BoundarySelection.moveNextWord(editor, caret2)
            },
            {
              keyCode: VK.LEFT,
              ctrlKey: !os.isOSX(),
              altKey: os.isOSX(),
              action: BoundarySelection.movePrevWord(editor, caret2)
            },
            {
              keyCode: VK.UP,
              action: moveV$2(editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: moveV$2(editor, true)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$7 = function(editor, caret2) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride(editor, caret2, evt);
            }
          });
        };
        var ArrowKeys = { setup: setup$7 };
        var executeKeydownOverride$1 = function(editor, caret2, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret2, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret2, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(TableDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(TableDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, true)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var executeKeyupOverride = function(editor, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.BACKSPACE,
              action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
            },
            {
              keyCode: VK.DELETE,
              action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
            }
          ], evt);
        };
        var setup$8 = function(editor, caret2) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$1(editor, caret2, evt);
            }
          });
          editor.on("keyup", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeyupOverride(editor, evt);
            }
          });
        };
        var DeleteBackspaceKeys = { setup: setup$8 };
        var firstNonWhiteSpaceNodeSibling = function(node2) {
          while (node2) {
            if (node2.nodeType === 1 || node2.nodeType === 3 && node2.data && /[\r\n\s]/.test(node2.data)) {
              return node2;
            }
            node2 = node2.nextSibling;
          }
        };
        var moveToCaretPosition = function(editor, root2) {
          var walker, node2, rng, lastNode = root2, tempElm;
          var dom2 = editor.dom;
          var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
          if (!root2) {
            return;
          }
          if (/^(LI|DT|DD)$/.test(root2.nodeName)) {
            var firstChild2 = firstNonWhiteSpaceNodeSibling(root2.firstChild);
            if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
              root2.insertBefore(dom2.doc.createTextNode("Â "), root2.firstChild);
            }
          }
          rng = dom2.createRng();
          root2.normalize();
          if (root2.hasChildNodes()) {
            walker = new TreeWalker(root2, root2);
            while (node2 = walker.current()) {
              if (NodeType.isText(node2)) {
                rng.setStart(node2, 0);
                rng.setEnd(node2, 0);
                break;
              }
              if (moveCaretBeforeOnEnterElementsMap[node2.nodeName.toLowerCase()]) {
                rng.setStartBefore(node2);
                rng.setEndBefore(node2);
                break;
              }
              lastNode = node2;
              node2 = walker.next();
            }
            if (!node2) {
              rng.setStart(lastNode, 0);
              rng.setEnd(lastNode, 0);
            }
          } else {
            if (NodeType.isBr(root2)) {
              if (root2.nextSibling && dom2.isBlock(root2.nextSibling)) {
                rng.setStartBefore(root2);
                rng.setEndBefore(root2);
              } else {
                rng.setStartAfter(root2);
                rng.setEndAfter(root2);
              }
            } else {
              rng.setStart(root2, 0);
              rng.setEnd(root2, 0);
            }
          }
          editor.selection.setRng(rng);
          dom2.remove(tempElm);
          editor.selection.scrollIntoView(root2);
        };
        var getEditableRoot = function(dom2, node2) {
          var root2 = dom2.getRoot();
          var parent2, editableRoot;
          parent2 = node2;
          while (parent2 !== root2 && dom2.getContentEditable(parent2) !== "false") {
            if (dom2.getContentEditable(parent2) === "true") {
              editableRoot = parent2;
            }
            parent2 = parent2.parentNode;
          }
          return parent2 !== root2 ? editableRoot : root2;
        };
        var getParentBlock$2 = function(editor) {
          return Option.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
        };
        var getParentBlockName = function(editor) {
          return getParentBlock$2(editor).fold(constant(""), function(parentBlock) {
            return parentBlock.nodeName.toUpperCase();
          });
        };
        var isListItemParentBlock = function(editor) {
          return getParentBlock$2(editor).filter(function(elm) {
            return isListItem(Element2.fromDom(elm));
          }).isSome();
        };
        var NewLineUtils = {
          moveToCaretPosition,
          getEditableRoot,
          getParentBlock: getParentBlock$2,
          getParentBlockName,
          isListItemParentBlock
        };
        var hasFirstChild = function(elm, name2) {
          return elm.firstChild && elm.firstChild.nodeName === name2;
        };
        var hasParent$1 = function(elm, parentName) {
          return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
        };
        var isListBlock = function(elm) {
          return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
        };
        var isNestedList = function(elm) {
          return isListBlock(elm) && isListBlock(elm.parentNode);
        };
        var getContainerBlock = function(containerBlock) {
          var containerBlockParent = containerBlock.parentNode;
          if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
            return containerBlockParent;
          }
          return containerBlock;
        };
        var isFirstOrLastLi = function(containerBlock, parentBlock, first2) {
          var node2 = containerBlock[first2 ? "firstChild" : "lastChild"];
          while (node2) {
            if (NodeType.isElement(node2)) {
              break;
            }
            node2 = node2[first2 ? "nextSibling" : "previousSibling"];
          }
          return node2 === parentBlock;
        };
        var insert$1 = function(editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
          var dom2 = editor.dom;
          var rng = editor.selection.getRng();
          if (containerBlock === editor.getBody()) {
            return;
          }
          if (isNestedList(containerBlock)) {
            newBlockName = "LI";
          }
          var newBlock = newBlockName ? createNewBlock(newBlockName) : dom2.create("BR");
          if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
            if (hasParent$1(containerBlock, "LI")) {
              dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
            } else {
              dom2.replace(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
            if (hasParent$1(containerBlock, "LI")) {
              dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
              newBlock.appendChild(dom2.doc.createTextNode(" "));
              newBlock.appendChild(containerBlock);
            } else {
              containerBlock.parentNode.insertBefore(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
            dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
          } else {
            containerBlock = getContainerBlock(containerBlock);
            var tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            var fragment = tmpRng.extractContents();
            if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
              newBlock = fragment.firstChild;
              dom2.insertAfter(fragment, containerBlock);
            } else {
              dom2.insertAfter(fragment, containerBlock);
              dom2.insertAfter(newBlock, containerBlock);
            }
          }
          dom2.remove(parentBlock);
          NewLineUtils.moveToCaretPosition(editor, newBlock);
        };
        var InsertLi = { insert: insert$1 };
        var trimZwsp = function(fragment) {
          each(descendants(Element2.fromDom(fragment), isText), function(text2) {
            var rawNode = text2.dom();
            rawNode.nodeValue = Zwsp.trim(rawNode.nodeValue);
          });
        };
        var isEmptyAnchor = function(dom2, elm) {
          return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
        };
        var isTableCell$5 = function(node2) {
          return node2 && /^(TD|TH|CAPTION)$/.test(node2.nodeName);
        };
        var emptyBlock = function(elm) {
          elm.innerHTML = '<br data-mce-bogus="1">';
        };
        var containerAndSiblingName = function(container, nodeName) {
          return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
        };
        var canSplitBlock = function(dom2, node2) {
          return node2 && dom2.isBlock(node2) && !/^(TD|TH|CAPTION|FORM)$/.test(node2.nodeName) && !/^(fixed|absolute)/i.test(node2.style.position) && dom2.getContentEditable(node2) !== "true";
        };
        var trimInlineElementsOnLeftSideOfBlock = function(dom2, nonEmptyElementsMap, block2) {
          var node2 = block2;
          var firstChilds = [];
          var i2;
          if (!node2) {
            return;
          }
          while (node2 = node2.firstChild) {
            if (dom2.isBlock(node2)) {
              return;
            }
            if (NodeType.isElement(node2) && !nonEmptyElementsMap[node2.nodeName.toLowerCase()]) {
              firstChilds.push(node2);
            }
          }
          i2 = firstChilds.length;
          while (i2--) {
            node2 = firstChilds[i2];
            if (!node2.hasChildNodes() || node2.firstChild === node2.lastChild && node2.firstChild.nodeValue === "") {
              dom2.remove(node2);
            } else {
              if (isEmptyAnchor(dom2, node2)) {
                dom2.remove(node2);
              }
            }
          }
        };
        var normalizeZwspOffset = function(start2, container, offset) {
          if (NodeType.isText(container) === false) {
            return offset;
          } else if (start2) {
            return offset === 1 && container.data.charAt(offset - 1) === Zwsp.ZWSP ? 0 : offset;
          } else {
            return offset === container.data.length - 1 && container.data.charAt(offset) === Zwsp.ZWSP ? container.data.length : offset;
          }
        };
        var includeZwspInRange = function(rng) {
          var newRng = rng.cloneRange();
          newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
          newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
          return newRng;
        };
        var trimLeadingLineBreaks = function(node2) {
          do {
            if (NodeType.isText(node2)) {
              node2.nodeValue = node2.nodeValue.replace(/^[\r\n]+/, "");
            }
            node2 = node2.firstChild;
          } while (node2);
        };
        var getEditableRoot$1 = function(dom2, node2) {
          var root2 = dom2.getRoot();
          var parent2, editableRoot;
          parent2 = node2;
          while (parent2 !== root2 && dom2.getContentEditable(parent2) !== "false") {
            if (dom2.getContentEditable(parent2) === "true") {
              editableRoot = parent2;
            }
            parent2 = parent2.parentNode;
          }
          return parent2 !== root2 ? editableRoot : root2;
        };
        var applyAttributes = function(editor, node2, forcedRootBlockAttrs) {
          Option.from(forcedRootBlockAttrs.style).map(editor.dom.parseStyle).each(function(attrStyles) {
            var currentStyles = getAllRaw(Element2.fromDom(node2));
            var newStyles = __assign(__assign({}, currentStyles), attrStyles);
            editor.dom.setStyles(node2, newStyles);
          });
          var attrClassesOpt = Option.from(forcedRootBlockAttrs.class).map(function(attrClasses) {
            return attrClasses.split(/\s+/);
          });
          var currentClassesOpt = Option.from(node2.className).map(function(currentClasses) {
            return filter(currentClasses.split(/\s+/), function(clazz) {
              return clazz !== "";
            });
          });
          lift2(attrClassesOpt, currentClassesOpt, function(attrClasses, currentClasses) {
            var filteredClasses = filter(currentClasses, function(clazz) {
              return !contains(attrClasses, clazz);
            });
            var newClasses = __spreadArrays(attrClasses, filteredClasses);
            editor.dom.setAttrib(node2, "class", newClasses.join(" "));
          });
          var appliedAttrs = [
            "style",
            "class"
          ];
          var remainingAttrs = bifilter(forcedRootBlockAttrs, function(_, attrs) {
            return !contains(appliedAttrs, attrs);
          }).t;
          editor.dom.setAttribs(node2, remainingAttrs);
        };
        var setForcedBlockAttrs = function(editor, node2) {
          var forcedRootBlockName = Settings.getForcedRootBlock(editor);
          if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node2.tagName.toLowerCase()) {
            var forcedRootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
            applyAttributes(editor, node2, forcedRootBlockAttrs);
          }
        };
        var wrapSelfAndSiblingsInDefaultBlock = function(editor, newBlockName, rng, container, offset) {
          var newBlock, parentBlock, startNode, node2, next2, rootBlockName;
          var blockName = newBlockName || "P";
          var dom2 = editor.dom, editableRoot = getEditableRoot$1(dom2, container);
          parentBlock = dom2.getParent(container, dom2.isBlock);
          if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
            parentBlock = parentBlock || editableRoot;
            if (parentBlock === editor.getBody() || isTableCell$5(parentBlock)) {
              rootBlockName = parentBlock.nodeName.toLowerCase();
            } else {
              rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
            }
            if (!parentBlock.hasChildNodes()) {
              newBlock = dom2.create(blockName);
              setForcedBlockAttrs(editor, newBlock);
              parentBlock.appendChild(newBlock);
              rng.setStart(newBlock, 0);
              rng.setEnd(newBlock, 0);
              return newBlock;
            }
            node2 = container;
            while (node2.parentNode !== parentBlock) {
              node2 = node2.parentNode;
            }
            while (node2 && !dom2.isBlock(node2)) {
              startNode = node2;
              node2 = node2.previousSibling;
            }
            if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
              newBlock = dom2.create(blockName);
              setForcedBlockAttrs(editor, newBlock);
              startNode.parentNode.insertBefore(newBlock, startNode);
              node2 = startNode;
              while (node2 && !dom2.isBlock(node2)) {
                next2 = node2.nextSibling;
                newBlock.appendChild(node2);
                node2 = next2;
              }
              rng.setStart(container, offset);
              rng.setEnd(container, offset);
            }
          }
          return container;
        };
        var addBrToBlockIfNeeded = function(dom2, block2) {
          var lastChild2;
          block2.normalize();
          lastChild2 = block2.lastChild;
          if (!lastChild2 || /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
            dom2.add(block2, "br");
          }
        };
        var insert$2 = function(editor, evt) {
          var tmpRng, editableRoot, container, offset, parentBlock, shiftKey;
          var newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
          var dom2 = editor.dom;
          var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
          var rng = editor.selection.getRng();
          var createNewBlock = function(name2) {
            var node2 = container, block2, clonedNode, caretNode;
            var textInlineElements = schema.getTextInlineElements();
            if (name2 || parentBlockName === "TABLE" || parentBlockName === "HR") {
              block2 = dom2.create(name2 || newBlockName);
            } else {
              block2 = parentBlock.cloneNode(false);
            }
            caretNode = block2;
            if (Settings.shouldKeepStyles(editor) === false) {
              dom2.setAttrib(block2, "style", null);
              dom2.setAttrib(block2, "class", null);
            } else {
              do {
                if (textInlineElements[node2.nodeName]) {
                  if (isCaretNode(node2) || Bookmarks.isBookmarkNode(node2)) {
                    continue;
                  }
                  clonedNode = node2.cloneNode(false);
                  dom2.setAttrib(clonedNode, "id", "");
                  if (block2.hasChildNodes()) {
                    clonedNode.appendChild(block2.firstChild);
                    block2.appendChild(clonedNode);
                  } else {
                    caretNode = clonedNode;
                    block2.appendChild(clonedNode);
                  }
                }
              } while ((node2 = node2.parentNode) && node2 !== editableRoot);
            }
            setForcedBlockAttrs(editor, block2);
            emptyBlock(caretNode);
            return block2;
          };
          var isCaretAtStartOrEndOfBlock = function(start2) {
            var walker, node2, name2, normalizedOffset;
            normalizedOffset = normalizeZwspOffset(start2, container, offset);
            if (NodeType.isText(container) && (start2 ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
              return false;
            }
            if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start2) {
              return true;
            }
            if (start2 && NodeType.isElement(container) && container === parentBlock.firstChild) {
              return true;
            }
            if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
              return isAfterLastNodeInContainer && !start2 || !isAfterLastNodeInContainer && start2;
            }
            walker = new TreeWalker(container, parentBlock);
            if (NodeType.isText(container)) {
              if (start2 && normalizedOffset === 0) {
                walker.prev();
              } else if (!start2 && normalizedOffset === container.nodeValue.length) {
                walker.next();
              }
            }
            while (node2 = walker.current()) {
              if (NodeType.isElement(node2)) {
                if (!node2.getAttribute("data-mce-bogus")) {
                  name2 = node2.nodeName.toLowerCase();
                  if (nonEmptyElementsMap[name2] && name2 !== "br") {
                    return false;
                  }
                }
              } else if (NodeType.isText(node2) && !/^[ \t\r\n]*$/.test(node2.nodeValue)) {
                return false;
              }
              if (start2) {
                walker.prev();
              } else {
                walker.next();
              }
            }
            return true;
          };
          var insertNewBlockAfter = function() {
            if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
              newBlock = createNewBlock(newBlockName);
            } else {
              newBlock = createNewBlock();
            }
            if (Settings.shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock)) {
              newBlock = dom2.split(containerBlock, parentBlock);
            } else {
              dom2.insertAfter(newBlock, parentBlock);
            }
            NewLineUtils.moveToCaretPosition(editor, newBlock);
          };
          NormalizeRange.normalize(dom2, rng).each(function(normRng) {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          container = rng.startContainer;
          offset = rng.startOffset;
          newBlockName = Settings.getForcedRootBlock(editor);
          shiftKey = evt.shiftKey;
          if (NodeType.isElement(container) && container.hasChildNodes()) {
            isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && NodeType.isText(container)) {
              offset = container.nodeValue.length;
            } else {
              offset = 0;
            }
          }
          editableRoot = getEditableRoot$1(dom2, container);
          if (!editableRoot) {
            return;
          }
          if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
            container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
          }
          parentBlock = dom2.getParent(container, dom2.isBlock);
          containerBlock = parentBlock ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
          containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          if (containerBlockName === "LI" && !evt.ctrlKey) {
            parentBlock = containerBlock;
            containerBlock = containerBlock.parentNode;
            parentBlockName = containerBlockName;
          }
          if (/^(LI|DT|DD)$/.test(parentBlockName)) {
            if (dom2.isEmpty(parentBlock)) {
              InsertLi.insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
              return;
            }
          }
          if (newBlockName && parentBlock === editor.getBody()) {
            return;
          }
          newBlockName = newBlockName || "P";
          if (isCaretContainerBlock(parentBlock)) {
            newBlock = showCaretContainerBlock(parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            setForcedBlockAttrs(editor, newBlock);
            NewLineUtils.moveToCaretPosition(editor, newBlock);
          } else if (isCaretAtStartOrEndOfBlock()) {
            insertNewBlockAfter();
          } else if (isCaretAtStartOrEndOfBlock(true)) {
            newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
            NewLineUtils.moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") ? newBlock : parentBlock);
          } else {
            tmpRng = includeZwspInRange(rng).cloneRange();
            tmpRng.setEndAfter(parentBlock);
            fragment = tmpRng.extractContents();
            trimZwsp(fragment);
            trimLeadingLineBreaks(fragment);
            newBlock = fragment.firstChild;
            dom2.insertAfter(fragment, parentBlock);
            trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
            addBrToBlockIfNeeded(dom2, parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            newBlock.normalize();
            if (dom2.isEmpty(newBlock)) {
              dom2.remove(newBlock);
              insertNewBlockAfter();
            } else {
              setForcedBlockAttrs(editor, newBlock);
              NewLineUtils.moveToCaretPosition(editor, newBlock);
            }
          }
          dom2.setAttrib(newBlock, "id", "");
          editor.fire("NewBlock", { newBlock });
        };
        var InsertBlock = { insert: insert$2 };
        var matchesSelector = function(editor, selector) {
          return NewLineUtils.getParentBlock(editor).filter(function(parentBlock) {
            return selector.length > 0 && is$1(Element2.fromDom(parentBlock), selector);
          }).isSome();
        };
        var shouldInsertBr = function(editor) {
          return matchesSelector(editor, Settings.getBrNewLineSelector(editor));
        };
        var shouldBlockNewLine = function(editor) {
          return matchesSelector(editor, Settings.getNoNewLineSelector(editor));
        };
        var ContextSelectors = {
          shouldInsertBr,
          shouldBlockNewLine
        };
        var newLineAction = Adt.generate([
          { br: [] },
          { block: [] },
          { none: [] }
        ]);
        var shouldBlockNewLine$1 = function(editor, shiftKey) {
          return ContextSelectors.shouldBlockNewLine(editor);
        };
        var isBrMode = function(requiredState) {
          return function(editor, shiftKey) {
            var brMode = Settings.getForcedRootBlock(editor) === "";
            return brMode === requiredState;
          };
        };
        var inListBlock = function(requiredState) {
          return function(editor, shiftKey) {
            return NewLineUtils.isListItemParentBlock(editor) === requiredState;
          };
        };
        var inBlock = function(blockName, requiredState) {
          return function(editor, shiftKey) {
            var state = NewLineUtils.getParentBlockName(editor) === blockName.toUpperCase();
            return state === requiredState;
          };
        };
        var inPreBlock = function(requiredState) {
          return inBlock("pre", requiredState);
        };
        var inSummaryBlock = function() {
          return inBlock("summary", true);
        };
        var shouldPutBrInPre$1 = function(requiredState) {
          return function(editor, shiftKey) {
            return Settings.shouldPutBrInPre(editor) === requiredState;
          };
        };
        var inBrContext = function(editor, shiftKey) {
          return ContextSelectors.shouldInsertBr(editor);
        };
        var hasShiftKey = function(editor, shiftKey) {
          return shiftKey;
        };
        var canInsertIntoEditableRoot = function(editor) {
          var forcedRootBlock = Settings.getForcedRootBlock(editor);
          var rootEditable = NewLineUtils.getEditableRoot(editor.dom, editor.selection.getStart());
          return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : "P");
        };
        var match$2 = function(predicates, action2) {
          return function(editor, shiftKey) {
            var isMatch = foldl(predicates, function(res, p) {
              return res && p(editor, shiftKey);
            }, true);
            return isMatch ? Option.some(action2) : Option.none();
          };
        };
        var getAction$1 = function(editor, evt) {
          return LazyEvaluator.evaluateUntil([
            match$2([shouldBlockNewLine$1], newLineAction.none()),
            match$2([inSummaryBlock()], newLineAction.br()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(false),
              hasShiftKey
            ], newLineAction.br()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(false)
            ], newLineAction.block()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(true),
              hasShiftKey
            ], newLineAction.block()),
            match$2([
              inPreBlock(true),
              shouldPutBrInPre$1(true)
            ], newLineAction.br()),
            match$2([
              inListBlock(true),
              hasShiftKey
            ], newLineAction.br()),
            match$2([inListBlock(true)], newLineAction.block()),
            match$2([
              isBrMode(true),
              hasShiftKey,
              canInsertIntoEditableRoot
            ], newLineAction.block()),
            match$2([isBrMode(true)], newLineAction.br()),
            match$2([inBrContext], newLineAction.br()),
            match$2([
              isBrMode(false),
              hasShiftKey
            ], newLineAction.br()),
            match$2([canInsertIntoEditableRoot], newLineAction.block())
          ], [
            editor,
            evt.shiftKey
          ]).getOr(newLineAction.none());
        };
        var NewLineAction = { getAction: getAction$1 };
        var insert$3 = function(editor, evt) {
          NewLineAction.getAction(editor, evt).fold(function() {
            InsertBr.insert(editor, evt);
          }, function() {
            InsertBlock.insert(editor, evt);
          }, noop);
        };
        var InsertNewLine = { insert: insert$3 };
        var endTypingLevel = function(undoManager) {
          if (undoManager.typing) {
            undoManager.typing = false;
            undoManager.add();
          }
        };
        var handleEnterKeyEvent = function(editor, event) {
          if (event.isDefaultPrevented()) {
            return;
          }
          event.preventDefault();
          endTypingLevel(editor.undoManager);
          editor.undoManager.transact(function() {
            if (editor.selection.isCollapsed() === false) {
              editor.execCommand("Delete");
            }
            InsertNewLine.insert(editor, event);
          });
        };
        var setup$9 = function(editor) {
          editor.on("keydown", function(event) {
            if (event.keyCode === VK.ENTER) {
              handleEnterKeyEvent(editor, event);
            }
          });
        };
        var EnterKey = { setup: setup$9 };
        var insertTextAtPosition = function(text2, pos) {
          var container = pos.container();
          var offset = pos.offset();
          if (NodeType.isText(container)) {
            container.insertData(offset, text2);
            return Option.some(CaretPosition(container, offset + text2.length));
          } else {
            return getElementFromPosition(pos).map(function(elm) {
              var textNode = Element2.fromText(text2);
              if (pos.isAtEnd()) {
                after(elm, textNode);
              } else {
                before(elm, textNode);
              }
              return CaretPosition(textNode.dom(), text2.length);
            });
          }
        };
        var insertNbspAtPosition = curry(insertTextAtPosition, "Â ");
        var insertSpaceAtPosition = curry(insertTextAtPosition, " ");
        var navigateIgnoreEmptyTextNodes = function(forward, root2, from2) {
          return CaretFinder.navigateIgnore(forward, root2, from2, isEmptyText);
        };
        var getClosestBlock = function(root2, pos) {
          return find(Parents.parentsAndSelf(Element2.fromDom(pos.container()), root2), isBlock2);
        };
        var isAtBeforeAfterBlockBoundary = function(forward, root2, pos) {
          return navigateIgnoreEmptyTextNodes(forward, root2.dom(), pos).forall(function(newPos) {
            return getClosestBlock(root2, pos).fold(function() {
              return isInSameBlock(newPos, pos, root2.dom()) === false;
            }, function(fromBlock) {
              return isInSameBlock(newPos, pos, root2.dom()) === false && contains$3(fromBlock, Element2.fromDom(newPos.container()));
            });
          });
        };
        var isAtBlockBoundary = function(forward, root2, pos) {
          return getClosestBlock(root2, pos).fold(function() {
            return navigateIgnoreEmptyTextNodes(forward, root2.dom(), pos).forall(function(newPos) {
              return isInSameBlock(newPos, pos, root2.dom()) === false;
            });
          }, function(parent2) {
            return navigateIgnoreEmptyTextNodes(forward, parent2.dom(), pos).isNone();
          });
        };
        var isAtStartOfBlock = curry(isAtBlockBoundary, false);
        var isAtEndOfBlock = curry(isAtBlockBoundary, true);
        var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
        var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
        var nbsp2 = "Â ";
        var isInMiddleOfText = function(pos) {
          return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
        };
        var getClosestBlock$1 = function(root2, pos) {
          var parentBlocks = filter(Parents.parentsAndSelf(Element2.fromDom(pos.container()), root2), isBlock2);
          return head(parentBlocks).getOr(root2);
        };
        var hasSpaceBefore = function(root2, pos) {
          if (isInMiddleOfText(pos)) {
            return isAfterSpace(pos);
          } else {
            return isAfterSpace(pos) || CaretFinder.prevPosition(getClosestBlock$1(root2, pos).dom(), pos).exists(isAfterSpace);
          }
        };
        var hasSpaceAfter = function(root2, pos) {
          if (isInMiddleOfText(pos)) {
            return isBeforeSpace(pos);
          } else {
            return isBeforeSpace(pos) || CaretFinder.nextPosition(getClosestBlock$1(root2, pos).dom(), pos).exists(isBeforeSpace);
          }
        };
        var isPreValue = function(value2) {
          return contains([
            "pre",
            "pre-wrap"
          ], value2);
        };
        var isInPre = function(pos) {
          return getElementFromPosition(pos).bind(function(elm) {
            return closest(elm, isElement);
          }).exists(function(elm) {
            return isPreValue(get$1(elm, "white-space"));
          });
        };
        var isAtBeginningOfBody = function(root2, pos) {
          return CaretFinder.prevPosition(root2.dom(), pos).isNone();
        };
        var isAtEndOfBody = function(root2, pos) {
          return CaretFinder.nextPosition(root2.dom(), pos).isNone();
        };
        var isAtLineBoundary = function(root2, pos) {
          return isAtBeginningOfBody(root2, pos) || isAtEndOfBody(root2, pos) || isAtStartOfBlock(root2, pos) || isAtEndOfBlock(root2, pos) || isAfterBr(root2, pos) || isBeforeBr(root2, pos);
        };
        var needsToHaveNbsp = function(root2, pos) {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtLineBoundary(root2, pos) || hasSpaceBefore(root2, pos) || hasSpaceAfter(root2, pos);
          }
        };
        var needsToBeNbspLeft = function(root2, pos) {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtStartOfBlock(root2, pos) || isBeforeBlock(root2, pos) || isAfterBr(root2, pos) || hasSpaceBefore(root2, pos);
          }
        };
        var leanRight = function(pos) {
          var container = pos.container();
          var offset = pos.offset();
          if (NodeType.isText(container) && offset < container.data.length) {
            return CaretPosition(container, offset + 1);
          } else {
            return pos;
          }
        };
        var needsToBeNbspRight = function(root2, pos) {
          var afterPos = leanRight(pos);
          if (isInPre(afterPos)) {
            return false;
          } else {
            return isAtEndOfBlock(root2, afterPos) || isAfterBlock(root2, afterPos) || isBeforeBr(root2, afterPos) || hasSpaceAfter(root2, afterPos);
          }
        };
        var needsToBeNbsp = function(root2, pos) {
          return needsToBeNbspLeft(root2, pos) || needsToBeNbspRight(root2, pos);
        };
        var isNbspAt = function(text2, offset) {
          return isNbsp(text2.charAt(offset));
        };
        var hasNbsp = function(pos) {
          var container = pos.container();
          return NodeType.isText(container) && contains$2(container.data, nbsp2);
        };
        var normalizeNbspMiddle = function(text2) {
          var chars = text2.split("");
          return map2(chars, function(chr, i2) {
            if (isNbsp(chr) && i2 > 0 && i2 < chars.length - 1 && isContent$1(chars[i2 - 1]) && isContent$1(chars[i2 + 1])) {
              return " ";
            } else {
              return chr;
            }
          }).join("");
        };
        var normalizeNbspAtStart = function(root2, node2) {
          var text2 = node2.data;
          var firstPos = CaretPosition(node2, 0);
          if (isNbspAt(text2, 0) && !needsToBeNbsp(root2, firstPos)) {
            node2.data = " " + text2.slice(1);
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbspInMiddleOfTextNode = function(node2) {
          var text2 = node2.data;
          var newText = normalizeNbspMiddle(text2);
          if (newText !== text2) {
            node2.data = newText;
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbspAtEnd = function(root2, node2) {
          var text2 = node2.data;
          var lastPos = CaretPosition(node2, text2.length - 1);
          if (isNbspAt(text2, text2.length - 1) && !needsToBeNbsp(root2, lastPos)) {
            node2.data = text2.slice(0, -1) + " ";
            return true;
          } else {
            return false;
          }
        };
        var normalizeNbsps = function(root2, pos) {
          return Option.some(pos).filter(hasNbsp).bind(function(pos2) {
            var container = pos2.container();
            var normalized = normalizeNbspAtStart(root2, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root2, container);
            return normalized ? Option.some(pos2) : Option.none();
          });
        };
        var normalizeNbspsInEditor = function(editor) {
          var root2 = Element2.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            normalizeNbsps(root2, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function(pos) {
              editor.selection.setRng(pos.toRange());
            });
          }
        };
        var locationToCaretPosition = function(root2) {
          return function(location) {
            return location.fold(function(element) {
              return CaretFinder.prevPosition(root2.dom(), CaretPosition$1.before(element));
            }, function(element) {
              return CaretFinder.firstPositionIn(element);
            }, function(element) {
              return CaretFinder.lastPositionIn(element);
            }, function(element) {
              return CaretFinder.nextPosition(root2.dom(), CaretPosition$1.after(element));
            });
          };
        };
        var insertInlineBoundarySpaceOrNbsp = function(root2, pos) {
          return function(checkPos) {
            return needsToHaveNbsp(root2, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
          };
        };
        var setSelection$1 = function(editor) {
          return function(pos) {
            editor.selection.setRng(pos.toRange());
            editor.nodeChanged();
            return true;
          };
        };
        var insertSpaceOrNbspAtSelection = function(editor) {
          var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
          var root2 = Element2.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            var isInlineTarget2 = curry(InlineUtils.isInlineTarget, editor);
            var caretPosition = CaretPosition$1.fromRangeStart(editor.selection.getRng());
            return BoundaryLocation.readLocation(isInlineTarget2, editor.getBody(), caretPosition).bind(locationToCaretPosition(root2)).bind(insertInlineBoundarySpaceOrNbsp(root2, pos)).exists(setSelection$1(editor));
          } else {
            return false;
          }
        };
        var executeKeydownOverride$2 = function(editor, evt) {
          MatchKeys.execute([{
            keyCode: VK.SPACEBAR,
            action: MatchKeys.action(insertSpaceOrNbspAtSelection, editor)
          }], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$a = function(editor) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$2(editor, evt);
            }
          });
        };
        var SpaceKey = { setup: setup$a };
        var findBlockCaretContainer = function(editor) {
          return descendant(Element2.fromDom(editor.getBody()), "*[data-mce-caret]").fold(constant(null), function(elm) {
            return elm.dom();
          });
        };
        var removeIeControlRect = function(editor) {
          editor.selection.setRng(editor.selection.getRng());
        };
        var showBlockCaretContainer = function(editor, blockCaretContainer) {
          if (blockCaretContainer.hasAttribute("data-mce-caret")) {
            showCaretContainerBlock(blockCaretContainer);
            removeIeControlRect(editor);
            editor.selection.scrollIntoView(blockCaretContainer);
          }
        };
        var handleBlockContainer = function(editor, e) {
          var blockCaretContainer = findBlockCaretContainer(editor);
          if (!blockCaretContainer) {
            return;
          }
          if (e.type === "compositionstart") {
            e.preventDefault();
            e.stopPropagation();
            showBlockCaretContainer(editor, blockCaretContainer);
            return;
          }
          if (hasContent(blockCaretContainer)) {
            showBlockCaretContainer(editor, blockCaretContainer);
            editor.undoManager.add();
          }
        };
        var setup$b = function(editor) {
          editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
        };
        var CaretContainerInput = { setup: setup$b };
        var browser$4 = PlatformDetection$1.detect().browser;
        var setupIeInput = function(editor) {
          var keypressThrotter = first(function() {
            if (!editor.composing) {
              normalizeNbspsInEditor(editor);
            }
          }, 0);
          if (browser$4.isIE()) {
            editor.on("keypress", function(e) {
              keypressThrotter.throttle();
            });
            editor.on("remove", function(e) {
              keypressThrotter.cancel();
            });
          }
        };
        var setup$c = function(editor) {
          setupIeInput(editor);
          editor.on("input", function(e) {
            if (e.isComposing === false) {
              normalizeNbspsInEditor(editor);
            }
          });
        };
        var executeKeydownOverride$3 = function(editor, evt) {
          MatchKeys.execute([
            {
              keyCode: VK.END,
              action: moveToLineEndPoint(editor, true)
            },
            {
              keyCode: VK.HOME,
              action: moveToLineEndPoint(editor, false)
            }
          ], evt).each(function(_) {
            evt.preventDefault();
          });
        };
        var setup$d = function(editor) {
          editor.on("keydown", function(evt) {
            if (evt.isDefaultPrevented() === false) {
              executeKeydownOverride$3(editor, evt);
            }
          });
        };
        var HomeEndKeys = { setup: setup$d };
        var setup$e = function(editor) {
          var caret2 = BoundarySelection.setupSelectedState(editor);
          CaretContainerInput.setup(editor);
          ArrowKeys.setup(editor, caret2);
          DeleteBackspaceKeys.setup(editor, caret2);
          EnterKey.setup(editor);
          SpaceKey.setup(editor);
          setup$c(editor);
          HomeEndKeys.setup(editor);
        };
        var KeyboardOverrides = { setup: setup$e };
        function Quirks(editor) {
          var each2 = Tools.each;
          var BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, settings = editor.settings, parser = editor.parser;
          var isGecko = Env.gecko, isIE2 = Env.ie, isWebKit = Env.webkit;
          var mceInternalUrlPrefix = "data:text/mce-internal,";
          var mceInternalDataType = isIE2 ? "Text" : "URL";
          var setEditorCommandState2 = function(cmd, state) {
            try {
              editor.getDoc().execCommand(cmd, false, state);
            } catch (ex) {
            }
          };
          var isDefaultPrevented = function(e) {
            return e.isDefaultPrevented();
          };
          var setMceInternalContent = function(e) {
            var selectionHtml, internalContent;
            if (e.dataTransfer) {
              if (editor.selection.isCollapsed() && e.target.tagName === "IMG") {
                selection.select(e.target);
              }
              selectionHtml = editor.selection.getContent();
              if (selectionHtml.length > 0) {
                internalContent = mceInternalUrlPrefix + escape(editor.id) + "," + escape(selectionHtml);
                e.dataTransfer.setData(mceInternalDataType, internalContent);
              }
            }
          };
          var getMceInternalContent = function(e) {
            var internalContent;
            if (e.dataTransfer) {
              internalContent = e.dataTransfer.getData(mceInternalDataType);
              if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
                internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(",");
                return {
                  id: unescape(internalContent[0]),
                  html: unescape(internalContent[1])
                };
              }
            }
            return null;
          };
          var insertClipboardContents = function(content, internal) {
            if (editor.queryCommandSupported("mceInsertClipboardContent")) {
              editor.execCommand("mceInsertClipboardContent", false, {
                content,
                internal
              });
            } else {
              editor.execCommand("mceInsertContent", false, content);
            }
          };
          var emptyEditorWhenDeleting = function() {
            var serializeRng = function(rng) {
              var body = dom2.create("body");
              var contents = rng.cloneContents();
              body.appendChild(contents);
              return selection.serializer.serialize(body, { format: "html" });
            };
            var allContentsSelected = function(rng) {
              var selection2 = serializeRng(rng);
              var allRng = dom2.createRng();
              allRng.selectNode(editor.getBody());
              var allSelection = serializeRng(allRng);
              return selection2 === allSelection;
            };
            editor.on("keydown", function(e) {
              var keyCode = e.keyCode;
              var isCollapsed, body;
              if (!isDefaultPrevented(e) && (keyCode === DELETE2 || keyCode === BACKSPACE)) {
                isCollapsed = editor.selection.isCollapsed();
                body = editor.getBody();
                if (isCollapsed && !dom2.isEmpty(body)) {
                  return;
                }
                if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
                  return;
                }
                e.preventDefault();
                editor.setContent("");
                if (body.firstChild && dom2.isBlock(body.firstChild)) {
                  editor.selection.setCursorLocation(body.firstChild, 0);
                } else {
                  editor.selection.setCursorLocation(body, 0);
                }
                editor.nodeChanged();
              }
            });
          };
          var selectAll = function() {
            editor.shortcuts.add("meta+a", null, "SelectAll");
          };
          var inputMethodFocus = function() {
            if (!editor.settings.content_editable) {
              dom2.bind(editor.getDoc(), "mousedown mouseup", function(e) {
                var rng;
                if (e.target === editor.getDoc().documentElement) {
                  rng = selection.getRng();
                  editor.getBody().focus();
                  if (e.type === "mousedown") {
                    if (isCaretContainer(rng.startContainer)) {
                      return;
                    }
                    selection.placeCaretAt(e.clientX, e.clientY);
                  } else {
                    selection.setRng(rng);
                  }
                }
              });
            }
          };
          var removeHrOnBackspace = function() {
            editor.on("keydown", function(e) {
              if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                if (!editor.getBody().getElementsByTagName("hr").length) {
                  return;
                }
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  var node2 = selection.getNode();
                  var previousSibling = node2.previousSibling;
                  if (node2.nodeName === "HR") {
                    dom2.remove(node2);
                    e.preventDefault();
                    return;
                  }
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
                    dom2.remove(previousSibling);
                    e.preventDefault();
                  }
                }
              }
            });
          };
          var focusBody2 = function() {
            if (!domGlobals.Range.prototype.getClientRects) {
              editor.on("mousedown", function(e) {
                if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
                  var body_1 = editor.getBody();
                  body_1.blur();
                  Delay.setEditorTimeout(editor, function() {
                    body_1.focus();
                  });
                }
              });
            }
          };
          var selectControlElements = function() {
            editor.on("click", function(e) {
              var target2 = e.target;
              if (/^(IMG|HR)$/.test(target2.nodeName) && dom2.getContentEditableParent(target2) !== "false") {
                e.preventDefault();
                editor.selection.select(target2);
                editor.nodeChanged();
              }
              if (target2.nodeName === "A" && dom2.hasClass(target2, "mce-item-anchor")) {
                e.preventDefault();
                selection.select(target2);
              }
            });
          };
          var removeStylesWhenDeletingAcrossBlockElements = function() {
            var getAttributeApplyFunction = function() {
              var template = dom2.getAttribs(selection.getStart().cloneNode(false));
              return function() {
                var target2 = selection.getStart();
                if (target2 !== editor.getBody()) {
                  dom2.setAttrib(target2, "style", null);
                  each2(template, function(attr) {
                    target2.setAttributeNode(attr.cloneNode(true));
                  });
                }
              };
            };
            var isSelectionAcrossElements = function() {
              return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
            };
            editor.on("keypress", function(e) {
              var applyAttributes2;
              if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
                applyAttributes2 = getAttributeApplyFunction();
                editor.getDoc().execCommand("delete", false, null);
                applyAttributes2();
                e.preventDefault();
                return false;
              }
            });
            dom2.bind(editor.getDoc(), "cut", function(e) {
              var applyAttributes2;
              if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
                applyAttributes2 = getAttributeApplyFunction();
                Delay.setEditorTimeout(editor, function() {
                  applyAttributes2();
                });
              }
            });
          };
          var disableBackspaceIntoATable = function() {
            editor.on("keydown", function(e) {
              if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  var previousSibling = selection.getNode().previousSibling;
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
                    e.preventDefault();
                    return false;
                  }
                }
              }
            });
          };
          var removeBlockQuoteOnBackSpace = function() {
            editor.on("keydown", function(e) {
              var rng, container, offset, root2, parent2;
              if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
                return;
              }
              rng = selection.getRng();
              container = rng.startContainer;
              offset = rng.startOffset;
              root2 = dom2.getRoot();
              parent2 = container;
              if (!rng.collapsed || offset !== 0) {
                return;
              }
              while (parent2 && parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root2) {
                parent2 = parent2.parentNode;
              }
              if (parent2.tagName === "BLOCKQUOTE") {
                editor.formatter.toggle("blockquote", null, parent2);
                rng = dom2.createRng();
                rng.setStart(container, 0);
                rng.setEnd(container, 0);
                selection.setRng(rng);
              }
            });
          };
          var setGeckoEditingOptions = function() {
            var setOpts = function() {
              setEditorCommandState2("StyleWithCSS", false);
              setEditorCommandState2("enableInlineTableEditing", false);
              if (!settings.object_resizing) {
                setEditorCommandState2("enableObjectResizing", false);
              }
            };
            if (!settings.readonly) {
              editor.on("BeforeExecCommand MouseDown", setOpts);
            }
          };
          var addBrAfterLastLinks = function() {
            var fixLinks = function() {
              each2(dom2.select("a"), function(node2) {
                var parentNode = node2.parentNode;
                var root2 = dom2.getRoot();
                if (parentNode.lastChild === node2) {
                  while (parentNode && !dom2.isBlock(parentNode)) {
                    if (parentNode.parentNode.lastChild !== parentNode || parentNode === root2) {
                      return;
                    }
                    parentNode = parentNode.parentNode;
                  }
                  dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
                }
              });
            };
            editor.on("SetContent ExecCommand", function(e) {
              if (e.type === "setcontent" || e.command === "mceInsertLink") {
                fixLinks();
              }
            });
          };
          var setDefaultBlockType = function() {
            if (settings.forced_root_block) {
              editor.on("init", function() {
                setEditorCommandState2("DefaultParagraphSeparator", settings.forced_root_block);
              });
            }
          };
          var normalizeSelection2 = function() {
            editor.on("keyup focusin mouseup", function(e) {
              if (!VK.modifierPressed(e)) {
                selection.normalize();
              }
            }, true);
          };
          var showBrokenImageIcon = function() {
            editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
          };
          var restoreFocusOnKeyDown = function() {
            if (!editor.inline) {
              editor.on("keydown", function() {
                if (domGlobals.document.activeElement === domGlobals.document.body) {
                  editor.getWin().focus();
                }
              });
            }
          };
          var bodyHeight = function() {
            if (!editor.inline) {
              editor.contentStyles.push("body {min-height: 150px}");
              editor.on("click", function(e) {
                var rng;
                if (e.target.nodeName === "HTML") {
                  if (Env.ie > 11) {
                    editor.getBody().focus();
                    return;
                  }
                  rng = editor.selection.getRng();
                  editor.getBody().focus();
                  editor.selection.setRng(rng);
                  editor.selection.normalize();
                  editor.nodeChanged();
                }
              });
            }
          };
          var blockCmdArrowNavigation = function() {
            if (Env.mac) {
              editor.on("keydown", function(e) {
                if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
                  e.preventDefault();
                  editor.selection.getSel().modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
                }
              });
            }
          };
          var disableAutoUrlDetect = function() {
            setEditorCommandState2("AutoUrlDetect", false);
          };
          var tapLinksAndImages = function() {
            editor.on("click", function(e) {
              var elm = e.target;
              do {
                if (elm.tagName === "A") {
                  e.preventDefault();
                  return;
                }
              } while (elm = elm.parentNode);
            });
            editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
          };
          var blockFormSubmitInsideEditor = function() {
            editor.on("init", function() {
              editor.dom.bind(editor.getBody(), "submit", function(e) {
                e.preventDefault();
              });
            });
          };
          var removeAppleInterchangeBrs = function() {
            parser.addNodeFilter("br", function(nodes) {
              var i2 = nodes.length;
              while (i2--) {
                if (nodes[i2].attr("class") === "Apple-interchange-newline") {
                  nodes[i2].remove();
                }
              }
            });
          };
          var ieInternalDragAndDrop = function() {
            editor.on("dragstart", function(e) {
              setMceInternalContent(e);
            });
            editor.on("drop", function(e) {
              if (!isDefaultPrevented(e)) {
                var internalContent = getMceInternalContent(e);
                if (internalContent && internalContent.id !== editor.id) {
                  e.preventDefault();
                  var rng = CaretRangeFromPoint.fromPoint(e.x, e.y, editor.getDoc());
                  selection.setRng(rng);
                  insertClipboardContents(internalContent.html, true);
                }
              }
            });
          };
          var refreshContentEditable = function() {
          };
          var isHidden = function() {
            var sel;
            if (!isGecko || editor.removed) {
              return 0;
            }
            sel = editor.selection.getSel();
            return !sel || !sel.rangeCount || sel.rangeCount === 0;
          };
          removeBlockQuoteOnBackSpace();
          emptyEditorWhenDeleting();
          if (!Env.windowsPhone) {
            normalizeSelection2();
          }
          if (isWebKit) {
            inputMethodFocus();
            selectControlElements();
            setDefaultBlockType();
            blockFormSubmitInsideEditor();
            disableBackspaceIntoATable();
            removeAppleInterchangeBrs();
            if (Env.iOS) {
              restoreFocusOnKeyDown();
              bodyHeight();
              tapLinksAndImages();
            } else {
              selectAll();
            }
          }
          if (Env.ie >= 11) {
            bodyHeight();
            disableBackspaceIntoATable();
          }
          if (Env.ie) {
            selectAll();
            disableAutoUrlDetect();
            ieInternalDragAndDrop();
          }
          if (isGecko) {
            removeHrOnBackspace();
            focusBody2();
            removeStylesWhenDeletingAcrossBlockElements();
            setGeckoEditingOptions();
            addBrAfterLastLinks();
            showBrokenImageIcon();
            blockCmdArrowNavigation();
            disableBackspaceIntoATable();
          }
          return {
            refreshContentEditable,
            isHidden
          };
        }
        var isTextBlockNode = function(node2) {
          return NodeType.isElement(node2) && isTextBlock(Element2.fromDom(node2));
        };
        var normalizeSelection$1 = function(editor) {
          var rng = editor.selection.getRng();
          var startPos = CaretPosition.fromRangeStart(rng);
          var endPos = CaretPosition.fromRangeEnd(rng);
          if (CaretPosition.isElementPosition(startPos)) {
            var container = startPos.container();
            if (isTextBlockNode(container)) {
              CaretFinder.firstPositionIn(container).each(function(pos) {
                return rng.setStart(pos.container(), pos.offset());
              });
            }
          }
          if (CaretPosition.isElementPosition(endPos)) {
            var container = startPos.container();
            if (isTextBlockNode(container)) {
              CaretFinder.lastPositionIn(container).each(function(pos) {
                return rng.setEnd(pos.container(), pos.offset());
              });
            }
          }
          editor.selection.setRng(RangeNormalizer.normalize(rng));
        };
        var setup$f = function(editor) {
          editor.on("click", function(e) {
            if (e.detail >= 3) {
              normalizeSelection$1(editor);
            }
          });
        };
        var preventSummaryToggle = function(editor) {
          editor.on("click", function(e) {
            if (editor.dom.getParent(e.target, "details")) {
              e.preventDefault();
            }
          });
        };
        var filterDetails = function(editor) {
          editor.parser.addNodeFilter("details", function(elms) {
            each(elms, function(details) {
              details.attr("data-mce-open", details.attr("open"));
              details.attr("open", "open");
            });
          });
          editor.serializer.addNodeFilter("details", function(elms) {
            each(elms, function(details) {
              var open = details.attr("data-mce-open");
              details.attr("open", isString(open) ? open : null);
              details.attr("data-mce-open", null);
            });
          });
        };
        var setup$g = function(editor) {
          preventSummaryToggle(editor);
          filterDetails(editor);
        };
        var DOM$2 = DOMUtils$1.DOM;
        var appendStyle = function(editor, text2) {
          var head2 = Element2.fromDom(editor.getDoc().head);
          var tag = Element2.fromTag("style");
          set(tag, "type", "text/css");
          append(tag, Element2.fromText(text2));
          append(head2, tag);
        };
        var createParser = function(editor) {
          var parser = DomParser(editor.settings, editor.schema);
          parser.addAttributeFilter("src,href,style,tabindex", function(nodes, name2) {
            var i2 = nodes.length, node2;
            var dom2 = editor.dom;
            var value2, internalName;
            while (i2--) {
              node2 = nodes[i2];
              value2 = node2.attr(name2);
              internalName = "data-mce-" + name2;
              if (!node2.attributes.map[internalName]) {
                if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
                  continue;
                }
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node2.name);
                  if (!value2.length) {
                    value2 = null;
                  }
                  node2.attr(internalName, value2);
                  node2.attr(name2, value2);
                } else if (name2 === "tabindex") {
                  node2.attr(internalName, value2);
                  node2.attr(name2, null);
                } else {
                  node2.attr(internalName, editor.convertURL(value2, name2, node2.name));
                }
              }
            }
          });
          parser.addNodeFilter("script", function(nodes) {
            var i2 = nodes.length, node2, type2;
            while (i2--) {
              node2 = nodes[i2];
              type2 = node2.attr("type") || "no/type";
              if (type2.indexOf("mce-") !== 0) {
                node2.attr("type", "mce-" + type2);
              }
            }
          });
          parser.addNodeFilter("#cdata", function(nodes) {
            var i2 = nodes.length, node2;
            while (i2--) {
              node2 = nodes[i2];
              node2.type = 8;
              node2.name = "#comment";
              node2.value = "[CDATA[" + node2.value + "]]";
            }
          });
          parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(nodes) {
            var i2 = nodes.length, node2;
            var nonEmptyElements = editor.schema.getNonEmptyElements();
            while (i2--) {
              node2 = nodes[i2];
              if (node2.isEmpty(nonEmptyElements) && node2.getAll("br").length === 0) {
                node2.append(new Node$1("br", 1)).shortEnded = true;
              }
            }
          });
          return parser;
        };
        var autoFocus = function(editor) {
          if (editor.settings.auto_focus) {
            Delay.setEditorTimeout(editor, function() {
              var focusEditor2;
              if (editor.settings.auto_focus === true) {
                focusEditor2 = editor;
              } else {
                focusEditor2 = editor.editorManager.get(editor.settings.auto_focus);
              }
              if (!focusEditor2.destroyed) {
                focusEditor2.focus();
              }
            }, 100);
          }
        };
        var initEditor = function(editor) {
          editor.bindPendingEventDelegates();
          editor.initialized = true;
          editor.fire("init");
          editor.focus(true);
          editor.nodeChanged({ initial: true });
          editor.execCallback("init_instance_callback", editor);
          autoFocus(editor);
        };
        var getStyleSheetLoader = function(editor) {
          return editor.inline ? DOM$2.styleSheetLoader : editor.dom.styleSheetLoader;
        };
        var initContentBody = function(editor, skipWrite) {
          var settings = editor.settings;
          var targetElm = editor.getElement();
          var doc2 = editor.getDoc(), body, contentCssText;
          if (!settings.inline) {
            editor.getElement().style.visibility = editor.orgVisibility;
          }
          if (!skipWrite && !settings.content_editable) {
            doc2.open();
            doc2.write(editor.iframeHTML);
            doc2.close();
          }
          if (settings.content_editable) {
            editor.on("remove", function() {
              var bodyEl = this.getBody();
              DOM$2.removeClass(bodyEl, "mce-content-body");
              DOM$2.removeClass(bodyEl, "mce-edit-focus");
              DOM$2.setAttrib(bodyEl, "contentEditable", null);
            });
            DOM$2.addClass(targetElm, "mce-content-body");
            editor.contentDocument = doc2 = settings.content_document || domGlobals.document;
            editor.contentWindow = settings.content_window || domGlobals.window;
            editor.bodyElement = targetElm;
            settings.content_document = settings.content_window = null;
            settings.root_name = targetElm.nodeName.toLowerCase();
          }
          body = editor.getBody();
          body.disabled = true;
          editor.readonly = settings.readonly;
          if (!editor.readonly) {
            if (editor.inline && DOM$2.getStyle(body, "position", true) === "static") {
              body.style.position = "relative";
            }
            body.contentEditable = editor.getParam("content_editable_state", true);
          }
          body.disabled = false;
          editor.editorUpload = EditorUpload(editor);
          editor.schema = Schema(settings);
          editor.dom = DOMUtils$1(doc2, {
            keep_values: true,
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            hex_colors: settings.force_hex_style_colors,
            class_filter: settings.class_filter,
            update_styles: true,
            root_element: editor.inline ? editor.getBody() : null,
            collect: settings.content_editable,
            schema: editor.schema,
            contentCssCors: Settings.shouldUseContentCssCors(editor),
            onSetAttrib: function(e) {
              editor.fire("SetAttrib", e);
            }
          });
          editor.parser = createParser(editor);
          editor.serializer = DomSerializer$1(settings, editor);
          editor.selection = Selection$1(editor.dom, editor.getWin(), editor.serializer, editor);
          editor.annotator = Annotator(editor);
          editor.formatter = Formatter(editor);
          editor.undoManager = UndoManager(editor);
          editor._nodeChangeDispatcher = new NodeChange(editor);
          editor._selectionOverrides = SelectionOverrides(editor);
          setup$g(editor);
          setup$f(editor);
          KeyboardOverrides.setup(editor);
          ForceBlocks.setup(editor);
          editor.fire("PreInit");
          if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
            doc2.body.spellcheck = false;
            DOM$2.setAttrib(body, "spellcheck", "false");
          }
          editor.quirks = Quirks(editor);
          editor.fire("PostRender");
          if (settings.directionality) {
            body.dir = settings.directionality;
          }
          if (settings.nowrap) {
            body.style.whiteSpace = "nowrap";
          }
          if (settings.protect) {
            editor.on("BeforeSetContent", function(e) {
              Tools.each(settings.protect, function(pattern2) {
                e.content = e.content.replace(pattern2, function(str) {
                  return "<!--mce:protected " + escape(str) + "-->";
                });
              });
            });
          }
          editor.on("SetContent", function() {
            editor.addVisual(editor.getBody());
          });
          editor.load({
            initial: true,
            format: "html"
          });
          editor.startContent = editor.getContent({ format: "raw" });
          editor.on("compositionstart compositionend", function(e) {
            editor.composing = e.type === "compositionstart";
          });
          if (editor.contentStyles.length > 0) {
            contentCssText = "";
            Tools.each(editor.contentStyles, function(style) {
              contentCssText += style + "\r\n";
            });
            editor.dom.addStyle(contentCssText);
          }
          getStyleSheetLoader(editor).loadAll(editor.contentCSS, function(_) {
            initEditor(editor);
          }, function(urls) {
            initEditor(editor);
          });
          if (settings.content_style) {
            appendStyle(editor, settings.content_style);
          }
        };
        var InitContentBody = { initContentBody };
        var DOM$3 = DOMUtils$1.DOM;
        var relaxDomain = function(editor, ifr2) {
          if (domGlobals.document.domain !== domGlobals.window.location.hostname && Env.ie && Env.ie < 12) {
            var bodyUuid = Uuid.uuid("mce");
            editor[bodyUuid] = function() {
              InitContentBody.initContentBody(editor);
            };
            var domainRelaxUrl = 'javascript:(function(){document.open();document.domain="' + domGlobals.document.domain + '";var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);document.close();ed.' + bodyUuid + "(true);})()";
            DOM$3.setAttrib(ifr2, "src", domainRelaxUrl);
            return true;
          }
          return false;
        };
        var normalizeHeight = function(height) {
          var normalizedHeight = typeof height === "number" ? height + "px" : height;
          return normalizedHeight ? normalizedHeight : "";
        };
        var createIframeElement = function(id, title, height, customAttrs) {
          var iframe = Element2.fromTag("iframe");
          setAll(iframe, customAttrs);
          setAll(iframe, {
            id: id + "_ifr",
            frameBorder: "0",
            allowTransparency: "true",
            title
          });
          setAll$1(iframe, {
            width: "100%",
            height: normalizeHeight(height),
            display: "block"
          });
          return iframe;
        };
        var getIframeHtml = function(editor) {
          var bodyId, bodyClass, iframeHTML;
          iframeHTML = Settings.getDocType(editor) + "<html><head>";
          if (Settings.getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
            iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
          }
          iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
          bodyId = Settings.getBodyId(editor);
          bodyClass = Settings.getBodyClass(editor);
          if (Settings.getContentSecurityPolicy(editor)) {
            iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + Settings.getContentSecurityPolicy(editor) + '" />';
          }
          iframeHTML += '</head><body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '"><br></body></html>';
          return iframeHTML;
        };
        var createIframe = function(editor, o) {
          var title = editor.editorManager.translate("Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help");
          var ifr2 = createIframeElement(editor.id, title, o.height, Settings.getIframeAttrs(editor)).dom();
          ifr2.onload = function() {
            ifr2.onload = null;
            editor.fire("load");
          };
          var isDomainRelaxed = relaxDomain(editor, ifr2);
          editor.contentAreaContainer = o.iframeContainer;
          editor.iframeElement = ifr2;
          editor.iframeHTML = getIframeHtml(editor);
          DOM$3.add(o.iframeContainer, ifr2);
          return isDomainRelaxed;
        };
        var init$1 = function(editor, boxInfo) {
          var isDomainRelaxed = createIframe(editor, boxInfo);
          if (boxInfo.editorContainer) {
            DOM$3.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
            editor.hidden = DOM$3.isHidden(boxInfo.editorContainer);
          }
          editor.getElement().style.display = "none";
          DOM$3.setAttrib(editor.id, "aria-hidden", "true");
          if (!isDomainRelaxed) {
            InitContentBody.initContentBody(editor);
          }
        };
        var InitIframe = { init: init$1 };
        var DOM$4 = DOMUtils$1.DOM;
        var initPlugin = function(editor, initializedPlugins, plugin2) {
          var Plugin = PluginManager$1.get(plugin2);
          var pluginUrl = PluginManager$1.urls[plugin2] || editor.documentBaseUrl.replace(/\/$/, "");
          plugin2 = Tools.trim(plugin2);
          if (Plugin && Tools.inArray(initializedPlugins, plugin2) === -1) {
            Tools.each(PluginManager$1.dependencies(plugin2), function(dep) {
              initPlugin(editor, initializedPlugins, dep);
            });
            if (editor.plugins[plugin2]) {
              return;
            }
            try {
              var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
              editor.plugins[plugin2] = pluginInstance;
              if (pluginInstance.init) {
                pluginInstance.init(editor, pluginUrl);
                initializedPlugins.push(plugin2);
              }
            } catch (e) {
              ErrorReporter.pluginInitError(editor, plugin2, e);
            }
          }
        };
        var trimLegacyPrefix = function(name2) {
          return name2.replace(/^\-/, "");
        };
        var initPlugins = function(editor) {
          var initializedPlugins = [];
          Tools.each(editor.settings.plugins.split(/[ ,]/), function(name2) {
            initPlugin(editor, initializedPlugins, trimLegacyPrefix(name2));
          });
        };
        var initTheme = function(editor) {
          var Theme;
          var theme2 = editor.settings.theme;
          if (isString(theme2)) {
            editor.settings.theme = trimLegacyPrefix(theme2);
            Theme = ThemeManager.get(theme2);
            editor.theme = new Theme(editor, ThemeManager.urls[theme2]);
            if (editor.theme.init) {
              editor.theme.init(editor, ThemeManager.urls[theme2] || editor.documentBaseUrl.replace(/\/$/, ""), editor.$);
            }
          } else {
            editor.theme = {};
          }
        };
        var renderFromLoadedTheme = function(editor) {
          var w, h, minHeight, re2, info;
          var settings = editor.settings;
          var elm = editor.getElement();
          w = settings.width || DOM$4.getStyle(elm, "width") || "100%";
          h = settings.height || DOM$4.getStyle(elm, "height") || elm.offsetHeight;
          minHeight = settings.min_height || 100;
          re2 = /^[0-9\.]+(|px)$/i;
          if (re2.test("" + w)) {
            w = Math.max(parseInt(w, 10), 100);
          }
          if (re2.test("" + h)) {
            h = Math.max(parseInt(h, 10), minHeight);
          }
          info = editor.theme.renderUI({
            targetNode: elm,
            width: w,
            height: h,
            deltaWidth: settings.delta_width,
            deltaHeight: settings.delta_height
          });
          if (!settings.content_editable) {
            h = (info.iframeHeight || h) + (typeof h === "number" ? info.deltaHeight || 0 : "");
            if (h < minHeight) {
              h = minHeight;
            }
          }
          info.height = h;
          return info;
        };
        var renderFromThemeFunc = function(editor) {
          var info;
          var elm = editor.getElement();
          info = editor.settings.theme(editor, elm);
          if (info.editorContainer.nodeType) {
            info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
          }
          if (info.iframeContainer && info.iframeContainer.nodeType) {
            info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
          }
          info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
          return info;
        };
        var createThemeFalseResult = function(element) {
          return {
            editorContainer: element,
            iframeContainer: element
          };
        };
        var renderThemeFalseIframe = function(targetElement) {
          var iframeContainer = DOM$4.create("div");
          DOM$4.insertAfter(iframeContainer, targetElement);
          return createThemeFalseResult(iframeContainer);
        };
        var renderThemeFalse = function(editor) {
          var targetElement = editor.getElement();
          return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
        };
        var renderThemeUi = function(editor) {
          var settings = editor.settings, elm = editor.getElement();
          editor.orgDisplay = elm.style.display;
          if (isString(settings.theme)) {
            return renderFromLoadedTheme(editor);
          } else if (isFunction(settings.theme)) {
            return renderFromThemeFunc(editor);
          } else {
            return renderThemeFalse(editor);
          }
        };
        var init$2 = function(editor) {
          var settings = editor.settings;
          var elm = editor.getElement();
          var boxInfo;
          editor.rtl = settings.rtl_ui || editor.editorManager.i18n.rtl;
          editor.editorManager.i18n.setCode(settings.language);
          settings.aria_label = settings.aria_label || DOM$4.getAttrib(elm, "aria-label", editor.getLang("aria.rich_text_area"));
          editor.fire("ScriptsLoaded");
          initTheme(editor);
          initPlugins(editor);
          boxInfo = renderThemeUi(editor);
          editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
          if (settings.content_css) {
            Tools.each(Tools.explode(settings.content_css), function(u) {
              editor.contentCSS.push(editor.documentBaseURI.toAbsolute(u));
            });
          }
          if (settings.content_editable) {
            return InitContentBody.initContentBody(editor);
          } else {
            return InitIframe.init(editor, boxInfo);
          }
        };
        var Init = { init: init$2 };
        var DOM$5 = DOMUtils$1.DOM;
        var hasSkipLoadPrefix = function(name2) {
          return name2.charAt(0) === "-";
        };
        var loadLanguage = function(scriptLoader, editor) {
          var settings = editor.settings;
          if (settings.language && settings.language !== "en" && !settings.language_url) {
            settings.language_url = editor.editorManager.baseURL + "/langs/" + settings.language + ".js";
          }
          if (settings.language_url && !editor.editorManager.i18n.data[settings.language]) {
            scriptLoader.add(settings.language_url);
          }
        };
        var loadTheme = function(scriptLoader, editor, suffix, callback) {
          var settings = editor.settings, theme2 = settings.theme;
          if (isString(theme2)) {
            if (!hasSkipLoadPrefix(theme2) && !ThemeManager.urls.hasOwnProperty(theme2)) {
              var themeUrl = settings.theme_url;
              if (themeUrl) {
                ThemeManager.load(theme2, editor.documentBaseURI.toAbsolute(themeUrl));
              } else {
                ThemeManager.load(theme2, "themes/" + theme2 + "/theme" + suffix + ".js");
              }
            }
            scriptLoader.loadQueue(function() {
              ThemeManager.waitFor(theme2, callback);
            });
          } else {
            callback();
          }
        };
        var loadPlugins = function(settings, suffix) {
          if (Tools.isArray(settings.plugins)) {
            settings.plugins = settings.plugins.join(" ");
          }
          Tools.each(settings.external_plugins, function(url2, name2) {
            PluginManager$1.load(name2, url2);
            settings.plugins += " " + name2;
          });
          Tools.each(settings.plugins.split(/[ ,]/), function(plugin2) {
            plugin2 = Tools.trim(plugin2);
            if (plugin2 && !PluginManager$1.urls[plugin2]) {
              if (hasSkipLoadPrefix(plugin2)) {
                plugin2 = plugin2.substr(1, plugin2.length);
                var dependencies = PluginManager$1.dependencies(plugin2);
                Tools.each(dependencies, function(dep) {
                  var defaultSettings = {
                    prefix: "plugins/",
                    resource: dep,
                    suffix: "/plugin" + suffix + ".js"
                  };
                  dep = PluginManager$1.createUrl(defaultSettings, dep);
                  PluginManager$1.load(dep.resource, dep);
                });
              } else {
                PluginManager$1.load(plugin2, {
                  prefix: "plugins/",
                  resource: plugin2,
                  suffix: "/plugin" + suffix + ".js"
                });
              }
            }
          });
        };
        var loadScripts = function(editor, suffix) {
          var scriptLoader = ScriptLoader.ScriptLoader;
          loadTheme(scriptLoader, editor, suffix, function() {
            loadLanguage(scriptLoader, editor);
            loadPlugins(editor.settings, suffix);
            scriptLoader.loadQueue(function() {
              if (!editor.removed) {
                Init.init(editor);
              }
            }, editor, function(urls) {
              ErrorReporter.pluginLoadError(editor, urls[0]);
              if (!editor.removed) {
                Init.init(editor);
              }
            });
          });
        };
        var render = function(editor) {
          var settings = editor.settings, id = editor.id;
          var readyHandler = function() {
            DOM$5.unbind(domGlobals.window, "ready", readyHandler);
            editor.render();
          };
          if (!EventUtils.Event.domLoaded) {
            DOM$5.bind(domGlobals.window, "ready", readyHandler);
            return;
          }
          if (!editor.getElement()) {
            return;
          }
          if (!Env.contentEditable) {
            return;
          }
          if (!settings.inline) {
            editor.orgVisibility = editor.getElement().style.visibility;
            editor.getElement().style.visibility = "hidden";
          } else {
            editor.inline = true;
          }
          var form = editor.getElement().form || DOM$5.getParent(id, "form");
          if (form) {
            editor.formElement = form;
            if (settings.hidden_input && !/TEXTAREA|INPUT/i.test(editor.getElement().nodeName)) {
              DOM$5.insertAfter(DOM$5.create("input", {
                type: "hidden",
                name: id
              }), id);
              editor.hasHiddenInput = true;
            }
            editor.formEventDelegate = function(e) {
              editor.fire(e.type, e);
            };
            DOM$5.bind(form, "submit reset", editor.formEventDelegate);
            editor.on("reset", function() {
              editor.setContent(editor.startContent, { format: "raw" });
            });
            if (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
              form._mceOldSubmit = form.submit;
              form.submit = function() {
                editor.editorManager.triggerSave();
                editor.setDirty(false);
                return form._mceOldSubmit(form);
              };
            }
          }
          editor.windowManager = WindowManager(editor);
          editor.notificationManager = NotificationManager(editor);
          if (settings.encoding === "xml") {
            editor.on("GetContent", function(e) {
              if (e.save) {
                e.content = DOM$5.encode(e.content);
              }
            });
          }
          if (settings.add_form_submit_trigger) {
            editor.on("submit", function() {
              if (editor.initialized) {
                editor.save();
              }
            });
          }
          if (settings.add_unload_trigger) {
            editor._beforeUnload = function() {
              if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
                editor.save({
                  format: "raw",
                  no_events: true,
                  set_dirty: false
                });
              }
            };
            editor.editorManager.on("BeforeUnload", editor._beforeUnload);
          }
          editor.editorManager.add(editor);
          loadScripts(editor, editor.suffix);
        };
        var Render = { render };
        var add$4 = function(editor, name2, settings) {
          var sidebars = editor.sidebars ? editor.sidebars : [];
          sidebars.push({
            name: name2,
            settings
          });
          editor.sidebars = sidebars;
        };
        var Sidebar = { add: add$4 };
        var each$k = Tools.each, trim$4 = Tools.trim;
        var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
        var DEFAULT_PORTS = {
          ftp: 21,
          http: 80,
          https: 443,
          mailto: 25
        };
        var URI = function(url2, settings) {
          var self2 = this;
          var baseUri, baseUrl;
          url2 = trim$4(url2);
          settings = self2.settings = settings || {};
          baseUri = settings.base_uri;
          if (/^([\w\-]+):([^\/]{2})/i.test(url2) || /^\s*#/.test(url2)) {
            self2.source = url2;
            return;
          }
          var isProtocolRelative = url2.indexOf("//") === 0;
          if (url2.indexOf("/") === 0 && !isProtocolRelative) {
            url2 = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url2;
          }
          if (!/^[\w\-]*:?\/\//.test(url2)) {
            baseUrl = settings.base_uri ? settings.base_uri.path : new URI(domGlobals.document.location.href).directory;
            if (settings.base_uri.protocol == "") {
              url2 = "//mce_host" + self2.toAbsPath(baseUrl, url2);
            } else {
              url2 = /([^#?]*)([#?]?.*)/.exec(url2);
              url2 = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, url2[1]) + url2[2];
            }
          }
          url2 = url2.replace(/@@/g, "(mce_at)");
          url2 = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url2);
          each$k(queryParts, function(v, i2) {
            var part2 = url2[i2];
            if (part2) {
              part2 = part2.replace(/\(mce_at\)/g, "@@");
            }
            self2[v] = part2;
          });
          if (baseUri) {
            if (!self2.protocol) {
              self2.protocol = baseUri.protocol;
            }
            if (!self2.userInfo) {
              self2.userInfo = baseUri.userInfo;
            }
            if (!self2.port && self2.host === "mce_host") {
              self2.port = baseUri.port;
            }
            if (!self2.host || self2.host === "mce_host") {
              self2.host = baseUri.host;
            }
            self2.source = "";
          }
          if (isProtocolRelative) {
            self2.protocol = "";
          }
        };
        URI.prototype = {
          setPath: function(path2) {
            var self2 = this;
            path2 = /^(.*?)\/?(\w+)?$/.exec(path2);
            self2.path = path2[0];
            self2.directory = path2[1];
            self2.file = path2[2];
            self2.source = "";
            self2.getURI();
          },
          toRelative: function(uri) {
            var self2 = this;
            var output2;
            if (uri === "./") {
              return uri;
            }
            uri = new URI(uri, { base_uri: self2 });
            if (uri.host !== "mce_host" && self2.host !== uri.host && uri.host || self2.port !== uri.port || self2.protocol !== uri.protocol && uri.protocol !== "") {
              return uri.getURI();
            }
            var tu = self2.getURI(), uu = uri.getURI();
            if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
              return tu;
            }
            output2 = self2.toRelPath(self2.path, uri.path);
            if (uri.query) {
              output2 += "?" + uri.query;
            }
            if (uri.anchor) {
              output2 += "#" + uri.anchor;
            }
            return output2;
          },
          toAbsolute: function(uri, noHost) {
            uri = new URI(uri, { base_uri: this });
            return uri.getURI(noHost && this.isSameOrigin(uri));
          },
          isSameOrigin: function(uri) {
            if (this.host == uri.host && this.protocol == uri.protocol) {
              if (this.port == uri.port) {
                return true;
              }
              var defaultPort = DEFAULT_PORTS[this.protocol];
              if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
                return true;
              }
            }
            return false;
          },
          toRelPath: function(base2, path2) {
            var items, breakPoint = 0, out = "", i2, l;
            base2 = base2.substring(0, base2.lastIndexOf("/"));
            base2 = base2.split("/");
            items = path2.split("/");
            if (base2.length >= items.length) {
              for (i2 = 0, l = base2.length; i2 < l; i2++) {
                if (i2 >= items.length || base2[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (base2.length < items.length) {
              for (i2 = 0, l = items.length; i2 < l; i2++) {
                if (i2 >= base2.length || base2[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (breakPoint === 1) {
              return path2;
            }
            for (i2 = 0, l = base2.length - (breakPoint - 1); i2 < l; i2++) {
              out += "../";
            }
            for (i2 = breakPoint - 1, l = items.length; i2 < l; i2++) {
              if (i2 !== breakPoint - 1) {
                out += "/" + items[i2];
              } else {
                out += items[i2];
              }
            }
            return out;
          },
          toAbsPath: function(base2, path2) {
            var i2, nb = 0, o = [], tr, outPath;
            tr = /\/$/.test(path2) ? "/" : "";
            base2 = base2.split("/");
            path2 = path2.split("/");
            each$k(base2, function(k) {
              if (k) {
                o.push(k);
              }
            });
            base2 = o;
            for (i2 = path2.length - 1, o = []; i2 >= 0; i2--) {
              if (path2[i2].length === 0 || path2[i2] === ".") {
                continue;
              }
              if (path2[i2] === "..") {
                nb++;
                continue;
              }
              if (nb > 0) {
                nb--;
                continue;
              }
              o.push(path2[i2]);
            }
            i2 = base2.length - nb;
            if (i2 <= 0) {
              outPath = o.reverse().join("/");
            } else {
              outPath = base2.slice(0, i2).join("/") + "/" + o.reverse().join("/");
            }
            if (outPath.indexOf("/") !== 0) {
              outPath = "/" + outPath;
            }
            if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
              outPath += tr;
            }
            return outPath;
          },
          getURI: function(noProtoHost) {
            var s;
            var self2 = this;
            if (!self2.source || noProtoHost) {
              s = "";
              if (!noProtoHost) {
                if (self2.protocol) {
                  s += self2.protocol + "://";
                } else {
                  s += "//";
                }
                if (self2.userInfo) {
                  s += self2.userInfo + "@";
                }
                if (self2.host) {
                  s += self2.host;
                }
                if (self2.port) {
                  s += ":" + self2.port;
                }
              }
              if (self2.path) {
                s += self2.path;
              }
              if (self2.query) {
                s += "?" + self2.query;
              }
              if (self2.anchor) {
                s += "#" + self2.anchor;
              }
              self2.source = s;
            }
            return self2.source;
          }
        };
        URI.parseDataUri = function(uri) {
          var type2, matches2;
          uri = decodeURIComponent(uri).split(",");
          matches2 = /data:([^;]+)/.exec(uri[0]);
          if (matches2) {
            type2 = matches2[1];
          }
          return {
            type: type2,
            data: uri[1]
          };
        };
        URI.getDocumentBaseUrl = function(loc) {
          var baseUrl;
          if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
            baseUrl = loc.href;
          } else {
            baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
          }
          if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
            baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
            if (!/[\/\\]$/.test(baseUrl)) {
              baseUrl += "/";
            }
          }
          return baseUrl;
        };
        var defaultFormat = "html";
        var trimEmptyContents = function(editor, html2) {
          var blockName = Settings.getForcedRootBlock(editor);
          var emptyRegExp = new RegExp("^(<" + blockName + "[^>]*>(&nbsp;|&#160;|\\s|Â |<br \\/>|)<\\/" + blockName + ">[\r\n]*|<br \\/>[\r\n]*)$");
          return html2.replace(emptyRegExp, "");
        };
        var getContentFromBody = function(editor, args, body) {
          var content;
          args.format = args.format ? args.format : defaultFormat;
          args.get = true;
          args.getInner = true;
          if (!args.no_events) {
            editor.fire("BeforeGetContent", args);
          }
          if (args.format === "raw") {
            content = Tools.trim(TrimHtml.trimExternal(editor.serializer, body.innerHTML));
          } else if (args.format === "text") {
            content = Zwsp.trim(body.innerText || body.textContent);
          } else if (args.format === "tree") {
            return editor.serializer.serialize(body, args);
          } else {
            content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
          }
          if (args.format !== "text" && !isWsPreserveElement(Element2.fromDom(body))) {
            args.content = Tools.trim(content);
          } else {
            args.content = content;
          }
          if (!args.no_events) {
            editor.fire("GetContent", args);
          }
          return args.content;
        };
        var getContent$1 = function(editor, args) {
          if (args === void 0) {
            args = {};
          }
          return Option.from(editor.getBody()).fold(constant(args.format === "tree" ? new Node$1("body", 11) : ""), function(body) {
            return getContentFromBody(editor, args, body);
          });
        };
        var traverse = function(node2, fn) {
          fn(node2);
          if (node2.firstChild) {
            traverse(node2.firstChild, fn);
          }
          if (node2.next) {
            traverse(node2.next, fn);
          }
        };
        var findMatchingNodes = function(nodeFilters, attributeFilters, node2) {
          var nodeMatches = {};
          var attrMatches = {};
          var matches2 = [];
          if (node2.firstChild) {
            traverse(node2.firstChild, function(node3) {
              each(nodeFilters, function(filter2) {
                if (filter2.name === node3.name) {
                  if (nodeMatches[filter2.name]) {
                    nodeMatches[filter2.name].nodes.push(node3);
                  } else {
                    nodeMatches[filter2.name] = {
                      filter: filter2,
                      nodes: [node3]
                    };
                  }
                }
              });
              each(attributeFilters, function(filter2) {
                if (typeof node3.attr(filter2.name) === "string") {
                  if (attrMatches[filter2.name]) {
                    attrMatches[filter2.name].nodes.push(node3);
                  } else {
                    attrMatches[filter2.name] = {
                      filter: filter2,
                      nodes: [node3]
                    };
                  }
                }
              });
            });
          }
          for (var name2 in nodeMatches) {
            if (nodeMatches.hasOwnProperty(name2)) {
              matches2.push(nodeMatches[name2]);
            }
          }
          for (var name2 in attrMatches) {
            if (attrMatches.hasOwnProperty(name2)) {
              matches2.push(attrMatches[name2]);
            }
          }
          return matches2;
        };
        var filter$3 = function(nodeFilters, attributeFilters, node2) {
          var matches2 = findMatchingNodes(nodeFilters, attributeFilters, node2);
          each(matches2, function(match2) {
            each(match2.filter.callbacks, function(callback) {
              callback(match2.nodes, match2.filter.name, {});
            });
          });
        };
        var defaultFormat$1 = "html";
        var isTreeNode = function(content) {
          return content instanceof Node$1;
        };
        var moveSelection = function(editor) {
          if (EditorFocus.hasFocus(editor)) {
            CaretFinder.firstPositionIn(editor.getBody()).each(function(pos) {
              var node2 = pos.getNode();
              var caretPos = NodeType.isTable(node2) ? CaretFinder.firstPositionIn(node2).getOr(pos) : pos;
              editor.selection.setRng(caretPos.toRange());
            });
          }
        };
        var setEditorHtml = function(editor, html2) {
          editor.dom.setHTML(editor.getBody(), html2);
          moveSelection(editor);
        };
        var setContentString = function(editor, body, content, args) {
          var forcedRootBlockName, padd;
          if (content.length === 0 || /^\s+$/.test(content)) {
            padd = '<br data-mce-bogus="1">';
            if (body.nodeName === "TABLE") {
              content = "<tr><td>" + padd + "</td></tr>";
            } else if (/^(UL|OL)$/.test(body.nodeName)) {
              content = "<li>" + padd + "</li>";
            }
            forcedRootBlockName = Settings.getForcedRootBlock(editor);
            if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
              content = padd;
              content = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs, content);
            } else if (!content) {
              content = '<br data-mce-bogus="1">';
            }
            setEditorHtml(editor, content);
            editor.fire("SetContent", args);
          } else {
            if (args.format !== "raw") {
              content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
                isRootContent: true,
                insert: true
              }));
            }
            args.content = isWsPreserveElement(Element2.fromDom(body)) ? content : Tools.trim(content);
            setEditorHtml(editor, args.content);
            if (!args.no_events) {
              editor.fire("SetContent", args);
            }
          }
          return args.content;
        };
        var setContentTree = function(editor, body, content, args) {
          filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
          var html2 = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);
          args.content = isWsPreserveElement(Element2.fromDom(body)) ? html2 : Tools.trim(html2);
          setEditorHtml(editor, args.content);
          if (!args.no_events) {
            editor.fire("SetContent", args);
          }
          return content;
        };
        var setContent$1 = function(editor, content, args) {
          if (args === void 0) {
            args = {};
          }
          args.format = args.format ? args.format : defaultFormat$1;
          args.set = true;
          args.content = isTreeNode(content) ? "" : content;
          if (!isTreeNode(content) && !args.no_events) {
            editor.fire("BeforeSetContent", args);
            content = args.content;
          }
          return Option.from(editor.getBody()).fold(constant(content), function(body) {
            return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
          });
        };
        var DOM$6 = DOMUtils$1.DOM;
        var restoreOriginalStyles = function(editor) {
          DOM$6.setStyle(editor.id, "display", editor.orgDisplay);
        };
        var safeDestroy = function(x) {
          return Option.from(x).each(function(x2) {
            return x2.destroy();
          });
        };
        var clearDomReferences = function(editor) {
          editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
          editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
          editor.iframeElement = editor.targetElm = null;
          if (editor.selection) {
            editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
          }
        };
        var restoreForm = function(editor) {
          var form = editor.formElement;
          if (form) {
            if (form._mceOldSubmit) {
              form.submit = form._mceOldSubmit;
              form._mceOldSubmit = null;
            }
            DOM$6.unbind(form, "submit reset", editor.formEventDelegate);
          }
        };
        var remove$7 = function(editor) {
          if (!editor.removed) {
            var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
            var body = editor.getBody();
            var element = editor.getElement();
            if (body) {
              editor.save({ is_removing: true });
            }
            editor.removed = true;
            editor.unbindAllNativeEvents();
            if (editor.hasHiddenInput && element) {
              DOM$6.remove(element.nextSibling);
            }
            Events.fireRemove(editor);
            editor.editorManager.remove(editor);
            if (!editor.inline && body) {
              restoreOriginalStyles(editor);
            }
            Events.fireDetach(editor);
            DOM$6.remove(editor.getContainer());
            safeDestroy(_selectionOverrides);
            safeDestroy(editorUpload);
            editor.destroy();
          }
        };
        var destroy = function(editor, automatic) {
          var selection = editor.selection, dom2 = editor.dom;
          if (editor.destroyed) {
            return;
          }
          if (!automatic && !editor.removed) {
            editor.remove();
            return;
          }
          if (!automatic) {
            editor.editorManager.off("beforeunload", editor._beforeUnload);
            if (editor.theme && editor.theme.destroy) {
              editor.theme.destroy();
            }
            safeDestroy(selection);
            safeDestroy(dom2);
          }
          restoreForm(editor);
          clearDomReferences(editor);
          editor.destroyed = true;
        };
        var DOM$7 = DOMUtils$1.DOM;
        var extend$4 = Tools.extend, each$l = Tools.each;
        var resolve$4 = Tools.resolve;
        var ie$2 = Env.ie;
        var Editor = function(id, settings, editorManager) {
          var self2 = this;
          var documentBaseUrl = self2.documentBaseUrl = editorManager.documentBaseURL;
          var baseUri = editorManager.baseURI;
          settings = getEditorSettings(self2, id, documentBaseUrl, editorManager.defaultSettings, settings);
          self2.settings = settings;
          AddOnManager.language = settings.language || "en";
          AddOnManager.languageLoad = settings.language_load;
          AddOnManager.baseURL = editorManager.baseURL;
          self2.id = id;
          self2.setDirty(false);
          self2.plugins = {};
          self2.documentBaseURI = new URI(settings.document_base_url, { base_uri: baseUri });
          self2.baseURI = baseUri;
          self2.contentCSS = [];
          self2.contentStyles = [];
          self2.shortcuts = new Shortcuts(self2);
          self2.loadedCSS = {};
          self2.editorCommands = new EditorCommands(self2);
          self2.suffix = editorManager.suffix;
          self2.editorManager = editorManager;
          self2.inline = settings.inline;
          self2.buttons = {};
          self2.menuItems = {};
          if (settings.cache_suffix) {
            Env.cacheSuffix = settings.cache_suffix.replace(/^[\?\&]+/, "");
          }
          if (settings.override_viewport === false) {
            Env.overrideViewPort = false;
          }
          editorManager.fire("SetupEditor", { editor: self2 });
          self2.execCallback("setup", self2);
          self2.$ = DomQuery.overrideDefaults(function() {
            return {
              context: self2.inline ? self2.getBody() : self2.getDoc(),
              element: self2.getBody()
            };
          });
        };
        Editor.prototype = {
          render: function() {
            Render.render(this);
          },
          focus: function(skipFocus) {
            EditorFocus.focus(this, skipFocus);
          },
          hasFocus: function() {
            return EditorFocus.hasFocus(this);
          },
          execCallback: function(name2) {
            var self2 = this;
            var callback = self2.settings[name2], scope;
            if (!callback) {
              return;
            }
            if (self2.callbackLookup && (scope = self2.callbackLookup[name2])) {
              callback = scope.func;
              scope = scope.scope;
            }
            if (typeof callback === "string") {
              scope = callback.replace(/\.\w+$/, "");
              scope = scope ? resolve$4(scope) : 0;
              callback = resolve$4(callback);
              self2.callbackLookup = self2.callbackLookup || {};
              self2.callbackLookup[name2] = {
                func: callback,
                scope
              };
            }
            return callback.apply(scope || self2, Array.prototype.slice.call(arguments, 1));
          },
          translate: function(text2) {
            if (text2 && Tools.is(text2, "string")) {
              var lang_1 = this.settings.language || "en", i18n_1 = this.editorManager.i18n;
              text2 = i18n_1.data[lang_1 + "." + text2] || text2.replace(/\{\#([^\}]+)\}/g, function(a, b) {
                return i18n_1.data[lang_1 + "." + b] || "{#" + b + "}";
              });
            }
            return this.editorManager.translate(text2);
          },
          getLang: function(name2, defaultVal) {
            return this.editorManager.i18n.data[(this.settings.language || "en") + "." + name2] || (defaultVal !== void 0 ? defaultVal : "{#" + name2 + "}");
          },
          getParam: function(name2, defaultVal, type2) {
            return getParam(this, name2, defaultVal, type2);
          },
          nodeChanged: function(args) {
            this._nodeChangeDispatcher.nodeChanged(args);
          },
          addButton: function(name2, settings) {
            var self2 = this;
            if (settings.cmd) {
              settings.onclick = function() {
                self2.execCommand(settings.cmd);
              };
            }
            if (settings.stateSelector && typeof settings.active === "undefined") {
              settings.active = false;
            }
            if (!settings.text && !settings.icon) {
              settings.icon = name2;
            }
            settings.tooltip = settings.tooltip || settings.title;
            self2.buttons[name2] = settings;
          },
          addSidebar: function(name2, settings) {
            return Sidebar.add(this, name2, settings);
          },
          addMenuItem: function(name2, settings) {
            var self2 = this;
            if (settings.cmd) {
              settings.onclick = function() {
                self2.execCommand(settings.cmd);
              };
            }
            self2.menuItems[name2] = settings;
          },
          addContextToolbar: function(predicate, items) {
            var self2 = this;
            var selector;
            self2.contextToolbars = self2.contextToolbars || [];
            if (typeof predicate === "string") {
              selector = predicate;
              predicate = function(elm) {
                return self2.dom.is(elm, selector);
              };
            }
            self2.contextToolbars.push({
              id: Uuid.uuid("mcet"),
              predicate,
              items
            });
          },
          addCommand: function(name2, callback, scope) {
            this.editorCommands.addCommand(name2, callback, scope);
          },
          addQueryStateHandler: function(name2, callback, scope) {
            this.editorCommands.addQueryStateHandler(name2, callback, scope);
          },
          addQueryValueHandler: function(name2, callback, scope) {
            this.editorCommands.addQueryValueHandler(name2, callback, scope);
          },
          addShortcut: function(pattern2, desc, cmdFunc, scope) {
            this.shortcuts.add(pattern2, desc, cmdFunc, scope);
          },
          execCommand: function(cmd, ui, value2, args) {
            return this.editorCommands.execCommand(cmd, ui, value2, args);
          },
          queryCommandState: function(cmd) {
            return this.editorCommands.queryCommandState(cmd);
          },
          queryCommandValue: function(cmd) {
            return this.editorCommands.queryCommandValue(cmd);
          },
          queryCommandSupported: function(cmd) {
            return this.editorCommands.queryCommandSupported(cmd);
          },
          show: function() {
            var self2 = this;
            if (self2.hidden) {
              self2.hidden = false;
              if (self2.inline) {
                self2.getBody().contentEditable = true;
              } else {
                DOM$7.show(self2.getContainer());
                DOM$7.hide(self2.id);
              }
              self2.load();
              self2.fire("show");
            }
          },
          hide: function() {
            var self2 = this, doc2 = self2.getDoc();
            if (!self2.hidden) {
              if (ie$2 && doc2 && !self2.inline) {
                doc2.execCommand("SelectAll");
              }
              self2.save();
              if (self2.inline) {
                self2.getBody().contentEditable = false;
                if (self2 === self2.editorManager.focusedEditor) {
                  self2.editorManager.focusedEditor = null;
                }
              } else {
                DOM$7.hide(self2.getContainer());
                DOM$7.setStyle(self2.id, "display", self2.orgDisplay);
              }
              self2.hidden = true;
              self2.fire("hide");
            }
          },
          isHidden: function() {
            return !!this.hidden;
          },
          setProgressState: function(state, time) {
            this.fire("ProgressState", {
              state,
              time
            });
          },
          load: function(args) {
            var self2 = this;
            var elm = self2.getElement(), html2;
            if (self2.removed) {
              return "";
            }
            if (elm) {
              args = args || {};
              args.load = true;
              html2 = self2.setContent(elm.value !== void 0 ? elm.value : elm.innerHTML, args);
              args.element = elm;
              if (!args.no_events) {
                self2.fire("LoadContent", args);
              }
              args.element = elm = null;
              return html2;
            }
          },
          save: function(args) {
            var self2 = this;
            var elm = self2.getElement(), html2, form;
            if (!elm || !self2.initialized || self2.removed) {
              return;
            }
            args = args || {};
            args.save = true;
            args.element = elm;
            html2 = args.content = self2.getContent(args);
            if (!args.no_events) {
              self2.fire("SaveContent", args);
            }
            if (args.format === "raw") {
              self2.fire("RawSaveContent", args);
            }
            html2 = args.content;
            if (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {
              if (args.is_removing || !self2.inline) {
                elm.innerHTML = html2;
              }
              if (form = DOM$7.getParent(self2.id, "form")) {
                each$l(form.elements, function(elm2) {
                  if (elm2.name === self2.id) {
                    elm2.value = html2;
                    return false;
                  }
                });
              }
            } else {
              elm.value = html2;
            }
            args.element = elm = null;
            if (args.set_dirty !== false) {
              self2.setDirty(false);
            }
            return html2;
          },
          setContent: function(content, args) {
            return setContent$1(this, content, args);
          },
          getContent: function(args) {
            return getContent$1(this, args);
          },
          insertContent: function(content, args) {
            if (args) {
              content = extend$4({ content }, args);
            }
            this.execCommand("mceInsertContent", false, content);
          },
          isDirty: function() {
            return !this.isNotDirty;
          },
          setDirty: function(state) {
            var oldState = !this.isNotDirty;
            this.isNotDirty = !state;
            if (state && state !== oldState) {
              this.fire("dirty");
            }
          },
          setMode: function(mode) {
            setMode(this, mode);
          },
          getContainer: function() {
            var self2 = this;
            if (!self2.container) {
              self2.container = DOM$7.get(self2.editorContainer || self2.id + "_parent");
            }
            return self2.container;
          },
          getContentAreaContainer: function() {
            return this.contentAreaContainer;
          },
          getElement: function() {
            if (!this.targetElm) {
              this.targetElm = DOM$7.get(this.id);
            }
            return this.targetElm;
          },
          getWin: function() {
            var self2 = this;
            var elm;
            if (!self2.contentWindow) {
              elm = self2.iframeElement;
              if (elm) {
                self2.contentWindow = elm.contentWindow;
              }
            }
            return self2.contentWindow;
          },
          getDoc: function() {
            var self2 = this;
            var win;
            if (!self2.contentDocument) {
              win = self2.getWin();
              if (win) {
                self2.contentDocument = win.document;
              }
            }
            return self2.contentDocument;
          },
          getBody: function() {
            var doc2 = this.getDoc();
            return this.bodyElement || (doc2 ? doc2.body : null);
          },
          convertURL: function(url2, name2, elm) {
            var self2 = this, settings = self2.settings;
            if (settings.urlconverter_callback) {
              return self2.execCallback("urlconverter_callback", url2, elm, true, name2);
            }
            if (!settings.convert_urls || elm && elm.nodeName === "LINK" || url2.indexOf("file:") === 0 || url2.length === 0) {
              return url2;
            }
            if (settings.relative_urls) {
              return self2.documentBaseURI.toRelative(url2);
            }
            url2 = self2.documentBaseURI.toAbsolute(url2, settings.remove_script_host);
            return url2;
          },
          addVisual: function(elm) {
            var self2 = this;
            var settings = self2.settings;
            var dom2 = self2.dom;
            var cls;
            elm = elm || self2.getBody();
            if (self2.hasVisual === void 0) {
              self2.hasVisual = settings.visual;
            }
            each$l(dom2.select("table,a", elm), function(elm2) {
              var value2;
              switch (elm2.nodeName) {
                case "TABLE":
                  cls = settings.visual_table_class || "mce-item-table";
                  value2 = dom2.getAttrib(elm2, "border");
                  if ((!value2 || value2 === "0") && self2.hasVisual) {
                    dom2.addClass(elm2, cls);
                  } else {
                    dom2.removeClass(elm2, cls);
                  }
                  return;
                case "A":
                  if (!dom2.getAttrib(elm2, "href")) {
                    value2 = dom2.getAttrib(elm2, "name") || elm2.id;
                    cls = settings.visual_anchor_class || "mce-item-anchor";
                    if (value2 && self2.hasVisual) {
                      dom2.addClass(elm2, cls);
                    } else {
                      dom2.removeClass(elm2, cls);
                    }
                  }
                  return;
              }
            });
            self2.fire("VisualAid", {
              element: elm,
              hasVisual: self2.hasVisual
            });
          },
          remove: function() {
            remove$7(this);
          },
          destroy: function(automatic) {
            destroy(this, automatic);
          },
          uploadImages: function(callback) {
            return this.editorUpload.uploadImages(callback);
          },
          _scanForImages: function() {
            return this.editorUpload.scanForImages();
          }
        };
        extend$4(Editor.prototype, EditorObservable$1);
        var isEditorUIElement = function(elm) {
          return elm.className.toString().indexOf("mce-") !== -1;
        };
        var FocusManager = { isEditorUIElement };
        var isManualNodeChange = function(e) {
          return e.type === "nodechange" && e.selectionChange;
        };
        var registerPageMouseUp = function(editor, throttledStore) {
          var mouseUpPage = function() {
            throttledStore.throttle();
          };
          DOMUtils$1.DOM.bind(domGlobals.document, "mouseup", mouseUpPage);
          editor.on("remove", function() {
            DOMUtils$1.DOM.unbind(domGlobals.document, "mouseup", mouseUpPage);
          });
        };
        var registerFocusOut = function(editor) {
          editor.on("focusout", function() {
            SelectionBookmark.store(editor);
          });
        };
        var registerMouseUp = function(editor, throttledStore) {
          editor.on("mouseup touchend", function(e) {
            throttledStore.throttle();
          });
        };
        var registerEditorEvents = function(editor, throttledStore) {
          var browser2 = PlatformDetection$1.detect().browser;
          if (browser2.isIE()) {
            registerFocusOut(editor);
          } else {
            registerMouseUp(editor, throttledStore);
          }
          editor.on("keyup nodechange", function(e) {
            if (!isManualNodeChange(e)) {
              SelectionBookmark.store(editor);
            }
          });
        };
        var register$3 = function(editor) {
          var throttledStore = first(function() {
            SelectionBookmark.store(editor);
          }, 0);
          if (editor.inline) {
            registerPageMouseUp(editor, throttledStore);
          }
          editor.on("init", function() {
            registerEditorEvents(editor, throttledStore);
          });
          editor.on("remove", function() {
            throttledStore.cancel();
          });
        };
        var SelectionRestore = { register: register$3 };
        var documentFocusInHandler;
        var DOM$8 = DOMUtils$1.DOM;
        var isEditorUIElement$1 = function(elm) {
          return FocusManager.isEditorUIElement(elm);
        };
        var isUIElement = function(editor, elm) {
          var customSelector = editor ? editor.settings.custom_ui_selector : "";
          var parent2 = DOM$8.getParent(elm, function(elm2) {
            return isEditorUIElement$1(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
          });
          return parent2 !== null;
        };
        var getActiveElement = function() {
          try {
            return domGlobals.document.activeElement;
          } catch (ex) {
            return domGlobals.document.body;
          }
        };
        var registerEvents = function(editorManager, e) {
          var editor = e.editor;
          SelectionRestore.register(editor);
          editor.on("focusin", function() {
            var self2 = this;
            var focusedEditor = editorManager.focusedEditor;
            if (focusedEditor !== self2) {
              if (focusedEditor) {
                focusedEditor.fire("blur", { focusedEditor: self2 });
              }
              editorManager.setActive(self2);
              editorManager.focusedEditor = self2;
              self2.fire("focus", { blurredEditor: focusedEditor });
              self2.focus(true);
            }
          });
          editor.on("focusout", function() {
            var self2 = this;
            Delay.setEditorTimeout(self2, function() {
              var focusedEditor = editorManager.focusedEditor;
              if (!isUIElement(self2, getActiveElement()) && focusedEditor === self2) {
                self2.fire("blur", { focusedEditor: null });
                editorManager.focusedEditor = null;
              }
            });
          });
          if (!documentFocusInHandler) {
            documentFocusInHandler = function(e2) {
              var activeEditor = editorManager.activeEditor;
              var target2;
              target2 = e2.target;
              if (activeEditor && target2.ownerDocument === domGlobals.document) {
                if (target2 !== domGlobals.document.body && !isUIElement(activeEditor, target2) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.fire("blur", { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            };
            DOM$8.bind(domGlobals.document, "focusin", documentFocusInHandler);
          }
        };
        var unregisterDocumentEvents = function(editorManager, e) {
          if (editorManager.focusedEditor === e.editor) {
            editorManager.focusedEditor = null;
          }
          if (!editorManager.activeEditor) {
            DOM$8.unbind(domGlobals.document, "focusin", documentFocusInHandler);
            documentFocusInHandler = null;
          }
        };
        var setup$h = function(editorManager) {
          editorManager.on("AddEditor", curry(registerEvents, editorManager));
          editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
        };
        var FocusController = {
          setup: setup$h,
          isEditorUIElement: isEditorUIElement$1,
          isUIElement
        };
        var DOM$9 = DOMUtils$1.DOM;
        var explode$4 = Tools.explode, each$m = Tools.each, extend$5 = Tools.extend;
        var instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;
        var legacyEditors = [];
        var editors2 = [];
        var isValidLegacyKey = function(id) {
          return id !== "length";
        };
        var globalEventDelegate = function(e) {
          var type2 = e.type;
          each$m(EditorManager.get(), function(editor) {
            switch (type2) {
              case "scroll":
                editor.fire("ScrollWindow", e);
                break;
              case "resize":
                editor.fire("ResizeWindow", e);
                break;
            }
          });
        };
        var toggleGlobalEvents = function(state) {
          if (state !== boundGlobalEvents) {
            if (state) {
              DomQuery(window).on("resize scroll", globalEventDelegate);
            } else {
              DomQuery(window).off("resize scroll", globalEventDelegate);
            }
            boundGlobalEvents = state;
          }
        };
        var removeEditorFromList = function(targetEditor) {
          var oldEditors = editors2;
          delete legacyEditors[targetEditor.id];
          for (var i2 = 0; i2 < legacyEditors.length; i2++) {
            if (legacyEditors[i2] === targetEditor) {
              legacyEditors.splice(i2, 1);
              break;
            }
          }
          editors2 = filter(editors2, function(editor) {
            return targetEditor !== editor;
          });
          if (EditorManager.activeEditor === targetEditor) {
            EditorManager.activeEditor = editors2.length > 0 ? editors2[0] : null;
          }
          if (EditorManager.focusedEditor === targetEditor) {
            EditorManager.focusedEditor = null;
          }
          return oldEditors.length !== editors2.length;
        };
        var purgeDestroyedEditor = function(editor) {
          if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
            removeEditorFromList(editor);
            editor.unbindAllNativeEvents();
            editor.destroy(true);
            editor.removed = true;
            editor = null;
          }
          return editor;
        };
        EditorManager = {
          defaultSettings: {},
          $: DomQuery,
          majorVersion: "4",
          minorVersion: "9.11",
          releaseDate: "2020-07-13",
          editors: legacyEditors,
          i18n: I18n,
          activeEditor: null,
          settings: {},
          setup: function() {
            var self2 = this;
            var baseURL, documentBaseURL, suffix = "";
            documentBaseURL = URI.getDocumentBaseUrl(domGlobals.document.location);
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
              documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
              if (!/[\/\\]$/.test(documentBaseURL)) {
                documentBaseURL += "/";
              }
            }
            var preInit = window.tinymce || window.tinyMCEPreInit;
            if (preInit) {
              baseURL = preInit.base || preInit.baseURL;
              suffix = preInit.suffix;
            } else {
              var scripts = domGlobals.document.getElementsByTagName("script");
              for (var i2 = 0; i2 < scripts.length; i2++) {
                var src2 = scripts[i2].src || "";
                if (src2 === "") {
                  continue;
                }
                var srcScript = src2.substring(src2.lastIndexOf("/"));
                if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src2)) {
                  if (srcScript.indexOf(".min") !== -1) {
                    suffix = ".min";
                  }
                  baseURL = src2.substring(0, src2.lastIndexOf("/"));
                  break;
                }
              }
              if (!baseURL && domGlobals.document.currentScript) {
                var src2 = domGlobals.document.currentScript.src;
                if (src2.indexOf(".min") !== -1) {
                  suffix = ".min";
                }
                baseURL = src2.substring(0, src2.lastIndexOf("/"));
              }
            }
            self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
            self2.documentBaseURL = documentBaseURL;
            self2.baseURI = new URI(self2.baseURL);
            self2.suffix = suffix;
            FocusController.setup(self2);
          },
          overrideDefaults: function(defaultSettings) {
            var baseUrl, suffix;
            baseUrl = defaultSettings.base_url;
            if (baseUrl) {
              this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
              this.baseURI = new URI(this.baseURL);
            }
            suffix = defaultSettings.suffix;
            if (defaultSettings.suffix) {
              this.suffix = suffix;
            }
            this.defaultSettings = defaultSettings;
            var pluginBaseUrls = defaultSettings.plugin_base_urls;
            for (var name2 in pluginBaseUrls) {
              AddOnManager.PluginManager.urls[name2] = pluginBaseUrls[name2];
            }
          },
          init: function(settings) {
            var self2 = this;
            var result, invalidInlineTargets;
            invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option tbody tfoot thead tr script noscript style textarea video audio iframe object menu", " ");
            var isInvalidInlineTarget = function(settings2, elm) {
              return settings2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
            };
            var createId = function(elm) {
              var id = elm.id;
              if (!id) {
                id = elm.name;
                if (id && !DOM$9.get(id)) {
                  id = elm.name;
                } else {
                  id = DOM$9.uniqueId();
                }
                elm.setAttribute("id", id);
              }
              return id;
            };
            var execCallback = function(name2) {
              var callback = settings[name2];
              if (!callback) {
                return;
              }
              return callback.apply(self2, Array.prototype.slice.call(arguments, 2));
            };
            var hasClass2 = function(elm, className) {
              return className.constructor === RegExp ? className.test(elm.className) : DOM$9.hasClass(elm, className);
            };
            var findTargets = function(settings2) {
              var l, targets = [];
              if (Env.ie && Env.ie < 11) {
                ErrorReporter.initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/");
                return [];
              }
              if (settings2.types) {
                each$m(settings2.types, function(type2) {
                  targets = targets.concat(DOM$9.select(type2.selector));
                });
                return targets;
              } else if (settings2.selector) {
                return DOM$9.select(settings2.selector);
              } else if (settings2.target) {
                return [settings2.target];
              }
              switch (settings2.mode) {
                case "exact":
                  l = settings2.elements || "";
                  if (l.length > 0) {
                    each$m(explode$4(l), function(id) {
                      var elm;
                      if (elm = DOM$9.get(id)) {
                        targets.push(elm);
                      } else {
                        each$m(domGlobals.document.forms, function(f) {
                          each$m(f.elements, function(e) {
                            if (e.name === id) {
                              id = "mce_editor_" + instanceCounter++;
                              DOM$9.setAttrib(e, "id", id);
                              targets.push(e);
                            }
                          });
                        });
                      }
                    });
                  }
                  break;
                case "textareas":
                case "specific_textareas":
                  each$m(DOM$9.select("textarea"), function(elm) {
                    if (settings2.editor_deselector && hasClass2(elm, settings2.editor_deselector)) {
                      return;
                    }
                    if (!settings2.editor_selector || hasClass2(elm, settings2.editor_selector)) {
                      targets.push(elm);
                    }
                  });
                  break;
              }
              return targets;
            };
            var provideResults = function(editors3) {
              result = editors3;
            };
            var initEditors = function() {
              var initCount = 0;
              var editors3 = [];
              var targets;
              var createEditor = function(id, settings2, targetElm) {
                var editor = new Editor(id, settings2, self2);
                editors3.push(editor);
                editor.on("init", function() {
                  if (++initCount === targets.length) {
                    provideResults(editors3);
                  }
                });
                editor.targetElm = editor.targetElm || targetElm;
                editor.render();
              };
              DOM$9.unbind(window, "ready", initEditors);
              execCallback("onpageload");
              targets = DomQuery.unique(findTargets(settings));
              if (settings.types) {
                each$m(settings.types, function(type2) {
                  Tools.each(targets, function(elm) {
                    if (DOM$9.is(elm, type2.selector)) {
                      createEditor(createId(elm), extend$5({}, settings, type2), elm);
                      return false;
                    }
                    return true;
                  });
                });
                return;
              }
              Tools.each(targets, function(elm) {
                purgeDestroyedEditor(self2.get(elm.id));
              });
              targets = Tools.grep(targets, function(elm) {
                return !self2.get(elm.id);
              });
              if (targets.length === 0) {
                provideResults([]);
              } else {
                each$m(targets, function(elm) {
                  if (isInvalidInlineTarget(settings, elm)) {
                    ErrorReporter.initError("Could not initialize inline editor on invalid inline target element", elm);
                  } else {
                    createEditor(createId(elm), settings, elm);
                  }
                });
              }
            };
            self2.settings = settings;
            DOM$9.bind(window, "ready", initEditors);
            return new promiseObj(function(resolve2) {
              if (result) {
                resolve2(result);
              } else {
                provideResults = function(editors3) {
                  resolve2(editors3);
                };
              }
            });
          },
          get: function(id) {
            if (arguments.length === 0) {
              return editors2.slice(0);
            } else if (isString(id)) {
              return find(editors2, function(editor) {
                return editor.id === id;
              }).getOr(null);
            } else if (isNumber(id)) {
              return editors2[id] ? editors2[id] : null;
            } else {
              return null;
            }
          },
          add: function(editor) {
            var self2 = this;
            var existingEditor;
            existingEditor = legacyEditors[editor.id];
            if (existingEditor === editor) {
              return editor;
            }
            if (self2.get(editor.id) === null) {
              if (isValidLegacyKey(editor.id)) {
                legacyEditors[editor.id] = editor;
              }
              legacyEditors.push(editor);
              editors2.push(editor);
            }
            toggleGlobalEvents(true);
            self2.activeEditor = editor;
            self2.fire("AddEditor", { editor });
            if (!beforeUnloadDelegate) {
              beforeUnloadDelegate = function() {
                self2.fire("BeforeUnload");
              };
              DOM$9.bind(window, "beforeunload", beforeUnloadDelegate);
            }
            return editor;
          },
          createEditor: function(id, settings) {
            return this.add(new Editor(id, settings, this));
          },
          remove: function(selector) {
            var self2 = this;
            var i2, editor;
            if (!selector) {
              for (i2 = editors2.length - 1; i2 >= 0; i2--) {
                self2.remove(editors2[i2]);
              }
              return;
            }
            if (isString(selector)) {
              each$m(DOM$9.select(selector), function(elm) {
                editor = self2.get(elm.id);
                if (editor) {
                  self2.remove(editor);
                }
              });
              return;
            }
            editor = selector;
            if (isNull(self2.get(editor.id))) {
              return null;
            }
            if (removeEditorFromList(editor)) {
              self2.fire("RemoveEditor", { editor });
            }
            if (editors2.length === 0) {
              DOM$9.unbind(window, "beforeunload", beforeUnloadDelegate);
            }
            editor.remove();
            toggleGlobalEvents(editors2.length > 0);
            return editor;
          },
          execCommand: function(cmd, ui, value2) {
            var self2 = this, editor = self2.get(value2);
            switch (cmd) {
              case "mceAddEditor":
                if (!self2.get(value2)) {
                  new Editor(value2, self2.settings, self2).render();
                }
                return true;
              case "mceRemoveEditor":
                if (editor) {
                  editor.remove();
                }
                return true;
              case "mceToggleEditor":
                if (!editor) {
                  self2.execCommand("mceAddEditor", 0, value2);
                  return true;
                }
                if (editor.isHidden()) {
                  editor.show();
                } else {
                  editor.hide();
                }
                return true;
            }
            if (self2.activeEditor) {
              return self2.activeEditor.execCommand(cmd, ui, value2);
            }
            return false;
          },
          triggerSave: function() {
            each$m(editors2, function(editor) {
              editor.save();
            });
          },
          addI18n: function(code3, items) {
            I18n.add(code3, items);
          },
          translate: function(text2) {
            return I18n.translate(text2);
          },
          setActive: function(editor) {
            var activeEditor = this.activeEditor;
            if (this.activeEditor !== editor) {
              if (activeEditor) {
                activeEditor.fire("deactivate", { relatedTarget: editor });
              }
              editor.fire("activate", { relatedTarget: activeEditor });
            }
            this.activeEditor = editor;
          }
        };
        extend$5(EditorManager, Observable);
        EditorManager.setup();
        var EditorManager$1 = EditorManager;
        function RangeUtils(dom2) {
          var walk2 = function(rng, callback) {
            return RangeWalk.walk(dom2, rng, callback);
          };
          var split2 = SplitRange.split;
          var normalize3 = function(rng) {
            return NormalizeRange.normalize(dom2, rng).fold(constant(false), function(normalizedRng) {
              rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
              rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
              return true;
            });
          };
          return {
            walk: walk2,
            split: split2,
            normalize: normalize3
          };
        }
        (function(RangeUtils2) {
          RangeUtils2.compareRanges = RangeCompare.isEq;
          RangeUtils2.getCaretRangeFromPoint = CaretRangeFromPoint.fromPoint;
          RangeUtils2.getSelectedNode = getSelectedNode;
          RangeUtils2.getNode = getNode;
        })(RangeUtils || (RangeUtils = {}));
        var RangeUtils$1 = RangeUtils;
        var min = Math.min, max = Math.max, round$2 = Math.round;
        var relativePosition = function(rect2, targetRect, rel) {
          var x, y, w, h, targetW, targetH;
          x = targetRect.x;
          y = targetRect.y;
          w = rect2.w;
          h = rect2.h;
          targetW = targetRect.w;
          targetH = targetRect.h;
          rel = (rel || "").split("");
          if (rel[0] === "b") {
            y += targetH;
          }
          if (rel[1] === "r") {
            x += targetW;
          }
          if (rel[0] === "c") {
            y += round$2(targetH / 2);
          }
          if (rel[1] === "c") {
            x += round$2(targetW / 2);
          }
          if (rel[3] === "b") {
            y -= h;
          }
          if (rel[4] === "r") {
            x -= w;
          }
          if (rel[3] === "c") {
            y -= round$2(h / 2);
          }
          if (rel[4] === "c") {
            x -= round$2(w / 2);
          }
          return create$4(x, y, w, h);
        };
        var findBestRelativePosition = function(rect2, targetRect, constrainRect, rels) {
          var pos, i2;
          for (i2 = 0; i2 < rels.length; i2++) {
            pos = relativePosition(rect2, targetRect, rels[i2]);
            if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
              return rels[i2];
            }
          }
          return null;
        };
        var inflate = function(rect2, w, h) {
          return create$4(rect2.x - w, rect2.y - h, rect2.w + w * 2, rect2.h + h * 2);
        };
        var intersect = function(rect2, cropRect) {
          var x1, y1, x2, y2;
          x1 = max(rect2.x, cropRect.x);
          y1 = max(rect2.y, cropRect.y);
          x2 = min(rect2.x + rect2.w, cropRect.x + cropRect.w);
          y2 = min(rect2.y + rect2.h, cropRect.y + cropRect.h);
          if (x2 - x1 < 0 || y2 - y1 < 0) {
            return null;
          }
          return create$4(x1, y1, x2 - x1, y2 - y1);
        };
        var clamp$1 = function(rect2, clampRect, fixedSize) {
          var underflowX1, underflowY1, overflowX2, overflowY2, x1, y1, x2, y2, cx2, cy2;
          x1 = rect2.x;
          y1 = rect2.y;
          x2 = rect2.x + rect2.w;
          y2 = rect2.y + rect2.h;
          cx2 = clampRect.x + clampRect.w;
          cy2 = clampRect.y + clampRect.h;
          underflowX1 = max(0, clampRect.x - x1);
          underflowY1 = max(0, clampRect.y - y1);
          overflowX2 = max(0, x2 - cx2);
          overflowY2 = max(0, y2 - cy2);
          x1 += underflowX1;
          y1 += underflowY1;
          if (fixedSize) {
            x2 += underflowX1;
            y2 += underflowY1;
            x1 -= overflowX2;
            y1 -= overflowY2;
          }
          x2 -= overflowX2;
          y2 -= overflowY2;
          return create$4(x1, y1, x2 - x1, y2 - y1);
        };
        var create$4 = function(x, y, w, h) {
          return {
            x,
            y,
            w,
            h
          };
        };
        var fromClientRect = function(clientRect) {
          return create$4(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
        };
        var Rect = {
          inflate,
          relativePosition,
          findBestRelativePosition,
          intersect,
          clamp: clamp$1,
          create: create$4,
          fromClientRect
        };
        var types = {};
        var Factory = {
          add: function(type2, typeClass) {
            types[type2.toLowerCase()] = typeClass;
          },
          has: function(type2) {
            return !!types[type2.toLowerCase()];
          },
          get: function(type2) {
            var lctype = type2.toLowerCase();
            var controlType = types.hasOwnProperty(lctype) ? types[lctype] : null;
            if (controlType === null) {
              throw new Error("Could not find module for type: " + type2);
            }
            return controlType;
          },
          create: function(type2, settings) {
            var ControlType;
            if (typeof type2 === "string") {
              settings = settings || {};
              settings.type = type2;
            } else {
              settings = type2;
              type2 = settings.type;
            }
            type2 = type2.toLowerCase();
            ControlType = types[type2];
            if (!ControlType) {
              throw new Error("Could not find control by type: " + type2);
            }
            ControlType = new ControlType(settings);
            ControlType.type = type2;
            return ControlType;
          }
        };
        var each$n = Tools.each, extend$6 = Tools.extend;
        var extendClass, initializing;
        var Class = function() {
        };
        Class.extend = extendClass = function(prop2) {
          var self2 = this;
          var _super = self2.prototype;
          var prototype, name2, member;
          var Class2 = function() {
            var i2, mixins, mixin;
            var self3 = this;
            if (!initializing) {
              if (self3.init) {
                self3.init.apply(self3, arguments);
              }
              mixins = self3.Mixins;
              if (mixins) {
                i2 = mixins.length;
                while (i2--) {
                  mixin = mixins[i2];
                  if (mixin.init) {
                    mixin.init.apply(self3, arguments);
                  }
                }
              }
            }
          };
          var dummy = function() {
            return this;
          };
          var createMethod = function(name3, fn) {
            return function() {
              var self3 = this;
              var tmp = self3._super;
              var ret;
              self3._super = _super[name3];
              ret = fn.apply(self3, arguments);
              self3._super = tmp;
              return ret;
            };
          };
          initializing = true;
          prototype = new self2();
          initializing = false;
          if (prop2.Mixins) {
            each$n(prop2.Mixins, function(mixin) {
              for (var name_1 in mixin) {
                if (name_1 !== "init") {
                  prop2[name_1] = mixin[name_1];
                }
              }
            });
            if (_super.Mixins) {
              prop2.Mixins = _super.Mixins.concat(prop2.Mixins);
            }
          }
          if (prop2.Methods) {
            each$n(prop2.Methods.split(","), function(name3) {
              prop2[name3] = dummy;
            });
          }
          if (prop2.Properties) {
            each$n(prop2.Properties.split(","), function(name3) {
              var fieldName = "_" + name3;
              prop2[name3] = function(value2) {
                var self3 = this;
                if (value2 !== void 0) {
                  self3[fieldName] = value2;
                  return self3;
                }
                return self3[fieldName];
              };
            });
          }
          if (prop2.Statics) {
            each$n(prop2.Statics, function(func, name3) {
              Class2[name3] = func;
            });
          }
          if (prop2.Defaults && _super.Defaults) {
            prop2.Defaults = extend$6({}, _super.Defaults, prop2.Defaults);
          }
          for (name2 in prop2) {
            member = prop2[name2];
            if (typeof member === "function" && _super[name2]) {
              prototype[name2] = createMethod(name2, member);
            } else {
              prototype[name2] = member;
            }
          }
          Class2.prototype = prototype;
          Class2.constructor = Class2;
          Class2.extend = extendClass;
          return Class2;
        };
        var min$1 = Math.min, max$1 = Math.max, round$3 = Math.round;
        var Color = function(value2) {
          var self2 = {};
          var r = 0, g = 0, b = 0;
          var rgb2hsv = function(r2, g2, b2) {
            var h, s, v, d, minRGB, maxRGB;
            h = 0;
            s = 0;
            v = 0;
            r2 = r2 / 255;
            g2 = g2 / 255;
            b2 = b2 / 255;
            minRGB = min$1(r2, min$1(g2, b2));
            maxRGB = max$1(r2, max$1(g2, b2));
            if (minRGB === maxRGB) {
              v = minRGB;
              return {
                h: 0,
                s: 0,
                v: v * 100
              };
            }
            d = r2 === minRGB ? g2 - b2 : b2 === minRGB ? r2 - g2 : b2 - r2;
            h = r2 === minRGB ? 3 : b2 === minRGB ? 1 : 5;
            h = 60 * (h - d / (maxRGB - minRGB));
            s = (maxRGB - minRGB) / maxRGB;
            v = maxRGB;
            return {
              h: round$3(h),
              s: round$3(s * 100),
              v: round$3(v * 100)
            };
          };
          var hsvToRgb = function(hue, saturation, brightness) {
            var side, chroma, x, match2;
            hue = (parseInt(hue, 10) || 0) % 360;
            saturation = parseInt(saturation, 10) / 100;
            brightness = parseInt(brightness, 10) / 100;
            saturation = max$1(0, min$1(saturation, 1));
            brightness = max$1(0, min$1(brightness, 1));
            if (saturation === 0) {
              r = g = b = round$3(255 * brightness);
              return;
            }
            side = hue / 60;
            chroma = brightness * saturation;
            x = chroma * (1 - Math.abs(side % 2 - 1));
            match2 = brightness - chroma;
            switch (Math.floor(side)) {
              case 0:
                r = chroma;
                g = x;
                b = 0;
                break;
              case 1:
                r = x;
                g = chroma;
                b = 0;
                break;
              case 2:
                r = 0;
                g = chroma;
                b = x;
                break;
              case 3:
                r = 0;
                g = x;
                b = chroma;
                break;
              case 4:
                r = x;
                g = 0;
                b = chroma;
                break;
              case 5:
                r = chroma;
                g = 0;
                b = x;
                break;
              default:
                r = g = b = 0;
            }
            r = round$3(255 * (r + match2));
            g = round$3(255 * (g + match2));
            b = round$3(255 * (b + match2));
          };
          var toHex2 = function() {
            var hex = function(val) {
              val = parseInt(val, 10).toString(16);
              return val.length > 1 ? val : "0" + val;
            };
            return "#" + hex(r) + hex(g) + hex(b);
          };
          var toRgb = function() {
            return {
              r,
              g,
              b
            };
          };
          var toHsv = function() {
            return rgb2hsv(r, g, b);
          };
          var parse2 = function(value3) {
            var matches2;
            if (typeof value3 === "object") {
              if ("r" in value3) {
                r = value3.r;
                g = value3.g;
                b = value3.b;
              } else if ("v" in value3) {
                hsvToRgb(value3.h, value3.s, value3.v);
              }
            } else {
              if (matches2 = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value3)) {
                r = parseInt(matches2[1], 10);
                g = parseInt(matches2[2], 10);
                b = parseInt(matches2[3], 10);
              } else if (matches2 = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value3)) {
                r = parseInt(matches2[1], 16);
                g = parseInt(matches2[2], 16);
                b = parseInt(matches2[3], 16);
              } else if (matches2 = /#([0-F])([0-F])([0-F])/gi.exec(value3)) {
                r = parseInt(matches2[1] + matches2[1], 16);
                g = parseInt(matches2[2] + matches2[2], 16);
                b = parseInt(matches2[3] + matches2[3], 16);
              }
            }
            r = r < 0 ? 0 : r > 255 ? 255 : r;
            g = g < 0 ? 0 : g > 255 ? 255 : g;
            b = b < 0 ? 0 : b > 255 ? 255 : b;
            return self2;
          };
          if (value2) {
            parse2(value2);
          }
          self2.toRgb = toRgb;
          self2.toHsv = toHsv;
          self2.toHex = toHex2;
          self2.parse = parse2;
          return self2;
        };
        var serialize = function(o, quote) {
          var i2, v, t, name2;
          quote = quote || '"';
          if (o === null) {
            return "null";
          }
          t = typeof o;
          if (t === "string") {
            v = `\bb	t
n\ff\rr""''\\\\`;
            return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
              if (quote === '"' && a === "'") {
                return a;
              }
              i2 = v.indexOf(b);
              if (i2 + 1) {
                return "\\" + v.charAt(i2 + 1);
              }
              a = b.charCodeAt().toString(16);
              return "\\u" + "0000".substring(a.length) + a;
            }) + quote;
          }
          if (t === "object") {
            if (o.hasOwnProperty && Object.prototype.toString.call(o) === "[object Array]") {
              for (i2 = 0, v = "["; i2 < o.length; i2++) {
                v += (i2 > 0 ? "," : "") + serialize(o[i2], quote);
              }
              return v + "]";
            }
            v = "{";
            for (name2 in o) {
              if (o.hasOwnProperty(name2)) {
                v += typeof o[name2] !== "function" ? (v.length > 1 ? "," + quote : quote) + name2 + quote + ":" + serialize(o[name2], quote) : "";
              }
            }
            return v + "}";
          }
          return "" + o;
        };
        var JSON$1 = {
          serialize,
          parse: function(text2) {
            try {
              return JSON.parse(text2);
            } catch (ex) {
            }
          }
        };
        var JSONP = {
          callbacks: {},
          count: 0,
          send: function(settings) {
            var self2 = this, dom2 = DOMUtils$1.DOM, count2 = settings.count !== void 0 ? settings.count : self2.count;
            var id = "tinymce_jsonp_" + count2;
            self2.callbacks[count2] = function(json) {
              dom2.remove(id);
              delete self2.callbacks[count2];
              settings.callback(json);
            };
            dom2.add(dom2.doc.body, "script", {
              id,
              src: settings.url,
              type: "text/javascript"
            });
            self2.count++;
          }
        };
        var XHR = {
          send: function(settings) {
            var xhr, count2 = 0;
            var ready = function() {
              if (!settings.async || xhr.readyState === 4 || count2++ > 1e4) {
                if (settings.success && count2 < 1e4 && xhr.status === 200) {
                  settings.success.call(settings.success_scope, "" + xhr.responseText, xhr, settings);
                } else if (settings.error) {
                  settings.error.call(settings.error_scope, count2 > 1e4 ? "TIMED_OUT" : "GENERAL", xhr, settings);
                }
                xhr = null;
              } else {
                setTimeout(ready, 10);
              }
            };
            settings.scope = settings.scope || this;
            settings.success_scope = settings.success_scope || settings.scope;
            settings.error_scope = settings.error_scope || settings.scope;
            settings.async = settings.async === false ? false : true;
            settings.data = settings.data || "";
            XHR.fire("beforeInitialize", { settings });
            xhr = XMLHttpRequest();
            if (xhr) {
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType(settings.content_type);
              }
              xhr.open(settings.type || (settings.data ? "POST" : "GET"), settings.url, settings.async);
              if (settings.crossDomain) {
                xhr.withCredentials = true;
              }
              if (settings.content_type) {
                xhr.setRequestHeader("Content-Type", settings.content_type);
              }
              if (settings.requestheaders) {
                Tools.each(settings.requestheaders, function(header) {
                  xhr.setRequestHeader(header.key, header.value);
                });
              }
              xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
              xhr = XHR.fire("beforeSend", {
                xhr,
                settings
              }).xhr;
              xhr.send(settings.data);
              if (!settings.async) {
                return ready();
              }
              setTimeout(ready, 10);
            }
          }
        };
        Tools.extend(XHR, Observable);
        var extend$7 = Tools.extend;
        var JSONRequest = function(settings) {
          this.settings = extend$7({}, settings);
          this.count = 0;
        };
        JSONRequest.sendRPC = function(o) {
          return new JSONRequest().send(o);
        };
        JSONRequest.prototype = {
          send: function(args) {
            var ecb = args.error, scb = args.success;
            args = extend$7(this.settings, args);
            args.success = function(c, x) {
              c = JSON$1.parse(c);
              if (typeof c === "undefined") {
                c = { error: "JSON Parse error." };
              }
              if (c.error) {
                ecb.call(args.error_scope || args.scope, c.error, x);
              } else {
                scb.call(args.success_scope || args.scope, c.result);
              }
            };
            args.error = function(ty, x) {
              if (ecb) {
                ecb.call(args.error_scope || args.scope, ty, x);
              }
            };
            args.data = JSON$1.serialize({
              id: args.id || "c" + this.count++,
              method: args.method,
              params: args.params
            });
            args.content_type = "application/json";
            XHR.send(args);
          }
        };
        var create$5 = function() {
          return (function() {
            var data2 = {};
            var keys2 = [];
            var storage = {
              getItem: function(key) {
                var item = data2[key];
                return item ? item : null;
              },
              setItem: function(key, value2) {
                keys2.push(key);
                data2[key] = String(value2);
              },
              key: function(index) {
                return keys2[index];
              },
              removeItem: function(key) {
                keys2 = keys2.filter(function(k) {
                  return k === key;
                });
                delete data2[key];
              },
              clear: function() {
                keys2 = [];
                data2 = {};
              },
              length: 0
            };
            Object.defineProperty(storage, "length", {
              get: function() {
                return keys2.length;
              },
              configurable: false,
              enumerable: false
            });
            return storage;
          })();
        };
        var localStorage;
        try {
          localStorage = domGlobals.window.localStorage;
        } catch (e) {
          localStorage = create$5();
        }
        var LocalStorage = localStorage;
        var tinymce2 = EditorManager$1;
        var publicApi = {
          geom: { Rect },
          util: {
            Promise: promiseObj,
            Delay,
            Tools,
            VK,
            URI,
            Class,
            EventDispatcher: Dispatcher,
            Observable,
            I18n,
            XHR,
            JSON: JSON$1,
            JSONRequest,
            JSONP,
            LocalStorage,
            Color
          },
          dom: {
            EventUtils,
            Sizzle,
            DomQuery,
            TreeWalker,
            DOMUtils: DOMUtils$1,
            ScriptLoader,
            RangeUtils: RangeUtils$1,
            Serializer: DomSerializer$1,
            ControlSelection,
            BookmarkManager: BookmarkManager$1,
            Selection: Selection$1,
            Event: EventUtils.Event
          },
          html: {
            Styles,
            Entities,
            Node: Node$1,
            Schema,
            SaxParser: SaxParser$1,
            DomParser,
            Writer,
            Serializer: HtmlSerializer
          },
          ui: { Factory },
          Env,
          AddOnManager,
          Annotator,
          Formatter,
          UndoManager,
          EditorCommands,
          WindowManager,
          NotificationManager,
          EditorObservable: EditorObservable$1,
          Shortcuts,
          Editor,
          FocusManager,
          EditorManager: EditorManager$1,
          DOM: DOMUtils$1.DOM,
          ScriptLoader: ScriptLoader.ScriptLoader,
          PluginManager: AddOnManager.PluginManager,
          ThemeManager: AddOnManager.ThemeManager,
          trim: Tools.trim,
          isArray: Tools.isArray,
          is: Tools.is,
          toArray: Tools.toArray,
          makeMap: Tools.makeMap,
          each: Tools.each,
          map: Tools.map,
          grep: Tools.grep,
          inArray: Tools.inArray,
          extend: Tools.extend,
          create: Tools.create,
          walk: Tools.walk,
          createNS: Tools.createNS,
          resolve: Tools.resolve,
          explode: Tools.explode,
          _addCacheSuffix: Tools._addCacheSuffix,
          isOpera: Env.opera,
          isWebKit: Env.webkit,
          isIE: Env.ie,
          isGecko: Env.gecko,
          isMac: Env.mac
        };
        tinymce2 = Tools.extend(tinymce2, publicApi);
        var Tinymce = tinymce2;
        var exportToModuleLoaders = function(tinymce3) {
          {
            try {
              module.exports = tinymce3;
            } catch (_) {
            }
          }
        };
        var exportToWindowGlobal = function(tinymce3) {
          window.tinymce = tinymce3;
          window.tinyMCE = tinymce3;
        };
        exportToWindowGlobal(Tinymce);
        exportToModuleLoaders(Tinymce);
      })(window);
    })();
  })(tinymce$2);
  return tinymce$2.exports;
}
var tinymceExports = requireTinymce();
const tinymce$1 = /* @__PURE__ */ getDefaultExportFromCjs(tinymceExports);
var theme = {};
var hasRequiredTheme;
function requireTheme() {
  if (hasRequiredTheme) return theme;
  hasRequiredTheme = 1;
  (function() {
    (function(domGlobals) {
      var global2 = tinymce.util.Tools.resolve("tinymce.ThemeManager");
      var global$1 = tinymce.util.Tools.resolve("tinymce.EditorManager");
      var global$2 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var isBrandingEnabled = function(editor) {
        return editor.getParam("branding", true, "boolean");
      };
      var hasMenubar = function(editor) {
        return getMenubar(editor) !== false;
      };
      var getMenubar = function(editor) {
        return editor.getParam("menubar");
      };
      var hasStatusbar = function(editor) {
        return editor.getParam("statusbar", true, "boolean");
      };
      var getToolbarSize = function(editor) {
        return editor.getParam("toolbar_items_size");
      };
      var isReadOnly = function(editor) {
        return editor.getParam("readonly", false, "boolean");
      };
      var getFixedToolbarContainer = function(editor) {
        return editor.getParam("fixed_toolbar_container");
      };
      var getInlineToolbarPositionHandler = function(editor) {
        return editor.getParam("inline_toolbar_position_handler");
      };
      var getMenu = function(editor) {
        return editor.getParam("menu");
      };
      var getRemovedMenuItems = function(editor) {
        return editor.getParam("removed_menuitems", "");
      };
      var getMinWidth = function(editor) {
        return editor.getParam("min_width", 100, "number");
      };
      var getMinHeight = function(editor) {
        return editor.getParam("min_height", 100, "number");
      };
      var getMaxWidth = function(editor) {
        return editor.getParam("max_width", 65535, "number");
      };
      var getMaxHeight = function(editor) {
        return editor.getParam("max_height", 65535, "number");
      };
      var isSkinDisabled = function(editor) {
        return editor.settings.skin === false;
      };
      var isInline = function(editor) {
        return editor.getParam("inline", false, "boolean");
      };
      var getResize = function(editor) {
        var resize = editor.getParam("resize", "vertical");
        if (resize === false) {
          return "none";
        } else if (resize === "both") {
          return "both";
        } else {
          return "vertical";
        }
      };
      var getSkinUrl = function(editor) {
        var settings = editor.settings;
        var skin = settings.skin;
        var skinUrl = settings.skin_url;
        if (skin !== false) {
          var skinName = skin ? skin : "lightgray";
          if (skinUrl) {
            skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
          } else {
            skinUrl = global$1.baseURL + "/skins/" + skinName;
          }
        }
        return skinUrl;
      };
      var getIndexedToolbars = function(settings, defaultToolbar) {
        var toolbars = [];
        for (var i = 1; i < 10; i++) {
          var toolbar = settings["toolbar" + i];
          if (!toolbar) {
            break;
          }
          toolbars.push(toolbar);
        }
        var mainToolbar = settings.toolbar ? [settings.toolbar] : [defaultToolbar];
        return toolbars.length > 0 ? toolbars : mainToolbar;
      };
      var getToolbars = function(editor) {
        var toolbar = editor.getParam("toolbar");
        var defaultToolbar = "undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image";
        if (toolbar === false) {
          return [];
        } else if (global$2.isArray(toolbar)) {
          return global$2.grep(toolbar, function(toolbar2) {
            return toolbar2.length > 0;
          });
        } else {
          return getIndexedToolbars(editor.settings, defaultToolbar);
        }
      };
      var global$3 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
      var global$4 = tinymce.util.Tools.resolve("tinymce.ui.Factory");
      var global$5 = tinymce.util.Tools.resolve("tinymce.util.I18n");
      var fireSkinLoaded = function(editor) {
        return editor.fire("SkinLoaded");
      };
      var fireResizeEditor = function(editor) {
        return editor.fire("ResizeEditor");
      };
      var fireBeforeRenderUI = function(editor) {
        return editor.fire("BeforeRenderUI");
      };
      var Events = {
        fireSkinLoaded,
        fireResizeEditor,
        fireBeforeRenderUI
      };
      var focus = function(panel, type) {
        return function() {
          var item = panel.find(type)[0];
          if (item) {
            item.focus(true);
          }
        };
      };
      var addKeys = function(editor, panel) {
        editor.shortcuts.add("Alt+F9", "", focus(panel, "menubar"));
        editor.shortcuts.add("Alt+F10,F10", "", focus(panel, "toolbar"));
        editor.shortcuts.add("Alt+F11", "", focus(panel, "elementpath"));
        panel.on("cancel", function() {
          editor.focus();
        });
      };
      var A11y = { addKeys };
      var global$6 = tinymce.util.Tools.resolve("tinymce.geom.Rect");
      var global$7 = tinymce.util.Tools.resolve("tinymce.util.Delay");
      var noop = function() {
      };
      var constant = function(value) {
        return function() {
          return value;
        };
      };
      var never = constant(false);
      var always = constant(true);
      var none = function() {
        return NONE;
      };
      var NONE = (function() {
        var eq = function(o) {
          return o.isNone();
        };
        var call = function(thunk) {
          return thunk();
        };
        var id = function(n) {
          return n;
        };
        var me = {
          fold: function(n, s) {
            return n();
          },
          is: never,
          isSome: never,
          isNone: always,
          getOr: id,
          getOrThunk: call,
          getOrDie: function(msg) {
            throw new Error(msg || "error: getOrDie called on none.");
          },
          getOrNull: constant(null),
          getOrUndefined: constant(void 0),
          or: id,
          orThunk: call,
          map: none,
          each: noop,
          bind: none,
          exists: never,
          forall: always,
          filter: none,
          equals: eq,
          equals_: eq,
          toArray: function() {
            return [];
          },
          toString: constant("none()")
        };
        if (Object.freeze) {
          Object.freeze(me);
        }
        return me;
      })();
      var some = function(a) {
        var constant_a = constant(a);
        var self2 = function() {
          return me;
        };
        var bind = function(f) {
          return f(a);
        };
        var me = {
          fold: function(n, s) {
            return s(a);
          },
          is: function(v) {
            return a === v;
          },
          isSome: always,
          isNone: never,
          getOr: constant_a,
          getOrThunk: constant_a,
          getOrDie: constant_a,
          getOrNull: constant_a,
          getOrUndefined: constant_a,
          or: self2,
          orThunk: self2,
          map: function(f) {
            return some(f(a));
          },
          each: function(f) {
            f(a);
          },
          bind,
          exists: bind,
          forall: bind,
          filter: function(f) {
            return f(a) ? me : NONE;
          },
          toArray: function() {
            return [a];
          },
          toString: function() {
            return "some(" + a + ")";
          },
          equals: function(o) {
            return o.is(a);
          },
          equals_: function(o, elementEq) {
            return o.fold(never, function(b) {
              return elementEq(a, b);
            });
          }
        };
        return me;
      };
      var from = function(value) {
        return value === null || value === void 0 ? NONE : some(value);
      };
      var Option = {
        some,
        none,
        from
      };
      var getUiContainerDelta = function(ctrl) {
        var uiContainer = getUiContainer(ctrl);
        if (uiContainer && global$3.DOM.getStyle(uiContainer, "position", true) !== "static") {
          var containerPos = global$3.DOM.getPos(uiContainer);
          var dx = uiContainer.scrollLeft - containerPos.x;
          var dy = uiContainer.scrollTop - containerPos.y;
          return Option.some({
            x: dx,
            y: dy
          });
        } else {
          return Option.none();
        }
      };
      var setUiContainer = function(editor, ctrl) {
        var uiContainer = global$3.DOM.select(editor.settings.ui_container)[0];
        ctrl.getRoot().uiContainer = uiContainer;
      };
      var getUiContainer = function(ctrl) {
        return ctrl ? ctrl.getRoot().uiContainer : null;
      };
      var inheritUiContainer = function(fromCtrl, toCtrl) {
        return toCtrl.uiContainer = getUiContainer(fromCtrl);
      };
      var UiContainer = {
        getUiContainerDelta,
        setUiContainer,
        getUiContainer,
        inheritUiContainer
      };
      var createToolbar = function(editor, items, size) {
        var toolbarItems = [];
        var buttonGroup;
        if (!items) {
          return;
        }
        global$2.each(items.split(/[ ,]/), function(item) {
          var itemName;
          var bindSelectorChanged = function() {
            var selection = editor.selection;
            if (item.settings.stateSelector) {
              selection.selectorChanged(item.settings.stateSelector, function(state) {
                item.active(state);
              }, true);
            }
            if (item.settings.disabledStateSelector) {
              selection.selectorChanged(item.settings.disabledStateSelector, function(state) {
                item.disabled(state);
              });
            }
          };
          if (item === "|") {
            buttonGroup = null;
          } else {
            if (!buttonGroup) {
              buttonGroup = {
                type: "buttongroup",
                items: []
              };
              toolbarItems.push(buttonGroup);
            }
            if (editor.buttons[item]) {
              itemName = item;
              item = editor.buttons[itemName];
              if (typeof item === "function") {
                item = item();
              }
              item.type = item.type || "button";
              item.size = size;
              item = global$4.create(item);
              buttonGroup.items.push(item);
              if (editor.initialized) {
                bindSelectorChanged();
              } else {
                editor.on("init", bindSelectorChanged);
              }
            }
          }
        });
        return {
          type: "toolbar",
          layout: "flow",
          items: toolbarItems
        };
      };
      var createToolbars = function(editor, size) {
        var toolbars = [];
        var addToolbar = function(items) {
          if (items) {
            toolbars.push(createToolbar(editor, items, size));
          }
        };
        global$2.each(getToolbars(editor), function(toolbar) {
          addToolbar(toolbar);
        });
        if (toolbars.length) {
          return {
            type: "panel",
            layout: "stack",
            classes: "toolbar-grp",
            ariaRoot: true,
            ariaRemember: true,
            items: toolbars
          };
        }
      };
      var Toolbar = {
        createToolbar,
        createToolbars
      };
      var DOM = global$3.DOM;
      var toClientRect = function(geomRect) {
        return {
          left: geomRect.x,
          top: geomRect.y,
          width: geomRect.w,
          height: geomRect.h,
          right: geomRect.x + geomRect.w,
          bottom: geomRect.y + geomRect.h
        };
      };
      var hideAllFloatingPanels = function(editor) {
        global$2.each(editor.contextToolbars, function(toolbar) {
          if (toolbar.panel) {
            toolbar.panel.hide();
          }
        });
      };
      var movePanelTo = function(panel, pos) {
        panel.moveTo(pos.left, pos.top);
      };
      var togglePositionClass = function(panel, relPos, predicate) {
        relPos = relPos ? relPos.substr(0, 2) : "";
        global$2.each({
          t: "down",
          b: "up"
        }, function(cls, pos) {
          panel.classes.toggle("arrow-" + cls, predicate(pos, relPos.substr(0, 1)));
        });
        global$2.each({
          l: "left",
          r: "right"
        }, function(cls, pos) {
          panel.classes.toggle("arrow-" + cls, predicate(pos, relPos.substr(1, 1)));
        });
      };
      var userConstrain = function(handler, x, y, elementRect, contentAreaRect, panelRect) {
        panelRect = toClientRect({
          x,
          y,
          w: panelRect.w,
          h: panelRect.h
        });
        if (handler) {
          panelRect = handler({
            elementRect: toClientRect(elementRect),
            contentAreaRect: toClientRect(contentAreaRect),
            panelRect
          });
        }
        return panelRect;
      };
      var addContextualToolbars = function(editor) {
        var scrollContainer;
        var getContextToolbars = function() {
          return editor.contextToolbars || [];
        };
        var getElementRect = function(elm) {
          var pos, targetRect, root2;
          pos = DOM.getPos(editor.getContentAreaContainer());
          targetRect = editor.dom.getRect(elm);
          root2 = editor.dom.getRoot();
          if (root2.nodeName === "BODY") {
            targetRect.x -= root2.ownerDocument.documentElement.scrollLeft || root2.scrollLeft;
            targetRect.y -= root2.ownerDocument.documentElement.scrollTop || root2.scrollTop;
          }
          targetRect.x += pos.x;
          targetRect.y += pos.y;
          return targetRect;
        };
        var reposition = function(match, shouldShow) {
          var relPos, panelRect, elementRect, contentAreaRect, panel, relRect, testPositions, smallElementWidthThreshold;
          var handler = getInlineToolbarPositionHandler(editor);
          if (editor.removed) {
            return;
          }
          if (!match || !match.toolbar.panel) {
            hideAllFloatingPanels(editor);
            return;
          }
          testPositions = [
            "bc-tc",
            "tc-bc",
            "tl-bl",
            "bl-tl",
            "tr-br",
            "br-tr"
          ];
          panel = match.toolbar.panel;
          if (shouldShow) {
            panel.show();
          }
          elementRect = getElementRect(match.element);
          panelRect = DOM.getRect(panel.getEl());
          contentAreaRect = DOM.getRect(editor.getContentAreaContainer() || editor.getBody());
          var delta2 = UiContainer.getUiContainerDelta(panel).getOr({
            x: 0,
            y: 0
          });
          elementRect.x += delta2.x;
          elementRect.y += delta2.y;
          panelRect.x += delta2.x;
          panelRect.y += delta2.y;
          contentAreaRect.x += delta2.x;
          contentAreaRect.y += delta2.y;
          smallElementWidthThreshold = 25;
          if (DOM.getStyle(match.element, "display", true) !== "inline") {
            var clientRect = match.element.getBoundingClientRect();
            elementRect.w = clientRect.width;
            elementRect.h = clientRect.height;
          }
          if (!editor.inline) {
            contentAreaRect.w = editor.getDoc().documentElement.offsetWidth;
          }
          if (editor.selection.controlSelection.isResizable(match.element) && elementRect.w < smallElementWidthThreshold) {
            elementRect = global$6.inflate(elementRect, 0, 8);
          }
          relPos = global$6.findBestRelativePosition(panelRect, elementRect, contentAreaRect, testPositions);
          elementRect = global$6.clamp(elementRect, contentAreaRect);
          if (relPos) {
            relRect = global$6.relativePosition(panelRect, elementRect, relPos);
            movePanelTo(panel, userConstrain(handler, relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
          } else {
            contentAreaRect.h += panelRect.h;
            elementRect = global$6.intersect(contentAreaRect, elementRect);
            if (elementRect) {
              relPos = global$6.findBestRelativePosition(panelRect, elementRect, contentAreaRect, [
                "bc-tc",
                "bl-tl",
                "br-tr"
              ]);
              if (relPos) {
                relRect = global$6.relativePosition(panelRect, elementRect, relPos);
                movePanelTo(panel, userConstrain(handler, relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
              } else {
                movePanelTo(panel, userConstrain(handler, elementRect.x, elementRect.y, elementRect, contentAreaRect, panelRect));
              }
            } else {
              panel.hide();
            }
          }
          togglePositionClass(panel, relPos, function(pos1, pos2) {
            return pos1 === pos2;
          });
        };
        var repositionHandler = function(show) {
          return function() {
            var execute = function() {
              if (editor.selection) {
                reposition(findFrontMostMatch(editor.selection.getNode()), show);
              }
            };
            global$7.requestAnimationFrame(execute);
          };
        };
        var bindScrollEvent = function(panel) {
          if (!scrollContainer) {
            var reposition_1 = repositionHandler(true);
            var uiContainer_1 = UiContainer.getUiContainer(panel);
            scrollContainer = editor.selection.getScrollContainer() || editor.getWin();
            DOM.bind(scrollContainer, "scroll", reposition_1);
            DOM.bind(uiContainer_1, "scroll", reposition_1);
            editor.on("remove", function() {
              DOM.unbind(scrollContainer, "scroll", reposition_1);
              DOM.unbind(uiContainer_1, "scroll", reposition_1);
            });
          }
        };
        var showContextToolbar = function(match) {
          var panel;
          if (match.toolbar.panel) {
            match.toolbar.panel.show();
            reposition(match);
            return;
          }
          panel = global$4.create({
            type: "floatpanel",
            role: "dialog",
            classes: "tinymce tinymce-inline arrow",
            ariaLabel: "Inline toolbar",
            layout: "flex",
            direction: "column",
            align: "stretch",
            autohide: false,
            autofix: true,
            fixed: true,
            border: 1,
            items: Toolbar.createToolbar(editor, match.toolbar.items),
            oncancel: function() {
              editor.focus();
            }
          });
          UiContainer.setUiContainer(editor, panel);
          bindScrollEvent(panel);
          match.toolbar.panel = panel;
          panel.renderTo().reflow();
          reposition(match);
        };
        var hideAllContextToolbars = function() {
          global$2.each(getContextToolbars(), function(toolbar) {
            if (toolbar.panel) {
              toolbar.panel.hide();
            }
          });
        };
        var findFrontMostMatch = function(targetElm) {
          var i, y, parentsAndSelf;
          var toolbars = getContextToolbars();
          parentsAndSelf = editor.$(targetElm).parents().add(targetElm);
          for (i = parentsAndSelf.length - 1; i >= 0; i--) {
            for (y = toolbars.length - 1; y >= 0; y--) {
              if (toolbars[y].predicate(parentsAndSelf[i])) {
                return {
                  toolbar: toolbars[y],
                  element: parentsAndSelf[i]
                };
              }
            }
          }
          return null;
        };
        editor.on("click keyup setContent ObjectResized", function(e) {
          if (e.type === "setcontent" && !e.selection) {
            return;
          }
          global$7.setEditorTimeout(editor, function() {
            var match;
            match = findFrontMostMatch(editor.selection.getNode());
            if (match) {
              hideAllContextToolbars();
              showContextToolbar(match);
            } else {
              hideAllContextToolbars();
            }
          });
        });
        editor.on("blur hide contextmenu", hideAllContextToolbars);
        editor.on("ObjectResizeStart", function() {
          var match = findFrontMostMatch(editor.selection.getNode());
          if (match && match.toolbar.panel) {
            match.toolbar.panel.hide();
          }
        });
        editor.on("ResizeEditor ResizeWindow", repositionHandler(true));
        editor.on("nodeChange", repositionHandler(false));
        editor.on("remove", function() {
          global$2.each(getContextToolbars(), function(toolbar) {
            if (toolbar.panel) {
              toolbar.panel.remove();
            }
          });
          editor.contextToolbars = {};
        });
        editor.shortcuts.add("ctrl+F9", "", function() {
          var match = findFrontMostMatch(editor.selection.getNode());
          if (match && match.toolbar.panel) {
            match.toolbar.panel.items()[0].focus();
          }
        });
      };
      var ContextToolbars = { addContextualToolbars };
      var typeOf = function(x) {
        if (x === null) {
          return "null";
        }
        var t = typeof x;
        if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
          return "array";
        }
        if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
          return "string";
        }
        return t;
      };
      var isType = function(type) {
        return function(value) {
          return typeOf(value) === type;
        };
      };
      var isArray = isType("array");
      var isFunction = isType("function");
      var isNumber = isType("number");
      var nativeSlice = Array.prototype.slice;
      var nativeIndexOf = Array.prototype.indexOf;
      var nativePush = Array.prototype.push;
      var rawIndexOf = function(ts, t) {
        return nativeIndexOf.call(ts, t);
      };
      var indexOf = function(xs, x) {
        var r = rawIndexOf(xs, x);
        return r === -1 ? Option.none() : Option.some(r);
      };
      var exists = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return true;
          }
        }
        return false;
      };
      var map2 = function(xs, f) {
        var len = xs.length;
        var r = new Array(len);
        for (var i = 0; i < len; i++) {
          var x = xs[i];
          r[i] = f(x, i);
        }
        return r;
      };
      var each = function(xs, f) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          f(x, i);
        }
      };
      var filter = function(xs, pred) {
        var r = [];
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            r.push(x);
          }
        }
        return r;
      };
      var foldl = function(xs, f, acc) {
        each(xs, function(x) {
          acc = f(acc, x);
        });
        return acc;
      };
      var find = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return Option.some(x);
          }
        }
        return Option.none();
      };
      var findIndex = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return Option.some(i);
          }
        }
        return Option.none();
      };
      var flatten = function(xs) {
        var r = [];
        for (var i = 0, len = xs.length; i < len; ++i) {
          if (!isArray(xs[i])) {
            throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
          }
          nativePush.apply(r, xs[i]);
        }
        return r;
      };
      isFunction(Array.from) ? Array.from : function(x) {
        return nativeSlice.call(x);
      };
      var defaultMenus = {
        file: {
          title: "File",
          items: "newdocument restoredraft | preview | print"
        },
        edit: {
          title: "Edit",
          items: "undo redo | cut copy paste pastetext | selectall"
        },
        view: {
          title: "View",
          items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen"
        },
        insert: {
          title: "Insert",
          items: "image link media template codesample inserttable | charmap hr | pagebreak nonbreaking anchor toc | insertdatetime"
        },
        format: {
          title: "Format",
          items: "bold italic underline strikethrough superscript subscript codeformat | blockformats align | removeformat"
        },
        tools: {
          title: "Tools",
          items: "spellchecker spellcheckerlanguage | a11ycheck code"
        },
        table: { title: "Table" },
        help: { title: "Help" }
      };
      var delimiterMenuNamePair = function() {
        return {
          name: "|",
          item: { text: "|" }
        };
      };
      var createMenuNameItemPair = function(name, item) {
        var menuItem = item ? {
          name,
          item
        } : null;
        return name === "|" ? delimiterMenuNamePair() : menuItem;
      };
      var hasItemName = function(namedMenuItems, name) {
        return findIndex(namedMenuItems, function(namedMenuItem) {
          return namedMenuItem.name === name;
        }).isSome();
      };
      var isSeparator = function(namedMenuItem) {
        return namedMenuItem && namedMenuItem.item.text === "|";
      };
      var cleanupMenu = function(namedMenuItems, removedMenuItems) {
        var menuItemsPass1 = filter(namedMenuItems, function(namedMenuItem) {
          return removedMenuItems.hasOwnProperty(namedMenuItem.name) === false;
        });
        var menuItemsPass2 = filter(menuItemsPass1, function(namedMenuItem, i) {
          return !isSeparator(namedMenuItem) || !isSeparator(menuItemsPass1[i - 1]);
        });
        return filter(menuItemsPass2, function(namedMenuItem, i) {
          return !isSeparator(namedMenuItem) || i > 0 && i < menuItemsPass2.length - 1;
        });
      };
      var createMenu = function(editorMenuItems, menus, removedMenuItems, context) {
        var menuButton, menu, namedMenuItems, isUserDefined;
        if (menus) {
          menu = menus[context];
          isUserDefined = true;
        } else {
          menu = defaultMenus[context];
        }
        if (menu) {
          menuButton = { text: menu.title };
          namedMenuItems = [];
          global$2.each((menu.items || "").split(/[ ,]/), function(name) {
            var namedMenuItem = createMenuNameItemPair(name, editorMenuItems[name]);
            if (namedMenuItem) {
              namedMenuItems.push(namedMenuItem);
            }
          });
          if (!isUserDefined) {
            global$2.each(editorMenuItems, function(item, name) {
              if (item.context === context && !hasItemName(namedMenuItems, name)) {
                if (item.separator === "before") {
                  namedMenuItems.push(delimiterMenuNamePair());
                }
                if (item.prependToContext) {
                  namedMenuItems.unshift(createMenuNameItemPair(name, item));
                } else {
                  namedMenuItems.push(createMenuNameItemPair(name, item));
                }
                if (item.separator === "after") {
                  namedMenuItems.push(delimiterMenuNamePair());
                }
              }
            });
          }
          menuButton.menu = map2(cleanupMenu(namedMenuItems, removedMenuItems), function(menuItem) {
            return menuItem.item;
          });
          if (!menuButton.menu.length) {
            return null;
          }
        }
        return menuButton;
      };
      var getDefaultMenubar = function(editor) {
        var name;
        var defaultMenuBar = [];
        var menu = getMenu(editor);
        if (menu) {
          for (name in menu) {
            defaultMenuBar.push(name);
          }
        } else {
          for (name in defaultMenus) {
            defaultMenuBar.push(name);
          }
        }
        return defaultMenuBar;
      };
      var createMenuButtons = function(editor) {
        var menuButtons = [];
        var defaultMenuBar = getDefaultMenubar(editor);
        var removedMenuItems = global$2.makeMap(getRemovedMenuItems(editor).split(/[ ,]/));
        var menubar = getMenubar(editor);
        var enabledMenuNames = typeof menubar === "string" ? menubar.split(/[ ,]/) : defaultMenuBar;
        for (var i = 0; i < enabledMenuNames.length; i++) {
          var menuItems = enabledMenuNames[i];
          var menu = createMenu(editor.menuItems, getMenu(editor), removedMenuItems, menuItems);
          if (menu) {
            menuButtons.push(menu);
          }
        }
        return menuButtons;
      };
      var Menubar = { createMenuButtons };
      var DOM$1 = global$3.DOM;
      var getSize = function(elm) {
        return {
          width: elm.clientWidth,
          height: elm.clientHeight
        };
      };
      var resizeTo = function(editor, width, height) {
        var containerElm, iframeElm, containerSize, iframeSize;
        containerElm = editor.getContainer();
        iframeElm = editor.getContentAreaContainer().firstChild;
        containerSize = getSize(containerElm);
        iframeSize = getSize(iframeElm);
        if (width !== null) {
          width = Math.max(getMinWidth(editor), width);
          width = Math.min(getMaxWidth(editor), width);
          DOM$1.setStyle(containerElm, "width", width + (containerSize.width - iframeSize.width));
          DOM$1.setStyle(iframeElm, "width", width);
        }
        height = Math.max(getMinHeight(editor), height);
        height = Math.min(getMaxHeight(editor), height);
        DOM$1.setStyle(iframeElm, "height", height);
        Events.fireResizeEditor(editor);
      };
      var resizeBy = function(editor, dw, dh) {
        var elm = editor.getContentAreaContainer();
        resizeTo(editor, elm.clientWidth + dw, elm.clientHeight + dh);
      };
      var Resize = {
        resizeTo,
        resizeBy
      };
      var global$8 = tinymce.util.Tools.resolve("tinymce.Env");
      var api = function(elm) {
        return {
          element: function() {
            return elm;
          }
        };
      };
      var trigger = function(sidebar, panel, callbackName) {
        var callback = sidebar.settings[callbackName];
        if (callback) {
          callback(api(panel.getEl("body")));
        }
      };
      var hidePanels = function(name, container, sidebars) {
        global$2.each(sidebars, function(sidebar) {
          var panel = container.items().filter("#" + sidebar.name)[0];
          if (panel && panel.visible() && sidebar.name !== name) {
            trigger(sidebar, panel, "onhide");
            panel.visible(false);
          }
        });
      };
      var deactivateButtons = function(toolbar) {
        toolbar.items().each(function(ctrl) {
          ctrl.active(false);
        });
      };
      var findSidebar = function(sidebars, name) {
        return global$2.grep(sidebars, function(sidebar) {
          return sidebar.name === name;
        })[0];
      };
      var showPanel = function(editor, name, sidebars) {
        return function(e) {
          var btnCtrl = e.control;
          var container = btnCtrl.parents().filter("panel")[0];
          var panel = container.find("#" + name)[0];
          var sidebar = findSidebar(sidebars, name);
          hidePanels(name, container, sidebars);
          deactivateButtons(btnCtrl.parent());
          if (panel && panel.visible()) {
            trigger(sidebar, panel, "onhide");
            panel.hide();
            btnCtrl.active(false);
          } else {
            if (panel) {
              panel.show();
              trigger(sidebar, panel, "onshow");
            } else {
              panel = global$4.create({
                type: "container",
                name,
                layout: "stack",
                classes: "sidebar-panel",
                html: ""
              });
              container.prepend(panel);
              trigger(sidebar, panel, "onrender");
              trigger(sidebar, panel, "onshow");
            }
            btnCtrl.active(true);
          }
          Events.fireResizeEditor(editor);
        };
      };
      var isModernBrowser = function() {
        return !global$8.ie || global$8.ie >= 11;
      };
      var hasSidebar = function(editor) {
        return isModernBrowser() && editor.sidebars ? editor.sidebars.length > 0 : false;
      };
      var createSidebar = function(editor) {
        var buttons = global$2.map(editor.sidebars, function(sidebar) {
          var settings = sidebar.settings;
          return {
            type: "button",
            icon: settings.icon,
            image: settings.image,
            tooltip: settings.tooltip,
            onclick: showPanel(editor, sidebar.name, editor.sidebars)
          };
        });
        return {
          type: "panel",
          name: "sidebar",
          layout: "stack",
          classes: "sidebar",
          items: [{
            type: "toolbar",
            layout: "stack",
            classes: "sidebar-toolbar",
            items: buttons
          }]
        };
      };
      var Sidebar = {
        hasSidebar,
        createSidebar
      };
      var fireSkinLoaded$1 = function(editor) {
        var done = function() {
          editor._skinLoaded = true;
          Events.fireSkinLoaded(editor);
        };
        return function() {
          if (editor.initialized) {
            done();
          } else {
            editor.on("init", done);
          }
        };
      };
      var SkinLoaded = { fireSkinLoaded: fireSkinLoaded$1 };
      var DOM$2 = global$3.DOM;
      var switchMode = function(panel) {
        return function(e) {
          panel.find("*").disabled(e.mode === "readonly");
        };
      };
      var editArea = function(border) {
        return {
          type: "panel",
          name: "iframe",
          layout: "stack",
          classes: "edit-area",
          border,
          html: ""
        };
      };
      var editAreaContainer = function(editor) {
        return {
          type: "panel",
          layout: "stack",
          classes: "edit-aria-container",
          border: "1 0 0 0",
          items: [
            editArea("0"),
            Sidebar.createSidebar(editor)
          ]
        };
      };
      var render = function(editor, theme2, args) {
        var panel, resizeHandleCtrl, startSize;
        if (isSkinDisabled(editor) === false && args.skinUiCss) {
          DOM$2.styleSheetLoader.load(args.skinUiCss, SkinLoaded.fireSkinLoaded(editor));
        } else {
          SkinLoaded.fireSkinLoaded(editor)();
        }
        panel = theme2.panel = global$4.create({
          type: "panel",
          role: "application",
          classes: "tinymce",
          style: "visibility: hidden",
          layout: "stack",
          border: 1,
          items: [
            {
              type: "container",
              classes: "top-part",
              items: [
                hasMenubar(editor) === false ? null : {
                  type: "menubar",
                  border: "0 0 1 0",
                  items: Menubar.createMenuButtons(editor)
                },
                Toolbar.createToolbars(editor, getToolbarSize(editor))
              ]
            },
            Sidebar.hasSidebar(editor) ? editAreaContainer(editor) : editArea("1 0 0 0")
          ]
        });
        UiContainer.setUiContainer(editor, panel);
        if (getResize(editor) !== "none") {
          resizeHandleCtrl = {
            type: "resizehandle",
            direction: getResize(editor),
            onResizeStart: function() {
              var elm = editor.getContentAreaContainer().firstChild;
              startSize = {
                width: elm.clientWidth,
                height: elm.clientHeight
              };
            },
            onResize: function(e) {
              if (getResize(editor) === "both") {
                Resize.resizeTo(editor, startSize.width + e.deltaX, startSize.height + e.deltaY);
              } else {
                Resize.resizeTo(editor, null, startSize.height + e.deltaY);
              }
            }
          };
        }
        if (hasStatusbar(editor)) {
          var linkHtml = '<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce" rel="noopener" target="_blank" role="presentation" tabindex="-1">Tiny</a>';
          var html2 = global$5.translate([
            "Powered by {0}",
            linkHtml
          ]);
          var brandingLabel = isBrandingEnabled(editor) ? {
            type: "label",
            classes: "branding",
            html: " " + html2
          } : null;
          panel.add({
            type: "panel",
            name: "statusbar",
            classes: "statusbar",
            layout: "flow",
            border: "1 0 0 0",
            ariaRoot: true,
            items: [
              {
                type: "elementpath",
                editor
              },
              resizeHandleCtrl,
              brandingLabel
            ]
          });
        }
        Events.fireBeforeRenderUI(editor);
        editor.on("SwitchMode", switchMode(panel));
        panel.renderBefore(args.targetNode).reflow();
        if (isReadOnly(editor)) {
          editor.setMode("readonly");
        }
        if (args.width) {
          DOM$2.setStyle(panel.getEl(), "width", args.width);
        }
        editor.on("remove", function() {
          panel.remove();
          panel = null;
        });
        A11y.addKeys(editor, panel);
        ContextToolbars.addContextualToolbars(editor);
        return {
          iframeContainer: panel.find("#iframe")[0].getEl(),
          editorContainer: panel.getEl()
        };
      };
      var Iframe = { render };
      var global$9 = tinymce.util.Tools.resolve("tinymce.dom.DomQuery");
      var count = 0;
      var funcs = {
        id: function() {
          return "mceu_" + count++;
        },
        create: function(name, attrs, children) {
          var elm = domGlobals.document.createElement(name);
          global$3.DOM.setAttribs(elm, attrs);
          if (typeof children === "string") {
            elm.innerHTML = children;
          } else {
            global$2.each(children, function(child) {
              if (child.nodeType) {
                elm.appendChild(child);
              }
            });
          }
          return elm;
        },
        createFragment: function(html2) {
          return global$3.DOM.createFragment(html2);
        },
        getWindowSize: function() {
          return global$3.DOM.getViewPort();
        },
        getSize: function(elm) {
          var width, height;
          if (elm.getBoundingClientRect) {
            var rect2 = elm.getBoundingClientRect();
            width = Math.max(rect2.width || rect2.right - rect2.left, elm.offsetWidth);
            height = Math.max(rect2.height || rect2.bottom - rect2.bottom, elm.offsetHeight);
          } else {
            width = elm.offsetWidth;
            height = elm.offsetHeight;
          }
          return {
            width,
            height
          };
        },
        getPos: function(elm, root2) {
          return global$3.DOM.getPos(elm, root2 || funcs.getContainer());
        },
        getContainer: function() {
          return global$8.container ? global$8.container : domGlobals.document.body;
        },
        getViewPort: function(win) {
          return global$3.DOM.getViewPort(win);
        },
        get: function(id) {
          return domGlobals.document.getElementById(id);
        },
        addClass: function(elm, cls) {
          return global$3.DOM.addClass(elm, cls);
        },
        removeClass: function(elm, cls) {
          return global$3.DOM.removeClass(elm, cls);
        },
        hasClass: function(elm, cls) {
          return global$3.DOM.hasClass(elm, cls);
        },
        toggleClass: function(elm, cls, state) {
          return global$3.DOM.toggleClass(elm, cls, state);
        },
        css: function(elm, name, value) {
          return global$3.DOM.setStyle(elm, name, value);
        },
        getRuntimeStyle: function(elm, name) {
          return global$3.DOM.getStyle(elm, name, true);
        },
        on: function(target2, name, callback, scope) {
          return global$3.DOM.bind(target2, name, callback, scope);
        },
        off: function(target2, name, callback) {
          return global$3.DOM.unbind(target2, name, callback);
        },
        fire: function(target2, name, args) {
          return global$3.DOM.fire(target2, name, args);
        },
        innerHtml: function(elm, html2) {
          global$3.DOM.setHTML(elm, html2);
        }
      };
      var isStatic = function(elm) {
        return funcs.getRuntimeStyle(elm, "position") === "static";
      };
      var isFixed = function(ctrl) {
        return ctrl.state.get("fixed");
      };
      function calculateRelativePosition(ctrl, targetElm, rel) {
        var ctrlElm, pos, x, y, selfW, selfH, targetW, targetH, viewport, size;
        viewport = getWindowViewPort();
        pos = funcs.getPos(targetElm, UiContainer.getUiContainer(ctrl));
        x = pos.x;
        y = pos.y;
        if (isFixed(ctrl) && isStatic(domGlobals.document.body)) {
          x -= viewport.x;
          y -= viewport.y;
        }
        ctrlElm = ctrl.getEl();
        size = funcs.getSize(ctrlElm);
        selfW = size.width;
        selfH = size.height;
        size = funcs.getSize(targetElm);
        targetW = size.width;
        targetH = size.height;
        rel = (rel || "").split("");
        if (rel[0] === "b") {
          y += targetH;
        }
        if (rel[1] === "r") {
          x += targetW;
        }
        if (rel[0] === "c") {
          y += Math.round(targetH / 2);
        }
        if (rel[1] === "c") {
          x += Math.round(targetW / 2);
        }
        if (rel[3] === "b") {
          y -= selfH;
        }
        if (rel[4] === "r") {
          x -= selfW;
        }
        if (rel[3] === "c") {
          y -= Math.round(selfH / 2);
        }
        if (rel[4] === "c") {
          x -= Math.round(selfW / 2);
        }
        return {
          x,
          y,
          w: selfW,
          h: selfH
        };
      }
      var getUiContainerViewPort = function(customUiContainer) {
        return {
          x: 0,
          y: 0,
          w: customUiContainer.scrollWidth - 1,
          h: customUiContainer.scrollHeight - 1
        };
      };
      var getWindowViewPort = function() {
        var win = domGlobals.window;
        var x = Math.max(win.pageXOffset, domGlobals.document.body.scrollLeft, domGlobals.document.documentElement.scrollLeft);
        var y = Math.max(win.pageYOffset, domGlobals.document.body.scrollTop, domGlobals.document.documentElement.scrollTop);
        var w = win.innerWidth || domGlobals.document.documentElement.clientWidth;
        var h = win.innerHeight || domGlobals.document.documentElement.clientHeight;
        return {
          x,
          y,
          w,
          h
        };
      };
      var getViewPortRect = function(ctrl) {
        var customUiContainer = UiContainer.getUiContainer(ctrl);
        return customUiContainer && !isFixed(ctrl) ? getUiContainerViewPort(customUiContainer) : getWindowViewPort();
      };
      var Movable = {
        testMoveRel: function(elm, rels) {
          var viewPortRect = getViewPortRect(this);
          for (var i = 0; i < rels.length; i++) {
            var pos = calculateRelativePosition(this, elm, rels[i]);
            if (isFixed(this)) {
              if (pos.x > 0 && pos.x + pos.w < viewPortRect.w && pos.y > 0 && pos.y + pos.h < viewPortRect.h) {
                return rels[i];
              }
            } else {
              if (pos.x > viewPortRect.x && pos.x + pos.w < viewPortRect.w + viewPortRect.x && pos.y > viewPortRect.y && pos.y + pos.h < viewPortRect.h + viewPortRect.y) {
                return rels[i];
              }
            }
          }
          return rels[0];
        },
        moveRel: function(elm, rel) {
          if (typeof rel !== "string") {
            rel = this.testMoveRel(elm, rel);
          }
          var pos = calculateRelativePosition(this, elm, rel);
          return this.moveTo(pos.x, pos.y);
        },
        moveBy: function(dx, dy) {
          var self2 = this, rect2 = self2.layoutRect();
          self2.moveTo(rect2.x + dx, rect2.y + dy);
          return self2;
        },
        moveTo: function(x, y) {
          var self2 = this;
          function constrain2(value, max, size) {
            if (value < 0) {
              return 0;
            }
            if (value + size > max) {
              value = max - size;
              return value < 0 ? 0 : value;
            }
            return value;
          }
          if (self2.settings.constrainToViewport) {
            var viewPortRect = getViewPortRect(this);
            var layoutRect = self2.layoutRect();
            x = constrain2(x, viewPortRect.w + viewPortRect.x, layoutRect.w);
            y = constrain2(y, viewPortRect.h + viewPortRect.y, layoutRect.h);
          }
          var uiContainer = UiContainer.getUiContainer(self2);
          if (uiContainer && isStatic(uiContainer) && !isFixed(self2)) {
            x -= uiContainer.scrollLeft;
            y -= uiContainer.scrollTop;
          }
          if (uiContainer) {
            x += 1;
            y += 1;
          }
          if (self2.state.get("rendered")) {
            self2.layoutRect({
              x,
              y
            }).repaint();
          } else {
            self2.settings.x = x;
            self2.settings.y = y;
          }
          self2.fire("move", {
            x,
            y
          });
          return self2;
        }
      };
      var global$a = tinymce.util.Tools.resolve("tinymce.util.Class");
      var global$b = tinymce.util.Tools.resolve("tinymce.util.EventDispatcher");
      var BoxUtils = {
        parseBox: function(value) {
          var len;
          var radix = 10;
          if (!value) {
            return;
          }
          if (typeof value === "number") {
            value = value || 0;
            return {
              top: value,
              left: value,
              bottom: value,
              right: value
            };
          }
          value = value.split(" ");
          len = value.length;
          if (len === 1) {
            value[1] = value[2] = value[3] = value[0];
          } else if (len === 2) {
            value[2] = value[0];
            value[3] = value[1];
          } else if (len === 3) {
            value[3] = value[1];
          }
          return {
            top: parseInt(value[0], radix) || 0,
            right: parseInt(value[1], radix) || 0,
            bottom: parseInt(value[2], radix) || 0,
            left: parseInt(value[3], radix) || 0
          };
        },
        measureBox: function(elm, prefix) {
          function getStyle(name) {
            var defaultView = elm.ownerDocument.defaultView;
            if (defaultView) {
              var computedStyle = defaultView.getComputedStyle(elm, null);
              if (computedStyle) {
                name = name.replace(/[A-Z]/g, function(a) {
                  return "-" + a;
                });
                return computedStyle.getPropertyValue(name);
              } else {
                return null;
              }
            }
            return elm.currentStyle[name];
          }
          function getSide(name) {
            var val = parseFloat(getStyle(name));
            return isNaN(val) ? 0 : val;
          }
          return {
            top: getSide(prefix + "TopWidth"),
            right: getSide(prefix + "RightWidth"),
            bottom: getSide(prefix + "BottomWidth"),
            left: getSide(prefix + "LeftWidth")
          };
        }
      };
      function noop$1() {
      }
      function ClassList(onchange) {
        this.cls = [];
        this.cls._map = {};
        this.onchange = onchange || noop$1;
        this.prefix = "";
      }
      global$2.extend(ClassList.prototype, {
        add: function(cls) {
          if (cls && !this.contains(cls)) {
            this.cls._map[cls] = true;
            this.cls.push(cls);
            this._change();
          }
          return this;
        },
        remove: function(cls) {
          if (this.contains(cls)) {
            var i = void 0;
            for (i = 0; i < this.cls.length; i++) {
              if (this.cls[i] === cls) {
                break;
              }
            }
            this.cls.splice(i, 1);
            delete this.cls._map[cls];
            this._change();
          }
          return this;
        },
        toggle: function(cls, state) {
          var curState = this.contains(cls);
          if (curState !== state) {
            if (curState) {
              this.remove(cls);
            } else {
              this.add(cls);
            }
            this._change();
          }
          return this;
        },
        contains: function(cls) {
          return !!this.cls._map[cls];
        },
        _change: function() {
          delete this.clsValue;
          this.onchange.call(this);
        }
      });
      ClassList.prototype.toString = function() {
        var value;
        if (this.clsValue) {
          return this.clsValue;
        }
        value = "";
        for (var i = 0; i < this.cls.length; i++) {
          if (i > 0) {
            value += " ";
          }
          value += this.prefix + this.cls[i];
        }
        return value;
      };
      function unique(array) {
        var uniqueItems = [];
        var i = array.length, item;
        while (i--) {
          item = array[i];
          if (!item.__checked) {
            uniqueItems.push(item);
            item.__checked = 1;
          }
        }
        i = uniqueItems.length;
        while (i--) {
          delete uniqueItems[i].__checked;
        }
        return uniqueItems;
      }
      var expression = /^([\w\\*]+)?(?:#([\w\-\\]+))?(?:\.([\w\\\.]+))?(?:\[\@?([\w\\]+)([\^\$\*!~]?=)([\w\\]+)\])?(?:\:(.+))?/i;
      var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
      var whiteSpace = /^\s*|\s*$/g;
      var Collection;
      var Selector = global$a.extend({
        init: function(selector) {
          var match = this.match;
          function compileNameFilter(name) {
            if (name) {
              name = name.toLowerCase();
              return function(item) {
                return name === "*" || item.type === name;
              };
            }
          }
          function compileIdFilter(id) {
            if (id) {
              return function(item) {
                return item._name === id;
              };
            }
          }
          function compileClassesFilter(classes) {
            if (classes) {
              classes = classes.split(".");
              return function(item) {
                var i = classes.length;
                while (i--) {
                  if (!item.classes.contains(classes[i])) {
                    return false;
                  }
                }
                return true;
              };
            }
          }
          function compileAttrFilter(name, cmp, check2) {
            if (name) {
              return function(item) {
                var value = item[name] ? item[name]() : "";
                return !cmp ? !!check2 : cmp === "=" ? value === check2 : cmp === "*=" ? value.indexOf(check2) >= 0 : cmp === "~=" ? (" " + value + " ").indexOf(" " + check2 + " ") >= 0 : cmp === "!=" ? value !== check2 : cmp === "^=" ? value.indexOf(check2) === 0 : cmp === "$=" ? value.substr(value.length - check2.length) === check2 : false;
              };
            }
          }
          function compilePsuedoFilter(name) {
            var notSelectors;
            if (name) {
              name = /(?:not\((.+)\))|(.+)/i.exec(name);
              if (!name[1]) {
                name = name[2];
                return function(item, index, length) {
                  return name === "first" ? index === 0 : name === "last" ? index === length - 1 : name === "even" ? index % 2 === 0 : name === "odd" ? index % 2 === 1 : item[name] ? item[name]() : false;
                };
              }
              notSelectors = parseChunks(name[1], []);
              return function(item) {
                return !match(item, notSelectors);
              };
            }
          }
          function compile(selector2, filters, direct) {
            var parts;
            function add(filter2) {
              if (filter2) {
                filters.push(filter2);
              }
            }
            parts = expression.exec(selector2.replace(whiteSpace, ""));
            add(compileNameFilter(parts[1]));
            add(compileIdFilter(parts[2]));
            add(compileClassesFilter(parts[3]));
            add(compileAttrFilter(parts[4], parts[5], parts[6]));
            add(compilePsuedoFilter(parts[7]));
            filters.pseudo = !!parts[7];
            filters.direct = direct;
            return filters;
          }
          function parseChunks(selector2, selectors) {
            var parts = [];
            var extra, matches, i;
            do {
              chunker.exec("");
              matches = chunker.exec(selector2);
              if (matches) {
                selector2 = matches[3];
                parts.push(matches[1]);
                if (matches[2]) {
                  extra = matches[3];
                  break;
                }
              }
            } while (matches);
            if (extra) {
              parseChunks(extra, selectors);
            }
            selector2 = [];
            for (i = 0; i < parts.length; i++) {
              if (parts[i] !== ">") {
                selector2.push(compile(parts[i], [], parts[i - 1] === ">"));
              }
            }
            selectors.push(selector2);
            return selectors;
          }
          this._selectors = parseChunks(selector, []);
        },
        match: function(control, selectors) {
          var i, l, si, sl, selector, fi, fl, filters, index, length, siblings, count2, item;
          selectors = selectors || this._selectors;
          for (i = 0, l = selectors.length; i < l; i++) {
            selector = selectors[i];
            sl = selector.length;
            item = control;
            count2 = 0;
            for (si = sl - 1; si >= 0; si--) {
              filters = selector[si];
              while (item) {
                if (filters.pseudo) {
                  siblings = item.parent().items();
                  index = length = siblings.length;
                  while (index--) {
                    if (siblings[index] === item) {
                      break;
                    }
                  }
                }
                for (fi = 0, fl = filters.length; fi < fl; fi++) {
                  if (!filters[fi](item, index, length)) {
                    fi = fl + 1;
                    break;
                  }
                }
                if (fi === fl) {
                  count2++;
                  break;
                } else {
                  if (si === sl - 1) {
                    break;
                  }
                }
                item = item.parent();
              }
            }
            if (count2 === sl) {
              return true;
            }
          }
          return false;
        },
        find: function(container) {
          var matches = [], i, l;
          var selectors = this._selectors;
          function collect(items, selector, index) {
            var i2, l2, fi, fl, item;
            var filters = selector[index];
            for (i2 = 0, l2 = items.length; i2 < l2; i2++) {
              item = items[i2];
              for (fi = 0, fl = filters.length; fi < fl; fi++) {
                if (!filters[fi](item, i2, l2)) {
                  fi = fl + 1;
                  break;
                }
              }
              if (fi === fl) {
                if (index === selector.length - 1) {
                  matches.push(item);
                } else {
                  if (item.items) {
                    collect(item.items(), selector, index + 1);
                  }
                }
              } else if (filters.direct) {
                return;
              }
              if (item.items) {
                collect(item.items(), selector, index);
              }
            }
          }
          if (container.items) {
            for (i = 0, l = selectors.length; i < l; i++) {
              collect(container.items(), selectors[i], 0);
            }
            if (l > 1) {
              matches = unique(matches);
            }
          }
          if (!Collection) {
            Collection = Selector.Collection;
          }
          return new Collection(matches);
        }
      });
      var Collection$1, proto;
      var push = Array.prototype.push, slice = Array.prototype.slice;
      proto = {
        length: 0,
        init: function(items) {
          if (items) {
            this.add(items);
          }
        },
        add: function(items) {
          var self2 = this;
          if (!global$2.isArray(items)) {
            if (items instanceof Collection$1) {
              self2.add(items.toArray());
            } else {
              push.call(self2, items);
            }
          } else {
            push.apply(self2, items);
          }
          return self2;
        },
        set: function(items) {
          var self2 = this;
          var len = self2.length;
          var i;
          self2.length = 0;
          self2.add(items);
          for (i = self2.length; i < len; i++) {
            delete self2[i];
          }
          return self2;
        },
        filter: function(selector) {
          var self2 = this;
          var i, l;
          var matches = [];
          var item, match;
          if (typeof selector === "string") {
            selector = new Selector(selector);
            match = function(item2) {
              return selector.match(item2);
            };
          } else {
            match = selector;
          }
          for (i = 0, l = self2.length; i < l; i++) {
            item = self2[i];
            if (match(item)) {
              matches.push(item);
            }
          }
          return new Collection$1(matches);
        },
        slice: function() {
          return new Collection$1(slice.apply(this, arguments));
        },
        eq: function(index) {
          return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
        },
        each: function(callback) {
          global$2.each(this, callback);
          return this;
        },
        toArray: function() {
          return global$2.toArray(this);
        },
        indexOf: function(ctrl) {
          var self2 = this;
          var i = self2.length;
          while (i--) {
            if (self2[i] === ctrl) {
              break;
            }
          }
          return i;
        },
        reverse: function() {
          return new Collection$1(global$2.toArray(this).reverse());
        },
        hasClass: function(cls) {
          return this[0] ? this[0].classes.contains(cls) : false;
        },
        prop: function(name, value) {
          var self2 = this;
          var item;
          if (value !== void 0) {
            self2.each(function(item2) {
              if (item2[name]) {
                item2[name](value);
              }
            });
            return self2;
          }
          item = self2[0];
          if (item && item[name]) {
            return item[name]();
          }
        },
        exec: function(name) {
          var self2 = this, args = global$2.toArray(arguments).slice(1);
          self2.each(function(item) {
            if (item[name]) {
              item[name].apply(item, args);
            }
          });
          return self2;
        },
        remove: function() {
          var i = this.length;
          while (i--) {
            this[i].remove();
          }
          return this;
        },
        addClass: function(cls) {
          return this.each(function(item) {
            item.classes.add(cls);
          });
        },
        removeClass: function(cls) {
          return this.each(function(item) {
            item.classes.remove(cls);
          });
        }
      };
      global$2.each("fire on off show hide append prepend before after reflow".split(" "), function(name) {
        proto[name] = function() {
          var args = global$2.toArray(arguments);
          this.each(function(ctrl) {
            if (name in ctrl) {
              ctrl[name].apply(ctrl, args);
            }
          });
          return this;
        };
      });
      global$2.each("text name disabled active selected checked visible parent value data".split(" "), function(name) {
        proto[name] = function(value) {
          return this.prop(name, value);
        };
      });
      Collection$1 = global$a.extend(proto);
      Selector.Collection = Collection$1;
      var Collection$2 = Collection$1;
      var Binding = function(settings) {
        this.create = settings.create;
      };
      Binding.create = function(model, name) {
        return new Binding({
          create: function(otherModel, otherName) {
            var bindings;
            var fromSelfToOther = function(e) {
              otherModel.set(otherName, e.value);
            };
            var fromOtherToSelf = function(e) {
              model.set(name, e.value);
            };
            otherModel.on("change:" + otherName, fromOtherToSelf);
            model.on("change:" + name, fromSelfToOther);
            bindings = otherModel._bindings;
            if (!bindings) {
              bindings = otherModel._bindings = [];
              otherModel.on("destroy", function() {
                var i = bindings.length;
                while (i--) {
                  bindings[i]();
                }
              });
            }
            bindings.push(function() {
              model.off("change:" + name, fromSelfToOther);
            });
            return model.get(name);
          }
        });
      };
      var global$c = tinymce.util.Tools.resolve("tinymce.util.Observable");
      function isNode(node2) {
        return node2.nodeType > 0;
      }
      function isEqual(a, b) {
        var k, checked;
        if (a === b) {
          return true;
        }
        if (a === null || b === null) {
          return a === b;
        }
        if (typeof a !== "object" || typeof b !== "object") {
          return a === b;
        }
        if (global$2.isArray(b)) {
          if (a.length !== b.length) {
            return false;
          }
          k = a.length;
          while (k--) {
            if (!isEqual(a[k], b[k])) {
              return false;
            }
          }
        }
        if (isNode(a) || isNode(b)) {
          return a === b;
        }
        checked = {};
        for (k in b) {
          if (!isEqual(a[k], b[k])) {
            return false;
          }
          checked[k] = true;
        }
        for (k in a) {
          if (!checked[k] && !isEqual(a[k], b[k])) {
            return false;
          }
        }
        return true;
      }
      var ObservableObject = global$a.extend({
        Mixins: [global$c],
        init: function(data) {
          var name, value;
          data = data || {};
          for (name in data) {
            value = data[name];
            if (value instanceof Binding) {
              data[name] = value.create(this, name);
            }
          }
          this.data = data;
        },
        set: function(name, value) {
          var key, args;
          var oldValue = this.data[name];
          if (value instanceof Binding) {
            value = value.create(this, name);
          }
          if (typeof name === "object") {
            for (key in name) {
              this.set(key, name[key]);
            }
            return this;
          }
          if (!isEqual(oldValue, value)) {
            this.data[name] = value;
            args = {
              target: this,
              name,
              value,
              oldValue
            };
            this.fire("change:" + name, args);
            this.fire("change", args);
          }
          return this;
        },
        get: function(name) {
          return this.data[name];
        },
        has: function(name) {
          return name in this.data;
        },
        bind: function(name) {
          return Binding.create(this, name);
        },
        destroy: function() {
          this.fire("destroy");
        }
      });
      var dirtyCtrls = {}, animationFrameRequested;
      var ReflowQueue = {
        add: function(ctrl) {
          var parent = ctrl.parent();
          if (parent) {
            if (!parent._layout || parent._layout.isNative()) {
              return;
            }
            if (!dirtyCtrls[parent._id]) {
              dirtyCtrls[parent._id] = parent;
            }
            if (!animationFrameRequested) {
              animationFrameRequested = true;
              global$7.requestAnimationFrame(function() {
                var id, ctrl2;
                animationFrameRequested = false;
                for (id in dirtyCtrls) {
                  ctrl2 = dirtyCtrls[id];
                  if (ctrl2.state.get("rendered")) {
                    ctrl2.reflow();
                  }
                }
                dirtyCtrls = {};
              }, domGlobals.document.body);
            }
          }
        },
        remove: function(ctrl) {
          if (dirtyCtrls[ctrl._id]) {
            delete dirtyCtrls[ctrl._id];
          }
        }
      };
      var hasMouseWheelEventSupport = "onmousewheel" in domGlobals.document;
      var classPrefix = "mce-";
      var Control, idCounter = 0;
      var proto$1 = {
        Statics: { classPrefix },
        isRtl: function() {
          return Control.rtl;
        },
        classPrefix,
        init: function(settings) {
          var self2 = this;
          var classes, defaultClasses;
          function applyClasses(classes2) {
            var i;
            classes2 = classes2.split(" ");
            for (i = 0; i < classes2.length; i++) {
              self2.classes.add(classes2[i]);
            }
          }
          self2.settings = settings = global$2.extend({}, self2.Defaults, settings);
          self2._id = settings.id || "mceu_" + idCounter++;
          self2._aria = { role: settings.role };
          self2._elmCache = {};
          self2.$ = global$9;
          self2.state = new ObservableObject({
            visible: true,
            active: false,
            disabled: false,
            value: ""
          });
          self2.data = new ObservableObject(settings.data);
          self2.classes = new ClassList(function() {
            if (self2.state.get("rendered")) {
              self2.getEl().className = this.toString();
            }
          });
          self2.classes.prefix = self2.classPrefix;
          classes = settings.classes;
          if (classes) {
            if (self2.Defaults) {
              defaultClasses = self2.Defaults.classes;
              if (defaultClasses && classes !== defaultClasses) {
                applyClasses(defaultClasses);
              }
            }
            applyClasses(classes);
          }
          global$2.each("title text name visible disabled active value".split(" "), function(name) {
            if (name in settings) {
              self2[name](settings[name]);
            }
          });
          self2.on("click", function() {
            if (self2.disabled()) {
              return false;
            }
          });
          self2.settings = settings;
          self2.borderBox = BoxUtils.parseBox(settings.border);
          self2.paddingBox = BoxUtils.parseBox(settings.padding);
          self2.marginBox = BoxUtils.parseBox(settings.margin);
          if (settings.hidden) {
            self2.hide();
          }
        },
        Properties: "parent,name",
        getContainerElm: function() {
          var uiContainer = UiContainer.getUiContainer(this);
          return uiContainer ? uiContainer : funcs.getContainer();
        },
        getParentCtrl: function(elm) {
          var ctrl;
          var lookup = this.getRoot().controlIdLookup;
          while (elm && lookup) {
            ctrl = lookup[elm.id];
            if (ctrl) {
              break;
            }
            elm = elm.parentNode;
          }
          return ctrl;
        },
        initLayoutRect: function() {
          var self2 = this;
          var settings = self2.settings;
          var borderBox, layoutRect;
          var elm = self2.getEl();
          var width, height, minWidth, minHeight, autoResize;
          var startMinWidth, startMinHeight, initialSize;
          borderBox = self2.borderBox = self2.borderBox || BoxUtils.measureBox(elm, "border");
          self2.paddingBox = self2.paddingBox || BoxUtils.measureBox(elm, "padding");
          self2.marginBox = self2.marginBox || BoxUtils.measureBox(elm, "margin");
          initialSize = funcs.getSize(elm);
          startMinWidth = settings.minWidth;
          startMinHeight = settings.minHeight;
          minWidth = startMinWidth || initialSize.width;
          minHeight = startMinHeight || initialSize.height;
          width = settings.width;
          height = settings.height;
          autoResize = settings.autoResize;
          autoResize = typeof autoResize !== "undefined" ? autoResize : !width && !height;
          width = width || minWidth;
          height = height || minHeight;
          var deltaW = borderBox.left + borderBox.right;
          var deltaH = borderBox.top + borderBox.bottom;
          var maxW = settings.maxWidth || 65535;
          var maxH = settings.maxHeight || 65535;
          self2._layoutRect = layoutRect = {
            x: settings.x || 0,
            y: settings.y || 0,
            w: width,
            h: height,
            deltaW,
            deltaH,
            contentW: width - deltaW,
            contentH: height - deltaH,
            innerW: width - deltaW,
            innerH: height - deltaH,
            startMinWidth: startMinWidth || 0,
            startMinHeight: startMinHeight || 0,
            minW: Math.min(minWidth, maxW),
            minH: Math.min(minHeight, maxH),
            maxW,
            maxH,
            autoResize,
            scrollW: 0
          };
          self2._lastLayoutRect = {};
          return layoutRect;
        },
        layoutRect: function(newRect) {
          var self2 = this;
          var curRect = self2._layoutRect, lastLayoutRect, size, deltaWidth, deltaHeight, repaintControls;
          if (!curRect) {
            curRect = self2.initLayoutRect();
          }
          if (newRect) {
            deltaWidth = curRect.deltaW;
            deltaHeight = curRect.deltaH;
            if (newRect.x !== void 0) {
              curRect.x = newRect.x;
            }
            if (newRect.y !== void 0) {
              curRect.y = newRect.y;
            }
            if (newRect.minW !== void 0) {
              curRect.minW = newRect.minW;
            }
            if (newRect.minH !== void 0) {
              curRect.minH = newRect.minH;
            }
            size = newRect.w;
            if (size !== void 0) {
              size = size < curRect.minW ? curRect.minW : size;
              size = size > curRect.maxW ? curRect.maxW : size;
              curRect.w = size;
              curRect.innerW = size - deltaWidth;
            }
            size = newRect.h;
            if (size !== void 0) {
              size = size < curRect.minH ? curRect.minH : size;
              size = size > curRect.maxH ? curRect.maxH : size;
              curRect.h = size;
              curRect.innerH = size - deltaHeight;
            }
            size = newRect.innerW;
            if (size !== void 0) {
              size = size < curRect.minW - deltaWidth ? curRect.minW - deltaWidth : size;
              size = size > curRect.maxW - deltaWidth ? curRect.maxW - deltaWidth : size;
              curRect.innerW = size;
              curRect.w = size + deltaWidth;
            }
            size = newRect.innerH;
            if (size !== void 0) {
              size = size < curRect.minH - deltaHeight ? curRect.minH - deltaHeight : size;
              size = size > curRect.maxH - deltaHeight ? curRect.maxH - deltaHeight : size;
              curRect.innerH = size;
              curRect.h = size + deltaHeight;
            }
            if (newRect.contentW !== void 0) {
              curRect.contentW = newRect.contentW;
            }
            if (newRect.contentH !== void 0) {
              curRect.contentH = newRect.contentH;
            }
            lastLayoutRect = self2._lastLayoutRect;
            if (lastLayoutRect.x !== curRect.x || lastLayoutRect.y !== curRect.y || lastLayoutRect.w !== curRect.w || lastLayoutRect.h !== curRect.h) {
              repaintControls = Control.repaintControls;
              if (repaintControls) {
                if (repaintControls.map && !repaintControls.map[self2._id]) {
                  repaintControls.push(self2);
                  repaintControls.map[self2._id] = true;
                }
              }
              lastLayoutRect.x = curRect.x;
              lastLayoutRect.y = curRect.y;
              lastLayoutRect.w = curRect.w;
              lastLayoutRect.h = curRect.h;
            }
            return self2;
          }
          return curRect;
        },
        repaint: function() {
          var self2 = this;
          var style, bodyStyle, bodyElm, rect2, borderBox;
          var borderW, borderH, lastRepaintRect, round2, value;
          round2 = !domGlobals.document.createRange ? Math.round : function(value2) {
            return value2;
          };
          style = self2.getEl().style;
          rect2 = self2._layoutRect;
          lastRepaintRect = self2._lastRepaintRect || {};
          borderBox = self2.borderBox;
          borderW = borderBox.left + borderBox.right;
          borderH = borderBox.top + borderBox.bottom;
          if (rect2.x !== lastRepaintRect.x) {
            style.left = round2(rect2.x) + "px";
            lastRepaintRect.x = rect2.x;
          }
          if (rect2.y !== lastRepaintRect.y) {
            style.top = round2(rect2.y) + "px";
            lastRepaintRect.y = rect2.y;
          }
          if (rect2.w !== lastRepaintRect.w) {
            value = round2(rect2.w - borderW);
            style.width = (value >= 0 ? value : 0) + "px";
            lastRepaintRect.w = rect2.w;
          }
          if (rect2.h !== lastRepaintRect.h) {
            value = round2(rect2.h - borderH);
            style.height = (value >= 0 ? value : 0) + "px";
            lastRepaintRect.h = rect2.h;
          }
          if (self2._hasBody && rect2.innerW !== lastRepaintRect.innerW) {
            value = round2(rect2.innerW);
            bodyElm = self2.getEl("body");
            if (bodyElm) {
              bodyStyle = bodyElm.style;
              bodyStyle.width = (value >= 0 ? value : 0) + "px";
            }
            lastRepaintRect.innerW = rect2.innerW;
          }
          if (self2._hasBody && rect2.innerH !== lastRepaintRect.innerH) {
            value = round2(rect2.innerH);
            bodyElm = bodyElm || self2.getEl("body");
            if (bodyElm) {
              bodyStyle = bodyStyle || bodyElm.style;
              bodyStyle.height = (value >= 0 ? value : 0) + "px";
            }
            lastRepaintRect.innerH = rect2.innerH;
          }
          self2._lastRepaintRect = lastRepaintRect;
          self2.fire("repaint", {}, false);
        },
        updateLayoutRect: function() {
          var self2 = this;
          self2.parent()._lastRect = null;
          funcs.css(self2.getEl(), {
            width: "",
            height: ""
          });
          self2._layoutRect = self2._lastRepaintRect = self2._lastLayoutRect = null;
          self2.initLayoutRect();
        },
        on: function(name, callback) {
          var self2 = this;
          function resolveCallbackName(name2) {
            var callback2, scope;
            if (typeof name2 !== "string") {
              return name2;
            }
            return function(e) {
              if (!callback2) {
                self2.parentsAndSelf().each(function(ctrl) {
                  var callbacks = ctrl.settings.callbacks;
                  if (callbacks && (callback2 = callbacks[name2])) {
                    scope = ctrl;
                    return false;
                  }
                });
              }
              if (!callback2) {
                e.action = name2;
                this.fire("execute", e);
                return;
              }
              return callback2.call(scope, e);
            };
          }
          getEventDispatcher(self2).on(name, resolveCallbackName(callback));
          return self2;
        },
        off: function(name, callback) {
          getEventDispatcher(this).off(name, callback);
          return this;
        },
        fire: function(name, args, bubble) {
          var self2 = this;
          args = args || {};
          if (!args.control) {
            args.control = self2;
          }
          args = getEventDispatcher(self2).fire(name, args);
          if (bubble !== false && self2.parent) {
            var parent = self2.parent();
            while (parent && !args.isPropagationStopped()) {
              parent.fire(name, args, false);
              parent = parent.parent();
            }
          }
          return args;
        },
        hasEventListeners: function(name) {
          return getEventDispatcher(this).has(name);
        },
        parents: function(selector) {
          var self2 = this;
          var ctrl, parents = new Collection$2();
          for (ctrl = self2.parent(); ctrl; ctrl = ctrl.parent()) {
            parents.add(ctrl);
          }
          if (selector) {
            parents = parents.filter(selector);
          }
          return parents;
        },
        parentsAndSelf: function(selector) {
          return new Collection$2(this).add(this.parents(selector));
        },
        next: function() {
          var parentControls = this.parent().items();
          return parentControls[parentControls.indexOf(this) + 1];
        },
        prev: function() {
          var parentControls = this.parent().items();
          return parentControls[parentControls.indexOf(this) - 1];
        },
        innerHtml: function(html2) {
          this.$el.html(html2);
          return this;
        },
        getEl: function(suffix) {
          var id = suffix ? this._id + "-" + suffix : this._id;
          if (!this._elmCache[id]) {
            this._elmCache[id] = global$9("#" + id)[0];
          }
          return this._elmCache[id];
        },
        show: function() {
          return this.visible(true);
        },
        hide: function() {
          return this.visible(false);
        },
        focus: function() {
          try {
            this.getEl().focus();
          } catch (ex) {
          }
          return this;
        },
        blur: function() {
          this.getEl().blur();
          return this;
        },
        aria: function(name, value) {
          var self2 = this, elm = self2.getEl(self2.ariaTarget);
          if (typeof value === "undefined") {
            return self2._aria[name];
          }
          self2._aria[name] = value;
          if (self2.state.get("rendered")) {
            elm.setAttribute(name === "role" ? name : "aria-" + name, value);
          }
          return self2;
        },
        encode: function(text2, translate) {
          if (translate !== false) {
            text2 = this.translate(text2);
          }
          return (text2 || "").replace(/[&<>"]/g, function(match) {
            return "&#" + match.charCodeAt(0) + ";";
          });
        },
        translate: function(text2) {
          return Control.translate ? Control.translate(text2) : text2;
        },
        before: function(items) {
          var self2 = this, parent = self2.parent();
          if (parent) {
            parent.insert(items, parent.items().indexOf(self2), true);
          }
          return self2;
        },
        after: function(items) {
          var self2 = this, parent = self2.parent();
          if (parent) {
            parent.insert(items, parent.items().indexOf(self2));
          }
          return self2;
        },
        remove: function() {
          var self2 = this;
          var elm = self2.getEl();
          var parent = self2.parent();
          var newItems, i;
          if (self2.items) {
            var controls = self2.items().toArray();
            i = controls.length;
            while (i--) {
              controls[i].remove();
            }
          }
          if (parent && parent.items) {
            newItems = [];
            parent.items().each(function(item) {
              if (item !== self2) {
                newItems.push(item);
              }
            });
            parent.items().set(newItems);
            parent._lastRect = null;
          }
          if (self2._eventsRoot && self2._eventsRoot === self2) {
            global$9(elm).off();
          }
          var lookup = self2.getRoot().controlIdLookup;
          if (lookup) {
            delete lookup[self2._id];
          }
          if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
          }
          self2.state.set("rendered", false);
          self2.state.destroy();
          self2.fire("remove");
          return self2;
        },
        renderBefore: function(elm) {
          global$9(elm).before(this.renderHtml());
          this.postRender();
          return this;
        },
        renderTo: function(elm) {
          global$9(elm || this.getContainerElm()).append(this.renderHtml());
          this.postRender();
          return this;
        },
        preRender: function() {
        },
        render: function() {
        },
        renderHtml: function() {
          return '<div id="' + this._id + '" class="' + this.classes + '"></div>';
        },
        postRender: function() {
          var self2 = this;
          var settings = self2.settings;
          var elm, box, parent, name, parentEventsRoot;
          self2.$el = global$9(self2.getEl());
          self2.state.set("rendered", true);
          for (name in settings) {
            if (name.indexOf("on") === 0) {
              self2.on(name.substr(2), settings[name]);
            }
          }
          if (self2._eventsRoot) {
            for (parent = self2.parent(); !parentEventsRoot && parent; parent = parent.parent()) {
              parentEventsRoot = parent._eventsRoot;
            }
            if (parentEventsRoot) {
              for (name in parentEventsRoot._nativeEvents) {
                self2._nativeEvents[name] = true;
              }
            }
          }
          bindPendingEvents(self2);
          if (settings.style) {
            elm = self2.getEl();
            if (elm) {
              elm.setAttribute("style", settings.style);
              elm.style.cssText = settings.style;
            }
          }
          if (self2.settings.border) {
            box = self2.borderBox;
            self2.$el.css({
              "border-top-width": box.top,
              "border-right-width": box.right,
              "border-bottom-width": box.bottom,
              "border-left-width": box.left
            });
          }
          var root2 = self2.getRoot();
          if (!root2.controlIdLookup) {
            root2.controlIdLookup = {};
          }
          root2.controlIdLookup[self2._id] = self2;
          for (var key in self2._aria) {
            self2.aria(key, self2._aria[key]);
          }
          if (self2.state.get("visible") === false) {
            self2.getEl().style.display = "none";
          }
          self2.bindStates();
          self2.state.on("change:visible", function(e) {
            var state = e.value;
            var parentCtrl;
            if (self2.state.get("rendered")) {
              self2.getEl().style.display = state === false ? "none" : "";
              self2.getEl().getBoundingClientRect();
            }
            parentCtrl = self2.parent();
            if (parentCtrl) {
              parentCtrl._lastRect = null;
            }
            self2.fire(state ? "show" : "hide");
            ReflowQueue.add(self2);
          });
          self2.fire("postrender", {}, false);
        },
        bindStates: function() {
        },
        scrollIntoView: function(align) {
          function getOffset(elm2, rootElm) {
            var x2, y2, parent = elm2;
            x2 = y2 = 0;
            while (parent && parent !== rootElm && parent.nodeType) {
              x2 += parent.offsetLeft || 0;
              y2 += parent.offsetTop || 0;
              parent = parent.offsetParent;
            }
            return {
              x: x2,
              y: y2
            };
          }
          var elm = this.getEl(), parentElm = elm.parentNode;
          var x, y, width, height, parentWidth, parentHeight;
          var pos = getOffset(elm, parentElm);
          x = pos.x;
          y = pos.y;
          width = elm.offsetWidth;
          height = elm.offsetHeight;
          parentWidth = parentElm.clientWidth;
          parentHeight = parentElm.clientHeight;
          if (align === "end") {
            x -= parentWidth - width;
            y -= parentHeight - height;
          } else if (align === "center") {
            x -= parentWidth / 2 - width / 2;
            y -= parentHeight / 2 - height / 2;
          }
          parentElm.scrollLeft = x;
          parentElm.scrollTop = y;
          return this;
        },
        getRoot: function() {
          var ctrl = this, rootControl;
          var parents = [];
          while (ctrl) {
            if (ctrl.rootControl) {
              rootControl = ctrl.rootControl;
              break;
            }
            parents.push(ctrl);
            rootControl = ctrl;
            ctrl = ctrl.parent();
          }
          if (!rootControl) {
            rootControl = this;
          }
          var i = parents.length;
          while (i--) {
            parents[i].rootControl = rootControl;
          }
          return rootControl;
        },
        reflow: function() {
          ReflowQueue.remove(this);
          var parent = this.parent();
          if (parent && parent._layout && !parent._layout.isNative()) {
            parent.reflow();
          }
          return this;
        }
      };
      global$2.each("text title visible disabled active value".split(" "), function(name) {
        proto$1[name] = function(value) {
          if (arguments.length === 0) {
            return this.state.get(name);
          }
          if (typeof value !== "undefined") {
            this.state.set(name, value);
          }
          return this;
        };
      });
      Control = global$a.extend(proto$1);
      function getEventDispatcher(obj) {
        if (!obj._eventDispatcher) {
          obj._eventDispatcher = new global$b({
            scope: obj,
            toggleEvent: function(name, state) {
              if (state && global$b.isNative(name)) {
                if (!obj._nativeEvents) {
                  obj._nativeEvents = {};
                }
                obj._nativeEvents[name] = true;
                if (obj.state.get("rendered")) {
                  bindPendingEvents(obj);
                }
              }
            }
          });
        }
        return obj._eventDispatcher;
      }
      function bindPendingEvents(eventCtrl) {
        var i, l, parents, eventRootCtrl, nativeEvents, name;
        function delegate(e) {
          var control = eventCtrl.getParentCtrl(e.target);
          if (control) {
            control.fire(e.type, e);
          }
        }
        function mouseLeaveHandler() {
          var ctrl = eventRootCtrl._lastHoverCtrl;
          if (ctrl) {
            ctrl.fire("mouseleave", { target: ctrl.getEl() });
            ctrl.parents().each(function(ctrl2) {
              ctrl2.fire("mouseleave", { target: ctrl2.getEl() });
            });
            eventRootCtrl._lastHoverCtrl = null;
          }
        }
        function mouseEnterHandler(e) {
          var ctrl = eventCtrl.getParentCtrl(e.target), lastCtrl = eventRootCtrl._lastHoverCtrl, idx = 0, i2, parents2, lastParents;
          if (ctrl !== lastCtrl) {
            eventRootCtrl._lastHoverCtrl = ctrl;
            parents2 = ctrl.parents().toArray().reverse();
            parents2.push(ctrl);
            if (lastCtrl) {
              lastParents = lastCtrl.parents().toArray().reverse();
              lastParents.push(lastCtrl);
              for (idx = 0; idx < lastParents.length; idx++) {
                if (parents2[idx] !== lastParents[idx]) {
                  break;
                }
              }
              for (i2 = lastParents.length - 1; i2 >= idx; i2--) {
                lastCtrl = lastParents[i2];
                lastCtrl.fire("mouseleave", { target: lastCtrl.getEl() });
              }
            }
            for (i2 = idx; i2 < parents2.length; i2++) {
              ctrl = parents2[i2];
              ctrl.fire("mouseenter", { target: ctrl.getEl() });
            }
          }
        }
        function fixWheelEvent(e) {
          e.preventDefault();
          if (e.type === "mousewheel") {
            e.deltaY = -1 / 40 * e.wheelDelta;
            if (e.wheelDeltaX) {
              e.deltaX = -1 / 40 * e.wheelDeltaX;
            }
          } else {
            e.deltaX = 0;
            e.deltaY = e.detail;
          }
          e = eventCtrl.fire("wheel", e);
        }
        nativeEvents = eventCtrl._nativeEvents;
        if (nativeEvents) {
          parents = eventCtrl.parents().toArray();
          parents.unshift(eventCtrl);
          for (i = 0, l = parents.length; !eventRootCtrl && i < l; i++) {
            eventRootCtrl = parents[i]._eventsRoot;
          }
          if (!eventRootCtrl) {
            eventRootCtrl = parents[parents.length - 1] || eventCtrl;
          }
          eventCtrl._eventsRoot = eventRootCtrl;
          for (l = i, i = 0; i < l; i++) {
            parents[i]._eventsRoot = eventRootCtrl;
          }
          var eventRootDelegates = eventRootCtrl._delegates;
          if (!eventRootDelegates) {
            eventRootDelegates = eventRootCtrl._delegates = {};
          }
          for (name in nativeEvents) {
            if (!nativeEvents) {
              return false;
            }
            if (name === "wheel" && true) {
              if (hasMouseWheelEventSupport) {
                global$9(eventCtrl.getEl()).on("mousewheel", fixWheelEvent);
              } else {
                global$9(eventCtrl.getEl()).on("DOMMouseScroll", fixWheelEvent);
              }
              continue;
            }
            if (name === "mouseenter" || name === "mouseleave") {
              if (!eventRootCtrl._hasMouseEnter) {
                global$9(eventRootCtrl.getEl()).on("mouseleave", mouseLeaveHandler).on("mouseover", mouseEnterHandler);
                eventRootCtrl._hasMouseEnter = 1;
              }
            } else if (!eventRootDelegates[name]) {
              global$9(eventRootCtrl.getEl()).on(name, delegate);
              eventRootDelegates[name] = true;
            }
            nativeEvents[name] = false;
          }
        }
      }
      var Control$1 = Control;
      var hasTabstopData = function(elm) {
        return elm.getAttribute("data-mce-tabstop") ? true : false;
      };
      function KeyboardNavigation(settings) {
        var root2 = settings.root;
        var focusedElement, focusedControl;
        function isElement(node2) {
          return node2 && node2.nodeType === 1;
        }
        try {
          focusedElement = domGlobals.document.activeElement;
        } catch (ex) {
          focusedElement = domGlobals.document.body;
        }
        focusedControl = root2.getParentCtrl(focusedElement);
        function getRole(elm) {
          elm = elm || focusedElement;
          if (isElement(elm)) {
            return elm.getAttribute("role");
          }
          return null;
        }
        function getParentRole(elm) {
          var role, parent = focusedElement;
          while (parent = parent.parentNode) {
            if (role = getRole(parent)) {
              return role;
            }
          }
        }
        function getAriaProp(name) {
          var elm = focusedElement;
          if (isElement(elm)) {
            return elm.getAttribute("aria-" + name);
          }
        }
        function isTextInputElement(elm) {
          var tagName = elm.tagName.toUpperCase();
          return tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT";
        }
        function canFocus(elm) {
          if (isTextInputElement(elm) && !elm.hidden) {
            return true;
          }
          if (hasTabstopData(elm)) {
            return true;
          }
          if (/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell|slider)$/.test(getRole(elm))) {
            return true;
          }
          return false;
        }
        function getFocusElements(elm) {
          var elements = [];
          function collect(elm2) {
            if (elm2.nodeType !== 1 || elm2.style.display === "none" || elm2.disabled) {
              return;
            }
            if (canFocus(elm2)) {
              elements.push(elm2);
            }
            for (var i = 0; i < elm2.childNodes.length; i++) {
              collect(elm2.childNodes[i]);
            }
          }
          collect(elm || root2.getEl());
          return elements;
        }
        function getNavigationRoot(targetControl) {
          var navigationRoot, controls;
          targetControl = targetControl || focusedControl;
          controls = targetControl.parents().toArray();
          controls.unshift(targetControl);
          for (var i = 0; i < controls.length; i++) {
            navigationRoot = controls[i];
            if (navigationRoot.settings.ariaRoot) {
              break;
            }
          }
          return navigationRoot;
        }
        function focusFirst(targetControl) {
          var navigationRoot = getNavigationRoot(targetControl);
          var focusElements = getFocusElements(navigationRoot.getEl());
          if (navigationRoot.settings.ariaRemember && "lastAriaIndex" in navigationRoot) {
            moveFocusToIndex(navigationRoot.lastAriaIndex, focusElements);
          } else {
            moveFocusToIndex(0, focusElements);
          }
        }
        function moveFocusToIndex(idx, elements) {
          if (idx < 0) {
            idx = elements.length - 1;
          } else if (idx >= elements.length) {
            idx = 0;
          }
          if (elements[idx]) {
            elements[idx].focus();
          }
          return idx;
        }
        function moveFocus(dir, elements) {
          var idx = -1;
          var navigationRoot = getNavigationRoot();
          elements = elements || getFocusElements(navigationRoot.getEl());
          for (var i = 0; i < elements.length; i++) {
            if (elements[i] === focusedElement) {
              idx = i;
            }
          }
          idx += dir;
          navigationRoot.lastAriaIndex = moveFocusToIndex(idx, elements);
        }
        function left() {
          var parentRole = getParentRole();
          if (parentRole === "tablist") {
            moveFocus(-1, getFocusElements(focusedElement.parentNode));
          } else if (focusedControl.parent().submenu) {
            cancel();
          } else {
            moveFocus(-1);
          }
        }
        function right() {
          var role = getRole(), parentRole = getParentRole();
          if (parentRole === "tablist") {
            moveFocus(1, getFocusElements(focusedElement.parentNode));
          } else if (role === "menuitem" && parentRole === "menu" && getAriaProp("haspopup")) {
            enter();
          } else {
            moveFocus(1);
          }
        }
        function up() {
          moveFocus(-1);
        }
        function down() {
          var role = getRole(), parentRole = getParentRole();
          if (role === "menuitem" && parentRole === "menubar") {
            enter();
          } else if (role === "button" && getAriaProp("haspopup")) {
            enter({ key: "down" });
          } else {
            moveFocus(1);
          }
        }
        function tab(e) {
          var parentRole = getParentRole();
          if (parentRole === "tablist") {
            var elm = getFocusElements(focusedControl.getEl("body"))[0];
            if (elm) {
              elm.focus();
            }
          } else {
            moveFocus(e.shiftKey ? -1 : 1);
          }
        }
        function cancel() {
          focusedControl.fire("cancel");
        }
        function enter(aria) {
          aria = aria || {};
          focusedControl.fire("click", {
            target: focusedElement,
            aria
          });
        }
        root2.on("keydown", function(e) {
          function handleNonTabOrEscEvent(e2, handler) {
            if (isTextInputElement(focusedElement) || hasTabstopData(focusedElement)) {
              return;
            }
            if (getRole(focusedElement) === "slider") {
              return;
            }
            if (handler(e2) !== false) {
              e2.preventDefault();
            }
          }
          if (e.isDefaultPrevented()) {
            return;
          }
          switch (e.keyCode) {
            case 37:
              handleNonTabOrEscEvent(e, left);
              break;
            case 39:
              handleNonTabOrEscEvent(e, right);
              break;
            case 38:
              handleNonTabOrEscEvent(e, up);
              break;
            case 40:
              handleNonTabOrEscEvent(e, down);
              break;
            case 27:
              cancel();
              break;
            case 14:
            case 13:
            case 32:
              handleNonTabOrEscEvent(e, enter);
              break;
            case 9:
              tab(e);
              e.preventDefault();
              break;
          }
        });
        root2.on("focusin", function(e) {
          focusedElement = e.target;
          focusedControl = e.control;
        });
        return { focusFirst };
      }
      var selectorCache = {};
      var Container = Control$1.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          settings = self2.settings;
          if (settings.fixed) {
            self2.state.set("fixed", true);
          }
          self2._items = new Collection$2();
          if (self2.isRtl()) {
            self2.classes.add("rtl");
          }
          self2.bodyClasses = new ClassList(function() {
            if (self2.state.get("rendered")) {
              self2.getEl("body").className = this.toString();
            }
          });
          self2.bodyClasses.prefix = self2.classPrefix;
          self2.classes.add("container");
          self2.bodyClasses.add("container-body");
          if (settings.containerCls) {
            self2.classes.add(settings.containerCls);
          }
          self2._layout = global$4.create((settings.layout || "") + "layout");
          if (self2.settings.items) {
            self2.add(self2.settings.items);
          } else {
            self2.add(self2.render());
          }
          self2._hasBody = true;
        },
        items: function() {
          return this._items;
        },
        find: function(selector) {
          selector = selectorCache[selector] = selectorCache[selector] || new Selector(selector);
          return selector.find(this);
        },
        add: function(items) {
          var self2 = this;
          self2.items().add(self2.create(items)).parent(self2);
          return self2;
        },
        focus: function(keyboard) {
          var self2 = this;
          var focusCtrl, keyboardNav, items;
          if (keyboard) {
            keyboardNav = self2.keyboardNav || self2.parents().eq(-1)[0].keyboardNav;
            if (keyboardNav) {
              keyboardNav.focusFirst(self2);
              return;
            }
          }
          items = self2.find("*");
          if (self2.statusbar) {
            items.add(self2.statusbar.items());
          }
          items.each(function(ctrl) {
            if (ctrl.settings.autofocus) {
              focusCtrl = null;
              return false;
            }
            if (ctrl.canFocus) {
              focusCtrl = focusCtrl || ctrl;
            }
          });
          if (focusCtrl) {
            focusCtrl.focus();
          }
          return self2;
        },
        replace: function(oldItem, newItem) {
          var ctrlElm;
          var items = this.items();
          var i = items.length;
          while (i--) {
            if (items[i] === oldItem) {
              items[i] = newItem;
              break;
            }
          }
          if (i >= 0) {
            ctrlElm = newItem.getEl();
            if (ctrlElm) {
              ctrlElm.parentNode.removeChild(ctrlElm);
            }
            ctrlElm = oldItem.getEl();
            if (ctrlElm) {
              ctrlElm.parentNode.removeChild(ctrlElm);
            }
          }
          newItem.parent(this);
        },
        create: function(items) {
          var self2 = this;
          var settings;
          var ctrlItems = [];
          if (!global$2.isArray(items)) {
            items = [items];
          }
          global$2.each(items, function(item) {
            if (item) {
              if (!(item instanceof Control$1)) {
                if (typeof item === "string") {
                  item = { type: item };
                }
                settings = global$2.extend({}, self2.settings.defaults, item);
                item.type = settings.type = settings.type || item.type || self2.settings.defaultType || (settings.defaults ? settings.defaults.type : null);
                item = global$4.create(settings);
              }
              ctrlItems.push(item);
            }
          });
          return ctrlItems;
        },
        renderNew: function() {
          var self2 = this;
          self2.items().each(function(ctrl, index) {
            var containerElm;
            ctrl.parent(self2);
            if (!ctrl.state.get("rendered")) {
              containerElm = self2.getEl("body");
              if (containerElm.hasChildNodes() && index <= containerElm.childNodes.length - 1) {
                global$9(containerElm.childNodes[index]).before(ctrl.renderHtml());
              } else {
                global$9(containerElm).append(ctrl.renderHtml());
              }
              ctrl.postRender();
              ReflowQueue.add(ctrl);
            }
          });
          self2._layout.applyClasses(self2.items().filter(":visible"));
          self2._lastRect = null;
          return self2;
        },
        append: function(items) {
          return this.add(items).renderNew();
        },
        prepend: function(items) {
          var self2 = this;
          self2.items().set(self2.create(items).concat(self2.items().toArray()));
          return self2.renderNew();
        },
        insert: function(items, index, before) {
          var self2 = this;
          var curItems, beforeItems, afterItems;
          items = self2.create(items);
          curItems = self2.items();
          if (!before && index < curItems.length - 1) {
            index += 1;
          }
          if (index >= 0 && index < curItems.length) {
            beforeItems = curItems.slice(0, index).toArray();
            afterItems = curItems.slice(index).toArray();
            curItems.set(beforeItems.concat(items, afterItems));
          }
          return self2.renderNew();
        },
        fromJSON: function(data) {
          var self2 = this;
          for (var name in data) {
            self2.find("#" + name).value(data[name]);
          }
          return self2;
        },
        toJSON: function() {
          var self2 = this, data = {};
          self2.find("*").each(function(ctrl) {
            var name = ctrl.name(), value = ctrl.value();
            if (name && typeof value !== "undefined") {
              data[name] = value;
            }
          });
          return data;
        },
        renderHtml: function() {
          var self2 = this, layout = self2._layout, role = this.settings.role;
          self2.preRender();
          layout.preRender(self2);
          return '<div id="' + self2._id + '" class="' + self2.classes + '"' + (role ? ' role="' + this.settings.role + '"' : "") + '><div id="' + self2._id + '-body" class="' + self2.bodyClasses + '">' + (self2.settings.html || "") + layout.renderHtml(self2) + "</div></div>";
        },
        postRender: function() {
          var self2 = this;
          var box;
          self2.items().exec("postRender");
          self2._super();
          self2._layout.postRender(self2);
          self2.state.set("rendered", true);
          if (self2.settings.style) {
            self2.$el.css(self2.settings.style);
          }
          if (self2.settings.border) {
            box = self2.borderBox;
            self2.$el.css({
              "border-top-width": box.top,
              "border-right-width": box.right,
              "border-bottom-width": box.bottom,
              "border-left-width": box.left
            });
          }
          if (!self2.parent()) {
            self2.keyboardNav = KeyboardNavigation({ root: self2 });
          }
          return self2;
        },
        initLayoutRect: function() {
          var self2 = this, layoutRect = self2._super();
          self2._layout.recalc(self2);
          return layoutRect;
        },
        recalc: function() {
          var self2 = this;
          var rect2 = self2._layoutRect;
          var lastRect = self2._lastRect;
          if (!lastRect || lastRect.w !== rect2.w || lastRect.h !== rect2.h) {
            self2._layout.recalc(self2);
            rect2 = self2.layoutRect();
            self2._lastRect = {
              x: rect2.x,
              y: rect2.y,
              w: rect2.w,
              h: rect2.h
            };
            return true;
          }
        },
        reflow: function() {
          var i;
          ReflowQueue.remove(this);
          if (this.visible()) {
            Control$1.repaintControls = [];
            Control$1.repaintControls.map = {};
            this.recalc();
            i = Control$1.repaintControls.length;
            while (i--) {
              Control$1.repaintControls[i].repaint();
            }
            if (this.settings.layout !== "flow" && this.settings.layout !== "stack") {
              this.repaint();
            }
            Control$1.repaintControls = [];
          }
          return this;
        }
      });
      function getDocumentSize(doc) {
        var documentElement, body, scrollWidth, clientWidth;
        var offsetWidth, scrollHeight, clientHeight, offsetHeight;
        var max = Math.max;
        documentElement = doc.documentElement;
        body = doc.body;
        scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
        clientWidth = max(documentElement.clientWidth, body.clientWidth);
        offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
        scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
        clientHeight = max(documentElement.clientHeight, body.clientHeight);
        offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
        return {
          width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
          height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
        };
      }
      function updateWithTouchData(e) {
        var keys, i;
        if (e.changedTouches) {
          keys = "screenX screenY pageX pageY clientX clientY".split(" ");
          for (i = 0; i < keys.length; i++) {
            e[keys[i]] = e.changedTouches[0][keys[i]];
          }
        }
      }
      function DragHelper(id, settings) {
        var $eventOverlay;
        var doc = settings.document || domGlobals.document;
        var downButton;
        var start, stop, drag, startX, startY;
        settings = settings || {};
        var handleElement = doc.getElementById(settings.handle || id);
        start = function(e) {
          var docSize = getDocumentSize(doc);
          var handleElm, cursor;
          updateWithTouchData(e);
          e.preventDefault();
          downButton = e.button;
          handleElm = handleElement;
          startX = e.screenX;
          startY = e.screenY;
          if (domGlobals.window.getComputedStyle) {
            cursor = domGlobals.window.getComputedStyle(handleElm, null).getPropertyValue("cursor");
          } else {
            cursor = handleElm.runtimeStyle.cursor;
          }
          $eventOverlay = global$9("<div></div>").css({
            position: "absolute",
            top: 0,
            left: 0,
            width: docSize.width,
            height: docSize.height,
            zIndex: 2147483647,
            opacity: 1e-4,
            cursor
          }).appendTo(doc.body);
          global$9(doc).on("mousemove touchmove", drag).on("mouseup touchend", stop);
          settings.start(e);
        };
        drag = function(e) {
          updateWithTouchData(e);
          if (e.button !== downButton) {
            return stop(e);
          }
          e.deltaX = e.screenX - startX;
          e.deltaY = e.screenY - startY;
          e.preventDefault();
          settings.drag(e);
        };
        stop = function(e) {
          updateWithTouchData(e);
          global$9(doc).off("mousemove touchmove", drag).off("mouseup touchend", stop);
          $eventOverlay.remove();
          if (settings.stop) {
            settings.stop(e);
          }
        };
        this.destroy = function() {
          global$9(handleElement).off();
        };
        global$9(handleElement).on("mousedown touchstart", start);
      }
      var Scrollable = {
        init: function() {
          var self2 = this;
          self2.on("repaint", self2.renderScroll);
        },
        renderScroll: function() {
          var self2 = this, margin = 2;
          function repaintScroll() {
            var hasScrollH, hasScrollV, bodyElm;
            function repaintAxis(axisName, posName, sizeName, contentSizeName, hasScroll, ax) {
              var containerElm, scrollBarElm, scrollThumbElm;
              var containerSize, scrollSize, ratio2, rect2;
              var posNameLower, sizeNameLower;
              scrollBarElm = self2.getEl("scroll" + axisName);
              if (scrollBarElm) {
                posNameLower = posName.toLowerCase();
                sizeNameLower = sizeName.toLowerCase();
                global$9(self2.getEl("absend")).css(posNameLower, self2.layoutRect()[contentSizeName] - 1);
                if (!hasScroll) {
                  global$9(scrollBarElm).css("display", "none");
                  return;
                }
                global$9(scrollBarElm).css("display", "block");
                containerElm = self2.getEl("body");
                scrollThumbElm = self2.getEl("scroll" + axisName + "t");
                containerSize = containerElm["client" + sizeName] - margin * 2;
                containerSize -= hasScrollH && hasScrollV ? scrollBarElm["client" + ax] : 0;
                scrollSize = containerElm["scroll" + sizeName];
                ratio2 = containerSize / scrollSize;
                rect2 = {};
                rect2[posNameLower] = containerElm["offset" + posName] + margin;
                rect2[sizeNameLower] = containerSize;
                global$9(scrollBarElm).css(rect2);
                rect2 = {};
                rect2[posNameLower] = containerElm["scroll" + posName] * ratio2;
                rect2[sizeNameLower] = containerSize * ratio2;
                global$9(scrollThumbElm).css(rect2);
              }
            }
            bodyElm = self2.getEl("body");
            hasScrollH = bodyElm.scrollWidth > bodyElm.clientWidth;
            hasScrollV = bodyElm.scrollHeight > bodyElm.clientHeight;
            repaintAxis("h", "Left", "Width", "contentW", hasScrollH, "Height");
            repaintAxis("v", "Top", "Height", "contentH", hasScrollV, "Width");
          }
          function addScroll() {
            function addScrollAxis(axisName, posName, sizeName, deltaPosName, ax) {
              var scrollStart;
              var axisId = self2._id + "-scroll" + axisName, prefix = self2.classPrefix;
              global$9(self2.getEl()).append('<div id="' + axisId + '" class="' + prefix + "scrollbar " + prefix + "scrollbar-" + axisName + '"><div id="' + axisId + 't" class="' + prefix + 'scrollbar-thumb"></div></div>');
              self2.draghelper = new DragHelper(axisId + "t", {
                start: function() {
                  scrollStart = self2.getEl("body")["scroll" + posName];
                  global$9("#" + axisId).addClass(prefix + "active");
                },
                drag: function(e) {
                  var ratio2, hasScrollH, hasScrollV, containerSize;
                  var layoutRect = self2.layoutRect();
                  hasScrollH = layoutRect.contentW > layoutRect.innerW;
                  hasScrollV = layoutRect.contentH > layoutRect.innerH;
                  containerSize = self2.getEl("body")["client" + sizeName] - margin * 2;
                  containerSize -= hasScrollH && hasScrollV ? self2.getEl("scroll" + axisName)["client" + ax] : 0;
                  ratio2 = containerSize / self2.getEl("body")["scroll" + sizeName];
                  self2.getEl("body")["scroll" + posName] = scrollStart + e["delta" + deltaPosName] / ratio2;
                },
                stop: function() {
                  global$9("#" + axisId).removeClass(prefix + "active");
                }
              });
            }
            self2.classes.add("scroll");
            addScrollAxis("v", "Top", "Height", "Y", "Width");
            addScrollAxis("h", "Left", "Width", "X", "Height");
          }
          if (self2.settings.autoScroll) {
            if (!self2._hasScroll) {
              self2._hasScroll = true;
              addScroll();
              self2.on("wheel", function(e) {
                var bodyEl = self2.getEl("body");
                bodyEl.scrollLeft += (e.deltaX || 0) * 10;
                bodyEl.scrollTop += e.deltaY * 10;
                repaintScroll();
              });
              global$9(self2.getEl("body")).on("scroll", repaintScroll);
            }
            repaintScroll();
          }
        }
      };
      var Panel = Container.extend({
        Defaults: {
          layout: "fit",
          containerCls: "panel"
        },
        Mixins: [Scrollable],
        renderHtml: function() {
          var self2 = this;
          var layout = self2._layout;
          var innerHtml = self2.settings.html;
          self2.preRender();
          layout.preRender(self2);
          if (typeof innerHtml === "undefined") {
            innerHtml = '<div id="' + self2._id + '-body" class="' + self2.bodyClasses + '">' + layout.renderHtml(self2) + "</div>";
          } else {
            if (typeof innerHtml === "function") {
              innerHtml = innerHtml.call(self2);
            }
            self2._hasBody = false;
          }
          return '<div id="' + self2._id + '" class="' + self2.classes + '" hidefocus="1" tabindex="-1" role="group">' + (self2._preBodyHtml || "") + innerHtml + "</div>";
        }
      });
      var Resizable = {
        resizeToContent: function() {
          this._layoutRect.autoResize = true;
          this._lastRect = null;
          this.reflow();
        },
        resizeTo: function(w, h) {
          if (w <= 1 || h <= 1) {
            var rect2 = funcs.getWindowSize();
            w = w <= 1 ? w * rect2.w : w;
            h = h <= 1 ? h * rect2.h : h;
          }
          this._layoutRect.autoResize = false;
          return this.layoutRect({
            minW: w,
            minH: h,
            w,
            h
          }).reflow();
        },
        resizeBy: function(dw, dh) {
          var self2 = this, rect2 = self2.layoutRect();
          return self2.resizeTo(rect2.w + dw, rect2.h + dh);
        }
      };
      var documentClickHandler, documentScrollHandler, windowResizeHandler;
      var visiblePanels = [];
      var zOrder = [];
      var hasModal;
      function isChildOf(ctrl, parent) {
        while (ctrl) {
          if (ctrl === parent) {
            return true;
          }
          ctrl = ctrl.parent();
        }
      }
      function skipOrHidePanels(e) {
        var i = visiblePanels.length;
        while (i--) {
          var panel = visiblePanels[i], clickCtrl = panel.getParentCtrl(e.target);
          if (panel.settings.autohide) {
            if (clickCtrl) {
              if (isChildOf(clickCtrl, panel) || panel.parent() === clickCtrl) {
                continue;
              }
            }
            e = panel.fire("autohide", { target: e.target });
            if (!e.isDefaultPrevented()) {
              panel.hide();
            }
          }
        }
      }
      function bindDocumentClickHandler() {
        if (!documentClickHandler) {
          documentClickHandler = function(e) {
            if (e.button === 2) {
              return;
            }
            skipOrHidePanels(e);
          };
          global$9(domGlobals.document).on("click touchstart", documentClickHandler);
        }
      }
      function bindDocumentScrollHandler() {
        if (!documentScrollHandler) {
          documentScrollHandler = function() {
            var i;
            i = visiblePanels.length;
            while (i--) {
              repositionPanel(visiblePanels[i]);
            }
          };
          global$9(domGlobals.window).on("scroll", documentScrollHandler);
        }
      }
      function bindWindowResizeHandler() {
        if (!windowResizeHandler) {
          var docElm_1 = domGlobals.document.documentElement;
          var clientWidth_1 = docElm_1.clientWidth, clientHeight_1 = docElm_1.clientHeight;
          windowResizeHandler = function() {
            if (!domGlobals.document.all || clientWidth_1 !== docElm_1.clientWidth || clientHeight_1 !== docElm_1.clientHeight) {
              clientWidth_1 = docElm_1.clientWidth;
              clientHeight_1 = docElm_1.clientHeight;
              FloatPanel.hideAll();
            }
          };
          global$9(domGlobals.window).on("resize", windowResizeHandler);
        }
      }
      function repositionPanel(panel) {
        var scrollY = funcs.getViewPort().y;
        function toggleFixedChildPanels(fixed, deltaY) {
          var parent;
          for (var i = 0; i < visiblePanels.length; i++) {
            if (visiblePanels[i] !== panel) {
              parent = visiblePanels[i].parent();
              while (parent && (parent = parent.parent())) {
                if (parent === panel) {
                  visiblePanels[i].fixed(fixed).moveBy(0, deltaY).repaint();
                }
              }
            }
          }
        }
        if (panel.settings.autofix) {
          if (!panel.state.get("fixed")) {
            panel._autoFixY = panel.layoutRect().y;
            if (panel._autoFixY < scrollY) {
              panel.fixed(true).layoutRect({ y: 0 }).repaint();
              toggleFixedChildPanels(true, scrollY - panel._autoFixY);
            }
          } else {
            if (panel._autoFixY > scrollY) {
              panel.fixed(false).layoutRect({ y: panel._autoFixY }).repaint();
              toggleFixedChildPanels(false, panel._autoFixY - scrollY);
            }
          }
        }
      }
      function addRemove(add, ctrl) {
        var i, zIndex = FloatPanel.zIndex || 65535, topModal;
        if (add) {
          zOrder.push(ctrl);
        } else {
          i = zOrder.length;
          while (i--) {
            if (zOrder[i] === ctrl) {
              zOrder.splice(i, 1);
            }
          }
        }
        if (zOrder.length) {
          for (i = 0; i < zOrder.length; i++) {
            if (zOrder[i].modal) {
              zIndex++;
              topModal = zOrder[i];
            }
            zOrder[i].getEl().style.zIndex = zIndex;
            zOrder[i].zIndex = zIndex;
            zIndex++;
          }
        }
        var modalBlockEl = global$9("#" + ctrl.classPrefix + "modal-block", ctrl.getContainerElm())[0];
        if (topModal) {
          global$9(modalBlockEl).css("z-index", topModal.zIndex - 1);
        } else if (modalBlockEl) {
          modalBlockEl.parentNode.removeChild(modalBlockEl);
          hasModal = false;
        }
        FloatPanel.currentZIndex = zIndex;
      }
      var FloatPanel = Panel.extend({
        Mixins: [
          Movable,
          Resizable
        ],
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2._eventsRoot = self2;
          self2.classes.add("floatpanel");
          if (settings.autohide) {
            bindDocumentClickHandler();
            bindWindowResizeHandler();
            visiblePanels.push(self2);
          }
          if (settings.autofix) {
            bindDocumentScrollHandler();
            self2.on("move", function() {
              repositionPanel(this);
            });
          }
          self2.on("postrender show", function(e) {
            if (e.control === self2) {
              var $modalBlockEl_1;
              var prefix_1 = self2.classPrefix;
              if (self2.modal && !hasModal) {
                $modalBlockEl_1 = global$9("#" + prefix_1 + "modal-block", self2.getContainerElm());
                if (!$modalBlockEl_1[0]) {
                  $modalBlockEl_1 = global$9('<div id="' + prefix_1 + 'modal-block" class="' + prefix_1 + "reset " + prefix_1 + 'fade"></div>').appendTo(self2.getContainerElm());
                }
                global$7.setTimeout(function() {
                  $modalBlockEl_1.addClass(prefix_1 + "in");
                  global$9(self2.getEl()).addClass(prefix_1 + "in");
                });
                hasModal = true;
              }
              addRemove(true, self2);
            }
          });
          self2.on("show", function() {
            self2.parents().each(function(ctrl) {
              if (ctrl.state.get("fixed")) {
                self2.fixed(true);
                return false;
              }
            });
          });
          if (settings.popover) {
            self2._preBodyHtml = '<div class="' + self2.classPrefix + 'arrow"></div>';
            self2.classes.add("popover").add("bottom").add(self2.isRtl() ? "end" : "start");
          }
          self2.aria("label", settings.ariaLabel);
          self2.aria("labelledby", self2._id);
          self2.aria("describedby", self2.describedBy || self2._id + "-none");
        },
        fixed: function(state) {
          var self2 = this;
          if (self2.state.get("fixed") !== state) {
            if (self2.state.get("rendered")) {
              var viewport = funcs.getViewPort();
              if (state) {
                self2.layoutRect().y -= viewport.y;
              } else {
                self2.layoutRect().y += viewport.y;
              }
            }
            self2.classes.toggle("fixed", state);
            self2.state.set("fixed", state);
          }
          return self2;
        },
        show: function() {
          var self2 = this;
          var i;
          var state = self2._super();
          i = visiblePanels.length;
          while (i--) {
            if (visiblePanels[i] === self2) {
              break;
            }
          }
          if (i === -1) {
            visiblePanels.push(self2);
          }
          return state;
        },
        hide: function() {
          removeVisiblePanel(this);
          addRemove(false, this);
          return this._super();
        },
        hideAll: function() {
          FloatPanel.hideAll();
        },
        close: function() {
          var self2 = this;
          if (!self2.fire("close").isDefaultPrevented()) {
            self2.remove();
            addRemove(false, self2);
          }
          return self2;
        },
        remove: function() {
          removeVisiblePanel(this);
          this._super();
        },
        postRender: function() {
          var self2 = this;
          if (self2.settings.bodyRole) {
            this.getEl("body").setAttribute("role", self2.settings.bodyRole);
          }
          return self2._super();
        }
      });
      FloatPanel.hideAll = function() {
        var i = visiblePanels.length;
        while (i--) {
          var panel = visiblePanels[i];
          if (panel && panel.settings.autohide) {
            panel.hide();
            visiblePanels.splice(i, 1);
          }
        }
      };
      function removeVisiblePanel(panel) {
        var i;
        i = visiblePanels.length;
        while (i--) {
          if (visiblePanels[i] === panel) {
            visiblePanels.splice(i, 1);
          }
        }
        i = zOrder.length;
        while (i--) {
          if (zOrder[i] === panel) {
            zOrder.splice(i, 1);
          }
        }
      }
      var isFixed$1 = function(inlineToolbarContainer, editor) {
        return !!(inlineToolbarContainer && !editor.settings.ui_container);
      };
      var render$1 = function(editor, theme2, args) {
        var panel, inlineToolbarContainer;
        var DOM2 = global$3.DOM;
        var fixedToolbarContainer = getFixedToolbarContainer(editor);
        if (fixedToolbarContainer) {
          inlineToolbarContainer = DOM2.select(fixedToolbarContainer)[0];
        }
        var reposition = function() {
          if (panel && panel.moveRel && panel.visible() && !panel._fixed) {
            var scrollContainer = editor.selection.getScrollContainer(), body = editor.getBody();
            var deltaX = 0, deltaY = 0;
            if (scrollContainer) {
              var bodyPos = DOM2.getPos(body), scrollContainerPos = DOM2.getPos(scrollContainer);
              deltaX = Math.max(0, scrollContainerPos.x - bodyPos.x);
              deltaY = Math.max(0, scrollContainerPos.y - bodyPos.y);
            }
            panel.fixed(false).moveRel(body, editor.rtl ? [
              "tr-br",
              "br-tr"
            ] : [
              "tl-bl",
              "bl-tl",
              "tr-br"
            ]).moveBy(deltaX, deltaY);
          }
        };
        var show = function() {
          if (panel) {
            panel.show();
            reposition();
            DOM2.addClass(editor.getBody(), "mce-edit-focus");
          }
        };
        var hide = function() {
          if (panel) {
            panel.hide();
            FloatPanel.hideAll();
            DOM2.removeClass(editor.getBody(), "mce-edit-focus");
          }
        };
        var render2 = function() {
          if (panel) {
            if (!panel.visible()) {
              show();
            }
            return;
          }
          panel = theme2.panel = global$4.create({
            type: inlineToolbarContainer ? "panel" : "floatpanel",
            role: "application",
            classes: "tinymce tinymce-inline",
            layout: "flex",
            direction: "column",
            align: "stretch",
            autohide: false,
            autofix: true,
            fixed: isFixed$1(inlineToolbarContainer, editor),
            border: 1,
            items: [
              hasMenubar(editor) === false ? null : {
                type: "menubar",
                border: "0 0 1 0",
                items: Menubar.createMenuButtons(editor)
              },
              Toolbar.createToolbars(editor, getToolbarSize(editor))
            ]
          });
          UiContainer.setUiContainer(editor, panel);
          Events.fireBeforeRenderUI(editor);
          if (inlineToolbarContainer) {
            panel.renderTo(inlineToolbarContainer).reflow();
          } else {
            panel.renderTo().reflow();
          }
          A11y.addKeys(editor, panel);
          show();
          ContextToolbars.addContextualToolbars(editor);
          editor.on("nodeChange", reposition);
          editor.on("ResizeWindow", reposition);
          editor.on("activate", show);
          editor.on("deactivate", hide);
          editor.nodeChanged();
        };
        editor.settings.content_editable = true;
        editor.on("focus", function() {
          if (isSkinDisabled(editor) === false && args.skinUiCss) {
            DOM2.styleSheetLoader.load(args.skinUiCss, render2, render2);
          } else {
            render2();
          }
        });
        editor.on("blur hide", hide);
        editor.on("remove", function() {
          if (panel) {
            panel.remove();
            panel = null;
          }
        });
        if (isSkinDisabled(editor) === false && args.skinUiCss) {
          DOM2.styleSheetLoader.load(args.skinUiCss, SkinLoaded.fireSkinLoaded(editor));
        } else {
          SkinLoaded.fireSkinLoaded(editor)();
        }
        return {};
      };
      var Inline = { render: render$1 };
      function Throbber(elm, inline2) {
        var self2 = this;
        var state;
        var classPrefix2 = Control$1.classPrefix;
        var timer;
        self2.show = function(time, callback) {
          function render2() {
            if (state) {
              global$9(elm).append('<div class="' + classPrefix2 + "throbber" + (inline2 ? " " + classPrefix2 + "throbber-inline" : "") + '"></div>');
              if (callback) {
                callback();
              }
            }
          }
          self2.hide();
          state = true;
          if (time) {
            timer = global$7.setTimeout(render2, time);
          } else {
            render2();
          }
          return self2;
        };
        self2.hide = function() {
          var child = elm.lastChild;
          global$7.clearTimeout(timer);
          if (child && child.className.indexOf("throbber") !== -1) {
            child.parentNode.removeChild(child);
          }
          state = false;
          return self2;
        };
      }
      var setup = function(editor, theme2) {
        var throbber;
        editor.on("ProgressState", function(e) {
          throbber = throbber || new Throbber(theme2.panel.getEl("body"));
          if (e.state) {
            throbber.show(e.time);
          } else {
            throbber.hide();
          }
        });
      };
      var ProgressState = { setup };
      var renderUI = function(editor, theme2, args) {
        var skinUrl = getSkinUrl(editor);
        if (skinUrl) {
          args.skinUiCss = skinUrl + "/skin.min.css";
          editor.contentCSS.push(skinUrl + "/content" + (editor.inline ? ".inline" : "") + ".min.css");
        }
        ProgressState.setup(editor, theme2);
        return isInline(editor) ? Inline.render(editor, theme2, args) : Iframe.render(editor, theme2, args);
      };
      var Render = { renderUI };
      var Tooltip = Control$1.extend({
        Mixins: [Movable],
        Defaults: { classes: "widget tooltip tooltip-n" },
        renderHtml: function() {
          var self2 = this, prefix = self2.classPrefix;
          return '<div id="' + self2._id + '" class="' + self2.classes + '" role="presentation"><div class="' + prefix + 'tooltip-arrow"></div><div class="' + prefix + 'tooltip-inner">' + self2.encode(self2.state.get("text")) + "</div></div>";
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:text", function(e) {
            self2.getEl().lastChild.innerHTML = self2.encode(e.value);
          });
          return self2._super();
        },
        repaint: function() {
          var self2 = this;
          var style, rect2;
          style = self2.getEl().style;
          rect2 = self2._layoutRect;
          style.left = rect2.x + "px";
          style.top = rect2.y + "px";
          style.zIndex = 65535 + 65535;
        }
      });
      var Widget = Control$1.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          settings = self2.settings;
          self2.canFocus = true;
          if (settings.tooltip && Widget.tooltips !== false) {
            self2.on("mouseenter", function(e) {
              var tooltip = self2.tooltip().moveTo(-65535);
              if (e.control === self2) {
                var rel = tooltip.text(settings.tooltip).show().testMoveRel(self2.getEl(), [
                  "bc-tc",
                  "bc-tl",
                  "bc-tr"
                ]);
                tooltip.classes.toggle("tooltip-n", rel === "bc-tc");
                tooltip.classes.toggle("tooltip-nw", rel === "bc-tl");
                tooltip.classes.toggle("tooltip-ne", rel === "bc-tr");
                tooltip.moveRel(self2.getEl(), rel);
              } else {
                tooltip.hide();
              }
            });
            self2.on("mouseleave mousedown click", function() {
              self2.tooltip().remove();
              self2._tooltip = null;
            });
          }
          self2.aria("label", settings.ariaLabel || settings.tooltip);
        },
        tooltip: function() {
          if (!this._tooltip) {
            this._tooltip = new Tooltip({ type: "tooltip" });
            UiContainer.inheritUiContainer(this, this._tooltip);
            this._tooltip.renderTo();
          }
          return this._tooltip;
        },
        postRender: function() {
          var self2 = this, settings = self2.settings;
          self2._super();
          if (!self2.parent() && (settings.width || settings.height)) {
            self2.initLayoutRect();
            self2.repaint();
          }
          if (settings.autofocus) {
            self2.focus();
          }
        },
        bindStates: function() {
          var self2 = this;
          function disable(state) {
            self2.aria("disabled", state);
            self2.classes.toggle("disabled", state);
          }
          function active(state) {
            self2.aria("pressed", state);
            self2.classes.toggle("active", state);
          }
          self2.state.on("change:disabled", function(e) {
            disable(e.value);
          });
          self2.state.on("change:active", function(e) {
            active(e.value);
          });
          if (self2.state.get("disabled")) {
            disable(true);
          }
          if (self2.state.get("active")) {
            active(true);
          }
          return self2._super();
        },
        remove: function() {
          this._super();
          if (this._tooltip) {
            this._tooltip.remove();
            this._tooltip = null;
          }
        }
      });
      var Progress = Widget.extend({
        Defaults: { value: 0 },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.classes.add("progress");
          if (!self2.settings.filter) {
            self2.settings.filter = function(value) {
              return Math.round(value);
            };
          }
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = this.classPrefix;
          return '<div id="' + id + '" class="' + self2.classes + '"><div class="' + prefix + 'bar-container"><div class="' + prefix + 'bar"></div></div><div class="' + prefix + 'text">0%</div></div>';
        },
        postRender: function() {
          var self2 = this;
          self2._super();
          self2.value(self2.settings.value);
          return self2;
        },
        bindStates: function() {
          var self2 = this;
          function setValue(value) {
            value = self2.settings.filter(value);
            self2.getEl().lastChild.innerHTML = value + "%";
            self2.getEl().firstChild.firstChild.style.width = value + "%";
          }
          self2.state.on("change:value", function(e) {
            setValue(e.value);
          });
          setValue(self2.state.get("value"));
          return self2._super();
        }
      });
      var updateLiveRegion = function(ctx, text2) {
        ctx.getEl().lastChild.textContent = text2 + (ctx.progressBar ? " " + ctx.progressBar.value() + "%" : "");
      };
      var Notification = Control$1.extend({
        Mixins: [Movable],
        Defaults: { classes: "widget notification" },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.maxWidth = settings.maxWidth;
          if (settings.text) {
            self2.text(settings.text);
          }
          if (settings.icon) {
            self2.icon = settings.icon;
          }
          if (settings.color) {
            self2.color = settings.color;
          }
          if (settings.type) {
            self2.classes.add("notification-" + settings.type);
          }
          if (settings.timeout && (settings.timeout < 0 || settings.timeout > 0) && !settings.closeButton) {
            self2.closeButton = false;
          } else {
            self2.classes.add("has-close");
            self2.closeButton = true;
          }
          if (settings.progressBar) {
            self2.progressBar = new Progress();
          }
          self2.on("click", function(e) {
            if (e.target.className.indexOf(self2.classPrefix + "close") !== -1) {
              self2.close();
            }
          });
        },
        renderHtml: function() {
          var self2 = this;
          var prefix = self2.classPrefix;
          var icon = "", closeButton = "", progressBar = "", notificationStyle = "";
          if (self2.icon) {
            icon = '<i class="' + prefix + "ico " + prefix + "i-" + self2.icon + '"></i>';
          }
          notificationStyle = ' style="max-width: ' + self2.maxWidth + "px;" + (self2.color ? "background-color: " + self2.color + ';"' : '"');
          if (self2.closeButton) {
            closeButton = '<button type="button" class="' + prefix + 'close" aria-hidden="true">Ã—</button>';
          }
          if (self2.progressBar) {
            progressBar = self2.progressBar.renderHtml();
          }
          return '<div id="' + self2._id + '" class="' + self2.classes + '"' + notificationStyle + ' role="presentation">' + icon + '<div class="' + prefix + 'notification-inner">' + self2.state.get("text") + "</div>" + progressBar + closeButton + '<div style="clip: rect(1px, 1px, 1px, 1px);height: 1px;overflow: hidden;position: absolute;width: 1px;" aria-live="assertive" aria-relevant="additions" aria-atomic="true"></div></div>';
        },
        postRender: function() {
          var self2 = this;
          global$7.setTimeout(function() {
            self2.$el.addClass(self2.classPrefix + "in");
            updateLiveRegion(self2, self2.state.get("text"));
          }, 100);
          return self2._super();
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:text", function(e) {
            self2.getEl().firstChild.innerHTML = e.value;
            updateLiveRegion(self2, e.value);
          });
          if (self2.progressBar) {
            self2.progressBar.bindStates();
            self2.progressBar.state.on("change:value", function(e) {
              updateLiveRegion(self2, self2.state.get("text"));
            });
          }
          return self2._super();
        },
        close: function() {
          var self2 = this;
          if (!self2.fire("close").isDefaultPrevented()) {
            self2.remove();
          }
          return self2;
        },
        repaint: function() {
          var self2 = this;
          var style, rect2;
          style = self2.getEl().style;
          rect2 = self2._layoutRect;
          style.left = rect2.x + "px";
          style.top = rect2.y + "px";
          style.zIndex = 65535 - 1;
        }
      });
      function NotificationManagerImpl(editor) {
        var getEditorContainer = function(editor2) {
          return editor2.inline ? editor2.getElement() : editor2.getContentAreaContainer();
        };
        var getContainerWidth = function() {
          var container = getEditorContainer(editor);
          return funcs.getSize(container).width;
        };
        var prePositionNotifications = function(notifications) {
          each(notifications, function(notification) {
            notification.moveTo(0, 0);
          });
        };
        var positionNotifications = function(notifications) {
          if (notifications.length > 0) {
            var firstItem = notifications.slice(0, 1)[0];
            var container = getEditorContainer(editor);
            firstItem.moveRel(container, "tc-tc");
            each(notifications, function(notification, index) {
              if (index > 0) {
                notification.moveRel(notifications[index - 1].getEl(), "bc-tc");
              }
            });
          }
        };
        var reposition = function(notifications) {
          prePositionNotifications(notifications);
          positionNotifications(notifications);
        };
        var open = function(args, closeCallback) {
          var extendedArgs = global$2.extend(args, { maxWidth: getContainerWidth() });
          var notif = new Notification(extendedArgs);
          notif.args = extendedArgs;
          if (extendedArgs.timeout > 0) {
            notif.timer = setTimeout(function() {
              notif.close();
              closeCallback();
            }, extendedArgs.timeout);
          }
          notif.on("close", function() {
            closeCallback();
          });
          notif.renderTo();
          return notif;
        };
        var close = function(notification) {
          notification.close();
        };
        var getArgs = function(notification) {
          return notification.args;
        };
        return {
          open,
          close,
          reposition,
          getArgs
        };
      }
      var windows = [];
      var oldMetaValue = "";
      function toggleFullScreenState(state) {
        var noScaleMetaValue = "width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0";
        var viewport = global$9("meta[name=viewport]")[0], contentValue;
        if (global$8.overrideViewPort === false) {
          return;
        }
        if (!viewport) {
          viewport = domGlobals.document.createElement("meta");
          viewport.setAttribute("name", "viewport");
          domGlobals.document.getElementsByTagName("head")[0].appendChild(viewport);
        }
        contentValue = viewport.getAttribute("content");
        if (contentValue && typeof oldMetaValue !== "undefined") {
          oldMetaValue = contentValue;
        }
        viewport.setAttribute("content", state ? noScaleMetaValue : oldMetaValue);
      }
      function toggleBodyFullScreenClasses(classPrefix2, state) {
        if (checkFullscreenWindows() && state === false) {
          global$9([
            domGlobals.document.documentElement,
            domGlobals.document.body
          ]).removeClass(classPrefix2 + "fullscreen");
        }
      }
      function checkFullscreenWindows() {
        for (var i = 0; i < windows.length; i++) {
          if (windows[i]._fullscreen) {
            return true;
          }
        }
        return false;
      }
      function handleWindowResize() {
        if (!global$8.desktop) {
          var lastSize_1 = {
            w: domGlobals.window.innerWidth,
            h: domGlobals.window.innerHeight
          };
          global$7.setInterval(function() {
            var w = domGlobals.window.innerWidth, h = domGlobals.window.innerHeight;
            if (lastSize_1.w !== w || lastSize_1.h !== h) {
              lastSize_1 = {
                w,
                h
              };
              global$9(domGlobals.window).trigger("resize");
            }
          }, 100);
        }
        function reposition() {
          var i;
          var rect2 = funcs.getWindowSize();
          var layoutRect;
          for (i = 0; i < windows.length; i++) {
            layoutRect = windows[i].layoutRect();
            windows[i].moveTo(windows[i].settings.x || Math.max(0, rect2.w / 2 - layoutRect.w / 2), windows[i].settings.y || Math.max(0, rect2.h / 2 - layoutRect.h / 2));
          }
        }
        global$9(domGlobals.window).on("resize", reposition);
      }
      var Window = FloatPanel.extend({
        modal: true,
        Defaults: {
          border: 1,
          layout: "flex",
          containerCls: "panel",
          role: "dialog",
          callbacks: {
            submit: function() {
              this.fire("submit", { data: this.toJSON() });
            },
            close: function() {
              this.close();
            }
          }
        },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          if (self2.isRtl()) {
            self2.classes.add("rtl");
          }
          self2.classes.add("window");
          self2.bodyClasses.add("window-body");
          self2.state.set("fixed", true);
          if (settings.buttons) {
            self2.statusbar = new Panel({
              layout: "flex",
              border: "1 0 0 0",
              spacing: 3,
              padding: 10,
              align: "center",
              pack: self2.isRtl() ? "start" : "end",
              defaults: { type: "button" },
              items: settings.buttons
            });
            self2.statusbar.classes.add("foot");
            self2.statusbar.parent(self2);
          }
          self2.on("click", function(e) {
            var closeClass = self2.classPrefix + "close";
            if (funcs.hasClass(e.target, closeClass) || funcs.hasClass(e.target.parentNode, closeClass)) {
              self2.close();
            }
          });
          self2.on("cancel", function() {
            self2.close();
          });
          self2.on("move", function(e) {
            if (e.control === self2) {
              FloatPanel.hideAll();
            }
          });
          self2.aria("describedby", self2.describedBy || self2._id + "-none");
          self2.aria("label", settings.title);
          self2._fullscreen = false;
        },
        recalc: function() {
          var self2 = this;
          var statusbar = self2.statusbar;
          var layoutRect, width, x, needsRecalc;
          if (self2._fullscreen) {
            self2.layoutRect(funcs.getWindowSize());
            self2.layoutRect().contentH = self2.layoutRect().innerH;
          }
          self2._super();
          layoutRect = self2.layoutRect();
          if (self2.settings.title && !self2._fullscreen) {
            width = layoutRect.headerW;
            if (width > layoutRect.w) {
              x = layoutRect.x - Math.max(0, width / 2);
              self2.layoutRect({
                w: width,
                x
              });
              needsRecalc = true;
            }
          }
          if (statusbar) {
            statusbar.layoutRect({ w: self2.layoutRect().innerW }).recalc();
            width = statusbar.layoutRect().minW + layoutRect.deltaW;
            if (width > layoutRect.w) {
              x = layoutRect.x - Math.max(0, width - layoutRect.w);
              self2.layoutRect({
                w: width,
                x
              });
              needsRecalc = true;
            }
          }
          if (needsRecalc) {
            self2.recalc();
          }
        },
        initLayoutRect: function() {
          var self2 = this;
          var layoutRect = self2._super();
          var deltaH = 0, headEl;
          if (self2.settings.title && !self2._fullscreen) {
            headEl = self2.getEl("head");
            var size = funcs.getSize(headEl);
            layoutRect.headerW = size.width;
            layoutRect.headerH = size.height;
            deltaH += layoutRect.headerH;
          }
          if (self2.statusbar) {
            deltaH += self2.statusbar.layoutRect().h;
          }
          layoutRect.deltaH += deltaH;
          layoutRect.minH += deltaH;
          layoutRect.h += deltaH;
          var rect2 = funcs.getWindowSize();
          layoutRect.x = self2.settings.x || Math.max(0, rect2.w / 2 - layoutRect.w / 2);
          layoutRect.y = self2.settings.y || Math.max(0, rect2.h / 2 - layoutRect.h / 2);
          return layoutRect;
        },
        renderHtml: function() {
          var self2 = this, layout = self2._layout, id = self2._id, prefix = self2.classPrefix;
          var settings = self2.settings;
          var headerHtml = "", footerHtml = "", html2 = settings.html;
          self2.preRender();
          layout.preRender(self2);
          if (settings.title) {
            headerHtml = '<div id="' + id + '-head" class="' + prefix + 'window-head"><div id="' + id + '-title" class="' + prefix + 'title">' + self2.encode(settings.title) + '</div><div id="' + id + '-dragh" class="' + prefix + 'dragh"></div><button type="button" class="' + prefix + 'close" aria-hidden="true"><i class="mce-ico mce-i-remove"></i></button></div>';
          }
          if (settings.url) {
            html2 = '<iframe src="' + settings.url + '" tabindex="-1"></iframe>';
          }
          if (typeof html2 === "undefined") {
            html2 = layout.renderHtml(self2);
          }
          if (self2.statusbar) {
            footerHtml = self2.statusbar.renderHtml();
          }
          return '<div id="' + id + '" class="' + self2.classes + '" hidefocus="1"><div class="' + self2.classPrefix + 'reset" role="application">' + headerHtml + '<div id="' + id + '-body" class="' + self2.bodyClasses + '">' + html2 + "</div>" + footerHtml + "</div></div>";
        },
        fullscreen: function(state) {
          var self2 = this;
          var documentElement = domGlobals.document.documentElement;
          var slowRendering;
          var prefix = self2.classPrefix;
          var layoutRect;
          if (state !== self2._fullscreen) {
            global$9(domGlobals.window).on("resize", function() {
              var time;
              if (self2._fullscreen) {
                if (!slowRendering) {
                  time = (/* @__PURE__ */ new Date()).getTime();
                  var rect3 = funcs.getWindowSize();
                  self2.moveTo(0, 0).resizeTo(rect3.w, rect3.h);
                  if ((/* @__PURE__ */ new Date()).getTime() - time > 50) {
                    slowRendering = true;
                  }
                } else {
                  if (!self2._timer) {
                    self2._timer = global$7.setTimeout(function() {
                      var rect4 = funcs.getWindowSize();
                      self2.moveTo(0, 0).resizeTo(rect4.w, rect4.h);
                      self2._timer = 0;
                    }, 50);
                  }
                }
              }
            });
            layoutRect = self2.layoutRect();
            self2._fullscreen = state;
            if (!state) {
              self2.borderBox = BoxUtils.parseBox(self2.settings.border);
              self2.getEl("head").style.display = "";
              layoutRect.deltaH += layoutRect.headerH;
              global$9([
                documentElement,
                domGlobals.document.body
              ]).removeClass(prefix + "fullscreen");
              self2.classes.remove("fullscreen");
              self2.moveTo(self2._initial.x, self2._initial.y).resizeTo(self2._initial.w, self2._initial.h);
            } else {
              self2._initial = {
                x: layoutRect.x,
                y: layoutRect.y,
                w: layoutRect.w,
                h: layoutRect.h
              };
              self2.borderBox = BoxUtils.parseBox("0");
              self2.getEl("head").style.display = "none";
              layoutRect.deltaH -= layoutRect.headerH + 2;
              global$9([
                documentElement,
                domGlobals.document.body
              ]).addClass(prefix + "fullscreen");
              self2.classes.add("fullscreen");
              var rect2 = funcs.getWindowSize();
              self2.moveTo(0, 0).resizeTo(rect2.w, rect2.h);
            }
          }
          return self2.reflow();
        },
        postRender: function() {
          var self2 = this;
          var startPos;
          setTimeout(function() {
            self2.classes.add("in");
            self2.fire("open");
          }, 0);
          self2._super();
          if (self2.statusbar) {
            self2.statusbar.postRender();
          }
          self2.focus();
          this.dragHelper = new DragHelper(self2._id + "-dragh", {
            start: function() {
              startPos = {
                x: self2.layoutRect().x,
                y: self2.layoutRect().y
              };
            },
            drag: function(e) {
              self2.moveTo(startPos.x + e.deltaX, startPos.y + e.deltaY);
            }
          });
          self2.on("submit", function(e) {
            if (!e.isDefaultPrevented()) {
              self2.close();
            }
          });
          windows.push(self2);
          toggleFullScreenState(true);
        },
        submit: function() {
          return this.fire("submit", { data: this.toJSON() });
        },
        remove: function() {
          var self2 = this;
          var i;
          self2.dragHelper.destroy();
          self2._super();
          if (self2.statusbar) {
            this.statusbar.remove();
          }
          toggleBodyFullScreenClasses(self2.classPrefix, false);
          i = windows.length;
          while (i--) {
            if (windows[i] === self2) {
              windows.splice(i, 1);
            }
          }
          toggleFullScreenState(windows.length > 0);
        },
        getContentWindow: function() {
          var ifr2 = this.getEl().getElementsByTagName("iframe")[0];
          return ifr2 ? ifr2.contentWindow : null;
        }
      });
      handleWindowResize();
      var MessageBox = Window.extend({
        init: function(settings) {
          settings = {
            border: 1,
            padding: 20,
            layout: "flex",
            pack: "center",
            align: "center",
            containerCls: "panel",
            autoScroll: true,
            buttons: {
              type: "button",
              text: "Ok",
              action: "ok"
            },
            items: {
              type: "label",
              multiline: true,
              maxWidth: 500,
              maxHeight: 200
            }
          };
          this._super(settings);
        },
        Statics: {
          OK: 1,
          OK_CANCEL: 2,
          YES_NO: 3,
          YES_NO_CANCEL: 4,
          msgBox: function(settings) {
            var buttons;
            var callback = settings.callback || function() {
            };
            function createButton(text2, status, primary) {
              return {
                type: "button",
                text: text2,
                subtype: primary ? "primary" : "",
                onClick: function(e) {
                  e.control.parents()[1].close();
                  callback(status);
                }
              };
            }
            switch (settings.buttons) {
              case MessageBox.OK_CANCEL:
                buttons = [
                  createButton("Ok", true, true),
                  createButton("Cancel", false)
                ];
                break;
              case MessageBox.YES_NO:
              case MessageBox.YES_NO_CANCEL:
                buttons = [
                  createButton("Yes", 1, true),
                  createButton("No", 0)
                ];
                if (settings.buttons === MessageBox.YES_NO_CANCEL) {
                  buttons.push(createButton("Cancel", -1));
                }
                break;
              default:
                buttons = [createButton("Ok", true, true)];
                break;
            }
            return new Window({
              padding: 20,
              x: settings.x,
              y: settings.y,
              minWidth: 300,
              minHeight: 100,
              layout: "flex",
              pack: "center",
              align: "center",
              buttons,
              title: settings.title,
              role: "alertdialog",
              items: {
                type: "label",
                multiline: true,
                maxWidth: 500,
                maxHeight: 200,
                text: settings.text
              },
              onPostRender: function() {
                this.aria("describedby", this.items()[0]._id);
              },
              onClose: settings.onClose,
              onCancel: function() {
                callback(false);
              }
            }).renderTo(domGlobals.document.body).reflow();
          },
          alert: function(settings, callback) {
            if (typeof settings === "string") {
              settings = { text: settings };
            }
            settings.callback = callback;
            return MessageBox.msgBox(settings);
          },
          confirm: function(settings, callback) {
            if (typeof settings === "string") {
              settings = { text: settings };
            }
            settings.callback = callback;
            settings.buttons = MessageBox.OK_CANCEL;
            return MessageBox.msgBox(settings);
          }
        }
      });
      function WindowManagerImpl(editor) {
        var open = function(args, params2, closeCallback) {
          var win;
          args.title = args.title || " ";
          args.url = args.url || args.file;
          if (args.url) {
            args.width = parseInt(args.width || 320, 10);
            args.height = parseInt(args.height || 240, 10);
          }
          if (args.body) {
            args.items = {
              defaults: args.defaults,
              type: args.bodyType || "form",
              items: args.body,
              data: args.data,
              callbacks: args.commands
            };
          }
          if (!args.url && !args.buttons) {
            args.buttons = [
              {
                text: "Ok",
                subtype: "primary",
                onclick: function() {
                  win.find("form")[0].submit();
                }
              },
              {
                text: "Cancel",
                onclick: function() {
                  win.close();
                }
              }
            ];
          }
          win = new Window(args);
          win.on("close", function() {
            closeCallback(win);
          });
          if (args.data) {
            win.on("postRender", function() {
              this.find("*").each(function(ctrl) {
                var name = ctrl.name();
                if (name in args.data) {
                  ctrl.value(args.data[name]);
                }
              });
            });
          }
          win.features = args || {};
          win.params = params2 || {};
          win = win.renderTo(domGlobals.document.body).reflow();
          return win;
        };
        var alert = function(message, choiceCallback, closeCallback) {
          var win;
          win = MessageBox.alert(message, function() {
            choiceCallback();
          });
          win.on("close", function() {
            closeCallback(win);
          });
          return win;
        };
        var confirm = function(message, choiceCallback, closeCallback) {
          var win;
          win = MessageBox.confirm(message, function(state) {
            choiceCallback(state);
          });
          win.on("close", function() {
            closeCallback(win);
          });
          return win;
        };
        var close = function(window2) {
          window2.close();
        };
        var getParams = function(window2) {
          return window2.params;
        };
        var setParams = function(window2, params2) {
          window2.params = params2;
        };
        return {
          open,
          alert,
          confirm,
          close,
          getParams,
          setParams
        };
      }
      var get = function(editor) {
        var renderUI2 = function(args) {
          return Render.renderUI(editor, this, args);
        };
        var resizeTo2 = function(w, h) {
          return Resize.resizeTo(editor, w, h);
        };
        var resizeBy2 = function(dw, dh) {
          return Resize.resizeBy(editor, dw, dh);
        };
        var getNotificationManagerImpl = function() {
          return NotificationManagerImpl(editor);
        };
        var getWindowManagerImpl = function() {
          return WindowManagerImpl();
        };
        return {
          renderUI: renderUI2,
          resizeTo: resizeTo2,
          resizeBy: resizeBy2,
          getNotificationManagerImpl,
          getWindowManagerImpl
        };
      };
      var ThemeApi = { get };
      var Layout = global$a.extend({
        Defaults: {
          firstControlClass: "first",
          lastControlClass: "last"
        },
        init: function(settings) {
          this.settings = global$2.extend({}, this.Defaults, settings);
        },
        preRender: function(container) {
          container.bodyClasses.add(this.settings.containerClass);
        },
        applyClasses: function(items) {
          var self2 = this;
          var settings = self2.settings;
          var firstClass, lastClass, firstItem, lastItem;
          firstClass = settings.firstControlClass;
          lastClass = settings.lastControlClass;
          items.each(function(item) {
            item.classes.remove(firstClass).remove(lastClass).add(settings.controlClass);
            if (item.visible()) {
              if (!firstItem) {
                firstItem = item;
              }
              lastItem = item;
            }
          });
          if (firstItem) {
            firstItem.classes.add(firstClass);
          }
          if (lastItem) {
            lastItem.classes.add(lastClass);
          }
        },
        renderHtml: function(container) {
          var self2 = this;
          var html2 = "";
          self2.applyClasses(container.items());
          container.items().each(function(item) {
            html2 += item.renderHtml();
          });
          return html2;
        },
        recalc: function() {
        },
        postRender: function() {
        },
        isNative: function() {
          return false;
        }
      });
      var AbsoluteLayout = Layout.extend({
        Defaults: {
          containerClass: "abs-layout",
          controlClass: "abs-layout-item"
        },
        recalc: function(container) {
          container.items().filter(":visible").each(function(ctrl) {
            var settings = ctrl.settings;
            ctrl.layoutRect({
              x: settings.x,
              y: settings.y,
              w: settings.w,
              h: settings.h
            });
            if (ctrl.recalc) {
              ctrl.recalc();
            }
          });
        },
        renderHtml: function(container) {
          return '<div id="' + container._id + '-absend" class="' + container.classPrefix + 'abs-end"></div>' + this._super(container);
        }
      });
      var Button = Widget.extend({
        Defaults: {
          classes: "widget btn",
          role: "button"
        },
        init: function(settings) {
          var self2 = this;
          var size;
          self2._super(settings);
          settings = self2.settings;
          size = self2.settings.size;
          self2.on("click mousedown", function(e) {
            e.preventDefault();
          });
          self2.on("touchstart", function(e) {
            self2.fire("click", e);
            e.preventDefault();
          });
          if (settings.subtype) {
            self2.classes.add(settings.subtype);
          }
          if (size) {
            self2.classes.add("btn-" + size);
          }
          if (settings.icon) {
            self2.icon(settings.icon);
          }
        },
        icon: function(icon) {
          if (!arguments.length) {
            return this.state.get("icon");
          }
          this.state.set("icon", icon);
          return this;
        },
        repaint: function() {
          var btnElm = this.getEl().firstChild;
          var btnStyle;
          if (btnElm) {
            btnStyle = btnElm.style;
            btnStyle.width = btnStyle.height = "100%";
          }
          this._super();
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = self2.classPrefix;
          var icon = self2.state.get("icon"), image2;
          var text2 = self2.state.get("text");
          var textHtml = "";
          var ariaPressed;
          var settings = self2.settings;
          image2 = settings.image;
          if (image2) {
            icon = "none";
            if (typeof image2 !== "string") {
              image2 = domGlobals.window.getSelection ? image2[0] : image2[1];
            }
            image2 = ` style="background-image: url('` + image2 + `')"`;
          } else {
            image2 = "";
          }
          if (text2) {
            self2.classes.add("btn-has-text");
            textHtml = '<span class="' + prefix + 'txt">' + self2.encode(text2) + "</span>";
          }
          icon = icon ? prefix + "ico " + prefix + "i-" + icon : "";
          ariaPressed = typeof settings.active === "boolean" ? ' aria-pressed="' + settings.active + '"' : "";
          return '<div id="' + id + '" class="' + self2.classes + '" tabindex="-1"' + ariaPressed + '><button id="' + id + '-button" role="presentation" type="button" tabindex="-1">' + (icon ? '<i class="' + icon + '"' + image2 + "></i>" : "") + textHtml + "</button></div>";
        },
        bindStates: function() {
          var self2 = this, $ = self2.$, textCls = self2.classPrefix + "txt";
          function setButtonText(text2) {
            var $span = $("span." + textCls, self2.getEl());
            if (text2) {
              if (!$span[0]) {
                $("button:first", self2.getEl()).append('<span class="' + textCls + '"></span>');
                $span = $("span." + textCls, self2.getEl());
              }
              $span.html(self2.encode(text2));
            } else {
              $span.remove();
            }
            self2.classes.toggle("btn-has-text", !!text2);
          }
          self2.state.on("change:text", function(e) {
            setButtonText(e.value);
          });
          self2.state.on("change:icon", function(e) {
            var icon = e.value;
            var prefix = self2.classPrefix;
            self2.settings.icon = icon;
            icon = icon ? prefix + "ico " + prefix + "i-" + self2.settings.icon : "";
            var btnElm = self2.getEl().firstChild;
            var iconElm = btnElm.getElementsByTagName("i")[0];
            if (icon) {
              if (!iconElm || iconElm !== btnElm.firstChild) {
                iconElm = domGlobals.document.createElement("i");
                btnElm.insertBefore(iconElm, btnElm.firstChild);
              }
              iconElm.className = icon;
            } else if (iconElm) {
              btnElm.removeChild(iconElm);
            }
            setButtonText(self2.state.get("text"));
          });
          return self2._super();
        }
      });
      var BrowseButton = Button.extend({
        init: function(settings) {
          var self2 = this;
          settings = global$2.extend({
            text: "Browse...",
            multiple: false,
            accept: null
          }, settings);
          self2._super(settings);
          self2.classes.add("browsebutton");
          if (settings.multiple) {
            self2.classes.add("multiple");
          }
        },
        postRender: function() {
          var self2 = this;
          var input = funcs.create("input", {
            type: "file",
            id: self2._id + "-browse",
            accept: self2.settings.accept
          });
          self2._super();
          global$9(input).on("change", function(e) {
            var files = e.target.files;
            self2.value = function() {
              if (!files.length) {
                return null;
              } else if (self2.settings.multiple) {
                return files;
              } else {
                return files[0];
              }
            };
            e.preventDefault();
            if (files.length) {
              self2.fire("change", e);
            }
          });
          global$9(input).on("click", function(e) {
            e.stopPropagation();
          });
          global$9(self2.getEl("button")).on("click touchstart", function(e) {
            e.stopPropagation();
            input.click();
            e.preventDefault();
          });
          self2.getEl().appendChild(input);
        },
        remove: function() {
          global$9(this.getEl("button")).off();
          global$9(this.getEl("input")).off();
          this._super();
        }
      });
      var ButtonGroup = Container.extend({
        Defaults: {
          defaultType: "button",
          role: "group"
        },
        renderHtml: function() {
          var self2 = this, layout = self2._layout;
          self2.classes.add("btn-group");
          self2.preRender();
          layout.preRender(self2);
          return '<div id="' + self2._id + '" class="' + self2.classes + '"><div id="' + self2._id + '-body">' + (self2.settings.html || "") + layout.renderHtml(self2) + "</div></div>";
        }
      });
      var Checkbox = Widget.extend({
        Defaults: {
          classes: "checkbox",
          role: "checkbox",
          checked: false
        },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.on("click mousedown", function(e) {
            e.preventDefault();
          });
          self2.on("click", function(e) {
            e.preventDefault();
            if (!self2.disabled()) {
              self2.checked(!self2.checked());
            }
          });
          self2.checked(self2.settings.checked);
        },
        checked: function(state) {
          if (!arguments.length) {
            return this.state.get("checked");
          }
          this.state.set("checked", state);
          return this;
        },
        value: function(state) {
          if (!arguments.length) {
            return this.checked();
          }
          return this.checked(state);
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = self2.classPrefix;
          return '<div id="' + id + '" class="' + self2.classes + '" unselectable="on" aria-labelledby="' + id + '-al" tabindex="-1"><i class="' + prefix + "ico " + prefix + 'i-checkbox"></i><span id="' + id + '-al" class="' + prefix + 'label">' + self2.encode(self2.state.get("text")) + "</span></div>";
        },
        bindStates: function() {
          var self2 = this;
          function checked(state) {
            self2.classes.toggle("checked", state);
            self2.aria("checked", state);
          }
          self2.state.on("change:text", function(e) {
            self2.getEl("al").firstChild.data = self2.translate(e.value);
          });
          self2.state.on("change:checked change:value", function(e) {
            self2.fire("change");
            checked(e.value);
          });
          self2.state.on("change:icon", function(e) {
            var icon = e.value;
            var prefix = self2.classPrefix;
            if (typeof icon === "undefined") {
              return self2.settings.icon;
            }
            self2.settings.icon = icon;
            icon = icon ? prefix + "ico " + prefix + "i-" + self2.settings.icon : "";
            var btnElm = self2.getEl().firstChild;
            var iconElm = btnElm.getElementsByTagName("i")[0];
            if (icon) {
              if (!iconElm || iconElm !== btnElm.firstChild) {
                iconElm = domGlobals.document.createElement("i");
                btnElm.insertBefore(iconElm, btnElm.firstChild);
              }
              iconElm.className = icon;
            } else if (iconElm) {
              btnElm.removeChild(iconElm);
            }
          });
          if (self2.state.get("checked")) {
            checked(true);
          }
          return self2._super();
        }
      });
      var global$d = tinymce.util.Tools.resolve("tinymce.util.VK");
      var ComboBox = Widget.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          settings = self2.settings;
          self2.classes.add("combobox");
          self2.subinput = true;
          self2.ariaTarget = "inp";
          settings.menu = settings.menu || settings.values;
          if (settings.menu) {
            settings.icon = "caret";
          }
          self2.on("click", function(e) {
            var elm = e.target;
            var root2 = self2.getEl();
            if (!global$9.contains(root2, elm) && elm !== root2) {
              return;
            }
            while (elm && elm !== root2) {
              if (elm.id && elm.id.indexOf("-open") !== -1) {
                self2.fire("action");
                if (settings.menu) {
                  self2.showMenu();
                  if (e.aria) {
                    self2.menu.items()[0].focus();
                  }
                }
              }
              elm = elm.parentNode;
            }
          });
          self2.on("keydown", function(e) {
            var rootControl;
            if (e.keyCode === 13 && e.target.nodeName === "INPUT") {
              e.preventDefault();
              self2.parents().reverse().each(function(ctrl) {
                if (ctrl.toJSON) {
                  rootControl = ctrl;
                  return false;
                }
              });
              self2.fire("submit", { data: rootControl.toJSON() });
            }
          });
          self2.on("keyup", function(e) {
            if (e.target.nodeName === "INPUT") {
              var oldValue = self2.state.get("value");
              var newValue = e.target.value;
              if (newValue !== oldValue) {
                self2.state.set("value", newValue);
                self2.fire("autocomplete", e);
              }
            }
          });
          self2.on("mouseover", function(e) {
            var tooltip = self2.tooltip().moveTo(-65535);
            if (self2.statusLevel() && e.target.className.indexOf(self2.classPrefix + "status") !== -1) {
              var statusMessage = self2.statusMessage() || "Ok";
              var rel = tooltip.text(statusMessage).show().testMoveRel(e.target, [
                "bc-tc",
                "bc-tl",
                "bc-tr"
              ]);
              tooltip.classes.toggle("tooltip-n", rel === "bc-tc");
              tooltip.classes.toggle("tooltip-nw", rel === "bc-tl");
              tooltip.classes.toggle("tooltip-ne", rel === "bc-tr");
              tooltip.moveRel(e.target, rel);
            }
          });
        },
        statusLevel: function(value) {
          if (arguments.length > 0) {
            this.state.set("statusLevel", value);
          }
          return this.state.get("statusLevel");
        },
        statusMessage: function(value) {
          if (arguments.length > 0) {
            this.state.set("statusMessage", value);
          }
          return this.state.get("statusMessage");
        },
        showMenu: function() {
          var self2 = this;
          var settings = self2.settings;
          var menu;
          if (!self2.menu) {
            menu = settings.menu || [];
            if (menu.length) {
              menu = {
                type: "menu",
                items: menu
              };
            } else {
              menu.type = menu.type || "menu";
            }
            self2.menu = global$4.create(menu).parent(self2).renderTo(self2.getContainerElm());
            self2.fire("createmenu");
            self2.menu.reflow();
            self2.menu.on("cancel", function(e) {
              if (e.control === self2.menu) {
                self2.focus();
              }
            });
            self2.menu.on("show hide", function(e) {
              e.control.items().each(function(ctrl) {
                ctrl.active(ctrl.value() === self2.value());
              });
            }).fire("show");
            self2.menu.on("select", function(e) {
              self2.value(e.control.value());
            });
            self2.on("focusin", function(e) {
              if (e.target.tagName.toUpperCase() === "INPUT") {
                self2.menu.hide();
              }
            });
            self2.aria("expanded", true);
          }
          self2.menu.show();
          self2.menu.layoutRect({ w: self2.layoutRect().w });
          self2.menu.moveRel(self2.getEl(), self2.isRtl() ? [
            "br-tr",
            "tr-br"
          ] : [
            "bl-tl",
            "tl-bl"
          ]);
        },
        focus: function() {
          this.getEl("inp").focus();
        },
        repaint: function() {
          var self2 = this, elm = self2.getEl(), openElm = self2.getEl("open"), rect2 = self2.layoutRect();
          var width, lineHeight, innerPadding = 0;
          var inputElm = elm.firstChild;
          if (self2.statusLevel() && self2.statusLevel() !== "none") {
            innerPadding = parseInt(funcs.getRuntimeStyle(inputElm, "padding-right"), 10) - parseInt(funcs.getRuntimeStyle(inputElm, "padding-left"), 10);
          }
          if (openElm) {
            width = rect2.w - funcs.getSize(openElm).width - 10;
          } else {
            width = rect2.w - 10;
          }
          var doc = domGlobals.document;
          if (doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
            lineHeight = self2.layoutRect().h - 2 + "px";
          }
          global$9(inputElm).css({
            width: width - innerPadding,
            lineHeight
          });
          self2._super();
          return self2;
        },
        postRender: function() {
          var self2 = this;
          global$9(this.getEl("inp")).on("change", function(e) {
            self2.state.set("value", e.target.value);
            self2.fire("change", e);
          });
          return self2._super();
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, settings = self2.settings, prefix = self2.classPrefix;
          var value = self2.state.get("value") || "";
          var icon, text2, openBtnHtml = "", extraAttrs = "", statusHtml = "";
          if ("spellcheck" in settings) {
            extraAttrs += ' spellcheck="' + settings.spellcheck + '"';
          }
          if (settings.maxLength) {
            extraAttrs += ' maxlength="' + settings.maxLength + '"';
          }
          if (settings.size) {
            extraAttrs += ' size="' + settings.size + '"';
          }
          if (settings.subtype) {
            extraAttrs += ' type="' + settings.subtype + '"';
          }
          statusHtml = '<i id="' + id + '-status" class="mce-status mce-ico" style="display: none"></i>';
          if (self2.disabled()) {
            extraAttrs += ' disabled="disabled"';
          }
          icon = settings.icon;
          if (icon && icon !== "caret") {
            icon = prefix + "ico " + prefix + "i-" + settings.icon;
          }
          text2 = self2.state.get("text");
          if (icon || text2) {
            openBtnHtml = '<div id="' + id + '-open" class="' + prefix + "btn " + prefix + 'open" tabIndex="-1" role="button"><button id="' + id + '-action" type="button" hidefocus="1" tabindex="-1">' + (icon !== "caret" ? '<i class="' + icon + '"></i>' : '<i class="' + prefix + 'caret"></i>') + (text2 ? (icon ? " " : "") + text2 : "") + "</button></div>";
            self2.classes.add("has-open");
          }
          return '<div id="' + id + '" class="' + self2.classes + '"><input id="' + id + '-inp" class="' + prefix + 'textbox" value="' + self2.encode(value, false) + '" hidefocus="1"' + extraAttrs + ' placeholder="' + self2.encode(settings.placeholder) + '" />' + statusHtml + openBtnHtml + "</div>";
        },
        value: function(value) {
          if (arguments.length) {
            this.state.set("value", value);
            return this;
          }
          if (this.state.get("rendered")) {
            this.state.set("value", this.getEl("inp").value);
          }
          return this.state.get("value");
        },
        showAutoComplete: function(items, term) {
          var self2 = this;
          if (items.length === 0) {
            self2.hideMenu();
            return;
          }
          var insert = function(value, title) {
            return function() {
              self2.fire("selectitem", {
                title,
                value
              });
            };
          };
          if (self2.menu) {
            self2.menu.items().remove();
          } else {
            self2.menu = global$4.create({
              type: "menu",
              classes: "combobox-menu",
              layout: "flow"
            }).parent(self2).renderTo();
          }
          global$2.each(items, function(item) {
            self2.menu.add({
              text: item.title,
              url: item.previewUrl,
              match: term,
              classes: "menu-item-ellipsis",
              onclick: insert(item.value, item.title)
            });
          });
          self2.menu.renderNew();
          self2.hideMenu();
          self2.menu.on("cancel", function(e) {
            if (e.control.parent() === self2.menu) {
              e.stopPropagation();
              self2.focus();
              self2.hideMenu();
            }
          });
          self2.menu.on("select", function() {
            self2.focus();
          });
          var maxW = self2.layoutRect().w;
          self2.menu.layoutRect({
            w: maxW,
            minW: 0,
            maxW
          });
          self2.menu.repaint();
          self2.menu.reflow();
          self2.menu.show();
          self2.menu.moveRel(self2.getEl(), self2.isRtl() ? [
            "br-tr",
            "tr-br"
          ] : [
            "bl-tl",
            "tl-bl"
          ]);
        },
        hideMenu: function() {
          if (this.menu) {
            this.menu.hide();
          }
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:value", function(e) {
            if (self2.getEl("inp").value !== e.value) {
              self2.getEl("inp").value = e.value;
            }
          });
          self2.state.on("change:disabled", function(e) {
            self2.getEl("inp").disabled = e.value;
          });
          self2.state.on("change:statusLevel", function(e) {
            var statusIconElm = self2.getEl("status");
            var prefix = self2.classPrefix, value = e.value;
            funcs.css(statusIconElm, "display", value === "none" ? "none" : "");
            funcs.toggleClass(statusIconElm, prefix + "i-checkmark", value === "ok");
            funcs.toggleClass(statusIconElm, prefix + "i-warning", value === "warn");
            funcs.toggleClass(statusIconElm, prefix + "i-error", value === "error");
            self2.classes.toggle("has-status", value !== "none");
            self2.repaint();
          });
          funcs.on(self2.getEl("status"), "mouseleave", function() {
            self2.tooltip().hide();
          });
          self2.on("cancel", function(e) {
            if (self2.menu && self2.menu.visible()) {
              e.stopPropagation();
              self2.hideMenu();
            }
          });
          var focusIdx = function(idx, menu) {
            if (menu && menu.items().length > 0) {
              menu.items().eq(idx)[0].focus();
            }
          };
          self2.on("keydown", function(e) {
            var keyCode = e.keyCode;
            if (e.target.nodeName === "INPUT") {
              if (keyCode === global$d.DOWN) {
                e.preventDefault();
                self2.fire("autocomplete");
                focusIdx(0, self2.menu);
              } else if (keyCode === global$d.UP) {
                e.preventDefault();
                focusIdx(-1, self2.menu);
              }
            }
          });
          return self2._super();
        },
        remove: function() {
          global$9(this.getEl("inp")).off();
          if (this.menu) {
            this.menu.remove();
          }
          this._super();
        }
      });
      var ColorBox = ComboBox.extend({
        init: function(settings) {
          var self2 = this;
          settings.spellcheck = false;
          if (settings.onaction) {
            settings.icon = "none";
          }
          self2._super(settings);
          self2.classes.add("colorbox");
          self2.on("change keyup postrender", function() {
            self2.repaintColor(self2.value());
          });
        },
        repaintColor: function(value) {
          var openElm = this.getEl("open");
          var elm = openElm ? openElm.getElementsByTagName("i")[0] : null;
          if (elm) {
            try {
              elm.style.background = value;
            } catch (ex) {
            }
          }
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:value", function(e) {
            if (self2.state.get("rendered")) {
              self2.repaintColor(e.value);
            }
          });
          return self2._super();
        }
      });
      var PanelButton = Button.extend({
        showPanel: function() {
          var self2 = this, settings = self2.settings;
          self2.classes.add("opened");
          if (!self2.panel) {
            var panelSettings = settings.panel;
            if (panelSettings.type) {
              panelSettings = {
                layout: "grid",
                items: panelSettings
              };
            }
            panelSettings.role = panelSettings.role || "dialog";
            panelSettings.popover = true;
            panelSettings.autohide = true;
            panelSettings.ariaRoot = true;
            self2.panel = new FloatPanel(panelSettings).on("hide", function() {
              self2.classes.remove("opened");
            }).on("cancel", function(e) {
              e.stopPropagation();
              self2.focus();
              self2.hidePanel();
            }).parent(self2).renderTo(self2.getContainerElm());
            self2.panel.fire("show");
            self2.panel.reflow();
          } else {
            self2.panel.show();
          }
          var rtlRels = [
            "bc-tc",
            "bc-tl",
            "bc-tr"
          ];
          var ltrRels = [
            "bc-tc",
            "bc-tr",
            "bc-tl",
            "tc-bc",
            "tc-br",
            "tc-bl"
          ];
          var rel = self2.panel.testMoveRel(self2.getEl(), settings.popoverAlign || (self2.isRtl() ? rtlRels : ltrRels));
          self2.panel.classes.toggle("start", rel.substr(-1) === "l");
          self2.panel.classes.toggle("end", rel.substr(-1) === "r");
          var isTop = rel.substr(0, 1) === "t";
          self2.panel.classes.toggle("bottom", !isTop);
          self2.panel.classes.toggle("top", isTop);
          self2.panel.moveRel(self2.getEl(), rel);
        },
        hidePanel: function() {
          var self2 = this;
          if (self2.panel) {
            self2.panel.hide();
          }
        },
        postRender: function() {
          var self2 = this;
          self2.aria("haspopup", true);
          self2.on("click", function(e) {
            if (e.control === self2) {
              if (self2.panel && self2.panel.visible()) {
                self2.hidePanel();
              } else {
                self2.showPanel();
                self2.panel.focus(!!e.aria);
              }
            }
          });
          return self2._super();
        },
        remove: function() {
          if (this.panel) {
            this.panel.remove();
            this.panel = null;
          }
          return this._super();
        }
      });
      var DOM$3 = global$3.DOM;
      var ColorButton = PanelButton.extend({
        init: function(settings) {
          this._super(settings);
          this.classes.add("splitbtn");
          this.classes.add("colorbutton");
        },
        color: function(color) {
          if (color) {
            this._color = color;
            this.getEl("preview").style.backgroundColor = color;
            return this;
          }
          return this._color;
        },
        resetColor: function() {
          this._color = null;
          this.getEl("preview").style.backgroundColor = null;
          return this;
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = self2.classPrefix, text2 = self2.state.get("text");
          var icon = self2.settings.icon ? prefix + "ico " + prefix + "i-" + self2.settings.icon : "";
          var image2 = self2.settings.image ? ` style="background-image: url('` + self2.settings.image + `')"` : "";
          var textHtml = "";
          if (text2) {
            self2.classes.add("btn-has-text");
            textHtml = '<span class="' + prefix + 'txt">' + self2.encode(text2) + "</span>";
          }
          return '<div id="' + id + '" class="' + self2.classes + '" role="button" tabindex="-1" aria-haspopup="true"><button role="presentation" hidefocus="1" type="button" tabindex="-1">' + (icon ? '<i class="' + icon + '"' + image2 + "></i>" : "") + '<span id="' + id + '-preview" class="' + prefix + 'preview"></span>' + textHtml + '</button><button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1"> <i class="' + prefix + 'caret"></i></button></div>';
        },
        postRender: function() {
          var self2 = this, onClickHandler = self2.settings.onclick;
          self2.on("click", function(e) {
            if (e.aria && e.aria.key === "down") {
              return;
            }
            if (e.control === self2 && !DOM$3.getParent(e.target, "." + self2.classPrefix + "open")) {
              e.stopImmediatePropagation();
              onClickHandler.call(self2, e);
            }
          });
          delete self2.settings.onclick;
          return self2._super();
        }
      });
      var global$e = tinymce.util.Tools.resolve("tinymce.util.Color");
      var ColorPicker = Widget.extend({
        Defaults: { classes: "widget colorpicker" },
        init: function(settings) {
          this._super(settings);
        },
        postRender: function() {
          var self2 = this;
          var color = self2.color();
          var hsv, hueRootElm, huePointElm, svRootElm, svPointElm;
          hueRootElm = self2.getEl("h");
          huePointElm = self2.getEl("hp");
          svRootElm = self2.getEl("sv");
          svPointElm = self2.getEl("svp");
          function getPos(elm, event) {
            var pos = funcs.getPos(elm);
            var x, y;
            x = event.pageX - pos.x;
            y = event.pageY - pos.y;
            x = Math.max(0, Math.min(x / elm.clientWidth, 1));
            y = Math.max(0, Math.min(y / elm.clientHeight, 1));
            return {
              x,
              y
            };
          }
          function updateColor(hsv2, hueUpdate) {
            var hue = (360 - hsv2.h) / 360;
            funcs.css(huePointElm, { top: hue * 100 + "%" });
            if (!hueUpdate) {
              funcs.css(svPointElm, {
                left: hsv2.s + "%",
                top: 100 - hsv2.v + "%"
              });
            }
            svRootElm.style.background = global$e({
              s: 100,
              v: 100,
              h: hsv2.h
            }).toHex();
            self2.color().parse({
              s: hsv2.s,
              v: hsv2.v,
              h: hsv2.h
            });
          }
          function updateSaturationAndValue(e) {
            var pos;
            pos = getPos(svRootElm, e);
            hsv.s = pos.x * 100;
            hsv.v = (1 - pos.y) * 100;
            updateColor(hsv);
            self2.fire("change");
          }
          function updateHue(e) {
            var pos;
            pos = getPos(hueRootElm, e);
            hsv = color.toHsv();
            hsv.h = (1 - pos.y) * 360;
            updateColor(hsv, true);
            self2.fire("change");
          }
          self2._repaint = function() {
            hsv = color.toHsv();
            updateColor(hsv);
          };
          self2._super();
          self2._svdraghelper = new DragHelper(self2._id + "-sv", {
            start: updateSaturationAndValue,
            drag: updateSaturationAndValue
          });
          self2._hdraghelper = new DragHelper(self2._id + "-h", {
            start: updateHue,
            drag: updateHue
          });
          self2._repaint();
        },
        rgb: function() {
          return this.color().toRgb();
        },
        value: function(value) {
          var self2 = this;
          if (arguments.length) {
            self2.color().parse(value);
            if (self2._rendered) {
              self2._repaint();
            }
          } else {
            return self2.color().toHex();
          }
        },
        color: function() {
          if (!this._color) {
            this._color = global$e();
          }
          return this._color;
        },
        renderHtml: function() {
          var self2 = this;
          var id = self2._id;
          var prefix = self2.classPrefix;
          var hueHtml;
          var stops = "#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000";
          function getOldIeFallbackHtml() {
            var i, l, html2 = "", gradientPrefix, stopsList;
            gradientPrefix = "filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=";
            stopsList = stops.split(",");
            for (i = 0, l = stopsList.length - 1; i < l; i++) {
              html2 += '<div class="' + prefix + 'colorpicker-h-chunk" style="height:' + 100 / l + "%;" + gradientPrefix + stopsList[i] + ",endColorstr=" + stopsList[i + 1] + ");-ms-" + gradientPrefix + stopsList[i] + ",endColorstr=" + stopsList[i + 1] + ')"></div>';
            }
            return html2;
          }
          var gradientCssText = "background: -ms-linear-gradient(top," + stops + ");background: linear-gradient(to bottom," + stops + ");";
          hueHtml = '<div id="' + id + '-h" class="' + prefix + 'colorpicker-h" style="' + gradientCssText + '">' + getOldIeFallbackHtml() + '<div id="' + id + '-hp" class="' + prefix + 'colorpicker-h-marker"></div></div>';
          return '<div id="' + id + '" class="' + self2.classes + '"><div id="' + id + '-sv" class="' + prefix + 'colorpicker-sv"><div class="' + prefix + 'colorpicker-overlay1"><div class="' + prefix + 'colorpicker-overlay2"><div id="' + id + '-svp" class="' + prefix + 'colorpicker-selector1"><div class="' + prefix + 'colorpicker-selector2"></div></div></div></div></div>' + hueHtml + "</div>";
        }
      });
      var DropZone = Widget.extend({
        init: function(settings) {
          var self2 = this;
          settings = global$2.extend({
            height: 100,
            text: "Drop an image here",
            multiple: false,
            accept: null
          }, settings);
          self2._super(settings);
          self2.classes.add("dropzone");
          if (settings.multiple) {
            self2.classes.add("multiple");
          }
        },
        renderHtml: function() {
          var self2 = this;
          var attrs, elm;
          var cfg = self2.settings;
          attrs = {
            id: self2._id,
            hidefocus: "1"
          };
          elm = funcs.create("div", attrs, "<span>" + this.translate(cfg.text) + "</span>");
          if (cfg.height) {
            funcs.css(elm, "height", cfg.height + "px");
          }
          if (cfg.width) {
            funcs.css(elm, "width", cfg.width + "px");
          }
          elm.className = self2.classes;
          return elm.outerHTML;
        },
        postRender: function() {
          var self2 = this;
          var toggleDragClass = function(e) {
            e.preventDefault();
            self2.classes.toggle("dragenter");
            self2.getEl().className = self2.classes;
          };
          var filter2 = function(files) {
            var accept = self2.settings.accept;
            if (typeof accept !== "string") {
              return files;
            }
            var re2 = new RegExp("(" + accept.split(/\s*,\s*/).join("|") + ")$", "i");
            return global$2.grep(files, function(file) {
              return re2.test(file.name);
            });
          };
          self2._super();
          self2.$el.on("dragover", function(e) {
            e.preventDefault();
          });
          self2.$el.on("dragenter", toggleDragClass);
          self2.$el.on("dragleave", toggleDragClass);
          self2.$el.on("drop", function(e) {
            e.preventDefault();
            if (self2.state.get("disabled")) {
              return;
            }
            var files = filter2(e.dataTransfer.files);
            self2.value = function() {
              if (!files.length) {
                return null;
              } else if (self2.settings.multiple) {
                return files;
              } else {
                return files[0];
              }
            };
            if (files.length) {
              self2.fire("change", e);
            }
          });
        },
        remove: function() {
          this.$el.off();
          this._super();
        }
      });
      var Path = Widget.extend({
        init: function(settings) {
          var self2 = this;
          if (!settings.delimiter) {
            settings.delimiter = "Â»";
          }
          self2._super(settings);
          self2.classes.add("path");
          self2.canFocus = true;
          self2.on("click", function(e) {
            var index;
            var target2 = e.target;
            if (index = target2.getAttribute("data-index")) {
              self2.fire("select", {
                value: self2.row()[index],
                index
              });
            }
          });
          self2.row(self2.settings.row);
        },
        focus: function() {
          var self2 = this;
          self2.getEl().firstChild.focus();
          return self2;
        },
        row: function(row) {
          if (!arguments.length) {
            return this.state.get("row");
          }
          this.state.set("row", row);
          return this;
        },
        renderHtml: function() {
          var self2 = this;
          return '<div id="' + self2._id + '" class="' + self2.classes + '">' + self2._getDataPathHtml(self2.state.get("row")) + "</div>";
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:row", function(e) {
            self2.innerHtml(self2._getDataPathHtml(e.value));
          });
          return self2._super();
        },
        _getDataPathHtml: function(data) {
          var self2 = this;
          var parts = data || [];
          var i, l, html2 = "";
          var prefix = self2.classPrefix;
          for (i = 0, l = parts.length; i < l; i++) {
            html2 += (i > 0 ? '<div class="' + prefix + 'divider" aria-hidden="true"> ' + self2.settings.delimiter + " </div>" : "") + '<div role="button" class="' + prefix + "path-item" + (i === l - 1 ? " " + prefix + "last" : "") + '" data-index="' + i + '" tabindex="-1" id="' + self2._id + "-" + i + '" aria-level="' + (i + 1) + '">' + parts[i].name + "</div>";
          }
          if (!html2) {
            html2 = '<div class="' + prefix + 'path-item">Â </div>';
          }
          return html2;
        }
      });
      var ElementPath = Path.extend({
        postRender: function() {
          var self2 = this, editor = self2.settings.editor;
          function isHidden(elm) {
            if (elm.nodeType === 1) {
              if (elm.nodeName === "BR" || !!elm.getAttribute("data-mce-bogus")) {
                return true;
              }
              if (elm.getAttribute("data-mce-type") === "bookmark") {
                return true;
              }
            }
            return false;
          }
          if (editor.settings.elementpath !== false) {
            self2.on("select", function(e) {
              editor.focus();
              editor.selection.select(this.row()[e.index].element);
              editor.nodeChanged();
            });
            editor.on("nodeChange", function(e) {
              var outParents = [];
              var parents = e.parents;
              var i = parents.length;
              while (i--) {
                if (parents[i].nodeType === 1 && !isHidden(parents[i])) {
                  var args = editor.fire("ResolveName", {
                    name: parents[i].nodeName.toLowerCase(),
                    target: parents[i]
                  });
                  if (!args.isDefaultPrevented()) {
                    outParents.push({
                      name: args.name,
                      element: parents[i]
                    });
                  }
                  if (args.isPropagationStopped()) {
                    break;
                  }
                }
              }
              self2.row(outParents);
            });
          }
          return self2._super();
        }
      });
      var FormItem = Container.extend({
        Defaults: {
          layout: "flex",
          align: "center",
          defaults: { flex: 1 }
        },
        renderHtml: function() {
          var self2 = this, layout = self2._layout, prefix = self2.classPrefix;
          self2.classes.add("formitem");
          layout.preRender(self2);
          return '<div id="' + self2._id + '" class="' + self2.classes + '" hidefocus="1" tabindex="-1">' + (self2.settings.title ? '<div id="' + self2._id + '-title" class="' + prefix + 'title">' + self2.settings.title + "</div>" : "") + '<div id="' + self2._id + '-body" class="' + self2.bodyClasses + '">' + (self2.settings.html || "") + layout.renderHtml(self2) + "</div></div>";
        }
      });
      var Form = Container.extend({
        Defaults: {
          containerCls: "form",
          layout: "flex",
          direction: "column",
          align: "stretch",
          flex: 1,
          padding: 15,
          labelGap: 30,
          spacing: 10,
          callbacks: {
            submit: function() {
              this.submit();
            }
          }
        },
        preRender: function() {
          var self2 = this, items = self2.items();
          if (!self2.settings.formItemDefaults) {
            self2.settings.formItemDefaults = {
              layout: "flex",
              autoResize: "overflow",
              defaults: { flex: 1 }
            };
          }
          items.each(function(ctrl) {
            var formItem;
            var label = ctrl.settings.label;
            if (label) {
              formItem = new FormItem(global$2.extend({
                items: {
                  type: "label",
                  id: ctrl._id + "-l",
                  text: label,
                  flex: 0,
                  forId: ctrl._id,
                  disabled: ctrl.disabled()
                }
              }, self2.settings.formItemDefaults));
              formItem.type = "formitem";
              ctrl.aria("labelledby", ctrl._id + "-l");
              if (typeof ctrl.settings.flex === "undefined") {
                ctrl.settings.flex = 1;
              }
              self2.replace(ctrl, formItem);
              formItem.add(ctrl);
            }
          });
        },
        submit: function() {
          return this.fire("submit", { data: this.toJSON() });
        },
        postRender: function() {
          var self2 = this;
          self2._super();
          self2.fromJSON(self2.settings.data);
        },
        bindStates: function() {
          var self2 = this;
          self2._super();
          function recalcLabels() {
            var maxLabelWidth = 0;
            var labels = [];
            var i, labelGap, items;
            if (self2.settings.labelGapCalc === false) {
              return;
            }
            if (self2.settings.labelGapCalc === "children") {
              items = self2.find("formitem");
            } else {
              items = self2.items();
            }
            items.filter("formitem").each(function(item) {
              var labelCtrl = item.items()[0], labelWidth = labelCtrl.getEl().clientWidth;
              maxLabelWidth = labelWidth > maxLabelWidth ? labelWidth : maxLabelWidth;
              labels.push(labelCtrl);
            });
            labelGap = self2.settings.labelGap || 0;
            i = labels.length;
            while (i--) {
              labels[i].settings.minWidth = maxLabelWidth + labelGap;
            }
          }
          self2.on("show", recalcLabels);
          recalcLabels();
        }
      });
      var FieldSet = Form.extend({
        Defaults: {
          containerCls: "fieldset",
          layout: "flex",
          direction: "column",
          align: "stretch",
          flex: 1,
          padding: "25 15 5 15",
          labelGap: 30,
          spacing: 10,
          border: 1
        },
        renderHtml: function() {
          var self2 = this, layout = self2._layout, prefix = self2.classPrefix;
          self2.preRender();
          layout.preRender(self2);
          return '<fieldset id="' + self2._id + '" class="' + self2.classes + '" hidefocus="1" tabindex="-1">' + (self2.settings.title ? '<legend id="' + self2._id + '-title" class="' + prefix + 'fieldset-title">' + self2.settings.title + "</legend>" : "") + '<div id="' + self2._id + '-body" class="' + self2.bodyClasses + '">' + (self2.settings.html || "") + layout.renderHtml(self2) + "</div></fieldset>";
        }
      });
      var unique$1 = 0;
      var generate = function(prefix) {
        var date = /* @__PURE__ */ new Date();
        var time = date.getTime();
        var random = Math.floor(Math.random() * 1e9);
        unique$1++;
        return prefix + "_" + random + unique$1 + String(time);
      };
      var fromHtml = function(html2, scope) {
        var doc = scope || domGlobals.document;
        var div2 = doc.createElement("div");
        div2.innerHTML = html2;
        if (!div2.hasChildNodes() || div2.childNodes.length > 1) {
          domGlobals.console.error("HTML does not have a single root node", html2);
          throw new Error("HTML must have a single root node");
        }
        return fromDom(div2.childNodes[0]);
      };
      var fromTag = function(tag, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createElement(tag);
        return fromDom(node2);
      };
      var fromText = function(text2, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createTextNode(text2);
        return fromDom(node2);
      };
      var fromDom = function(node2) {
        if (node2 === null || node2 === void 0) {
          throw new Error("Node cannot be null or undefined");
        }
        return { dom: constant(node2) };
      };
      var fromPoint = function(docElm, x, y) {
        var doc = docElm.dom();
        return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
      };
      var Element2 = {
        fromHtml,
        fromTag,
        fromText,
        fromDom,
        fromPoint
      };
      var cached = function(f) {
        var called = false;
        var r;
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (!called) {
            called = true;
            r = f.apply(null, args);
          }
          return r;
        };
      };
      var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
      var ELEMENT = domGlobals.Node.ELEMENT_NODE;
      var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
      var path = function(parts, scope) {
        var o = scope !== void 0 && scope !== null ? scope : Global;
        for (var i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
          o = o[parts[i]];
        }
        return o;
      };
      var resolve = function(p, scope) {
        var parts = p.split(".");
        return path(parts, scope);
      };
      var unsafe = function(name, scope) {
        return resolve(name, scope);
      };
      var getOrDie = function(name, scope) {
        var actual = unsafe(name, scope);
        if (actual === void 0 || actual === null) {
          throw new Error(name + " not available on this browser");
        }
        return actual;
      };
      var Global$1 = { getOrDie };
      var node = function() {
        var f = Global$1.getOrDie("Node");
        return f;
      };
      var compareDocumentPosition = function(a, b, match) {
        return (a.compareDocumentPosition(b) & match) !== 0;
      };
      var documentPositionPreceding = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
      };
      var documentPositionContainedBy = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
      };
      var Node2 = {
        documentPositionPreceding,
        documentPositionContainedBy
      };
      var firstMatch = function(regexes, s) {
        for (var i = 0; i < regexes.length; i++) {
          var x = regexes[i];
          if (x.test(s)) {
            return x;
          }
        }
        return void 0;
      };
      var find$1 = function(regexes, agent) {
        var r = firstMatch(regexes, agent);
        if (!r) {
          return {
            major: 0,
            minor: 0
          };
        }
        var group = function(i) {
          return Number(agent.replace(r, "$" + i));
        };
        return nu2(group(1), group(2));
      };
      var detect = function(versionRegexes, agent) {
        var cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
          return unknown();
        }
        return find$1(versionRegexes, cleanedAgent);
      };
      var unknown = function() {
        return nu2(0, 0);
      };
      var nu2 = function(major, minor) {
        return {
          major,
          minor
        };
      };
      var Version = {
        nu: nu2,
        detect,
        unknown
      };
      var edge = "Edge";
      var chrome = "Chrome";
      var ie = "IE";
      var opera = "Opera";
      var firefox = "Firefox";
      var safari = "Safari";
      var isBrowser = function(name, current) {
        return function() {
          return current === name;
        };
      };
      var unknown$1 = function() {
        return nu$1({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$1 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isEdge: isBrowser(edge, current),
          isChrome: isBrowser(chrome, current),
          isIE: isBrowser(ie, current),
          isOpera: isBrowser(opera, current),
          isFirefox: isBrowser(firefox, current),
          isSafari: isBrowser(safari, current)
        };
      };
      var Browser = {
        unknown: unknown$1,
        nu: nu$1
      };
      var windows$1 = "Windows";
      var ios = "iOS";
      var android = "Android";
      var linux = "Linux";
      var osx = "OSX";
      var solaris = "Solaris";
      var freebsd = "FreeBSD";
      var isOS = function(name, current) {
        return function() {
          return current === name;
        };
      };
      var unknown$2 = function() {
        return nu$2({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$2 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isWindows: isOS(windows$1, current),
          isiOS: isOS(ios, current),
          isAndroid: isOS(android, current),
          isOSX: isOS(osx, current),
          isLinux: isOS(linux, current),
          isSolaris: isOS(solaris, current),
          isFreeBSD: isOS(freebsd, current)
        };
      };
      var OperatingSystem = {
        unknown: unknown$2,
        nu: nu$2
      };
      var DeviceType = function(os, browser2, userAgent) {
        var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        var isiPhone = os.isiOS() && !isiPad;
        var isAndroid3 = os.isAndroid() && os.version.major === 3;
        var isAndroid4 = os.isAndroid() && os.version.major === 4;
        var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent) === true;
        var isTouch = os.isiOS() || os.isAndroid();
        var isPhone = isTouch && !isTablet;
        var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        return {
          isiPad: constant(isiPad),
          isiPhone: constant(isiPhone),
          isTablet: constant(isTablet),
          isPhone: constant(isPhone),
          isTouch: constant(isTouch),
          isAndroid: os.isAndroid,
          isiOS: os.isiOS,
          isWebView: constant(iOSwebview)
        };
      };
      var detect$1 = function(candidates, userAgent) {
        var agent = String(userAgent).toLowerCase();
        return find(candidates, function(candidate) {
          return candidate.search(agent);
        });
      };
      var detectBrowser = function(browsers2, userAgent) {
        return detect$1(browsers2, userAgent).map(function(browser2) {
          var version = Version.detect(browser2.versionRegexes, userAgent);
          return {
            current: browser2.name,
            version
          };
        });
      };
      var detectOs = function(oses2, userAgent) {
        return detect$1(oses2, userAgent).map(function(os) {
          var version = Version.detect(os.versionRegexes, userAgent);
          return {
            current: os.name,
            version
          };
        });
      };
      var UaString = {
        detectBrowser,
        detectOs
      };
      var contains = function(str, substr) {
        return str.indexOf(substr) !== -1;
      };
      var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
      var checkContains = function(target2) {
        return function(uastring) {
          return contains(uastring, target2);
        };
      };
      var browsers = [
        {
          name: "Edge",
          versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
          search: function(uastring) {
            return contains(uastring, "edge/") && contains(uastring, "chrome") && contains(uastring, "safari") && contains(uastring, "applewebkit");
          }
        },
        {
          name: "Chrome",
          versionRegexes: [
            /.*?chrome\/([0-9]+)\.([0-9]+).*/,
            normalVersionRegex
          ],
          search: function(uastring) {
            return contains(uastring, "chrome") && !contains(uastring, "chromeframe");
          }
        },
        {
          name: "IE",
          versionRegexes: [
            /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
            /.*?rv:([0-9]+)\.([0-9]+).*/
          ],
          search: function(uastring) {
            return contains(uastring, "msie") || contains(uastring, "trident");
          }
        },
        {
          name: "Opera",
          versionRegexes: [
            normalVersionRegex,
            /.*?opera\/([0-9]+)\.([0-9]+).*/
          ],
          search: checkContains("opera")
        },
        {
          name: "Firefox",
          versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
          search: checkContains("firefox")
        },
        {
          name: "Safari",
          versionRegexes: [
            normalVersionRegex,
            /.*?cpu os ([0-9]+)_([0-9]+).*/
          ],
          search: function(uastring) {
            return (contains(uastring, "safari") || contains(uastring, "mobile/")) && contains(uastring, "applewebkit");
          }
        }
      ];
      var oses = [
        {
          name: "Windows",
          search: checkContains("win"),
          versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "iOS",
          search: function(uastring) {
            return contains(uastring, "iphone") || contains(uastring, "ipad");
          },
          versionRegexes: [
            /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
            /.*cpu os ([0-9]+)_([0-9]+).*/,
            /.*cpu iphone os ([0-9]+)_([0-9]+).*/
          ]
        },
        {
          name: "Android",
          search: checkContains("android"),
          versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "OSX",
          search: checkContains("os x"),
          versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Linux",
          search: checkContains("linux"),
          versionRegexes: []
        },
        {
          name: "Solaris",
          search: checkContains("sunos"),
          versionRegexes: []
        },
        {
          name: "FreeBSD",
          search: checkContains("freebsd"),
          versionRegexes: []
        }
      ];
      var PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses)
      };
      var detect$2 = function(userAgent) {
        var browsers2 = PlatformInfo.browsers();
        var oses2 = PlatformInfo.oses();
        var browser2 = UaString.detectBrowser(browsers2, userAgent).fold(Browser.unknown, Browser.nu);
        var os = UaString.detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        var deviceType = DeviceType(os, browser2, userAgent);
        return {
          browser: browser2,
          os,
          deviceType
        };
      };
      var PlatformDetection = { detect: detect$2 };
      var detect$3 = cached(function() {
        var userAgent = domGlobals.navigator.userAgent;
        return PlatformDetection.detect(userAgent);
      });
      var PlatformDetection$1 = { detect: detect$3 };
      var ELEMENT$1 = ELEMENT;
      var DOCUMENT$1 = DOCUMENT;
      var bypassSelector = function(dom) {
        return dom.nodeType !== ELEMENT$1 && dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
      };
      var all = function(selector, scope) {
        var base2 = scope === void 0 ? domGlobals.document : scope.dom();
        return bypassSelector(base2) ? [] : map2(base2.querySelectorAll(selector), Element2.fromDom);
      };
      var one = function(selector, scope) {
        var base2 = scope === void 0 ? domGlobals.document : scope.dom();
        return bypassSelector(base2) ? Option.none() : Option.from(base2.querySelector(selector)).map(Element2.fromDom);
      };
      var regularContains = function(e1, e2) {
        var d1 = e1.dom();
        var d2 = e2.dom();
        return d1 === d2 ? false : d1.contains(d2);
      };
      var ieContains = function(e1, e2) {
        return Node2.documentPositionContainedBy(e1.dom(), e2.dom());
      };
      var browser = PlatformDetection$1.detect().browser;
      browser.isIE() ? ieContains : regularContains;
      var descendants = function(scope, selector) {
        return all(selector, scope);
      };
      var trim = global$2.trim;
      var hasContentEditableState = function(value) {
        return function(node2) {
          if (node2 && node2.nodeType === 1) {
            if (node2.contentEditable === value) {
              return true;
            }
            if (node2.getAttribute("data-mce-contenteditable") === value) {
              return true;
            }
          }
          return false;
        };
      };
      var isContentEditableTrue = hasContentEditableState("true");
      var isContentEditableFalse = hasContentEditableState("false");
      var create = function(type, title, url, level, attach) {
        return {
          type,
          title,
          url,
          level,
          attach
        };
      };
      var isChildOfContentEditableTrue = function(node2) {
        while (node2 = node2.parentNode) {
          var value = node2.contentEditable;
          if (value && value !== "inherit") {
            return isContentEditableTrue(node2);
          }
        }
        return false;
      };
      var select = function(selector, root2) {
        return map2(descendants(Element2.fromDom(root2), selector), function(element) {
          return element.dom();
        });
      };
      var getElementText = function(elm) {
        return elm.innerText || elm.textContent;
      };
      var getOrGenerateId = function(elm) {
        return elm.id ? elm.id : generate("h");
      };
      var isAnchor = function(elm) {
        return elm && elm.nodeName === "A" && (elm.id || elm.name);
      };
      var isValidAnchor = function(elm) {
        return isAnchor(elm) && isEditable(elm);
      };
      var isHeader = function(elm) {
        return elm && /^(H[1-6])$/.test(elm.nodeName);
      };
      var isEditable = function(elm) {
        return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
      };
      var isValidHeader = function(elm) {
        return isHeader(elm) && isEditable(elm);
      };
      var getLevel = function(elm) {
        return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
      };
      var headerTarget = function(elm) {
        var headerId = getOrGenerateId(elm);
        var attach = function() {
          elm.id = headerId;
        };
        return create("header", getElementText(elm), "#" + headerId, getLevel(elm), attach);
      };
      var anchorTarget = function(elm) {
        var anchorId = elm.id || elm.name;
        var anchorText = getElementText(elm);
        return create("anchor", anchorText ? anchorText : "#" + anchorId, "#" + anchorId, 0, noop);
      };
      var getHeaderTargets = function(elms) {
        return map2(filter(elms, isValidHeader), headerTarget);
      };
      var getAnchorTargets = function(elms) {
        return map2(filter(elms, isValidAnchor), anchorTarget);
      };
      var getTargetElements = function(elm) {
        var elms = select("h1,h2,h3,h4,h5,h6,a:not([href])", elm);
        return elms;
      };
      var hasTitle = function(target2) {
        return trim(target2.title).length > 0;
      };
      var find$2 = function(elm) {
        var elms = getTargetElements(elm);
        return filter(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
      };
      var LinkTargets = { find: find$2 };
      var getActiveEditor = function() {
        return window.tinymce ? window.tinymce.activeEditor : global$1.activeEditor;
      };
      var history = {};
      var HISTORY_LENGTH = 5;
      var clearHistory = function() {
        history = {};
      };
      var toMenuItem = function(target2) {
        return {
          title: target2.title,
          value: {
            title: { raw: target2.title },
            url: target2.url,
            attach: target2.attach
          }
        };
      };
      var toMenuItems = function(targets) {
        return global$2.map(targets, toMenuItem);
      };
      var staticMenuItem = function(title, url) {
        return {
          title,
          value: {
            title,
            url,
            attach: noop
          }
        };
      };
      var isUniqueUrl = function(url, targets) {
        var foundTarget = exists(targets, function(target2) {
          return target2.url === url;
        });
        return !foundTarget;
      };
      var getSetting = function(editorSettings, name, defaultValue) {
        var value = name in editorSettings ? editorSettings[name] : defaultValue;
        return value === false ? null : value;
      };
      var createMenuItems = function(term, targets, fileType, editorSettings) {
        var separator = { title: "-" };
        var fromHistoryMenuItems = function(history2) {
          var historyItems = history2.hasOwnProperty(fileType) ? history2[fileType] : [];
          var uniqueHistory = filter(historyItems, function(url) {
            return isUniqueUrl(url, targets);
          });
          return global$2.map(uniqueHistory, function(url) {
            return {
              title: url,
              value: {
                title: url,
                url,
                attach: noop
              }
            };
          });
        };
        var fromMenuItems = function(type) {
          var filteredTargets = filter(targets, function(target2) {
            return target2.type === type;
          });
          return toMenuItems(filteredTargets);
        };
        var anchorMenuItems = function() {
          var anchorMenuItems2 = fromMenuItems("anchor");
          var topAnchor = getSetting(editorSettings, "anchor_top", "#top");
          var bottomAchor = getSetting(editorSettings, "anchor_bottom", "#bottom");
          if (topAnchor !== null) {
            anchorMenuItems2.unshift(staticMenuItem("<top>", topAnchor));
          }
          if (bottomAchor !== null) {
            anchorMenuItems2.push(staticMenuItem("<bottom>", bottomAchor));
          }
          return anchorMenuItems2;
        };
        var join2 = function(items) {
          return foldl(items, function(a, b) {
            var bothEmpty = a.length === 0 || b.length === 0;
            return bothEmpty ? a.concat(b) : a.concat(separator, b);
          }, []);
        };
        if (editorSettings.typeahead_urls === false) {
          return [];
        }
        return fileType === "file" ? join2([
          filterByQuery(term, fromHistoryMenuItems(history)),
          filterByQuery(term, fromMenuItems("header")),
          filterByQuery(term, anchorMenuItems())
        ]) : filterByQuery(term, fromHistoryMenuItems(history));
      };
      var addToHistory = function(url, fileType) {
        var items = history[fileType];
        if (!/^https?/.test(url)) {
          return;
        }
        if (items) {
          if (indexOf(items, url).isNone()) {
            history[fileType] = items.slice(0, HISTORY_LENGTH).concat(url);
          }
        } else {
          history[fileType] = [url];
        }
      };
      var filterByQuery = function(term, menuItems) {
        var lowerCaseTerm = term.toLowerCase();
        var result = global$2.grep(menuItems, function(item) {
          return item.title.toLowerCase().indexOf(lowerCaseTerm) !== -1;
        });
        return result.length === 1 && result[0].title === term ? [] : result;
      };
      var getTitle = function(linkDetails) {
        var title = linkDetails.title;
        return title.raw ? title.raw : title;
      };
      var setupAutoCompleteHandler = function(ctrl, editorSettings, bodyElm, fileType) {
        var autocomplete = function(term) {
          var linkTargets = LinkTargets.find(bodyElm);
          var menuItems = createMenuItems(term, linkTargets, fileType, editorSettings);
          ctrl.showAutoComplete(menuItems, term);
        };
        ctrl.on("autocomplete", function() {
          autocomplete(ctrl.value());
        });
        ctrl.on("selectitem", function(e) {
          var linkDetails = e.value;
          ctrl.value(linkDetails.url);
          var title = getTitle(linkDetails);
          if (fileType === "image") {
            ctrl.fire("change", {
              meta: {
                alt: title,
                attach: linkDetails.attach
              }
            });
          } else {
            ctrl.fire("change", {
              meta: {
                text: title,
                attach: linkDetails.attach
              }
            });
          }
          ctrl.focus();
        });
        ctrl.on("click", function(e) {
          if (ctrl.value().length === 0 && e.target.nodeName === "INPUT") {
            autocomplete("");
          }
        });
        ctrl.on("PostRender", function() {
          ctrl.getRoot().on("submit", function(e) {
            if (!e.isDefaultPrevented()) {
              addToHistory(ctrl.value(), fileType);
            }
          });
        });
      };
      var statusToUiState = function(result) {
        var status = result.status, message = result.message;
        if (status === "valid") {
          return {
            status: "ok",
            message
          };
        } else if (status === "unknown") {
          return {
            status: "warn",
            message
          };
        } else if (status === "invalid") {
          return {
            status: "warn",
            message
          };
        } else {
          return {
            status: "none",
            message: ""
          };
        }
      };
      var setupLinkValidatorHandler = function(ctrl, editorSettings, fileType) {
        var validatorHandler = editorSettings.filepicker_validator_handler;
        if (validatorHandler) {
          var validateUrl_1 = function(url) {
            if (url.length === 0) {
              ctrl.statusLevel("none");
              return;
            }
            validatorHandler({
              url,
              type: fileType
            }, function(result) {
              var uiState = statusToUiState(result);
              ctrl.statusMessage(uiState.message);
              ctrl.statusLevel(uiState.status);
            });
          };
          ctrl.state.on("change:value", function(e) {
            validateUrl_1(e.value);
          });
        }
      };
      var FilePicker = ComboBox.extend({
        Statics: { clearHistory },
        init: function(settings) {
          var self2 = this, editor = getActiveEditor(), editorSettings = editor.settings;
          var actionCallback, fileBrowserCallback, fileBrowserCallbackTypes;
          var fileType = settings.filetype;
          settings.spellcheck = false;
          fileBrowserCallbackTypes = editorSettings.file_picker_types || editorSettings.file_browser_callback_types;
          if (fileBrowserCallbackTypes) {
            fileBrowserCallbackTypes = global$2.makeMap(fileBrowserCallbackTypes, /[, ]/);
          }
          if (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType]) {
            fileBrowserCallback = editorSettings.file_picker_callback;
            if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
              actionCallback = function() {
                var meta = self2.fire("beforecall").meta;
                meta = global$2.extend({ filetype: fileType }, meta);
                fileBrowserCallback.call(editor, function(value, meta2) {
                  self2.value(value).fire("change", { meta: meta2 });
                }, self2.value(), meta);
              };
            } else {
              fileBrowserCallback = editorSettings.file_browser_callback;
              if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[fileType])) {
                actionCallback = function() {
                  fileBrowserCallback(self2.getEl("inp").id, self2.value(), fileType, window);
                };
              }
            }
          }
          if (actionCallback) {
            settings.icon = "browse";
            settings.onaction = actionCallback;
          }
          self2._super(settings);
          self2.classes.add("filepicker");
          setupAutoCompleteHandler(self2, editorSettings, editor.getBody(), fileType);
          setupLinkValidatorHandler(self2, editorSettings, fileType);
        }
      });
      var FitLayout = AbsoluteLayout.extend({
        recalc: function(container) {
          var contLayoutRect = container.layoutRect(), paddingBox = container.paddingBox;
          container.items().filter(":visible").each(function(ctrl) {
            ctrl.layoutRect({
              x: paddingBox.left,
              y: paddingBox.top,
              w: contLayoutRect.innerW - paddingBox.right - paddingBox.left,
              h: contLayoutRect.innerH - paddingBox.top - paddingBox.bottom
            });
            if (ctrl.recalc) {
              ctrl.recalc();
            }
          });
        }
      });
      var FlexLayout = AbsoluteLayout.extend({
        recalc: function(container) {
          var i, l, items, contLayoutRect, contPaddingBox, contSettings, align, pack, spacing, totalFlex, availableSpace, direction;
          var ctrl, ctrlLayoutRect, ctrlSettings, flex;
          var maxSizeItems = [];
          var size, maxSize, ratio2, rect2, pos, maxAlignEndPos;
          var sizeName, minSizeName, posName, maxSizeName, beforeName, innerSizeName, deltaSizeName, contentSizeName;
          var alignAxisName, alignInnerSizeName, alignSizeName, alignMinSizeName, alignBeforeName, alignAfterName;
          var alignDeltaSizeName, alignContentSizeName;
          var max = Math.max, min = Math.min;
          items = container.items().filter(":visible");
          contLayoutRect = container.layoutRect();
          contPaddingBox = container.paddingBox;
          contSettings = container.settings;
          direction = container.isRtl() ? contSettings.direction || "row-reversed" : contSettings.direction;
          align = contSettings.align;
          pack = container.isRtl() ? contSettings.pack || "end" : contSettings.pack;
          spacing = contSettings.spacing || 0;
          if (direction === "row-reversed" || direction === "column-reverse") {
            items = items.set(items.toArray().reverse());
            direction = direction.split("-")[0];
          }
          if (direction === "column") {
            posName = "y";
            sizeName = "h";
            minSizeName = "minH";
            maxSizeName = "maxH";
            innerSizeName = "innerH";
            beforeName = "top";
            deltaSizeName = "deltaH";
            contentSizeName = "contentH";
            alignBeforeName = "left";
            alignSizeName = "w";
            alignAxisName = "x";
            alignInnerSizeName = "innerW";
            alignMinSizeName = "minW";
            alignAfterName = "right";
            alignDeltaSizeName = "deltaW";
            alignContentSizeName = "contentW";
          } else {
            posName = "x";
            sizeName = "w";
            minSizeName = "minW";
            maxSizeName = "maxW";
            innerSizeName = "innerW";
            beforeName = "left";
            deltaSizeName = "deltaW";
            contentSizeName = "contentW";
            alignBeforeName = "top";
            alignSizeName = "h";
            alignAxisName = "y";
            alignInnerSizeName = "innerH";
            alignMinSizeName = "minH";
            alignAfterName = "bottom";
            alignDeltaSizeName = "deltaH";
            alignContentSizeName = "contentH";
          }
          availableSpace = contLayoutRect[innerSizeName] - contPaddingBox[beforeName] - contPaddingBox[beforeName];
          maxAlignEndPos = totalFlex = 0;
          for (i = 0, l = items.length; i < l; i++) {
            ctrl = items[i];
            ctrlLayoutRect = ctrl.layoutRect();
            ctrlSettings = ctrl.settings;
            flex = ctrlSettings.flex;
            availableSpace -= i < l - 1 ? spacing : 0;
            if (flex > 0) {
              totalFlex += flex;
              if (ctrlLayoutRect[maxSizeName]) {
                maxSizeItems.push(ctrl);
              }
              ctrlLayoutRect.flex = flex;
            }
            availableSpace -= ctrlLayoutRect[minSizeName];
            size = contPaddingBox[alignBeforeName] + ctrlLayoutRect[alignMinSizeName] + contPaddingBox[alignAfterName];
            if (size > maxAlignEndPos) {
              maxAlignEndPos = size;
            }
          }
          rect2 = {};
          if (availableSpace < 0) {
            rect2[minSizeName] = contLayoutRect[minSizeName] - availableSpace + contLayoutRect[deltaSizeName];
          } else {
            rect2[minSizeName] = contLayoutRect[innerSizeName] - availableSpace + contLayoutRect[deltaSizeName];
          }
          rect2[alignMinSizeName] = maxAlignEndPos + contLayoutRect[alignDeltaSizeName];
          rect2[contentSizeName] = contLayoutRect[innerSizeName] - availableSpace;
          rect2[alignContentSizeName] = maxAlignEndPos;
          rect2.minW = min(rect2.minW, contLayoutRect.maxW);
          rect2.minH = min(rect2.minH, contLayoutRect.maxH);
          rect2.minW = max(rect2.minW, contLayoutRect.startMinWidth);
          rect2.minH = max(rect2.minH, contLayoutRect.startMinHeight);
          if (contLayoutRect.autoResize && (rect2.minW !== contLayoutRect.minW || rect2.minH !== contLayoutRect.minH)) {
            rect2.w = rect2.minW;
            rect2.h = rect2.minH;
            container.layoutRect(rect2);
            this.recalc(container);
            if (container._lastRect === null) {
              var parentCtrl = container.parent();
              if (parentCtrl) {
                parentCtrl._lastRect = null;
                parentCtrl.recalc();
              }
            }
            return;
          }
          ratio2 = availableSpace / totalFlex;
          for (i = 0, l = maxSizeItems.length; i < l; i++) {
            ctrl = maxSizeItems[i];
            ctrlLayoutRect = ctrl.layoutRect();
            maxSize = ctrlLayoutRect[maxSizeName];
            size = ctrlLayoutRect[minSizeName] + ctrlLayoutRect.flex * ratio2;
            if (size > maxSize) {
              availableSpace -= ctrlLayoutRect[maxSizeName] - ctrlLayoutRect[minSizeName];
              totalFlex -= ctrlLayoutRect.flex;
              ctrlLayoutRect.flex = 0;
              ctrlLayoutRect.maxFlexSize = maxSize;
            } else {
              ctrlLayoutRect.maxFlexSize = 0;
            }
          }
          ratio2 = availableSpace / totalFlex;
          pos = contPaddingBox[beforeName];
          rect2 = {};
          if (totalFlex === 0) {
            if (pack === "end") {
              pos = availableSpace + contPaddingBox[beforeName];
            } else if (pack === "center") {
              pos = Math.round(contLayoutRect[innerSizeName] / 2 - (contLayoutRect[innerSizeName] - availableSpace) / 2) + contPaddingBox[beforeName];
              if (pos < 0) {
                pos = contPaddingBox[beforeName];
              }
            } else if (pack === "justify") {
              pos = contPaddingBox[beforeName];
              spacing = Math.floor(availableSpace / (items.length - 1));
            }
          }
          rect2[alignAxisName] = contPaddingBox[alignBeforeName];
          for (i = 0, l = items.length; i < l; i++) {
            ctrl = items[i];
            ctrlLayoutRect = ctrl.layoutRect();
            size = ctrlLayoutRect.maxFlexSize || ctrlLayoutRect[minSizeName];
            if (align === "center") {
              rect2[alignAxisName] = Math.round(contLayoutRect[alignInnerSizeName] / 2 - ctrlLayoutRect[alignSizeName] / 2);
            } else if (align === "stretch") {
              rect2[alignSizeName] = max(ctrlLayoutRect[alignMinSizeName] || 0, contLayoutRect[alignInnerSizeName] - contPaddingBox[alignBeforeName] - contPaddingBox[alignAfterName]);
              rect2[alignAxisName] = contPaddingBox[alignBeforeName];
            } else if (align === "end") {
              rect2[alignAxisName] = contLayoutRect[alignInnerSizeName] - ctrlLayoutRect[alignSizeName] - contPaddingBox.top;
            }
            if (ctrlLayoutRect.flex > 0) {
              size += ctrlLayoutRect.flex * ratio2;
            }
            rect2[sizeName] = size;
            rect2[posName] = pos;
            ctrl.layoutRect(rect2);
            if (ctrl.recalc) {
              ctrl.recalc();
            }
            pos += size + spacing;
          }
        }
      });
      var FlowLayout = Layout.extend({
        Defaults: {
          containerClass: "flow-layout",
          controlClass: "flow-layout-item",
          endClass: "break"
        },
        recalc: function(container) {
          container.items().filter(":visible").each(function(ctrl) {
            if (ctrl.recalc) {
              ctrl.recalc();
            }
          });
        },
        isNative: function() {
          return true;
        }
      });
      var descendant = function(scope, selector) {
        return one(selector, scope);
      };
      var toggleFormat = function(editor, fmt) {
        return function() {
          editor.execCommand("mceToggleFormat", false, fmt);
        };
      };
      var addFormatChangedListener = function(editor, name, changed) {
        var handler = function(state) {
          changed(state, name);
        };
        if (editor.formatter) {
          editor.formatter.formatChanged(name, handler);
        } else {
          editor.on("init", function() {
            editor.formatter.formatChanged(name, handler);
          });
        }
      };
      var postRenderFormatToggle = function(editor, name) {
        return function(e) {
          addFormatChangedListener(editor, name, function(state) {
            e.control.active(state);
          });
        };
      };
      var register = function(editor) {
        var alignFormats = [
          "alignleft",
          "aligncenter",
          "alignright",
          "alignjustify"
        ];
        var defaultAlign = "alignleft";
        var alignMenuItems = [
          {
            text: "Left",
            icon: "alignleft",
            onclick: toggleFormat(editor, "alignleft")
          },
          {
            text: "Center",
            icon: "aligncenter",
            onclick: toggleFormat(editor, "aligncenter")
          },
          {
            text: "Right",
            icon: "alignright",
            onclick: toggleFormat(editor, "alignright")
          },
          {
            text: "Justify",
            icon: "alignjustify",
            onclick: toggleFormat(editor, "alignjustify")
          }
        ];
        editor.addMenuItem("align", {
          text: "Align",
          menu: alignMenuItems
        });
        editor.addButton("align", {
          type: "menubutton",
          icon: defaultAlign,
          menu: alignMenuItems,
          onShowMenu: function(e) {
            var menu = e.control.menu;
            global$2.each(alignFormats, function(formatName, idx) {
              menu.items().eq(idx).each(function(item) {
                return item.active(editor.formatter.match(formatName));
              });
            });
          },
          onPostRender: function(e) {
            var ctrl = e.control;
            global$2.each(alignFormats, function(formatName, idx) {
              addFormatChangedListener(editor, formatName, function(state) {
                ctrl.icon(defaultAlign);
                if (state) {
                  ctrl.icon(formatName);
                }
              });
            });
          }
        });
        global$2.each({
          alignleft: [
            "Align left",
            "JustifyLeft"
          ],
          aligncenter: [
            "Align center",
            "JustifyCenter"
          ],
          alignright: [
            "Align right",
            "JustifyRight"
          ],
          alignjustify: [
            "Justify",
            "JustifyFull"
          ],
          alignnone: [
            "No alignment",
            "JustifyNone"
          ]
        }, function(item, name) {
          editor.addButton(name, {
            active: false,
            tooltip: item[0],
            cmd: item[1],
            onPostRender: postRenderFormatToggle(editor, name)
          });
        });
      };
      var Align = { register };
      var getFirstFont = function(fontFamily) {
        return fontFamily ? fontFamily.split(",")[0] : "";
      };
      var findMatchingValue = function(items, fontFamily) {
        var font = fontFamily ? fontFamily.toLowerCase() : "";
        var value;
        global$2.each(items, function(item) {
          if (item.value.toLowerCase() === font) {
            value = item.value;
          }
        });
        global$2.each(items, function(item) {
          if (!value && getFirstFont(item.value).toLowerCase() === getFirstFont(font).toLowerCase()) {
            value = item.value;
          }
        });
        return value;
      };
      var createFontNameListBoxChangeHandler = function(editor, items) {
        return function() {
          var self2 = this;
          self2.state.set("value", null);
          editor.on("init nodeChange", function(e) {
            var fontFamily = editor.queryCommandValue("FontName");
            var match = findMatchingValue(items, fontFamily);
            self2.value(match ? match : null);
            if (!match && fontFamily) {
              self2.text(getFirstFont(fontFamily));
            }
          });
        };
      };
      var createFormats = function(formats) {
        formats = formats.replace(/;$/, "").split(";");
        var i = formats.length;
        while (i--) {
          formats[i] = formats[i].split("=");
        }
        return formats;
      };
      var getFontItems = function(editor) {
        var defaultFontsFormats = "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats";
        var fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);
        return global$2.map(fonts, function(font) {
          return {
            text: { raw: font[0] },
            value: font[1],
            textStyle: font[1].indexOf("dings") === -1 ? "font-family:" + font[1] : ""
          };
        });
      };
      var registerButtons = function(editor) {
        editor.addButton("fontselect", function() {
          var items = getFontItems(editor);
          return {
            type: "listbox",
            text: "Font Family",
            tooltip: "Font Family",
            values: items,
            fixedWidth: true,
            onPostRender: createFontNameListBoxChangeHandler(editor, items),
            onselect: function(e) {
              if (e.control.settings.value) {
                editor.execCommand("FontName", false, e.control.settings.value);
              }
            }
          };
        });
      };
      var register$1 = function(editor) {
        registerButtons(editor);
      };
      var FontSelect = { register: register$1 };
      var round = function(number, precision) {
        var factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
      };
      var toPt = function(fontSize, precision) {
        if (/[0-9.]+px$/.test(fontSize)) {
          return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + "pt";
        }
        return fontSize;
      };
      var findMatchingValue$1 = function(items, pt, px) {
        var value;
        global$2.each(items, function(item) {
          if (item.value === px) {
            value = px;
          } else if (item.value === pt) {
            value = pt;
          }
        });
        return value;
      };
      var createFontSizeListBoxChangeHandler = function(editor, items) {
        return function() {
          var self2 = this;
          editor.on("init nodeChange", function(e) {
            var px, pt, precision, match;
            px = editor.queryCommandValue("FontSize");
            if (px) {
              for (precision = 3; !match && precision >= 0; precision--) {
                pt = toPt(px, precision);
                match = findMatchingValue$1(items, pt, px);
              }
            }
            self2.value(match ? match : null);
            if (!match) {
              self2.text(pt);
            }
          });
        };
      };
      var getFontSizeItems = function(editor) {
        var defaultFontsizeFormats = "8pt 10pt 12pt 14pt 18pt 24pt 36pt";
        var fontsizeFormats = editor.settings.fontsize_formats || defaultFontsizeFormats;
        return global$2.map(fontsizeFormats.split(" "), function(item) {
          var text2 = item, value = item;
          var values = item.split("=");
          if (values.length > 1) {
            text2 = values[0];
            value = values[1];
          }
          return {
            text: text2,
            value
          };
        });
      };
      var registerButtons$1 = function(editor) {
        editor.addButton("fontsizeselect", function() {
          var items = getFontSizeItems(editor);
          return {
            type: "listbox",
            text: "Font Sizes",
            tooltip: "Font Sizes",
            values: items,
            fixedWidth: true,
            onPostRender: createFontSizeListBoxChangeHandler(editor, items),
            onclick: function(e) {
              if (e.control.settings.value) {
                editor.execCommand("FontSize", false, e.control.settings.value);
              }
            }
          };
        });
      };
      var register$2 = function(editor) {
        registerButtons$1(editor);
      };
      var FontSizeSelect = { register: register$2 };
      var hideMenuObjects = function(editor, menu) {
        var count2 = menu.length;
        global$2.each(menu, function(item) {
          if (item.menu) {
            item.hidden = hideMenuObjects(editor, item.menu) === 0;
          }
          var formatName = item.format;
          if (formatName) {
            item.hidden = !editor.formatter.canApply(formatName);
          }
          if (item.hidden) {
            count2--;
          }
        });
        return count2;
      };
      var hideFormatMenuItems = function(editor, menu) {
        var count2 = menu.items().length;
        menu.items().each(function(item) {
          if (item.menu) {
            item.visible(hideFormatMenuItems(editor, item.menu) > 0);
          }
          if (!item.menu && item.settings.menu) {
            item.visible(hideMenuObjects(editor, item.settings.menu) > 0);
          }
          var formatName = item.settings.format;
          if (formatName) {
            item.visible(editor.formatter.canApply(formatName));
          }
          if (!item.visible()) {
            count2--;
          }
        });
        return count2;
      };
      var createFormatMenu = function(editor) {
        var count2 = 0;
        var newFormats = [];
        var defaultStyleFormats = [
          {
            title: "Headings",
            items: [
              {
                title: "Heading 1",
                format: "h1"
              },
              {
                title: "Heading 2",
                format: "h2"
              },
              {
                title: "Heading 3",
                format: "h3"
              },
              {
                title: "Heading 4",
                format: "h4"
              },
              {
                title: "Heading 5",
                format: "h5"
              },
              {
                title: "Heading 6",
                format: "h6"
              }
            ]
          },
          {
            title: "Inline",
            items: [
              {
                title: "Bold",
                icon: "bold",
                format: "bold"
              },
              {
                title: "Italic",
                icon: "italic",
                format: "italic"
              },
              {
                title: "Underline",
                icon: "underline",
                format: "underline"
              },
              {
                title: "Strikethrough",
                icon: "strikethrough",
                format: "strikethrough"
              },
              {
                title: "Superscript",
                icon: "superscript",
                format: "superscript"
              },
              {
                title: "Subscript",
                icon: "subscript",
                format: "subscript"
              },
              {
                title: "Code",
                icon: "code",
                format: "code"
              }
            ]
          },
          {
            title: "Blocks",
            items: [
              {
                title: "Paragraph",
                format: "p"
              },
              {
                title: "Blockquote",
                format: "blockquote"
              },
              {
                title: "Div",
                format: "div"
              },
              {
                title: "Pre",
                format: "pre"
              }
            ]
          },
          {
            title: "Alignment",
            items: [
              {
                title: "Left",
                icon: "alignleft",
                format: "alignleft"
              },
              {
                title: "Center",
                icon: "aligncenter",
                format: "aligncenter"
              },
              {
                title: "Right",
                icon: "alignright",
                format: "alignright"
              },
              {
                title: "Justify",
                icon: "alignjustify",
                format: "alignjustify"
              }
            ]
          }
        ];
        var createMenu2 = function(formats) {
          var menu = [];
          if (!formats) {
            return;
          }
          global$2.each(formats, function(format2) {
            var menuItem = {
              text: format2.title,
              icon: format2.icon
            };
            if (format2.items) {
              menuItem.menu = createMenu2(format2.items);
            } else {
              var formatName = format2.format || "custom" + count2++;
              if (!format2.format) {
                format2.name = formatName;
                newFormats.push(format2);
              }
              menuItem.format = formatName;
              menuItem.cmd = format2.cmd;
            }
            menu.push(menuItem);
          });
          return menu;
        };
        var createStylesMenu = function() {
          var menu;
          if (editor.settings.style_formats_merge) {
            if (editor.settings.style_formats) {
              menu = createMenu2(defaultStyleFormats.concat(editor.settings.style_formats));
            } else {
              menu = createMenu2(defaultStyleFormats);
            }
          } else {
            menu = createMenu2(editor.settings.style_formats || defaultStyleFormats);
          }
          return menu;
        };
        editor.on("init", function() {
          global$2.each(newFormats, function(format2) {
            editor.formatter.register(format2.name, format2);
          });
        });
        return {
          type: "menu",
          items: createStylesMenu(),
          onPostRender: function(e) {
            editor.fire("renderFormatsMenu", { control: e.control });
          },
          itemDefaults: {
            preview: true,
            textStyle: function() {
              if (this.settings.format) {
                return editor.formatter.getCssText(this.settings.format);
              }
            },
            onPostRender: function() {
              var self2 = this;
              self2.parent().on("show", function() {
                var formatName, command;
                formatName = self2.settings.format;
                if (formatName) {
                  self2.disabled(!editor.formatter.canApply(formatName));
                  self2.active(editor.formatter.match(formatName));
                }
                command = self2.settings.cmd;
                if (command) {
                  self2.active(editor.queryCommandState(command));
                }
              });
            },
            onclick: function() {
              if (this.settings.format) {
                toggleFormat(editor, this.settings.format)();
              }
              if (this.settings.cmd) {
                editor.execCommand(this.settings.cmd);
              }
            }
          }
        };
      };
      var registerMenuItems = function(editor, formatMenu) {
        editor.addMenuItem("formats", {
          text: "Formats",
          menu: formatMenu
        });
      };
      var registerButtons$2 = function(editor, formatMenu) {
        editor.addButton("styleselect", {
          type: "menubutton",
          text: "Formats",
          menu: formatMenu,
          onShowMenu: function() {
            if (editor.settings.style_formats_autohide) {
              hideFormatMenuItems(editor, this.menu);
            }
          }
        });
      };
      var register$3 = function(editor) {
        var formatMenu = createFormatMenu(editor);
        registerMenuItems(editor, formatMenu);
        registerButtons$2(editor, formatMenu);
      };
      var Formats = { register: register$3 };
      var defaultBlocks = "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre";
      var createFormats$1 = function(formats) {
        formats = formats.replace(/;$/, "").split(";");
        var i = formats.length;
        while (i--) {
          formats[i] = formats[i].split("=");
        }
        return formats;
      };
      var createListBoxChangeHandler = function(editor, items, formatName) {
        return function() {
          var self2 = this;
          editor.on("nodeChange", function(e) {
            var formatter = editor.formatter;
            var value = null;
            global$2.each(e.parents, function(node2) {
              global$2.each(items, function(item) {
                {
                  if (formatter.matchNode(node2, item.value)) {
                    value = item.value;
                  }
                }
                if (value) {
                  return false;
                }
              });
              if (value) {
                return false;
              }
            });
            self2.value(value);
          });
        };
      };
      var lazyFormatSelectBoxItems = function(editor, blocks) {
        return function() {
          var items = [];
          global$2.each(blocks, function(block2) {
            items.push({
              text: block2[0],
              value: block2[1],
              textStyle: function() {
                return editor.formatter.getCssText(block2[1]);
              }
            });
          });
          return {
            type: "listbox",
            text: blocks[0][0],
            values: items,
            fixedWidth: true,
            onselect: function(e) {
              if (e.control) {
                var fmt = e.control.value();
                toggleFormat(editor, fmt)();
              }
            },
            onPostRender: createListBoxChangeHandler(editor, items)
          };
        };
      };
      var buildMenuItems = function(editor, blocks) {
        return global$2.map(blocks, function(block2) {
          return {
            text: block2[0],
            onclick: toggleFormat(editor, block2[1]),
            textStyle: function() {
              return editor.formatter.getCssText(block2[1]);
            }
          };
        });
      };
      var register$4 = function(editor) {
        var blocks = createFormats$1(editor.settings.block_formats || defaultBlocks);
        editor.addMenuItem("blockformats", {
          text: "Blocks",
          menu: buildMenuItems(editor, blocks)
        });
        editor.addButton("formatselect", lazyFormatSelectBoxItems(editor, blocks));
      };
      var FormatSelect = { register: register$4 };
      var createCustomMenuItems = function(editor, names) {
        var items, nameList;
        if (typeof names === "string") {
          nameList = names.split(" ");
        } else if (global$2.isArray(names)) {
          return flatten(global$2.map(names, function(names2) {
            return createCustomMenuItems(editor, names2);
          }));
        }
        items = global$2.grep(nameList, function(name) {
          return name === "|" || name in editor.menuItems;
        });
        return global$2.map(items, function(name) {
          return name === "|" ? { text: "-" } : editor.menuItems[name];
        });
      };
      var isSeparator$1 = function(menuItem) {
        return menuItem && menuItem.text === "-";
      };
      var trimMenuItems = function(menuItems) {
        var menuItems2 = filter(menuItems, function(menuItem, i) {
          return !isSeparator$1(menuItem) || !isSeparator$1(menuItems[i - 1]);
        });
        return filter(menuItems2, function(menuItem, i) {
          return !isSeparator$1(menuItem) || i > 0 && i < menuItems2.length - 1;
        });
      };
      var createContextMenuItems = function(editor, context) {
        var outputMenuItems = [{ text: "-" }];
        var menuItems = global$2.grep(editor.menuItems, function(menuItem) {
          return menuItem.context === context;
        });
        global$2.each(menuItems, function(menuItem) {
          if (menuItem.separator === "before") {
            outputMenuItems.push({ text: "|" });
          }
          if (menuItem.prependToContext) {
            outputMenuItems.unshift(menuItem);
          } else {
            outputMenuItems.push(menuItem);
          }
          if (menuItem.separator === "after") {
            outputMenuItems.push({ text: "|" });
          }
        });
        return outputMenuItems;
      };
      var createInsertMenu = function(editor) {
        var insertButtonItems = editor.settings.insert_button_items;
        if (insertButtonItems) {
          return trimMenuItems(createCustomMenuItems(editor, insertButtonItems));
        } else {
          return trimMenuItems(createContextMenuItems(editor, "insert"));
        }
      };
      var registerButtons$3 = function(editor) {
        editor.addButton("insert", {
          type: "menubutton",
          icon: "insert",
          menu: [],
          oncreatemenu: function() {
            this.menu.add(createInsertMenu(editor));
            this.menu.renderNew();
          }
        });
      };
      var register$5 = function(editor) {
        registerButtons$3(editor);
      };
      var InsertButton = { register: register$5 };
      var registerFormatButtons = function(editor) {
        global$2.each({
          bold: "Bold",
          italic: "Italic",
          underline: "Underline",
          strikethrough: "Strikethrough",
          subscript: "Subscript",
          superscript: "Superscript"
        }, function(text2, name) {
          editor.addButton(name, {
            active: false,
            tooltip: text2,
            onPostRender: postRenderFormatToggle(editor, name),
            onclick: toggleFormat(editor, name)
          });
        });
      };
      var registerCommandButtons = function(editor) {
        global$2.each({
          outdent: [
            "Decrease indent",
            "Outdent"
          ],
          indent: [
            "Increase indent",
            "Indent"
          ],
          cut: [
            "Cut",
            "Cut"
          ],
          copy: [
            "Copy",
            "Copy"
          ],
          paste: [
            "Paste",
            "Paste"
          ],
          help: [
            "Help",
            "mceHelp"
          ],
          selectall: [
            "Select all",
            "SelectAll"
          ],
          visualaid: [
            "Visual aids",
            "mceToggleVisualAid"
          ],
          newdocument: [
            "New document",
            "mceNewDocument"
          ],
          removeformat: [
            "Clear formatting",
            "RemoveFormat"
          ],
          remove: [
            "Remove",
            "Delete"
          ]
        }, function(item, name) {
          editor.addButton(name, {
            tooltip: item[0],
            cmd: item[1]
          });
        });
      };
      var registerCommandToggleButtons = function(editor) {
        global$2.each({
          blockquote: [
            "Blockquote",
            "mceBlockQuote"
          ],
          subscript: [
            "Subscript",
            "Subscript"
          ],
          superscript: [
            "Superscript",
            "Superscript"
          ]
        }, function(item, name) {
          editor.addButton(name, {
            active: false,
            tooltip: item[0],
            cmd: item[1],
            onPostRender: postRenderFormatToggle(editor, name)
          });
        });
      };
      var registerButtons$4 = function(editor) {
        registerFormatButtons(editor);
        registerCommandButtons(editor);
        registerCommandToggleButtons(editor);
      };
      var registerMenuItems$1 = function(editor) {
        global$2.each({
          bold: [
            "Bold",
            "Bold",
            "Meta+B"
          ],
          italic: [
            "Italic",
            "Italic",
            "Meta+I"
          ],
          underline: [
            "Underline",
            "Underline",
            "Meta+U"
          ],
          strikethrough: [
            "Strikethrough",
            "Strikethrough"
          ],
          subscript: [
            "Subscript",
            "Subscript"
          ],
          superscript: [
            "Superscript",
            "Superscript"
          ],
          removeformat: [
            "Clear formatting",
            "RemoveFormat"
          ],
          newdocument: [
            "New document",
            "mceNewDocument"
          ],
          cut: [
            "Cut",
            "Cut",
            "Meta+X"
          ],
          copy: [
            "Copy",
            "Copy",
            "Meta+C"
          ],
          paste: [
            "Paste",
            "Paste",
            "Meta+V"
          ],
          selectall: [
            "Select all",
            "SelectAll",
            "Meta+A"
          ]
        }, function(item, name) {
          editor.addMenuItem(name, {
            text: item[0],
            icon: name,
            shortcut: item[2],
            cmd: item[1]
          });
        });
        editor.addMenuItem("codeformat", {
          text: "Code",
          icon: "code",
          onclick: toggleFormat(editor, "code")
        });
      };
      var register$6 = function(editor) {
        registerButtons$4(editor);
        registerMenuItems$1(editor);
      };
      var SimpleControls = { register: register$6 };
      var toggleUndoRedoState = function(editor, type) {
        return function() {
          var self2 = this;
          var checkState = function() {
            var typeFn = type === "redo" ? "hasRedo" : "hasUndo";
            return editor.undoManager ? editor.undoManager[typeFn]() : false;
          };
          self2.disabled(!checkState());
          editor.on("Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", function() {
            self2.disabled(editor.readonly || !checkState());
          });
        };
      };
      var registerMenuItems$2 = function(editor) {
        editor.addMenuItem("undo", {
          text: "Undo",
          icon: "undo",
          shortcut: "Meta+Z",
          onPostRender: toggleUndoRedoState(editor, "undo"),
          cmd: "undo"
        });
        editor.addMenuItem("redo", {
          text: "Redo",
          icon: "redo",
          shortcut: "Meta+Y",
          onPostRender: toggleUndoRedoState(editor, "redo"),
          cmd: "redo"
        });
      };
      var registerButtons$5 = function(editor) {
        editor.addButton("undo", {
          tooltip: "Undo",
          onPostRender: toggleUndoRedoState(editor, "undo"),
          cmd: "undo"
        });
        editor.addButton("redo", {
          tooltip: "Redo",
          onPostRender: toggleUndoRedoState(editor, "redo"),
          cmd: "redo"
        });
      };
      var register$7 = function(editor) {
        registerMenuItems$2(editor);
        registerButtons$5(editor);
      };
      var UndoRedo = { register: register$7 };
      var toggleVisualAidState = function(editor) {
        return function() {
          var self2 = this;
          editor.on("VisualAid", function(e) {
            self2.active(e.hasVisual);
          });
          self2.active(editor.hasVisual);
        };
      };
      var registerMenuItems$3 = function(editor) {
        editor.addMenuItem("visualaid", {
          text: "Visual aids",
          selectable: true,
          onPostRender: toggleVisualAidState(editor),
          cmd: "mceToggleVisualAid"
        });
      };
      var register$8 = function(editor) {
        registerMenuItems$3(editor);
      };
      var VisualAid = { register: register$8 };
      var setupEnvironment = function() {
        Widget.tooltips = !global$8.iOS;
        Control$1.translate = function(text2) {
          return global$1.translate(text2);
        };
      };
      var setupUiContainer = function(editor) {
        if (editor.settings.ui_container) {
          global$8.container = descendant(Element2.fromDom(domGlobals.document.body), editor.settings.ui_container).fold(constant(null), function(elm) {
            return elm.dom();
          });
        }
      };
      var setupRtlMode = function(editor) {
        if (editor.rtl) {
          Control$1.rtl = true;
        }
      };
      var setupHideFloatPanels = function(editor) {
        editor.on("mousedown progressstate", function() {
          FloatPanel.hideAll();
        });
      };
      var setup$1 = function(editor) {
        setupRtlMode(editor);
        setupHideFloatPanels(editor);
        setupUiContainer(editor);
        setupEnvironment();
        FormatSelect.register(editor);
        Align.register(editor);
        SimpleControls.register(editor);
        UndoRedo.register(editor);
        FontSizeSelect.register(editor);
        FontSelect.register(editor);
        Formats.register(editor);
        VisualAid.register(editor);
        InsertButton.register(editor);
      };
      var FormatControls = { setup: setup$1 };
      var GridLayout = AbsoluteLayout.extend({
        recalc: function(container) {
          var settings, rows, cols, items, contLayoutRect, width, height, rect2, ctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY;
          var colWidths = [];
          var rowHeights = [];
          var ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;
          settings = container.settings;
          items = container.items().filter(":visible");
          contLayoutRect = container.layoutRect();
          cols = settings.columns || Math.ceil(Math.sqrt(items.length));
          rows = Math.ceil(items.length / cols);
          spacingH = settings.spacingH || settings.spacing || 0;
          spacingV = settings.spacingV || settings.spacing || 0;
          alignH = settings.alignH || settings.align;
          alignV = settings.alignV || settings.align;
          contPaddingBox = container.paddingBox;
          reverseRows = "reverseRows" in settings ? settings.reverseRows : container.isRtl();
          if (alignH && typeof alignH === "string") {
            alignH = [alignH];
          }
          if (alignV && typeof alignV === "string") {
            alignV = [alignV];
          }
          for (x = 0; x < cols; x++) {
            colWidths.push(0);
          }
          for (y = 0; y < rows; y++) {
            rowHeights.push(0);
          }
          for (y = 0; y < rows; y++) {
            for (x = 0; x < cols; x++) {
              ctrl = items[y * cols + x];
              if (!ctrl) {
                break;
              }
              ctrlLayoutRect = ctrl.layoutRect();
              ctrlMinWidth = ctrlLayoutRect.minW;
              ctrlMinHeight = ctrlLayoutRect.minH;
              colWidths[x] = ctrlMinWidth > colWidths[x] ? ctrlMinWidth : colWidths[x];
              rowHeights[y] = ctrlMinHeight > rowHeights[y] ? ctrlMinHeight : rowHeights[y];
            }
          }
          availableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;
          for (maxX = 0, x = 0; x < cols; x++) {
            maxX += colWidths[x] + (x > 0 ? spacingH : 0);
            availableWidth -= (x > 0 ? spacingH : 0) + colWidths[x];
          }
          availableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;
          for (maxY = 0, y = 0; y < rows; y++) {
            maxY += rowHeights[y] + (y > 0 ? spacingV : 0);
            availableHeight -= (y > 0 ? spacingV : 0) + rowHeights[y];
          }
          maxX += contPaddingBox.left + contPaddingBox.right;
          maxY += contPaddingBox.top + contPaddingBox.bottom;
          rect2 = {};
          rect2.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);
          rect2.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);
          rect2.contentW = rect2.minW - contLayoutRect.deltaW;
          rect2.contentH = rect2.minH - contLayoutRect.deltaH;
          rect2.minW = Math.min(rect2.minW, contLayoutRect.maxW);
          rect2.minH = Math.min(rect2.minH, contLayoutRect.maxH);
          rect2.minW = Math.max(rect2.minW, contLayoutRect.startMinWidth);
          rect2.minH = Math.max(rect2.minH, contLayoutRect.startMinHeight);
          if (contLayoutRect.autoResize && (rect2.minW !== contLayoutRect.minW || rect2.minH !== contLayoutRect.minH)) {
            rect2.w = rect2.minW;
            rect2.h = rect2.minH;
            container.layoutRect(rect2);
            this.recalc(container);
            if (container._lastRect === null) {
              var parentCtrl = container.parent();
              if (parentCtrl) {
                parentCtrl._lastRect = null;
                parentCtrl.recalc();
              }
            }
            return;
          }
          if (contLayoutRect.autoResize) {
            rect2 = container.layoutRect(rect2);
            rect2.contentW = rect2.minW - contLayoutRect.deltaW;
            rect2.contentH = rect2.minH - contLayoutRect.deltaH;
          }
          var flexV;
          if (settings.packV === "start") {
            flexV = 0;
          } else {
            flexV = availableHeight > 0 ? Math.floor(availableHeight / rows) : 0;
          }
          var totalFlex = 0;
          var flexWidths = settings.flexWidths;
          if (flexWidths) {
            for (x = 0; x < flexWidths.length; x++) {
              totalFlex += flexWidths[x];
            }
          } else {
            totalFlex = cols;
          }
          var ratio2 = availableWidth / totalFlex;
          for (x = 0; x < cols; x++) {
            colWidths[x] += flexWidths ? flexWidths[x] * ratio2 : ratio2;
          }
          posY = contPaddingBox.top;
          for (y = 0; y < rows; y++) {
            posX = contPaddingBox.left;
            height = rowHeights[y] + flexV;
            for (x = 0; x < cols; x++) {
              if (reverseRows) {
                idx = y * cols + cols - 1 - x;
              } else {
                idx = y * cols + x;
              }
              ctrl = items[idx];
              if (!ctrl) {
                break;
              }
              ctrlSettings = ctrl.settings;
              ctrlLayoutRect = ctrl.layoutRect();
              width = Math.max(colWidths[x], ctrlLayoutRect.startMinWidth);
              ctrlLayoutRect.x = posX;
              ctrlLayoutRect.y = posY;
              align = ctrlSettings.alignH || (alignH ? alignH[x] || alignH[0] : null);
              if (align === "center") {
                ctrlLayoutRect.x = posX + width / 2 - ctrlLayoutRect.w / 2;
              } else if (align === "right") {
                ctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;
              } else if (align === "stretch") {
                ctrlLayoutRect.w = width;
              }
              align = ctrlSettings.alignV || (alignV ? alignV[x] || alignV[0] : null);
              if (align === "center") {
                ctrlLayoutRect.y = posY + height / 2 - ctrlLayoutRect.h / 2;
              } else if (align === "bottom") {
                ctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;
              } else if (align === "stretch") {
                ctrlLayoutRect.h = height;
              }
              ctrl.layoutRect(ctrlLayoutRect);
              posX += width + spacingH;
              if (ctrl.recalc) {
                ctrl.recalc();
              }
            }
            posY += height + spacingV;
          }
        }
      });
      var Iframe$1 = Widget.extend({
        renderHtml: function() {
          var self2 = this;
          self2.classes.add("iframe");
          self2.canFocus = false;
          return '<iframe id="' + self2._id + '" class="' + self2.classes + '" tabindex="-1" src="' + (self2.settings.url || "javascript:''") + '" frameborder="0"></iframe>';
        },
        src: function(src2) {
          this.getEl().src = src2;
        },
        html: function(html2, callback) {
          var self2 = this, body = this.getEl().contentWindow.document.body;
          if (!body) {
            global$7.setTimeout(function() {
              self2.html(html2);
            });
          } else {
            body.innerHTML = html2;
            if (callback) {
              callback();
            }
          }
          return this;
        }
      });
      var InfoBox = Widget.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.classes.add("widget").add("infobox");
          self2.canFocus = false;
        },
        severity: function(level) {
          this.classes.remove("error");
          this.classes.remove("warning");
          this.classes.remove("success");
          this.classes.add(level);
        },
        help: function(state) {
          this.state.set("help", state);
        },
        renderHtml: function() {
          var self2 = this, prefix = self2.classPrefix;
          return '<div id="' + self2._id + '" class="' + self2.classes + '"><div id="' + self2._id + '-body">' + self2.encode(self2.state.get("text")) + '<button role="button" tabindex="-1"><i class="' + prefix + "ico " + prefix + 'i-help"></i></button></div></div>';
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:text", function(e) {
            self2.getEl("body").firstChild.data = self2.encode(e.value);
            if (self2.state.get("rendered")) {
              self2.updateLayoutRect();
            }
          });
          self2.state.on("change:help", function(e) {
            self2.classes.toggle("has-help", e.value);
            if (self2.state.get("rendered")) {
              self2.updateLayoutRect();
            }
          });
          return self2._super();
        }
      });
      var Label = Widget.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.classes.add("widget").add("label");
          self2.canFocus = false;
          if (settings.multiline) {
            self2.classes.add("autoscroll");
          }
          if (settings.strong) {
            self2.classes.add("strong");
          }
        },
        initLayoutRect: function() {
          var self2 = this, layoutRect = self2._super();
          if (self2.settings.multiline) {
            var size = funcs.getSize(self2.getEl());
            if (size.width > layoutRect.maxW) {
              layoutRect.minW = layoutRect.maxW;
              self2.classes.add("multiline");
            }
            self2.getEl().style.width = layoutRect.minW + "px";
            layoutRect.startMinH = layoutRect.h = layoutRect.minH = Math.min(layoutRect.maxH, funcs.getSize(self2.getEl()).height);
          }
          return layoutRect;
        },
        repaint: function() {
          var self2 = this;
          if (!self2.settings.multiline) {
            self2.getEl().style.lineHeight = self2.layoutRect().h + "px";
          }
          return self2._super();
        },
        severity: function(level) {
          this.classes.remove("error");
          this.classes.remove("warning");
          this.classes.remove("success");
          this.classes.add(level);
        },
        renderHtml: function() {
          var self2 = this;
          var targetCtrl, forName, forId = self2.settings.forId;
          var text2 = self2.settings.html ? self2.settings.html : self2.encode(self2.state.get("text"));
          if (!forId && (forName = self2.settings.forName)) {
            targetCtrl = self2.getRoot().find("#" + forName)[0];
            if (targetCtrl) {
              forId = targetCtrl._id;
            }
          }
          if (forId) {
            return '<label id="' + self2._id + '" class="' + self2.classes + '"' + (forId ? ' for="' + forId + '"' : "") + ">" + text2 + "</label>";
          }
          return '<span id="' + self2._id + '" class="' + self2.classes + '">' + text2 + "</span>";
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:text", function(e) {
            self2.innerHtml(self2.encode(e.value));
            if (self2.state.get("rendered")) {
              self2.updateLayoutRect();
            }
          });
          return self2._super();
        }
      });
      var Toolbar$1 = Container.extend({
        Defaults: {
          role: "toolbar",
          layout: "flow"
        },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.classes.add("toolbar");
        },
        postRender: function() {
          var self2 = this;
          self2.items().each(function(ctrl) {
            ctrl.classes.add("toolbar-item");
          });
          return self2._super();
        }
      });
      var MenuBar = Toolbar$1.extend({
        Defaults: {
          role: "menubar",
          containerCls: "menubar",
          ariaRoot: true,
          defaults: { type: "menubutton" }
        }
      });
      function isChildOf$1(node2, parent) {
        while (node2) {
          if (parent === node2) {
            return true;
          }
          node2 = node2.parentNode;
        }
        return false;
      }
      var MenuButton = Button.extend({
        init: function(settings) {
          var self2 = this;
          self2._renderOpen = true;
          self2._super(settings);
          settings = self2.settings;
          self2.classes.add("menubtn");
          if (settings.fixedWidth) {
            self2.classes.add("fixed-width");
          }
          self2.aria("haspopup", true);
          self2.state.set("menu", settings.menu || self2.render());
        },
        showMenu: function(toggle) {
          var self2 = this;
          var menu;
          if (self2.menu && self2.menu.visible() && toggle !== false) {
            return self2.hideMenu();
          }
          if (!self2.menu) {
            menu = self2.state.get("menu") || [];
            self2.classes.add("opened");
            if (menu.length) {
              menu = {
                type: "menu",
                animate: true,
                items: menu
              };
            } else {
              menu.type = menu.type || "menu";
              menu.animate = true;
            }
            if (!menu.renderTo) {
              self2.menu = global$4.create(menu).parent(self2).renderTo();
            } else {
              self2.menu = menu.parent(self2).show().renderTo();
            }
            self2.fire("createmenu");
            self2.menu.reflow();
            self2.menu.on("cancel", function(e) {
              if (e.control.parent() === self2.menu) {
                e.stopPropagation();
                self2.focus();
                self2.hideMenu();
              }
            });
            self2.menu.on("select", function() {
              self2.focus();
            });
            self2.menu.on("show hide", function(e) {
              if (e.type === "hide" && e.control.parent() === self2) {
                self2.classes.remove("opened-under");
              }
              if (e.control === self2.menu) {
                self2.activeMenu(e.type === "show");
                self2.classes.toggle("opened", e.type === "show");
              }
              self2.aria("expanded", e.type === "show");
            }).fire("show");
          }
          self2.menu.show();
          self2.menu.layoutRect({ w: self2.layoutRect().w });
          self2.menu.repaint();
          self2.menu.moveRel(self2.getEl(), self2.isRtl() ? [
            "br-tr",
            "tr-br"
          ] : [
            "bl-tl",
            "tl-bl"
          ]);
          var menuLayoutRect = self2.menu.layoutRect();
          var selfBottom = self2.$el.offset().top + self2.layoutRect().h;
          if (selfBottom > menuLayoutRect.y && selfBottom < menuLayoutRect.y + menuLayoutRect.h) {
            self2.classes.add("opened-under");
          }
          self2.fire("showmenu");
        },
        hideMenu: function() {
          var self2 = this;
          if (self2.menu) {
            self2.menu.items().each(function(item) {
              if (item.hideMenu) {
                item.hideMenu();
              }
            });
            self2.menu.hide();
          }
        },
        activeMenu: function(state) {
          this.classes.toggle("active", state);
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = self2.classPrefix;
          var icon = self2.settings.icon, image2;
          var text2 = self2.state.get("text");
          var textHtml = "";
          image2 = self2.settings.image;
          if (image2) {
            icon = "none";
            if (typeof image2 !== "string") {
              image2 = domGlobals.window.getSelection ? image2[0] : image2[1];
            }
            image2 = ` style="background-image: url('` + image2 + `')"`;
          } else {
            image2 = "";
          }
          if (text2) {
            self2.classes.add("btn-has-text");
            textHtml = '<span class="' + prefix + 'txt">' + self2.encode(text2) + "</span>";
          }
          icon = self2.settings.icon ? prefix + "ico " + prefix + "i-" + icon : "";
          self2.aria("role", self2.parent() instanceof MenuBar ? "menuitem" : "button");
          return '<div id="' + id + '" class="' + self2.classes + '" tabindex="-1" aria-labelledby="' + id + '"><button id="' + id + '-open" role="presentation" type="button" tabindex="-1">' + (icon ? '<i class="' + icon + '"' + image2 + "></i>" : "") + textHtml + ' <i class="' + prefix + 'caret"></i></button></div>';
        },
        postRender: function() {
          var self2 = this;
          self2.on("click", function(e) {
            if (e.control === self2 && isChildOf$1(e.target, self2.getEl())) {
              self2.focus();
              self2.showMenu(!e.aria);
              if (e.aria) {
                self2.menu.items().filter(":visible")[0].focus();
              }
            }
          });
          self2.on("mouseenter", function(e) {
            var overCtrl = e.control;
            var parent = self2.parent();
            var hasVisibleSiblingMenu;
            if (overCtrl && parent && overCtrl instanceof MenuButton && overCtrl.parent() === parent) {
              parent.items().filter("MenuButton").each(function(ctrl) {
                if (ctrl.hideMenu && ctrl !== overCtrl) {
                  if (ctrl.menu && ctrl.menu.visible()) {
                    hasVisibleSiblingMenu = true;
                  }
                  ctrl.hideMenu();
                }
              });
              if (hasVisibleSiblingMenu) {
                overCtrl.focus();
                overCtrl.showMenu();
              }
            }
          });
          return self2._super();
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:menu", function() {
            if (self2.menu) {
              self2.menu.remove();
            }
            self2.menu = null;
          });
          return self2._super();
        },
        remove: function() {
          this._super();
          if (this.menu) {
            this.menu.remove();
          }
        }
      });
      var Menu = FloatPanel.extend({
        Defaults: {
          defaultType: "menuitem",
          border: 1,
          layout: "stack",
          role: "application",
          bodyRole: "menu",
          ariaRoot: true
        },
        init: function(settings) {
          var self2 = this;
          settings.autohide = true;
          settings.constrainToViewport = true;
          if (typeof settings.items === "function") {
            settings.itemsFactory = settings.items;
            settings.items = [];
          }
          if (settings.itemDefaults) {
            var items = settings.items;
            var i = items.length;
            while (i--) {
              items[i] = global$2.extend({}, settings.itemDefaults, items[i]);
            }
          }
          self2._super(settings);
          self2.classes.add("menu");
          if (settings.animate && global$8.ie !== 11) {
            self2.classes.add("animate");
          }
        },
        repaint: function() {
          this.classes.toggle("menu-align", true);
          this._super();
          this.getEl().style.height = "";
          this.getEl("body").style.height = "";
          return this;
        },
        cancel: function() {
          var self2 = this;
          self2.hideAll();
          self2.fire("select");
        },
        load: function() {
          var self2 = this;
          var time, factory;
          function hideThrobber() {
            if (self2.throbber) {
              self2.throbber.hide();
              self2.throbber = null;
            }
          }
          factory = self2.settings.itemsFactory;
          if (!factory) {
            return;
          }
          if (!self2.throbber) {
            self2.throbber = new Throbber(self2.getEl("body"), true);
            if (self2.items().length === 0) {
              self2.throbber.show();
              self2.fire("loading");
            } else {
              self2.throbber.show(100, function() {
                self2.items().remove();
                self2.fire("loading");
              });
            }
            self2.on("hide close", hideThrobber);
          }
          self2.requestTime = time = (/* @__PURE__ */ new Date()).getTime();
          self2.settings.itemsFactory(function(items) {
            if (items.length === 0) {
              self2.hide();
              return;
            }
            if (self2.requestTime !== time) {
              return;
            }
            self2.getEl().style.width = "";
            self2.getEl("body").style.width = "";
            hideThrobber();
            self2.items().remove();
            self2.getEl("body").innerHTML = "";
            self2.add(items);
            self2.renderNew();
            self2.fire("loaded");
          });
        },
        hideAll: function() {
          var self2 = this;
          this.find("menuitem").exec("hideMenu");
          return self2._super();
        },
        preRender: function() {
          var self2 = this;
          self2.items().each(function(ctrl) {
            var settings = ctrl.settings;
            if (settings.icon || settings.image || settings.selectable) {
              self2._hasIcons = true;
              return false;
            }
          });
          if (self2.settings.itemsFactory) {
            self2.on("postrender", function() {
              if (self2.settings.itemsFactory) {
                self2.load();
              }
            });
          }
          self2.on("show hide", function(e) {
            if (e.control === self2) {
              if (e.type === "show") {
                global$7.setTimeout(function() {
                  self2.classes.add("in");
                }, 0);
              } else {
                self2.classes.remove("in");
              }
            }
          });
          return self2._super();
        }
      });
      var ListBox = MenuButton.extend({
        init: function(settings) {
          var self2 = this;
          var values, selected, selectedText, lastItemCtrl;
          function setSelected(menuValues) {
            for (var i = 0; i < menuValues.length; i++) {
              selected = menuValues[i].selected || settings.value === menuValues[i].value;
              if (selected) {
                selectedText = selectedText || menuValues[i].text;
                self2.state.set("value", menuValues[i].value);
                return true;
              }
              if (menuValues[i].menu) {
                if (setSelected(menuValues[i].menu)) {
                  return true;
                }
              }
            }
          }
          self2._super(settings);
          settings = self2.settings;
          self2._values = values = settings.values;
          if (values) {
            if (typeof settings.value !== "undefined") {
              setSelected(values);
            }
            if (!selected && values.length > 0) {
              selectedText = values[0].text;
              self2.state.set("value", values[0].value);
            }
            self2.state.set("menu", values);
          }
          self2.state.set("text", settings.text || selectedText);
          self2.classes.add("listbox");
          self2.on("select", function(e) {
            var ctrl = e.control;
            if (lastItemCtrl) {
              e.lastControl = lastItemCtrl;
            }
            if (settings.multiple) {
              ctrl.active(!ctrl.active());
            } else {
              self2.value(e.control.value());
            }
            lastItemCtrl = ctrl;
          });
        },
        value: function(value) {
          if (arguments.length === 0) {
            return this.state.get("value");
          }
          if (typeof value === "undefined") {
            return this;
          }
          function valueExists(values) {
            return exists(values, function(a) {
              return a.menu ? valueExists(a.menu) : a.value === value;
            });
          }
          if (this.settings.values) {
            if (valueExists(this.settings.values)) {
              this.state.set("value", value);
            } else if (value === null) {
              this.state.set("value", null);
            }
          } else {
            this.state.set("value", value);
          }
          return this;
        },
        bindStates: function() {
          var self2 = this;
          function activateMenuItemsByValue(menu, value) {
            if (menu instanceof Menu) {
              menu.items().each(function(ctrl) {
                if (!ctrl.hasMenus()) {
                  ctrl.active(ctrl.value() === value);
                }
              });
            }
          }
          function getSelectedItem(menuValues, value) {
            var selectedItem;
            if (!menuValues) {
              return;
            }
            for (var i = 0; i < menuValues.length; i++) {
              if (menuValues[i].value === value) {
                return menuValues[i];
              }
              if (menuValues[i].menu) {
                selectedItem = getSelectedItem(menuValues[i].menu, value);
                if (selectedItem) {
                  return selectedItem;
                }
              }
            }
          }
          self2.on("show", function(e) {
            activateMenuItemsByValue(e.control, self2.value());
          });
          self2.state.on("change:value", function(e) {
            var selectedItem = getSelectedItem(self2.state.get("menu"), e.value);
            if (selectedItem) {
              self2.text(selectedItem.text);
            } else {
              self2.text(self2.settings.text);
            }
          });
          return self2._super();
        }
      });
      var toggleTextStyle = function(ctrl, state) {
        var textStyle = ctrl._textStyle;
        if (textStyle) {
          var textElm = ctrl.getEl("text");
          textElm.setAttribute("style", textStyle);
          if (state) {
            textElm.style.color = "";
            textElm.style.backgroundColor = "";
          }
        }
      };
      var MenuItem = Widget.extend({
        Defaults: {
          border: 0,
          role: "menuitem"
        },
        init: function(settings) {
          var self2 = this;
          var text2;
          self2._super(settings);
          settings = self2.settings;
          self2.classes.add("menu-item");
          if (settings.menu) {
            self2.classes.add("menu-item-expand");
          }
          if (settings.preview) {
            self2.classes.add("menu-item-preview");
          }
          text2 = self2.state.get("text");
          if (text2 === "-" || text2 === "|") {
            self2.classes.add("menu-item-sep");
            self2.aria("role", "separator");
            self2.state.set("text", "-");
          }
          if (settings.selectable) {
            self2.aria("role", "menuitemcheckbox");
            self2.classes.add("menu-item-checkbox");
            settings.icon = "selected";
          }
          if (!settings.preview && !settings.selectable) {
            self2.classes.add("menu-item-normal");
          }
          self2.on("mousedown", function(e) {
            e.preventDefault();
          });
          if (settings.menu && !settings.ariaHideMenu) {
            self2.aria("haspopup", true);
          }
        },
        hasMenus: function() {
          return !!this.settings.menu;
        },
        showMenu: function() {
          var self2 = this;
          var settings = self2.settings;
          var menu;
          var parent = self2.parent();
          parent.items().each(function(ctrl) {
            if (ctrl !== self2) {
              ctrl.hideMenu();
            }
          });
          if (settings.menu) {
            menu = self2.menu;
            if (!menu) {
              menu = settings.menu;
              if (menu.length) {
                menu = {
                  type: "menu",
                  items: menu
                };
              } else {
                menu.type = menu.type || "menu";
              }
              if (parent.settings.itemDefaults) {
                menu.itemDefaults = parent.settings.itemDefaults;
              }
              menu = self2.menu = global$4.create(menu).parent(self2).renderTo();
              menu.reflow();
              menu.on("cancel", function(e) {
                e.stopPropagation();
                self2.focus();
                menu.hide();
              });
              menu.on("show hide", function(e) {
                if (e.control.items) {
                  e.control.items().each(function(ctrl) {
                    ctrl.active(ctrl.settings.selected);
                  });
                }
              }).fire("show");
              menu.on("hide", function(e) {
                if (e.control === menu) {
                  self2.classes.remove("selected");
                }
              });
              menu.submenu = true;
            } else {
              menu.show();
            }
            menu._parentMenu = parent;
            menu.classes.add("menu-sub");
            var rel = menu.testMoveRel(self2.getEl(), self2.isRtl() ? [
              "tl-tr",
              "bl-br",
              "tr-tl",
              "br-bl"
            ] : [
              "tr-tl",
              "br-bl",
              "tl-tr",
              "bl-br"
            ]);
            menu.moveRel(self2.getEl(), rel);
            menu.rel = rel;
            rel = "menu-sub-" + rel;
            menu.classes.remove(menu._lastRel).add(rel);
            menu._lastRel = rel;
            self2.classes.add("selected");
            self2.aria("expanded", true);
          }
        },
        hideMenu: function() {
          var self2 = this;
          if (self2.menu) {
            self2.menu.items().each(function(item) {
              if (item.hideMenu) {
                item.hideMenu();
              }
            });
            self2.menu.hide();
            self2.aria("expanded", false);
          }
          return self2;
        },
        renderHtml: function() {
          var self2 = this;
          var id = self2._id;
          var settings = self2.settings;
          var prefix = self2.classPrefix;
          var text2 = self2.state.get("text");
          var icon = self2.settings.icon, image2 = "", shortcut = settings.shortcut;
          var url = self2.encode(settings.url), iconHtml = "";
          function convertShortcut(shortcut2) {
            var i, value, replace = {};
            if (global$8.mac) {
              replace = {
                alt: "&#x2325;",
                ctrl: "&#x2318;",
                shift: "&#x21E7;",
                meta: "&#x2318;"
              };
            } else {
              replace = { meta: "Ctrl" };
            }
            shortcut2 = shortcut2.split("+");
            for (i = 0; i < shortcut2.length; i++) {
              value = replace[shortcut2[i].toLowerCase()];
              if (value) {
                shortcut2[i] = value;
              }
            }
            return shortcut2.join("+");
          }
          function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          }
          function markMatches(text3) {
            var match = settings.match || "";
            return match ? text3.replace(new RegExp(escapeRegExp(match), "gi"), function(match2) {
              return "!mce~match[" + match2 + "]mce~match!";
            }) : text3;
          }
          function boldMatches(text3) {
            return text3.replace(new RegExp(escapeRegExp("!mce~match["), "g"), "<b>").replace(new RegExp(escapeRegExp("]mce~match!"), "g"), "</b>");
          }
          if (icon) {
            self2.parent().classes.add("menu-has-icons");
          }
          if (settings.image) {
            image2 = ` style="background-image: url('` + settings.image + `')"`;
          }
          if (shortcut) {
            shortcut = convertShortcut(shortcut);
          }
          icon = prefix + "ico " + prefix + "i-" + (self2.settings.icon || "none");
          iconHtml = text2 !== "-" ? '<i class="' + icon + '"' + image2 + "></i>Â " : "";
          text2 = boldMatches(self2.encode(markMatches(text2)));
          url = boldMatches(self2.encode(markMatches(url)));
          return '<div id="' + id + '" class="' + self2.classes + '" tabindex="-1">' + iconHtml + (text2 !== "-" ? '<span id="' + id + '-text" class="' + prefix + 'text">' + text2 + "</span>" : "") + (shortcut ? '<div id="' + id + '-shortcut" class="' + prefix + 'menu-shortcut">' + shortcut + "</div>" : "") + (settings.menu ? '<div class="' + prefix + 'caret"></div>' : "") + (url ? '<div class="' + prefix + 'menu-item-link">' + url + "</div>" : "") + "</div>";
        },
        postRender: function() {
          var self2 = this, settings = self2.settings;
          var textStyle = settings.textStyle;
          if (typeof textStyle === "function") {
            textStyle = textStyle.call(this);
          }
          if (textStyle) {
            var textElm = self2.getEl("text");
            if (textElm) {
              textElm.setAttribute("style", textStyle);
              self2._textStyle = textStyle;
            }
          }
          self2.on("mouseenter click", function(e) {
            if (e.control === self2) {
              if (!settings.menu && e.type === "click") {
                self2.fire("select");
                global$7.requestAnimationFrame(function() {
                  self2.parent().hideAll();
                });
              } else {
                self2.showMenu();
                if (e.aria) {
                  self2.menu.focus(true);
                }
              }
            }
          });
          self2._super();
          return self2;
        },
        hover: function() {
          var self2 = this;
          self2.parent().items().each(function(ctrl) {
            ctrl.classes.remove("selected");
          });
          self2.classes.toggle("selected", true);
          return self2;
        },
        active: function(state) {
          toggleTextStyle(this, state);
          if (typeof state !== "undefined") {
            this.aria("checked", state);
          }
          return this._super(state);
        },
        remove: function() {
          this._super();
          if (this.menu) {
            this.menu.remove();
          }
        }
      });
      var Radio = Checkbox.extend({
        Defaults: {
          classes: "radio",
          role: "radio"
        }
      });
      var ResizeHandle = Widget.extend({
        renderHtml: function() {
          var self2 = this, prefix = self2.classPrefix;
          self2.classes.add("resizehandle");
          if (self2.settings.direction === "both") {
            self2.classes.add("resizehandle-both");
          }
          self2.canFocus = false;
          return '<div id="' + self2._id + '" class="' + self2.classes + '"><i class="' + prefix + "ico " + prefix + 'i-resize"></i></div>';
        },
        postRender: function() {
          var self2 = this;
          self2._super();
          self2.resizeDragHelper = new DragHelper(this._id, {
            start: function() {
              self2.fire("ResizeStart");
            },
            drag: function(e) {
              if (self2.settings.direction !== "both") {
                e.deltaX = 0;
              }
              self2.fire("Resize", e);
            },
            stop: function() {
              self2.fire("ResizeEnd");
            }
          });
        },
        remove: function() {
          if (this.resizeDragHelper) {
            this.resizeDragHelper.destroy();
          }
          return this._super();
        }
      });
      function createOptions(options2) {
        var strOptions = "";
        if (options2) {
          for (var i = 0; i < options2.length; i++) {
            strOptions += '<option value="' + options2[i] + '">' + options2[i] + "</option>";
          }
        }
        return strOptions;
      }
      var SelectBox = Widget.extend({
        Defaults: {
          classes: "selectbox",
          role: "selectbox",
          options: []
        },
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          if (self2.settings.size) {
            self2.size = self2.settings.size;
          }
          if (self2.settings.options) {
            self2._options = self2.settings.options;
          }
          self2.on("keydown", function(e) {
            var rootControl;
            if (e.keyCode === 13) {
              e.preventDefault();
              self2.parents().reverse().each(function(ctrl) {
                if (ctrl.toJSON) {
                  rootControl = ctrl;
                  return false;
                }
              });
              self2.fire("submit", { data: rootControl.toJSON() });
            }
          });
        },
        options: function(state) {
          if (!arguments.length) {
            return this.state.get("options");
          }
          this.state.set("options", state);
          return this;
        },
        renderHtml: function() {
          var self2 = this;
          var options2, size = "";
          options2 = createOptions(self2._options);
          if (self2.size) {
            size = ' size = "' + self2.size + '"';
          }
          return '<select id="' + self2._id + '" class="' + self2.classes + '"' + size + ">" + options2 + "</select>";
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:options", function(e) {
            self2.getEl().innerHTML = createOptions(e.value);
          });
          return self2._super();
        }
      });
      function constrain(value, minVal, maxVal) {
        if (value < minVal) {
          value = minVal;
        }
        if (value > maxVal) {
          value = maxVal;
        }
        return value;
      }
      function setAriaProp(el2, name, value) {
        el2.setAttribute("aria-" + name, value);
      }
      function updateSliderHandle(ctrl, value) {
        var maxHandlePos, shortSizeName, sizeName, stylePosName, styleValue, handleEl;
        if (ctrl.settings.orientation === "v") {
          stylePosName = "top";
          sizeName = "height";
          shortSizeName = "h";
        } else {
          stylePosName = "left";
          sizeName = "width";
          shortSizeName = "w";
        }
        handleEl = ctrl.getEl("handle");
        maxHandlePos = (ctrl.layoutRect()[shortSizeName] || 100) - funcs.getSize(handleEl)[sizeName];
        styleValue = maxHandlePos * ((value - ctrl._minValue) / (ctrl._maxValue - ctrl._minValue)) + "px";
        handleEl.style[stylePosName] = styleValue;
        handleEl.style.height = ctrl.layoutRect().h + "px";
        setAriaProp(handleEl, "valuenow", value);
        setAriaProp(handleEl, "valuetext", "" + ctrl.settings.previewFilter(value));
        setAriaProp(handleEl, "valuemin", ctrl._minValue);
        setAriaProp(handleEl, "valuemax", ctrl._maxValue);
      }
      var Slider = Widget.extend({
        init: function(settings) {
          var self2 = this;
          if (!settings.previewFilter) {
            settings.previewFilter = function(value) {
              return Math.round(value * 100) / 100;
            };
          }
          self2._super(settings);
          self2.classes.add("slider");
          if (settings.orientation === "v") {
            self2.classes.add("vertical");
          }
          self2._minValue = isNumber(settings.minValue) ? settings.minValue : 0;
          self2._maxValue = isNumber(settings.maxValue) ? settings.maxValue : 100;
          self2._initValue = self2.state.get("value");
        },
        renderHtml: function() {
          var self2 = this, id = self2._id, prefix = self2.classPrefix;
          return '<div id="' + id + '" class="' + self2.classes + '"><div id="' + id + '-handle" class="' + prefix + 'slider-handle" role="slider" tabindex="-1"></div></div>';
        },
        reset: function() {
          this.value(this._initValue).repaint();
        },
        postRender: function() {
          var self2 = this;
          var minValue, maxValue, screenCordName, stylePosName, sizeName, shortSizeName;
          function toFraction(min, max, val) {
            return (val + min) / (max - min);
          }
          function fromFraction(min, max, val) {
            return val * (max - min) - min;
          }
          function handleKeyboard(minValue2, maxValue2) {
            function alter(delta2) {
              var value;
              value = self2.value();
              value = fromFraction(minValue2, maxValue2, toFraction(minValue2, maxValue2, value) + delta2 * 0.05);
              value = constrain(value, minValue2, maxValue2);
              self2.value(value);
              self2.fire("dragstart", { value });
              self2.fire("drag", { value });
              self2.fire("dragend", { value });
            }
            self2.on("keydown", function(e) {
              switch (e.keyCode) {
                case 37:
                case 38:
                  alter(-1);
                  break;
                case 39:
                case 40:
                  alter(1);
                  break;
              }
            });
          }
          function handleDrag2(minValue2, maxValue2, handleEl) {
            var startPos, startHandlePos, maxHandlePos, handlePos, value;
            self2._dragHelper = new DragHelper(self2._id, {
              handle: self2._id + "-handle",
              start: function(e) {
                startPos = e[screenCordName];
                startHandlePos = parseInt(self2.getEl("handle").style[stylePosName], 10);
                maxHandlePos = (self2.layoutRect()[shortSizeName] || 100) - funcs.getSize(handleEl)[sizeName];
                self2.fire("dragstart", { value });
              },
              drag: function(e) {
                var delta2 = e[screenCordName] - startPos;
                handlePos = constrain(startHandlePos + delta2, 0, maxHandlePos);
                handleEl.style[stylePosName] = handlePos + "px";
                value = minValue2 + handlePos / maxHandlePos * (maxValue2 - minValue2);
                self2.value(value);
                self2.tooltip().text("" + self2.settings.previewFilter(value)).show().moveRel(handleEl, "bc tc");
                self2.fire("drag", { value });
              },
              stop: function() {
                self2.tooltip().hide();
                self2.fire("dragend", { value });
              }
            });
          }
          minValue = self2._minValue;
          maxValue = self2._maxValue;
          if (self2.settings.orientation === "v") {
            screenCordName = "screenY";
            stylePosName = "top";
            sizeName = "height";
            shortSizeName = "h";
          } else {
            screenCordName = "screenX";
            stylePosName = "left";
            sizeName = "width";
            shortSizeName = "w";
          }
          self2._super();
          handleKeyboard(minValue, maxValue);
          handleDrag2(minValue, maxValue, self2.getEl("handle"));
        },
        repaint: function() {
          this._super();
          updateSliderHandle(this, this.value());
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:value", function(e) {
            updateSliderHandle(self2, e.value);
          });
          return self2._super();
        }
      });
      var Spacer = Widget.extend({
        renderHtml: function() {
          var self2 = this;
          self2.classes.add("spacer");
          self2.canFocus = false;
          return '<div id="' + self2._id + '" class="' + self2.classes + '"></div>';
        }
      });
      var SplitButton = MenuButton.extend({
        Defaults: {
          classes: "widget btn splitbtn",
          role: "button"
        },
        repaint: function() {
          var self2 = this;
          var elm = self2.getEl();
          var rect2 = self2.layoutRect();
          var mainButtonElm, menuButtonElm;
          self2._super();
          mainButtonElm = elm.firstChild;
          menuButtonElm = elm.lastChild;
          global$9(mainButtonElm).css({
            width: rect2.w - funcs.getSize(menuButtonElm).width,
            height: rect2.h - 2
          });
          global$9(menuButtonElm).css({ height: rect2.h - 2 });
          return self2;
        },
        activeMenu: function(state) {
          var self2 = this;
          global$9(self2.getEl().lastChild).toggleClass(self2.classPrefix + "active", state);
        },
        renderHtml: function() {
          var self2 = this;
          var id = self2._id;
          var prefix = self2.classPrefix;
          var image2;
          var icon = self2.state.get("icon");
          var text2 = self2.state.get("text");
          var settings = self2.settings;
          var textHtml = "", ariaPressed;
          image2 = settings.image;
          if (image2) {
            icon = "none";
            if (typeof image2 !== "string") {
              image2 = domGlobals.window.getSelection ? image2[0] : image2[1];
            }
            image2 = ` style="background-image: url('` + image2 + `')"`;
          } else {
            image2 = "";
          }
          icon = settings.icon ? prefix + "ico " + prefix + "i-" + icon : "";
          if (text2) {
            self2.classes.add("btn-has-text");
            textHtml = '<span class="' + prefix + 'txt">' + self2.encode(text2) + "</span>";
          }
          ariaPressed = typeof settings.active === "boolean" ? ' aria-pressed="' + settings.active + '"' : "";
          return '<div id="' + id + '" class="' + self2.classes + '" role="button"' + ariaPressed + ' tabindex="-1"><button type="button" hidefocus="1" tabindex="-1">' + (icon ? '<i class="' + icon + '"' + image2 + "></i>" : "") + textHtml + '</button><button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1">' + (self2._menuBtnText ? (icon ? "Â " : "") + self2._menuBtnText : "") + ' <i class="' + prefix + 'caret"></i></button></div>';
        },
        postRender: function() {
          var self2 = this, onClickHandler = self2.settings.onclick;
          self2.on("click", function(e) {
            var node2 = e.target;
            if (e.control === this) {
              while (node2) {
                if (e.aria && e.aria.key !== "down" || node2.nodeName === "BUTTON" && node2.className.indexOf("open") === -1) {
                  e.stopImmediatePropagation();
                  if (onClickHandler) {
                    onClickHandler.call(this, e);
                  }
                  return;
                }
                node2 = node2.parentNode;
              }
            }
          });
          delete self2.settings.onclick;
          return self2._super();
        }
      });
      var StackLayout = FlowLayout.extend({
        Defaults: {
          containerClass: "stack-layout",
          controlClass: "stack-layout-item",
          endClass: "break"
        },
        isNative: function() {
          return true;
        }
      });
      var TabPanel = Panel.extend({
        Defaults: {
          layout: "absolute",
          defaults: { type: "panel" }
        },
        activateTab: function(idx) {
          var activeTabElm;
          if (this.activeTabId) {
            activeTabElm = this.getEl(this.activeTabId);
            global$9(activeTabElm).removeClass(this.classPrefix + "active");
            activeTabElm.setAttribute("aria-selected", "false");
          }
          this.activeTabId = "t" + idx;
          activeTabElm = this.getEl("t" + idx);
          activeTabElm.setAttribute("aria-selected", "true");
          global$9(activeTabElm).addClass(this.classPrefix + "active");
          this.items()[idx].show().fire("showtab");
          this.reflow();
          this.items().each(function(item, i) {
            if (idx !== i) {
              item.hide();
            }
          });
        },
        renderHtml: function() {
          var self2 = this;
          var layout = self2._layout;
          var tabsHtml = "";
          var prefix = self2.classPrefix;
          self2.preRender();
          layout.preRender(self2);
          self2.items().each(function(ctrl, i) {
            var id = self2._id + "-t" + i;
            ctrl.aria("role", "tabpanel");
            ctrl.aria("labelledby", id);
            tabsHtml += '<div id="' + id + '" class="' + prefix + 'tab" unselectable="on" role="tab" aria-controls="' + ctrl._id + '" aria-selected="false" tabIndex="-1">' + self2.encode(ctrl.settings.title) + "</div>";
          });
          return '<div id="' + self2._id + '" class="' + self2.classes + '" hidefocus="1" tabindex="-1"><div id="' + self2._id + '-head" class="' + prefix + 'tabs" role="tablist">' + tabsHtml + '</div><div id="' + self2._id + '-body" class="' + self2.bodyClasses + '">' + layout.renderHtml(self2) + "</div></div>";
        },
        postRender: function() {
          var self2 = this;
          self2._super();
          self2.settings.activeTab = self2.settings.activeTab || 0;
          self2.activateTab(self2.settings.activeTab);
          this.on("click", function(e) {
            var targetParent = e.target.parentNode;
            if (targetParent && targetParent.id === self2._id + "-head") {
              var i = targetParent.childNodes.length;
              while (i--) {
                if (targetParent.childNodes[i] === e.target) {
                  self2.activateTab(i);
                }
              }
            }
          });
        },
        initLayoutRect: function() {
          var self2 = this;
          var rect2, minW, minH;
          minW = funcs.getSize(self2.getEl("head")).width;
          minW = minW < 0 ? 0 : minW;
          minH = 0;
          self2.items().each(function(item) {
            minW = Math.max(minW, item.layoutRect().minW);
            minH = Math.max(minH, item.layoutRect().minH);
          });
          self2.items().each(function(ctrl) {
            ctrl.settings.x = 0;
            ctrl.settings.y = 0;
            ctrl.settings.w = minW;
            ctrl.settings.h = minH;
            ctrl.layoutRect({
              x: 0,
              y: 0,
              w: minW,
              h: minH
            });
          });
          var headH = funcs.getSize(self2.getEl("head")).height;
          self2.settings.minWidth = minW;
          self2.settings.minHeight = minH + headH;
          rect2 = self2._super();
          rect2.deltaH += headH;
          rect2.innerH = rect2.h - rect2.deltaH;
          return rect2;
        }
      });
      var TextBox = Widget.extend({
        init: function(settings) {
          var self2 = this;
          self2._super(settings);
          self2.classes.add("textbox");
          if (settings.multiline) {
            self2.classes.add("multiline");
          } else {
            self2.on("keydown", function(e) {
              var rootControl;
              if (e.keyCode === 13) {
                e.preventDefault();
                self2.parents().reverse().each(function(ctrl) {
                  if (ctrl.toJSON) {
                    rootControl = ctrl;
                    return false;
                  }
                });
                self2.fire("submit", { data: rootControl.toJSON() });
              }
            });
            self2.on("keyup", function(e) {
              self2.state.set("value", e.target.value);
            });
          }
        },
        repaint: function() {
          var self2 = this;
          var style, rect2, borderBox, borderW, borderH = 0, lastRepaintRect;
          style = self2.getEl().style;
          rect2 = self2._layoutRect;
          lastRepaintRect = self2._lastRepaintRect || {};
          var doc = domGlobals.document;
          if (!self2.settings.multiline && doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
            style.lineHeight = rect2.h - borderH + "px";
          }
          borderBox = self2.borderBox;
          borderW = borderBox.left + borderBox.right + 8;
          borderH = borderBox.top + borderBox.bottom + (self2.settings.multiline ? 8 : 0);
          if (rect2.x !== lastRepaintRect.x) {
            style.left = rect2.x + "px";
            lastRepaintRect.x = rect2.x;
          }
          if (rect2.y !== lastRepaintRect.y) {
            style.top = rect2.y + "px";
            lastRepaintRect.y = rect2.y;
          }
          if (rect2.w !== lastRepaintRect.w) {
            style.width = rect2.w - borderW + "px";
            lastRepaintRect.w = rect2.w;
          }
          if (rect2.h !== lastRepaintRect.h) {
            style.height = rect2.h - borderH + "px";
            lastRepaintRect.h = rect2.h;
          }
          self2._lastRepaintRect = lastRepaintRect;
          self2.fire("repaint", {}, false);
          return self2;
        },
        renderHtml: function() {
          var self2 = this;
          var settings = self2.settings;
          var attrs, elm;
          attrs = {
            id: self2._id,
            hidefocus: "1"
          };
          global$2.each([
            "rows",
            "spellcheck",
            "maxLength",
            "size",
            "readonly",
            "min",
            "max",
            "step",
            "list",
            "pattern",
            "placeholder",
            "required",
            "multiple"
          ], function(name) {
            attrs[name] = settings[name];
          });
          if (self2.disabled()) {
            attrs.disabled = "disabled";
          }
          if (settings.subtype) {
            attrs.type = settings.subtype;
          }
          elm = funcs.create(settings.multiline ? "textarea" : "input", attrs);
          elm.value = self2.state.get("value");
          elm.className = self2.classes.toString();
          return elm.outerHTML;
        },
        value: function(value) {
          if (arguments.length) {
            this.state.set("value", value);
            return this;
          }
          if (this.state.get("rendered")) {
            this.state.set("value", this.getEl().value);
          }
          return this.state.get("value");
        },
        postRender: function() {
          var self2 = this;
          self2.getEl().value = self2.state.get("value");
          self2._super();
          self2.$el.on("change", function(e) {
            self2.state.set("value", e.target.value);
            self2.fire("change", e);
          });
        },
        bindStates: function() {
          var self2 = this;
          self2.state.on("change:value", function(e) {
            if (self2.getEl().value !== e.value) {
              self2.getEl().value = e.value;
            }
          });
          self2.state.on("change:disabled", function(e) {
            self2.getEl().disabled = e.value;
          });
          return self2._super();
        },
        remove: function() {
          this.$el.off();
          this._super();
        }
      });
      var getApi = function() {
        return {
          Selector,
          Collection: Collection$2,
          ReflowQueue,
          Control: Control$1,
          Factory: global$4,
          KeyboardNavigation,
          Container,
          DragHelper,
          Scrollable,
          Panel,
          Movable,
          Resizable,
          FloatPanel,
          Window,
          MessageBox,
          Tooltip,
          Widget,
          Progress,
          Notification,
          Layout,
          AbsoluteLayout,
          Button,
          ButtonGroup,
          Checkbox,
          ComboBox,
          ColorBox,
          PanelButton,
          ColorButton,
          ColorPicker,
          Path,
          ElementPath,
          FormItem,
          Form,
          FieldSet,
          FilePicker,
          FitLayout,
          FlexLayout,
          FlowLayout,
          FormatControls,
          GridLayout,
          Iframe: Iframe$1,
          InfoBox,
          Label,
          Toolbar: Toolbar$1,
          MenuBar,
          MenuButton,
          MenuItem,
          Throbber,
          Menu,
          ListBox,
          Radio,
          ResizeHandle,
          SelectBox,
          Slider,
          Spacer,
          SplitButton,
          StackLayout,
          TabPanel,
          TextBox,
          DropZone,
          BrowseButton
        };
      };
      var appendTo = function(target2) {
        if (target2.ui) {
          global$2.each(getApi(), function(ref, key) {
            target2.ui[key] = ref;
          });
        } else {
          target2.ui = getApi();
        }
      };
      var registerToFactory = function() {
        global$2.each(getApi(), function(ref, key) {
          global$4.add(key, ref);
        });
      };
      var Api = {
        appendTo,
        registerToFactory
      };
      Api.registerToFactory();
      Api.appendTo(window.tinymce ? window.tinymce : {});
      global2.add("modern", function(editor) {
        FormatControls.setup(editor);
        return ThemeApi.get(editor);
      });
      function Theme() {
      }
      return Theme;
    })(window);
  })();
  return theme;
}
requireTheme();
var link = {};
var plugin$6 = {};
var hasRequiredPlugin$6;
function requirePlugin$6() {
  if (hasRequiredPlugin$6) return plugin$6;
  hasRequiredPlugin$6 = 1;
  (function() {
    (function(domGlobals) {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var global$1 = tinymce.util.Tools.resolve("tinymce.util.VK");
      var assumeExternalTargets = function(editorSettings) {
        return typeof editorSettings.link_assume_external_targets === "boolean" ? editorSettings.link_assume_external_targets : false;
      };
      var hasContextToolbar = function(editorSettings) {
        return typeof editorSettings.link_context_toolbar === "boolean" ? editorSettings.link_context_toolbar : false;
      };
      var getLinkList = function(editorSettings) {
        return editorSettings.link_list;
      };
      var hasDefaultLinkTarget = function(editorSettings) {
        return typeof editorSettings.default_link_target === "string";
      };
      var getDefaultLinkTarget = function(editorSettings) {
        return editorSettings.default_link_target;
      };
      var getTargetList = function(editorSettings) {
        return editorSettings.target_list;
      };
      var setTargetList = function(editor, list2) {
        editor.settings.target_list = list2;
      };
      var shouldShowTargetList = function(editorSettings) {
        return getTargetList(editorSettings) !== false;
      };
      var getRelList = function(editorSettings) {
        return editorSettings.rel_list;
      };
      var hasRelList = function(editorSettings) {
        return getRelList(editorSettings) !== void 0;
      };
      var getLinkClassList = function(editorSettings) {
        return editorSettings.link_class_list;
      };
      var hasLinkClassList = function(editorSettings) {
        return getLinkClassList(editorSettings) !== void 0;
      };
      var shouldShowLinkTitle = function(editorSettings) {
        return editorSettings.link_title !== false;
      };
      var allowUnsafeLinkTarget = function(editorSettings) {
        return typeof editorSettings.allow_unsafe_link_target === "boolean" ? editorSettings.allow_unsafe_link_target : false;
      };
      var Settings = {
        assumeExternalTargets,
        hasContextToolbar,
        getLinkList,
        hasDefaultLinkTarget,
        getDefaultLinkTarget,
        getTargetList,
        setTargetList,
        shouldShowTargetList,
        getRelList,
        hasRelList,
        getLinkClassList,
        hasLinkClassList,
        shouldShowLinkTitle,
        allowUnsafeLinkTarget
      };
      var global$2 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
      var global$3 = tinymce.util.Tools.resolve("tinymce.Env");
      var appendClickRemove = function(link3, evt) {
        domGlobals.document.body.appendChild(link3);
        link3.dispatchEvent(evt);
        domGlobals.document.body.removeChild(link3);
      };
      var open = function(url) {
        if (!global$3.ie || global$3.ie > 10) {
          var link3 = domGlobals.document.createElement("a");
          link3.target = "_blank";
          link3.href = url;
          link3.rel = "noreferrer noopener";
          var evt = domGlobals.document.createEvent("MouseEvents");
          evt.initMouseEvent("click", true, true, domGlobals.window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
          appendClickRemove(link3, evt);
        } else {
          var win = domGlobals.window.open("", "_blank");
          if (win) {
            win.opener = null;
            var doc = win.document;
            doc.open();
            doc.write('<meta http-equiv="refresh" content="0; url=' + global$2.DOM.encode(url) + '">');
            doc.close();
          }
        }
      };
      var OpenUrl = { open };
      var global$4 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var toggleTargetRules = function(rel, isUnsafe) {
        var rules2 = ["noopener"];
        var newRel = rel ? rel.split(/\s+/) : [];
        var toString = function(rel2) {
          return global$4.trim(rel2.sort().join(" "));
        };
        var addTargetRules = function(rel2) {
          rel2 = removeTargetRules(rel2);
          return rel2.length ? rel2.concat(rules2) : rules2;
        };
        var removeTargetRules = function(rel2) {
          return rel2.filter(function(val) {
            return global$4.inArray(rules2, val) === -1;
          });
        };
        newRel = isUnsafe ? addTargetRules(newRel) : removeTargetRules(newRel);
        return newRel.length ? toString(newRel) : null;
      };
      var trimCaretContainers = function(text2) {
        return text2.replace(/\uFEFF/g, "");
      };
      var getAnchorElement = function(editor, selectedElm) {
        selectedElm = selectedElm || editor.selection.getNode();
        if (isImageFigure(selectedElm)) {
          return editor.dom.select("a[href]", selectedElm)[0];
        } else {
          return editor.dom.getParent(selectedElm, "a[href]");
        }
      };
      var getAnchorText = function(selection, anchorElm) {
        var text2 = anchorElm ? anchorElm.innerText || anchorElm.textContent : selection.getContent({ format: "text" });
        return trimCaretContainers(text2);
      };
      var isLink = function(elm) {
        return elm && elm.nodeName === "A" && elm.href;
      };
      var hasLinks = function(elements) {
        return global$4.grep(elements, isLink).length > 0;
      };
      var isOnlyTextSelected = function(html2) {
        if (/</.test(html2) && (!/^<a [^>]+>[^<]+<\/a>$/.test(html2) || html2.indexOf("href=") === -1)) {
          return false;
        }
        return true;
      };
      var isImageFigure = function(node) {
        return node && node.nodeName === "FIGURE" && /\bimage\b/i.test(node.className);
      };
      var link2 = function(editor, attachState2) {
        return function(data) {
          editor.undoManager.transact(function() {
            var selectedElm = editor.selection.getNode();
            var anchorElm = getAnchorElement(editor, selectedElm);
            var linkAttrs = {
              href: data.href,
              target: data.target ? data.target : null,
              rel: data.rel ? data.rel : null,
              class: data.class ? data.class : null,
              title: data.title ? data.title : null
            };
            if (!Settings.hasRelList(editor.settings) && Settings.allowUnsafeLinkTarget(editor.settings) === false) {
              linkAttrs.rel = toggleTargetRules(linkAttrs.rel, linkAttrs.target === "_blank");
            }
            if (data.href === attachState2.href) {
              attachState2.attach();
              attachState2 = {};
            }
            if (anchorElm) {
              editor.focus();
              if (data.hasOwnProperty("text")) {
                if ("innerText" in anchorElm) {
                  anchorElm.innerText = data.text;
                } else {
                  anchorElm.textContent = data.text;
                }
              }
              editor.dom.setAttribs(anchorElm, linkAttrs);
              editor.selection.select(anchorElm);
              editor.undoManager.add();
            } else {
              if (isImageFigure(selectedElm)) {
                linkImageFigure(editor, selectedElm, linkAttrs);
              } else if (data.hasOwnProperty("text")) {
                editor.insertContent(editor.dom.createHTML("a", linkAttrs, editor.dom.encode(data.text)));
              } else {
                editor.execCommand("mceInsertLink", false, linkAttrs);
              }
            }
          });
        };
      };
      var unlink = function(editor) {
        return function() {
          editor.undoManager.transact(function() {
            var node = editor.selection.getNode();
            if (isImageFigure(node)) {
              unlinkImageFigure(editor, node);
            } else {
              editor.execCommand("unlink");
            }
          });
        };
      };
      var unlinkImageFigure = function(editor, fig) {
        var a, img;
        img = editor.dom.select("img", fig)[0];
        if (img) {
          a = editor.dom.getParents(img, "a[href]", fig)[0];
          if (a) {
            a.parentNode.insertBefore(img, a);
            editor.dom.remove(a);
          }
        }
      };
      var linkImageFigure = function(editor, fig, attrs) {
        var a, img;
        img = editor.dom.select("img", fig)[0];
        if (img) {
          a = editor.dom.create("a", attrs);
          img.parentNode.insertBefore(a, img);
          a.appendChild(img);
        }
      };
      var Utils = {
        link: link2,
        unlink,
        isLink,
        hasLinks,
        isOnlyTextSelected,
        getAnchorElement,
        getAnchorText,
        toggleTargetRules
      };
      var global$5 = tinymce.util.Tools.resolve("tinymce.util.Delay");
      var global$6 = tinymce.util.Tools.resolve("tinymce.util.XHR");
      var attachState = {};
      var createLinkList = function(editor, callback) {
        var linkList = Settings.getLinkList(editor.settings);
        if (typeof linkList === "string") {
          global$6.send({
            url: linkList,
            success: function(text2) {
              callback(editor, JSON.parse(text2));
            }
          });
        } else if (typeof linkList === "function") {
          linkList(function(list2) {
            callback(editor, list2);
          });
        } else {
          callback(editor, linkList);
        }
      };
      var buildListItems = function(inputList, itemCallback, startItems) {
        var appendItems = function(values, output2) {
          output2 = output2 || [];
          global$4.each(values, function(item) {
            var menuItem = { text: item.text || item.title };
            if (item.menu) {
              menuItem.menu = appendItems(item.menu);
            } else {
              menuItem.value = item.value;
              if (itemCallback) {
                itemCallback(menuItem);
              }
            }
            output2.push(menuItem);
          });
          return output2;
        };
        return appendItems(inputList, startItems || []);
      };
      var delayedConfirm = function(editor, message, callback) {
        var rng = editor.selection.getRng();
        global$5.setEditorTimeout(editor, function() {
          editor.windowManager.confirm(message, function(state) {
            editor.selection.setRng(rng);
            callback(state);
          });
        });
      };
      var showDialog = function(editor, linkList) {
        var data = {};
        var selection = editor.selection;
        var dom = editor.dom;
        var anchorElm, initialText;
        var win, onlyText, textListCtrl, linkListCtrl, relListCtrl, targetListCtrl, classListCtrl, linkTitleCtrl, value;
        var linkListChangeHandler = function(e) {
          var textCtrl = win.find("#text");
          if (!textCtrl.value() || e.lastControl && textCtrl.value() === e.lastControl.text()) {
            textCtrl.value(e.control.text());
          }
          win.find("#href").value(e.control.value());
        };
        var buildAnchorListControl = function(url) {
          var anchorList = [];
          global$4.each(editor.dom.select("a:not([href])"), function(anchor) {
            var id = anchor.name || anchor.id;
            if (id) {
              anchorList.push({
                text: id,
                value: "#" + id,
                selected: url.indexOf("#" + id) !== -1
              });
            }
          });
          if (anchorList.length) {
            anchorList.unshift({
              text: "None",
              value: ""
            });
            return {
              name: "anchor",
              type: "listbox",
              label: "Anchors",
              values: anchorList,
              onselect: linkListChangeHandler
            };
          }
        };
        var updateText = function() {
          if (!initialText && onlyText && !data.text) {
            this.parent().parent().find("#text")[0].value(this.value());
          }
        };
        var urlChange = function(e) {
          var meta = e.meta || {};
          if (linkListCtrl) {
            linkListCtrl.value(editor.convertURL(this.value(), "href"));
          }
          global$4.each(e.meta, function(value2, key) {
            var inp = win.find("#" + key);
            if (key === "text") {
              if (initialText.length === 0) {
                inp.value(value2);
                data.text = value2;
              }
            } else {
              inp.value(value2);
            }
          });
          if (meta.attach) {
            attachState = {
              href: this.value(),
              attach: meta.attach
            };
          }
          if (!meta.text) {
            updateText.call(this);
          }
        };
        var onBeforeCall = function(e) {
          e.meta = win.toJSON();
        };
        onlyText = Utils.isOnlyTextSelected(selection.getContent());
        anchorElm = Utils.getAnchorElement(editor);
        data.text = initialText = Utils.getAnchorText(editor.selection, anchorElm);
        data.href = anchorElm ? dom.getAttrib(anchorElm, "href") : "";
        if (anchorElm) {
          data.target = dom.getAttrib(anchorElm, "target");
        } else if (Settings.hasDefaultLinkTarget(editor.settings)) {
          data.target = Settings.getDefaultLinkTarget(editor.settings);
        }
        if (value = dom.getAttrib(anchorElm, "rel")) {
          data.rel = value;
        }
        if (value = dom.getAttrib(anchorElm, "class")) {
          data.class = value;
        }
        if (value = dom.getAttrib(anchorElm, "title")) {
          data.title = value;
        }
        if (onlyText) {
          textListCtrl = {
            name: "text",
            type: "textbox",
            size: 40,
            label: "Text to display",
            onchange: function() {
              data.text = this.value();
            }
          };
        }
        if (linkList) {
          linkListCtrl = {
            type: "listbox",
            label: "Link list",
            values: buildListItems(linkList, function(item) {
              item.value = editor.convertURL(item.value || item.url, "href");
            }, [{
              text: "None",
              value: ""
            }]),
            onselect: linkListChangeHandler,
            value: editor.convertURL(data.href, "href"),
            onPostRender: function() {
              linkListCtrl = this;
            }
          };
        }
        if (Settings.shouldShowTargetList(editor.settings)) {
          if (Settings.getTargetList(editor.settings) === void 0) {
            Settings.setTargetList(editor, [
              {
                text: "None",
                value: ""
              },
              {
                text: "New window",
                value: "_blank"
              }
            ]);
          }
          targetListCtrl = {
            name: "target",
            type: "listbox",
            label: "Target",
            values: buildListItems(Settings.getTargetList(editor.settings))
          };
        }
        if (Settings.hasRelList(editor.settings)) {
          relListCtrl = {
            name: "rel",
            type: "listbox",
            label: "Rel",
            values: buildListItems(Settings.getRelList(editor.settings), function(item) {
              if (Settings.allowUnsafeLinkTarget(editor.settings) === false) {
                item.value = Utils.toggleTargetRules(item.value, data.target === "_blank");
              }
            })
          };
        }
        if (Settings.hasLinkClassList(editor.settings)) {
          classListCtrl = {
            name: "class",
            type: "listbox",
            label: "Class",
            values: buildListItems(Settings.getLinkClassList(editor.settings), function(item) {
              if (item.value) {
                item.textStyle = function() {
                  return editor.formatter.getCssText({
                    inline: "a",
                    classes: [item.value]
                  });
                };
              }
            })
          };
        }
        if (Settings.shouldShowLinkTitle(editor.settings)) {
          linkTitleCtrl = {
            name: "title",
            type: "textbox",
            label: "Title",
            value: data.title
          };
        }
        win = editor.windowManager.open({
          title: "Insert link",
          data,
          body: [
            {
              name: "href",
              type: "filepicker",
              filetype: "file",
              size: 40,
              autofocus: true,
              label: "Url",
              onchange: urlChange,
              onkeyup: updateText,
              onpaste: updateText,
              onbeforecall: onBeforeCall
            },
            textListCtrl,
            linkTitleCtrl,
            buildAnchorListControl(data.href),
            linkListCtrl,
            relListCtrl,
            targetListCtrl,
            classListCtrl
          ],
          onSubmit: function(e) {
            var assumeExternalTargets2 = Settings.assumeExternalTargets(editor.settings);
            var insertLink = Utils.link(editor, attachState);
            var removeLink = Utils.unlink(editor);
            var resultData = global$4.extend({}, data, e.data);
            var href = resultData.href;
            if (!href) {
              removeLink();
              return;
            }
            if (!onlyText || resultData.text === initialText) {
              delete resultData.text;
            }
            if (href.indexOf("@") > 0 && href.indexOf("//") === -1 && href.indexOf("mailto:") === -1) {
              delayedConfirm(editor, "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?", function(state) {
                if (state) {
                  resultData.href = "mailto:" + href;
                }
                insertLink(resultData);
              });
              return;
            }
            if (assumeExternalTargets2 === true && !/^\w+:/i.test(href) || assumeExternalTargets2 === false && /^\s*www[\.|\d\.]/i.test(href)) {
              delayedConfirm(editor, "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?", function(state) {
                if (state) {
                  resultData.href = "http://" + href;
                }
                insertLink(resultData);
              });
              return;
            }
            insertLink(resultData);
          }
        });
      };
      var open$1 = function(editor) {
        createLinkList(editor, showDialog);
      };
      var Dialog = { open: open$1 };
      var getLink = function(editor, elm) {
        return editor.dom.getParent(elm, "a[href]");
      };
      var getSelectedLink = function(editor) {
        return getLink(editor, editor.selection.getStart());
      };
      var getHref = function(elm) {
        var href = elm.getAttribute("data-mce-href");
        return href ? href : elm.getAttribute("href");
      };
      var isContextMenuVisible = function(editor) {
        var contextmenu = editor.plugins.contextmenu;
        return contextmenu ? contextmenu.isContextMenuVisible() : false;
      };
      var hasOnlyAltModifier = function(e) {
        return e.altKey === true && e.shiftKey === false && e.ctrlKey === false && e.metaKey === false;
      };
      var gotoLink = function(editor, a) {
        if (a) {
          var href = getHref(a);
          if (/^#/.test(href)) {
            var targetEl = editor.$(href);
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            OpenUrl.open(a.href);
          }
        }
      };
      var openDialog = function(editor) {
        return function() {
          Dialog.open(editor);
        };
      };
      var gotoSelectedLink = function(editor) {
        return function() {
          gotoLink(editor, getSelectedLink(editor));
        };
      };
      var leftClickedOnAHref = function(editor) {
        return function(elm) {
          var sel, rng, node;
          if (Settings.hasContextToolbar(editor.settings) && !isContextMenuVisible(editor) && Utils.isLink(elm)) {
            sel = editor.selection;
            rng = sel.getRng();
            node = rng.startContainer;
            if (node.nodeType === 3 && sel.isCollapsed() && rng.startOffset > 0 && rng.startOffset < node.data.length) {
              return true;
            }
          }
          return false;
        };
      };
      var setupGotoLinks = function(editor) {
        editor.on("click", function(e) {
          var link3 = getLink(editor, e.target);
          if (link3 && global$1.metaKeyPressed(e)) {
            e.preventDefault();
            gotoLink(editor, link3);
          }
        });
        editor.on("keydown", function(e) {
          var link3 = getSelectedLink(editor);
          if (link3 && e.keyCode === 13 && hasOnlyAltModifier(e)) {
            e.preventDefault();
            gotoLink(editor, link3);
          }
        });
      };
      var toggleActiveState = function(editor) {
        return function() {
          var self2 = this;
          editor.on("nodechange", function(e) {
            self2.active(!editor.readonly && !!Utils.getAnchorElement(editor, e.element));
          });
        };
      };
      var toggleViewLinkState = function(editor) {
        return function() {
          var self2 = this;
          var toggleVisibility = function(e) {
            if (Utils.hasLinks(e.parents)) {
              self2.show();
            } else {
              self2.hide();
            }
          };
          if (!Utils.hasLinks(editor.dom.getParents(editor.selection.getStart()))) {
            self2.hide();
          }
          editor.on("nodechange", toggleVisibility);
          self2.on("remove", function() {
            editor.off("nodechange", toggleVisibility);
          });
        };
      };
      var Actions = {
        openDialog,
        gotoSelectedLink,
        leftClickedOnAHref,
        setupGotoLinks,
        toggleActiveState,
        toggleViewLinkState
      };
      var register = function(editor) {
        editor.addCommand("mceLink", Actions.openDialog(editor));
      };
      var Commands = { register };
      var setup = function(editor) {
        editor.addShortcut("Meta+K", "", Actions.openDialog(editor));
      };
      var Keyboard = { setup };
      var setupButtons = function(editor) {
        editor.addButton("link", {
          active: false,
          icon: "link",
          tooltip: "Insert/edit link",
          onclick: Actions.openDialog(editor),
          onpostrender: Actions.toggleActiveState(editor)
        });
        editor.addButton("unlink", {
          active: false,
          icon: "unlink",
          tooltip: "Remove link",
          onclick: Utils.unlink(editor),
          onpostrender: Actions.toggleActiveState(editor)
        });
        if (editor.addContextToolbar) {
          editor.addButton("openlink", {
            icon: "newtab",
            tooltip: "Open link",
            onclick: Actions.gotoSelectedLink(editor)
          });
        }
      };
      var setupMenuItems = function(editor) {
        editor.addMenuItem("openlink", {
          text: "Open link",
          icon: "newtab",
          onclick: Actions.gotoSelectedLink(editor),
          onPostRender: Actions.toggleViewLinkState(editor),
          prependToContext: true
        });
        editor.addMenuItem("link", {
          icon: "link",
          text: "Link",
          shortcut: "Meta+K",
          onclick: Actions.openDialog(editor),
          stateSelector: "a[href]",
          context: "insert",
          prependToContext: true
        });
        editor.addMenuItem("unlink", {
          icon: "unlink",
          text: "Remove link",
          onclick: Utils.unlink(editor),
          stateSelector: "a[href]"
        });
      };
      var setupContextToolbars = function(editor) {
        if (editor.addContextToolbar) {
          editor.addContextToolbar(Actions.leftClickedOnAHref(editor), "openlink | link unlink");
        }
      };
      var Controls = {
        setupButtons,
        setupMenuItems,
        setupContextToolbars
      };
      global2.add("link", function(editor) {
        Controls.setupButtons(editor);
        Controls.setupMenuItems(editor);
        Controls.setupContextToolbars(editor);
        Actions.setupGotoLinks(editor);
        Commands.register(editor);
        Keyboard.setup(editor);
      });
      function Plugin() {
      }
      return Plugin;
    })(window);
  })();
  return plugin$6;
}
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  requirePlugin$6();
  return link;
}
requireLink();
var lists = {};
var plugin$5 = {};
var hasRequiredPlugin$5;
function requirePlugin$5() {
  if (hasRequiredPlugin$5) return plugin$5;
  hasRequiredPlugin$5 = 1;
  (function() {
    (function(domGlobals) {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var global$1 = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils");
      var global$2 = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
      var global$3 = tinymce.util.Tools.resolve("tinymce.util.VK");
      var global$4 = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
      var global$5 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var global$6 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
      var isTextNode = function(node2) {
        return node2 && node2.nodeType === 3;
      };
      var isListNode = function(node2) {
        return node2 && /^(OL|UL|DL)$/.test(node2.nodeName);
      };
      var isOlUlNode = function(node2) {
        return node2 && /^(OL|UL)$/.test(node2.nodeName);
      };
      var isListItemNode = function(node2) {
        return node2 && /^(LI|DT|DD)$/.test(node2.nodeName);
      };
      var isDlItemNode = function(node2) {
        return node2 && /^(DT|DD)$/.test(node2.nodeName);
      };
      var isTableCellNode = function(node2) {
        return node2 && /^(TH|TD)$/.test(node2.nodeName);
      };
      var isBr = function(node2) {
        return node2 && node2.nodeName === "BR";
      };
      var isFirstChild = function(node2) {
        return node2.parentNode.firstChild === node2;
      };
      var isLastChild = function(node2) {
        return node2.parentNode.lastChild === node2;
      };
      var isTextBlock = function(editor, node2) {
        return node2 && !!editor.schema.getTextBlockElements()[node2.nodeName];
      };
      var isBlock2 = function(node2, blockElements2) {
        return node2 && node2.nodeName in blockElements2;
      };
      var isBogusBr = function(dom, node2) {
        if (!isBr(node2)) {
          return false;
        }
        if (dom.isBlock(node2.nextSibling) && !isBr(node2.previousSibling)) {
          return true;
        }
        return false;
      };
      var isEmpty = function(dom, elm, keepBookmarks) {
        var empty2 = dom.isEmpty(elm);
        if (keepBookmarks && dom.select("span[data-mce-type=bookmark]", elm).length > 0) {
          return false;
        }
        return empty2;
      };
      var isChildOfBody = function(dom, elm) {
        return dom.isChildOf(elm, dom.getRoot());
      };
      var NodeType = {
        isTextNode,
        isListNode,
        isOlUlNode,
        isDlItemNode,
        isListItemNode,
        isTableCellNode,
        isBr,
        isFirstChild,
        isLastChild,
        isTextBlock,
        isBlock: isBlock2,
        isBogusBr,
        isEmpty,
        isChildOfBody
      };
      var getNormalizedPoint = function(container, offset) {
        if (NodeType.isTextNode(container)) {
          return {
            container,
            offset
          };
        }
        var node2 = global$1.getNode(container, offset);
        if (NodeType.isTextNode(node2)) {
          return {
            container: node2,
            offset: offset >= container.childNodes.length ? node2.data.length : 0
          };
        } else if (node2.previousSibling && NodeType.isTextNode(node2.previousSibling)) {
          return {
            container: node2.previousSibling,
            offset: node2.previousSibling.data.length
          };
        } else if (node2.nextSibling && NodeType.isTextNode(node2.nextSibling)) {
          return {
            container: node2.nextSibling,
            offset: 0
          };
        }
        return {
          container,
          offset
        };
      };
      var normalizeRange = function(rng) {
        var outRng = rng.cloneRange();
        var rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);
        outRng.setStart(rangeStart.container, rangeStart.offset);
        var rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);
        outRng.setEnd(rangeEnd.container, rangeEnd.offset);
        return outRng;
      };
      var Range = {
        getNormalizedPoint,
        normalizeRange
      };
      var DOM = global$6.DOM;
      var createBookmark = function(rng) {
        var bookmark = {};
        var setupEndPoint = function(start) {
          var offsetNode, container, offset;
          container = rng[start ? "startContainer" : "endContainer"];
          offset = rng[start ? "startOffset" : "endOffset"];
          if (container.nodeType === 1) {
            offsetNode = DOM.create("span", { "data-mce-type": "bookmark" });
            if (container.hasChildNodes()) {
              offset = Math.min(offset, container.childNodes.length - 1);
              if (start) {
                container.insertBefore(offsetNode, container.childNodes[offset]);
              } else {
                DOM.insertAfter(offsetNode, container.childNodes[offset]);
              }
            } else {
              container.appendChild(offsetNode);
            }
            container = offsetNode;
            offset = 0;
          }
          bookmark[start ? "startContainer" : "endContainer"] = container;
          bookmark[start ? "startOffset" : "endOffset"] = offset;
        };
        setupEndPoint(true);
        if (!rng.collapsed) {
          setupEndPoint();
        }
        return bookmark;
      };
      var resolveBookmark = function(bookmark) {
        function restoreEndPoint(start) {
          var container, offset, node2;
          var nodeIndex = function(container2) {
            var node3 = container2.parentNode.firstChild, idx = 0;
            while (node3) {
              if (node3 === container2) {
                return idx;
              }
              if (node3.nodeType !== 1 || node3.getAttribute("data-mce-type") !== "bookmark") {
                idx++;
              }
              node3 = node3.nextSibling;
            }
            return -1;
          };
          container = node2 = bookmark[start ? "startContainer" : "endContainer"];
          offset = bookmark[start ? "startOffset" : "endOffset"];
          if (!container) {
            return;
          }
          if (container.nodeType === 1) {
            offset = nodeIndex(container);
            container = container.parentNode;
            DOM.remove(node2);
            if (!container.hasChildNodes() && DOM.isBlock(container)) {
              container.appendChild(DOM.create("br"));
            }
          }
          bookmark[start ? "startContainer" : "endContainer"] = container;
          bookmark[start ? "startOffset" : "endOffset"] = offset;
        }
        restoreEndPoint(true);
        restoreEndPoint();
        var rng = DOM.createRng();
        rng.setStart(bookmark.startContainer, bookmark.startOffset);
        if (bookmark.endContainer) {
          rng.setEnd(bookmark.endContainer, bookmark.endOffset);
        }
        return Range.normalizeRange(rng);
      };
      var Bookmark = {
        createBookmark,
        resolveBookmark
      };
      var noop = function() {
      };
      var constant = function(value) {
        return function() {
          return value;
        };
      };
      var not2 = function(f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return !f.apply(null, args);
        };
      };
      var never = constant(false);
      var always = constant(true);
      var none = function() {
        return NONE;
      };
      var NONE = (function() {
        var eq2 = function(o) {
          return o.isNone();
        };
        var call = function(thunk) {
          return thunk();
        };
        var id = function(n) {
          return n;
        };
        var me = {
          fold: function(n, s) {
            return n();
          },
          is: never,
          isSome: never,
          isNone: always,
          getOr: id,
          getOrThunk: call,
          getOrDie: function(msg) {
            throw new Error(msg || "error: getOrDie called on none.");
          },
          getOrNull: constant(null),
          getOrUndefined: constant(void 0),
          or: id,
          orThunk: call,
          map: none,
          each: noop,
          bind: none,
          exists: never,
          forall: always,
          filter: none,
          equals: eq2,
          equals_: eq2,
          toArray: function() {
            return [];
          },
          toString: constant("none()")
        };
        if (Object.freeze) {
          Object.freeze(me);
        }
        return me;
      })();
      var some = function(a) {
        var constant_a = constant(a);
        var self2 = function() {
          return me;
        };
        var bind2 = function(f) {
          return f(a);
        };
        var me = {
          fold: function(n, s) {
            return s(a);
          },
          is: function(v) {
            return a === v;
          },
          isSome: always,
          isNone: never,
          getOr: constant_a,
          getOrThunk: constant_a,
          getOrDie: constant_a,
          getOrNull: constant_a,
          getOrUndefined: constant_a,
          or: self2,
          orThunk: self2,
          map: function(f) {
            return some(f(a));
          },
          each: function(f) {
            f(a);
          },
          bind: bind2,
          exists: bind2,
          forall: bind2,
          filter: function(f) {
            return f(a) ? me : NONE;
          },
          toArray: function() {
            return [a];
          },
          toString: function() {
            return "some(" + a + ")";
          },
          equals: function(o) {
            return o.is(a);
          },
          equals_: function(o, elementEq) {
            return o.fold(never, function(b) {
              return elementEq(a, b);
            });
          }
        };
        return me;
      };
      var from = function(value) {
        return value === null || value === void 0 ? NONE : some(value);
      };
      var Option = {
        some,
        none,
        from
      };
      var typeOf = function(x) {
        if (x === null) {
          return "null";
        }
        var t = typeof x;
        if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
          return "array";
        }
        if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
          return "string";
        }
        return t;
      };
      var isType = function(type2) {
        return function(value) {
          return typeOf(value) === type2;
        };
      };
      var isString = isType("string");
      var isArray = isType("array");
      var isBoolean = isType("boolean");
      var isFunction = isType("function");
      var isNumber = isType("number");
      var nativeSlice = Array.prototype.slice;
      var nativePush = Array.prototype.push;
      var map2 = function(xs, f) {
        var len = xs.length;
        var r = new Array(len);
        for (var i = 0; i < len; i++) {
          var x = xs[i];
          r[i] = f(x, i);
        }
        return r;
      };
      var each = function(xs, f) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          f(x, i);
        }
      };
      var filter = function(xs, pred) {
        var r = [];
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            r.push(x);
          }
        }
        return r;
      };
      var groupBy = function(xs, f) {
        if (xs.length === 0) {
          return [];
        } else {
          var wasType = f(xs[0]);
          var r = [];
          var group = [];
          for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            var type2 = f(x);
            if (type2 !== wasType) {
              r.push(group);
              group = [];
            }
            wasType = type2;
            group.push(x);
          }
          if (group.length !== 0) {
            r.push(group);
          }
          return r;
        }
      };
      var foldl = function(xs, f, acc) {
        each(xs, function(x) {
          acc = f(acc, x);
        });
        return acc;
      };
      var find = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return Option.some(x);
          }
        }
        return Option.none();
      };
      var flatten = function(xs) {
        var r = [];
        for (var i = 0, len = xs.length; i < len; ++i) {
          if (!isArray(xs[i])) {
            throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
          }
          nativePush.apply(r, xs[i]);
        }
        return r;
      };
      var bind = function(xs, f) {
        var output2 = map2(xs, f);
        return flatten(output2);
      };
      var reverse = function(xs) {
        var r = nativeSlice.call(xs, 0);
        r.reverse();
        return r;
      };
      var head = function(xs) {
        return xs.length === 0 ? Option.none() : Option.some(xs[0]);
      };
      var last = function(xs) {
        return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
      };
      isFunction(Array.from) ? Array.from : function(x) {
        return nativeSlice.call(x);
      };
      var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
      var path = function(parts, scope) {
        var o = scope !== void 0 && scope !== null ? scope : Global;
        for (var i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
          o = o[parts[i]];
        }
        return o;
      };
      var resolve = function(p, scope) {
        var parts = p.split(".");
        return path(parts, scope);
      };
      var unsafe = function(name2, scope) {
        return resolve(name2, scope);
      };
      var getOrDie = function(name2, scope) {
        var actual = unsafe(name2, scope);
        if (actual === void 0 || actual === null) {
          throw new Error(name2 + " not available on this browser");
        }
        return actual;
      };
      var Global$1 = { getOrDie };
      var htmlElement = function(scope) {
        return Global$1.getOrDie("HTMLElement", scope);
      };
      var isPrototypeOf = function(x) {
        var scope = resolve("ownerDocument.defaultView", x);
        return htmlElement(scope).prototype.isPrototypeOf(x);
      };
      var HTMLElement = { isPrototypeOf };
      var global$7 = tinymce.util.Tools.resolve("tinymce.dom.DomQuery");
      var getParentList = function(editor) {
        var selectionStart = editor.selection.getStart(true);
        return editor.dom.getParent(selectionStart, "OL,UL,DL", getClosestListRootElm(editor, selectionStart));
      };
      var isParentListSelected = function(parentList, selectedBlocks) {
        return parentList && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;
      };
      var findSubLists = function(parentList) {
        return global$5.grep(parentList.querySelectorAll("ol,ul,dl"), function(elm) {
          return NodeType.isListNode(elm);
        });
      };
      var getSelectedSubLists = function(editor) {
        var parentList = getParentList(editor);
        var selectedBlocks = editor.selection.getSelectedBlocks();
        if (isParentListSelected(parentList, selectedBlocks)) {
          return findSubLists(parentList);
        } else {
          return global$5.grep(selectedBlocks, function(elm) {
            return NodeType.isListNode(elm) && parentList !== elm;
          });
        }
      };
      var findParentListItemsNodes = function(editor, elms) {
        var listItemsElms = global$5.map(elms, function(elm) {
          var parentLi = editor.dom.getParent(elm, "li,dd,dt", getClosestListRootElm(editor, elm));
          return parentLi ? parentLi : elm;
        });
        return global$7.unique(listItemsElms);
      };
      var getSelectedListItems = function(editor) {
        var selectedBlocks = editor.selection.getSelectedBlocks();
        return global$5.grep(findParentListItemsNodes(editor, selectedBlocks), function(block2) {
          return NodeType.isListItemNode(block2);
        });
      };
      var getSelectedDlItems = function(editor) {
        return filter(getSelectedListItems(editor), NodeType.isDlItemNode);
      };
      var getClosestListRootElm = function(editor, elm) {
        var parentTableCell = editor.dom.getParents(elm, "TD,TH");
        var root2 = parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();
        return root2;
      };
      var findLastParentListNode = function(editor, elm) {
        var parentLists = editor.dom.getParents(elm, "ol,ul", getClosestListRootElm(editor, elm));
        return last(parentLists);
      };
      var getSelectedLists = function(editor) {
        var firstList = findLastParentListNode(editor, editor.selection.getStart());
        var subsequentLists = filter(editor.selection.getSelectedBlocks(), NodeType.isOlUlNode);
        return firstList.toArray().concat(subsequentLists);
      };
      var getSelectedListRoots = function(editor) {
        var selectedLists = getSelectedLists(editor);
        return getUniqueListRoots(editor, selectedLists);
      };
      var getUniqueListRoots = function(editor, lists2) {
        var listRoots = map2(lists2, function(list2) {
          return findLastParentListNode(editor, list2).getOr(list2);
        });
        return global$7.unique(listRoots);
      };
      var isList = function(editor) {
        var list2 = getParentList(editor);
        return HTMLElement.isPrototypeOf(list2);
      };
      var Selection = {
        isList,
        getParentList,
        getSelectedSubLists,
        getSelectedListItems,
        getClosestListRootElm,
        getSelectedDlItems,
        getSelectedListRoots
      };
      var fromHtml = function(html2, scope) {
        var doc = scope || domGlobals.document;
        var div2 = doc.createElement("div");
        div2.innerHTML = html2;
        if (!div2.hasChildNodes() || div2.childNodes.length > 1) {
          domGlobals.console.error("HTML does not have a single root node", html2);
          throw new Error("HTML must have a single root node");
        }
        return fromDom(div2.childNodes[0]);
      };
      var fromTag = function(tag, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createElement(tag);
        return fromDom(node2);
      };
      var fromText = function(text2, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createTextNode(text2);
        return fromDom(node2);
      };
      var fromDom = function(node2) {
        if (node2 === null || node2 === void 0) {
          throw new Error("Node cannot be null or undefined");
        }
        return { dom: constant(node2) };
      };
      var fromPoint = function(docElm, x, y) {
        var doc = docElm.dom();
        return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
      };
      var Element2 = {
        fromHtml,
        fromTag,
        fromText,
        fromDom,
        fromPoint
      };
      var lift2 = function(oa, ob, f) {
        return oa.isSome() && ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
      };
      var fromElements = function(elements, scope) {
        var doc = domGlobals.document;
        var fragment = doc.createDocumentFragment();
        each(elements, function(element) {
          fragment.appendChild(element.dom());
        });
        return Element2.fromDom(fragment);
      };
      var keys = Object.keys;
      var each$1 = function(obj, f) {
        var props = keys(obj);
        for (var k = 0, len = props.length; k < len; k++) {
          var i = props[k];
          var x = obj[i];
          f(x, i);
        }
      };
      var node = function() {
        var f = Global$1.getOrDie("Node");
        return f;
      };
      var compareDocumentPosition = function(a, b, match) {
        return (a.compareDocumentPosition(b) & match) !== 0;
      };
      var documentPositionPreceding = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
      };
      var documentPositionContainedBy = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
      };
      var Node2 = {
        documentPositionPreceding,
        documentPositionContainedBy
      };
      var cached = function(f) {
        var called = false;
        var r;
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (!called) {
            called = true;
            r = f.apply(null, args);
          }
          return r;
        };
      };
      var firstMatch = function(regexes, s) {
        for (var i = 0; i < regexes.length; i++) {
          var x = regexes[i];
          if (x.test(s)) {
            return x;
          }
        }
        return void 0;
      };
      var find$1 = function(regexes, agent) {
        var r = firstMatch(regexes, agent);
        if (!r) {
          return {
            major: 0,
            minor: 0
          };
        }
        var group = function(i) {
          return Number(agent.replace(r, "$" + i));
        };
        return nu2(group(1), group(2));
      };
      var detect = function(versionRegexes, agent) {
        var cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
          return unknown();
        }
        return find$1(versionRegexes, cleanedAgent);
      };
      var unknown = function() {
        return nu2(0, 0);
      };
      var nu2 = function(major, minor) {
        return {
          major,
          minor
        };
      };
      var Version = {
        nu: nu2,
        detect,
        unknown
      };
      var edge = "Edge";
      var chrome = "Chrome";
      var ie = "IE";
      var opera = "Opera";
      var firefox = "Firefox";
      var safari = "Safari";
      var isBrowser = function(name2, current) {
        return function() {
          return current === name2;
        };
      };
      var unknown$1 = function() {
        return nu$1({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$1 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isEdge: isBrowser(edge, current),
          isChrome: isBrowser(chrome, current),
          isIE: isBrowser(ie, current),
          isOpera: isBrowser(opera, current),
          isFirefox: isBrowser(firefox, current),
          isSafari: isBrowser(safari, current)
        };
      };
      var Browser = {
        unknown: unknown$1,
        nu: nu$1
      };
      var windows = "Windows";
      var ios = "iOS";
      var android = "Android";
      var linux = "Linux";
      var osx = "OSX";
      var solaris = "Solaris";
      var freebsd = "FreeBSD";
      var isOS = function(name2, current) {
        return function() {
          return current === name2;
        };
      };
      var unknown$2 = function() {
        return nu$2({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$2 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isWindows: isOS(windows, current),
          isiOS: isOS(ios, current),
          isAndroid: isOS(android, current),
          isOSX: isOS(osx, current),
          isLinux: isOS(linux, current),
          isSolaris: isOS(solaris, current),
          isFreeBSD: isOS(freebsd, current)
        };
      };
      var OperatingSystem = {
        unknown: unknown$2,
        nu: nu$2
      };
      var DeviceType = function(os, browser2, userAgent) {
        var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        var isiPhone = os.isiOS() && !isiPad;
        var isAndroid3 = os.isAndroid() && os.version.major === 3;
        var isAndroid4 = os.isAndroid() && os.version.major === 4;
        var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent) === true;
        var isTouch = os.isiOS() || os.isAndroid();
        var isPhone = isTouch && !isTablet;
        var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        return {
          isiPad: constant(isiPad),
          isiPhone: constant(isiPhone),
          isTablet: constant(isTablet),
          isPhone: constant(isPhone),
          isTouch: constant(isTouch),
          isAndroid: os.isAndroid,
          isiOS: os.isiOS,
          isWebView: constant(iOSwebview)
        };
      };
      var detect$1 = function(candidates, userAgent) {
        var agent = String(userAgent).toLowerCase();
        return find(candidates, function(candidate) {
          return candidate.search(agent);
        });
      };
      var detectBrowser = function(browsers2, userAgent) {
        return detect$1(browsers2, userAgent).map(function(browser2) {
          var version = Version.detect(browser2.versionRegexes, userAgent);
          return {
            current: browser2.name,
            version
          };
        });
      };
      var detectOs = function(oses2, userAgent) {
        return detect$1(oses2, userAgent).map(function(os) {
          var version = Version.detect(os.versionRegexes, userAgent);
          return {
            current: os.name,
            version
          };
        });
      };
      var UaString = {
        detectBrowser,
        detectOs
      };
      var contains = function(str, substr) {
        return str.indexOf(substr) !== -1;
      };
      var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
      var checkContains = function(target2) {
        return function(uastring) {
          return contains(uastring, target2);
        };
      };
      var browsers = [
        {
          name: "Edge",
          versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
          search: function(uastring) {
            return contains(uastring, "edge/") && contains(uastring, "chrome") && contains(uastring, "safari") && contains(uastring, "applewebkit");
          }
        },
        {
          name: "Chrome",
          versionRegexes: [
            /.*?chrome\/([0-9]+)\.([0-9]+).*/,
            normalVersionRegex
          ],
          search: function(uastring) {
            return contains(uastring, "chrome") && !contains(uastring, "chromeframe");
          }
        },
        {
          name: "IE",
          versionRegexes: [
            /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
            /.*?rv:([0-9]+)\.([0-9]+).*/
          ],
          search: function(uastring) {
            return contains(uastring, "msie") || contains(uastring, "trident");
          }
        },
        {
          name: "Opera",
          versionRegexes: [
            normalVersionRegex,
            /.*?opera\/([0-9]+)\.([0-9]+).*/
          ],
          search: checkContains("opera")
        },
        {
          name: "Firefox",
          versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
          search: checkContains("firefox")
        },
        {
          name: "Safari",
          versionRegexes: [
            normalVersionRegex,
            /.*?cpu os ([0-9]+)_([0-9]+).*/
          ],
          search: function(uastring) {
            return (contains(uastring, "safari") || contains(uastring, "mobile/")) && contains(uastring, "applewebkit");
          }
        }
      ];
      var oses = [
        {
          name: "Windows",
          search: checkContains("win"),
          versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "iOS",
          search: function(uastring) {
            return contains(uastring, "iphone") || contains(uastring, "ipad");
          },
          versionRegexes: [
            /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
            /.*cpu os ([0-9]+)_([0-9]+).*/,
            /.*cpu iphone os ([0-9]+)_([0-9]+).*/
          ]
        },
        {
          name: "Android",
          search: checkContains("android"),
          versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "OSX",
          search: checkContains("os x"),
          versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Linux",
          search: checkContains("linux"),
          versionRegexes: []
        },
        {
          name: "Solaris",
          search: checkContains("sunos"),
          versionRegexes: []
        },
        {
          name: "FreeBSD",
          search: checkContains("freebsd"),
          versionRegexes: []
        }
      ];
      var PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses)
      };
      var detect$2 = function(userAgent) {
        var browsers2 = PlatformInfo.browsers();
        var oses2 = PlatformInfo.oses();
        var browser2 = UaString.detectBrowser(browsers2, userAgent).fold(Browser.unknown, Browser.nu);
        var os = UaString.detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        var deviceType = DeviceType(os, browser2, userAgent);
        return {
          browser: browser2,
          os,
          deviceType
        };
      };
      var PlatformDetection = { detect: detect$2 };
      var detect$3 = cached(function() {
        var userAgent = domGlobals.navigator.userAgent;
        return PlatformDetection.detect(userAgent);
      });
      var PlatformDetection$1 = { detect: detect$3 };
      var ELEMENT = domGlobals.Node.ELEMENT_NODE;
      var ELEMENT$1 = ELEMENT;
      var is2 = function(element, selector) {
        var dom = element.dom();
        if (dom.nodeType !== ELEMENT$1) {
          return false;
        } else {
          var elem = dom;
          if (elem.matches !== void 0) {
            return elem.matches(selector);
          } else if (elem.msMatchesSelector !== void 0) {
            return elem.msMatchesSelector(selector);
          } else if (elem.webkitMatchesSelector !== void 0) {
            return elem.webkitMatchesSelector(selector);
          } else if (elem.mozMatchesSelector !== void 0) {
            return elem.mozMatchesSelector(selector);
          } else {
            throw new Error("Browser lacks native selectors");
          }
        }
      };
      var eq = function(e1, e2) {
        return e1.dom() === e2.dom();
      };
      var regularContains = function(e1, e2) {
        var d1 = e1.dom();
        var d2 = e2.dom();
        return d1 === d2 ? false : d1.contains(d2);
      };
      var ieContains = function(e1, e2) {
        return Node2.documentPositionContainedBy(e1.dom(), e2.dom());
      };
      var browser = PlatformDetection$1.detect().browser;
      var contains$1 = browser.isIE() ? ieContains : regularContains;
      var is$1 = is2;
      var parent = function(element) {
        return Option.from(element.dom().parentNode).map(Element2.fromDom);
      };
      var children = function(element) {
        return map2(element.dom().childNodes, Element2.fromDom);
      };
      var child = function(element, index) {
        var cs = element.dom().childNodes;
        return Option.from(cs[index]).map(Element2.fromDom);
      };
      var firstChild = function(element) {
        return child(element, 0);
      };
      var lastChild = function(element) {
        return child(element, element.dom().childNodes.length - 1);
      };
      var before = function(marker2, element) {
        var parent$1 = parent(marker2);
        parent$1.each(function(v) {
          v.dom().insertBefore(element.dom(), marker2.dom());
        });
      };
      var append = function(parent2, element) {
        parent2.dom().appendChild(element.dom());
      };
      var before$1 = function(marker2, elements) {
        each(elements, function(x) {
          before(marker2, x);
        });
      };
      var append$1 = function(parent2, elements) {
        each(elements, function(x) {
          append(parent2, x);
        });
      };
      var remove2 = function(element) {
        var dom = element.dom();
        if (dom.parentNode !== null) {
          dom.parentNode.removeChild(dom);
        }
      };
      var name = function(element) {
        var r = element.dom().nodeName;
        return r.toLowerCase();
      };
      var type = function(element) {
        return element.dom().nodeType;
      };
      var isType$1 = function(t) {
        return function(element) {
          return type(element) === t;
        };
      };
      var isElement = isType$1(ELEMENT);
      var rawSet = function(dom, key, value) {
        if (isString(value) || isBoolean(value) || isNumber(value)) {
          dom.setAttribute(key, value + "");
        } else {
          domGlobals.console.error("Invalid call to Attr.set. Key ", key, ":: Value ", value, ":: Element ", dom);
          throw new Error("Attribute value was not simple");
        }
      };
      var setAll = function(element, attrs) {
        var dom = element.dom();
        each$1(attrs, function(v, k) {
          rawSet(dom, k, v);
        });
      };
      var clone = function(element) {
        return foldl(element.dom().attributes, function(acc, attr) {
          acc[attr.name] = attr.value;
          return acc;
        }, {});
      };
      var isSupported = function(dom) {
        return dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
      };
      var internalSet = function(dom, property, value) {
        if (!isString(value)) {
          domGlobals.console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value, ":: Element ", dom);
          throw new Error("CSS value must be a string: " + value);
        }
        if (isSupported(dom)) {
          dom.style.setProperty(property, value);
        }
      };
      var set = function(element, property, value) {
        var dom = element.dom();
        internalSet(dom, property, value);
      };
      var clone$1 = function(original, isDeep) {
        return Element2.fromDom(original.dom().cloneNode(isDeep));
      };
      var deep = function(original) {
        return clone$1(original, true);
      };
      var shallowAs = function(original, tag) {
        var nu3 = Element2.fromTag(tag);
        var attributes = clone(original);
        setAll(nu3, attributes);
        return nu3;
      };
      var mutate = function(original, tag) {
        var nu3 = shallowAs(original, tag);
        before(original, nu3);
        var children$1 = children(original);
        append$1(nu3, children$1);
        remove2(original);
        return nu3;
      };
      var joinSegment = function(parent2, child2) {
        append(parent2.item, child2.list);
      };
      var joinSegments = function(segments) {
        for (var i = 1; i < segments.length; i++) {
          joinSegment(segments[i - 1], segments[i]);
        }
      };
      var appendSegments = function(head$1, tail) {
        lift2(last(head$1), head(tail), joinSegment);
      };
      var createSegment = function(scope, listType) {
        var segment = {
          list: Element2.fromTag(listType, scope),
          item: Element2.fromTag("li", scope)
        };
        append(segment.list, segment.item);
        return segment;
      };
      var createSegments = function(scope, entry, size) {
        var segments = [];
        for (var i = 0; i < size; i++) {
          segments.push(createSegment(scope, entry.listType));
        }
        return segments;
      };
      var populateSegments = function(segments, entry) {
        for (var i = 0; i < segments.length - 1; i++) {
          set(segments[i].item, "list-style-type", "none");
        }
        last(segments).each(function(segment) {
          setAll(segment.list, entry.listAttributes);
          setAll(segment.item, entry.itemAttributes);
          append$1(segment.item, entry.content);
        });
      };
      var normalizeSegment = function(segment, entry) {
        if (name(segment.list) !== entry.listType) {
          segment.list = mutate(segment.list, entry.listType);
        }
        setAll(segment.list, entry.listAttributes);
      };
      var createItem = function(scope, attr, content) {
        var item = Element2.fromTag("li", scope);
        setAll(item, attr);
        append$1(item, content);
        return item;
      };
      var appendItem = function(segment, item) {
        append(segment.list, item);
        segment.item = item;
      };
      var writeShallow = function(scope, cast, entry) {
        var newCast = cast.slice(0, entry.depth);
        last(newCast).each(function(segment) {
          var item = createItem(scope, entry.itemAttributes, entry.content);
          appendItem(segment, item);
          normalizeSegment(segment, entry);
        });
        return newCast;
      };
      var writeDeep = function(scope, cast, entry) {
        var segments = createSegments(scope, entry, entry.depth - cast.length);
        joinSegments(segments);
        populateSegments(segments, entry);
        appendSegments(cast, segments);
        return cast.concat(segments);
      };
      var composeList = function(scope, entries) {
        var cast = foldl(entries, function(cast2, entry) {
          return entry.depth > cast2.length ? writeDeep(scope, cast2, entry) : writeShallow(scope, cast2, entry);
        }, []);
        return head(cast).map(function(segment) {
          return segment.list;
        });
      };
      var isList$1 = function(el2) {
        return is$1(el2, "OL,UL");
      };
      var hasFirstChildList = function(el2) {
        return firstChild(el2).map(isList$1).getOr(false);
      };
      var hasLastChildList = function(el2) {
        return lastChild(el2).map(isList$1).getOr(false);
      };
      var isIndented = function(entry) {
        return entry.depth > 0;
      };
      var isSelected = function(entry) {
        return entry.isSelected;
      };
      var cloneItemContent = function(li) {
        var children$1 = children(li);
        var content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;
        return map2(content, deep);
      };
      var createEntry = function(li, depth, isSelected2) {
        return parent(li).filter(isElement).map(function(list2) {
          return {
            depth,
            isSelected: isSelected2,
            content: cloneItemContent(li),
            itemAttributes: clone(li),
            listAttributes: clone(list2),
            listType: name(list2)
          };
        });
      };
      var indentEntry = function(indentation, entry) {
        switch (indentation) {
          case "Indent":
            entry.depth++;
            break;
          case "Outdent":
            entry.depth--;
            break;
          case "Flatten":
            entry.depth = 0;
        }
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var shallow = function(old, nu3) {
        return nu3;
      };
      var baseMerge = function(merger) {
        return function() {
          var objects = new Array(arguments.length);
          for (var i = 0; i < objects.length; i++) {
            objects[i] = arguments[i];
          }
          if (objects.length === 0) {
            throw new Error("Can't merge zero objects");
          }
          var ret = {};
          for (var j = 0; j < objects.length; j++) {
            var curObject = objects[j];
            for (var key in curObject) {
              if (hasOwnProperty.call(curObject, key)) {
                ret[key] = merger(ret[key], curObject[key]);
              }
            }
          }
          return ret;
        };
      };
      var merge = baseMerge(shallow);
      var cloneListProperties = function(target2, source) {
        target2.listType = source.listType;
        target2.listAttributes = merge({}, source.listAttributes);
      };
      var previousSiblingEntry = function(entries, start) {
        var depth = entries[start].depth;
        for (var i = start - 1; i >= 0; i--) {
          if (entries[i].depth === depth) {
            return Option.some(entries[i]);
          }
          if (entries[i].depth < depth) {
            break;
          }
        }
        return Option.none();
      };
      var normalizeEntries = function(entries) {
        each(entries, function(entry, i) {
          previousSiblingEntry(entries, i).each(function(matchingEntry) {
            cloneListProperties(entry, matchingEntry);
          });
        });
      };
      var Cell = function(initial) {
        var value = initial;
        var get2 = function() {
          return value;
        };
        var set2 = function(v) {
          value = v;
        };
        var clone2 = function() {
          return Cell(get2());
        };
        return {
          get: get2,
          set: set2,
          clone: clone2
        };
      };
      var parseItem = function(depth, itemSelection, selectionState, item) {
        return firstChild(item).filter(isList$1).fold(function() {
          itemSelection.each(function(selection) {
            if (eq(selection.start, item)) {
              selectionState.set(true);
            }
          });
          var currentItemEntry = createEntry(item, depth, selectionState.get());
          itemSelection.each(function(selection) {
            if (eq(selection.end, item)) {
              selectionState.set(false);
            }
          });
          var childListEntries = lastChild(item).filter(isList$1).map(function(list2) {
            return parseList(depth, itemSelection, selectionState, list2);
          }).getOr([]);
          return currentItemEntry.toArray().concat(childListEntries);
        }, function(list2) {
          return parseList(depth, itemSelection, selectionState, list2);
        });
      };
      var parseList = function(depth, itemSelection, selectionState, list2) {
        return bind(children(list2), function(element) {
          var parser = isList$1(element) ? parseList : parseItem;
          var newDepth = depth + 1;
          return parser(newDepth, itemSelection, selectionState, element);
        });
      };
      var parseLists = function(lists2, itemSelection) {
        var selectionState = Cell(false);
        var initialDepth = 0;
        return map2(lists2, function(list2) {
          return {
            sourceList: list2,
            entries: parseList(initialDepth, itemSelection, selectionState, list2)
          };
        });
      };
      var global$8 = tinymce.util.Tools.resolve("tinymce.Env");
      var createTextBlock = function(editor, contentNode) {
        var dom = editor.dom;
        var blockElements2 = editor.schema.getBlockElements();
        var fragment = dom.createFragment();
        var node2, textBlock, blockName, hasContentNode;
        if (editor.settings.forced_root_block) {
          blockName = editor.settings.forced_root_block;
        }
        if (blockName) {
          textBlock = dom.create(blockName);
          if (textBlock.tagName === editor.settings.forced_root_block) {
            dom.setAttribs(textBlock, editor.settings.forced_root_block_attrs);
          }
          if (!NodeType.isBlock(contentNode.firstChild, blockElements2)) {
            fragment.appendChild(textBlock);
          }
        }
        if (contentNode) {
          while (node2 = contentNode.firstChild) {
            var nodeName = node2.nodeName;
            if (!hasContentNode && (nodeName !== "SPAN" || node2.getAttribute("data-mce-type") !== "bookmark")) {
              hasContentNode = true;
            }
            if (NodeType.isBlock(node2, blockElements2)) {
              fragment.appendChild(node2);
              textBlock = null;
            } else {
              if (blockName) {
                if (!textBlock) {
                  textBlock = dom.create(blockName);
                  fragment.appendChild(textBlock);
                }
                textBlock.appendChild(node2);
              } else {
                fragment.appendChild(node2);
              }
            }
          }
        }
        if (!editor.settings.forced_root_block) {
          fragment.appendChild(dom.create("br"));
        } else {
          if (!hasContentNode && (!global$8.ie || global$8.ie > 10)) {
            textBlock.appendChild(dom.create("br", { "data-mce-bogus": "1" }));
          }
        }
        return fragment;
      };
      var outdentedComposer = function(editor, entries) {
        return map2(entries, function(entry) {
          var content = fromElements(entry.content);
          return Element2.fromDom(createTextBlock(editor, content.dom()));
        });
      };
      var indentedComposer = function(editor, entries) {
        normalizeEntries(entries);
        return composeList(editor.contentDocument, entries).toArray();
      };
      var composeEntries = function(editor, entries) {
        return bind(groupBy(entries, isIndented), function(entries2) {
          var groupIsIndented = head(entries2).map(isIndented).getOr(false);
          return groupIsIndented ? indentedComposer(editor, entries2) : outdentedComposer(editor, entries2);
        });
      };
      var indentSelectedEntries = function(entries, indentation) {
        each(filter(entries, isSelected), function(entry) {
          return indentEntry(indentation, entry);
        });
      };
      var getItemSelection = function(editor) {
        var selectedListItems = map2(Selection.getSelectedListItems(editor), Element2.fromDom);
        return lift2(find(selectedListItems, not2(hasFirstChildList)), find(reverse(selectedListItems), not2(hasFirstChildList)), function(start, end) {
          return {
            start,
            end
          };
        });
      };
      var listsIndentation = function(editor, lists2, indentation) {
        var entrySets = parseLists(lists2, getItemSelection(editor));
        each(entrySets, function(entrySet) {
          indentSelectedEntries(entrySet.entries, indentation);
          before$1(entrySet.sourceList, composeEntries(editor, entrySet.entries));
          remove2(entrySet.sourceList);
        });
      };
      var DOM$1 = global$6.DOM;
      var splitList = function(editor, ul, li) {
        var tmpRng, fragment, bookmarks, node2, newBlock;
        var removeAndKeepBookmarks = function(targetNode) {
          global$5.each(bookmarks, function(node3) {
            targetNode.parentNode.insertBefore(node3, li.parentNode);
          });
          DOM$1.remove(targetNode);
        };
        bookmarks = DOM$1.select('span[data-mce-type="bookmark"]', ul);
        newBlock = createTextBlock(editor, li);
        tmpRng = DOM$1.createRng();
        tmpRng.setStartAfter(li);
        tmpRng.setEndAfter(ul);
        fragment = tmpRng.extractContents();
        for (node2 = fragment.firstChild; node2; node2 = node2.firstChild) {
          if (node2.nodeName === "LI" && editor.dom.isEmpty(node2)) {
            DOM$1.remove(node2);
            break;
          }
        }
        if (!editor.dom.isEmpty(fragment)) {
          DOM$1.insertAfter(fragment, ul);
        }
        DOM$1.insertAfter(newBlock, ul);
        if (NodeType.isEmpty(editor.dom, li.parentNode)) {
          removeAndKeepBookmarks(li.parentNode);
        }
        DOM$1.remove(li);
        if (NodeType.isEmpty(editor.dom, ul)) {
          DOM$1.remove(ul);
        }
      };
      var SplitList = { splitList };
      var outdentDlItem = function(editor, item) {
        if (is$1(item, "dd")) {
          mutate(item, "dt");
        } else if (is$1(item, "dt")) {
          parent(item).each(function(dl) {
            return SplitList.splitList(editor, dl.dom(), item.dom());
          });
        }
      };
      var indentDlItem = function(item) {
        if (is$1(item, "dt")) {
          mutate(item, "dd");
        }
      };
      var dlIndentation = function(editor, indentation, dlItems) {
        if (indentation === "Indent") {
          each(dlItems, indentDlItem);
        } else {
          each(dlItems, function(item) {
            return outdentDlItem(editor, item);
          });
        }
      };
      var selectionIndentation = function(editor, indentation) {
        var lists2 = map2(Selection.getSelectedListRoots(editor), Element2.fromDom);
        var dlItems = map2(Selection.getSelectedDlItems(editor), Element2.fromDom);
        var isHandled = false;
        if (lists2.length || dlItems.length) {
          var bookmark = editor.selection.getBookmark();
          listsIndentation(editor, lists2, indentation);
          dlIndentation(editor, indentation, dlItems);
          editor.selection.moveToBookmark(bookmark);
          editor.selection.setRng(Range.normalizeRange(editor.selection.getRng()));
          editor.nodeChanged();
          isHandled = true;
        }
        return isHandled;
      };
      var indentListSelection = function(editor) {
        return selectionIndentation(editor, "Indent");
      };
      var outdentListSelection = function(editor) {
        return selectionIndentation(editor, "Outdent");
      };
      var flattenListSelection = function(editor) {
        return selectionIndentation(editor, "Flatten");
      };
      var updateListStyle = function(dom, el2, detail) {
        var type2 = detail["list-style-type"] ? detail["list-style-type"] : null;
        dom.setStyle(el2, "list-style-type", type2);
      };
      var setAttribs = function(elm, attrs) {
        global$5.each(attrs, function(value, key) {
          elm.setAttribute(key, value);
        });
      };
      var updateListAttrs = function(dom, el2, detail) {
        setAttribs(el2, detail["list-attributes"]);
        global$5.each(dom.select("li", el2), function(li) {
          setAttribs(li, detail["list-item-attributes"]);
        });
      };
      var updateListWithDetails = function(dom, el2, detail) {
        updateListStyle(dom, el2, detail);
        updateListAttrs(dom, el2, detail);
      };
      var removeStyles = function(dom, element, styles) {
        global$5.each(styles, function(style) {
          var _a;
          return dom.setStyle(element, (_a = {}, _a[style] = "", _a));
        });
      };
      var getEndPointNode = function(editor, rng, start, root2) {
        var container, offset;
        container = rng[start ? "startContainer" : "endContainer"];
        offset = rng[start ? "startOffset" : "endOffset"];
        if (container.nodeType === 1) {
          container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        }
        if (!start && NodeType.isBr(container.nextSibling)) {
          container = container.nextSibling;
        }
        while (container.parentNode !== root2) {
          if (NodeType.isTextBlock(editor, container)) {
            return container;
          }
          if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {
            return container;
          }
          container = container.parentNode;
        }
        return container;
      };
      var getSelectedTextBlocks = function(editor, rng, root2) {
        var textBlocks = [], dom = editor.dom;
        var startNode = getEndPointNode(editor, rng, true, root2);
        var endNode = getEndPointNode(editor, rng, false, root2);
        var block2;
        var siblings = [];
        for (var node2 = startNode; node2; node2 = node2.nextSibling) {
          siblings.push(node2);
          if (node2 === endNode) {
            break;
          }
        }
        global$5.each(siblings, function(node3) {
          if (NodeType.isTextBlock(editor, node3)) {
            textBlocks.push(node3);
            block2 = null;
            return;
          }
          if (dom.isBlock(node3) || NodeType.isBr(node3)) {
            if (NodeType.isBr(node3)) {
              dom.remove(node3);
            }
            block2 = null;
            return;
          }
          var nextSibling = node3.nextSibling;
          if (global$4.isBookmarkNode(node3)) {
            if (NodeType.isTextBlock(editor, nextSibling) || !nextSibling && node3.parentNode === root2) {
              block2 = null;
              return;
            }
          }
          if (!block2) {
            block2 = dom.create("p");
            node3.parentNode.insertBefore(block2, node3);
            textBlocks.push(block2);
          }
          block2.appendChild(node3);
        });
        return textBlocks;
      };
      var hasCompatibleStyle = function(dom, sib, detail) {
        var sibStyle = dom.getStyle(sib, "list-style-type");
        var detailStyle = detail ? detail["list-style-type"] : "";
        detailStyle = detailStyle === null ? "" : detailStyle;
        return sibStyle === detailStyle;
      };
      var applyList = function(editor, listName, detail) {
        if (detail === void 0) {
          detail = {};
        }
        var rng = editor.selection.getRng(true);
        var bookmark;
        var listItemName = "LI";
        var root2 = Selection.getClosestListRootElm(editor, editor.selection.getStart(true));
        var dom = editor.dom;
        if (dom.getContentEditable(editor.selection.getNode()) === "false") {
          return;
        }
        listName = listName.toUpperCase();
        if (listName === "DL") {
          listItemName = "DT";
        }
        bookmark = Bookmark.createBookmark(rng);
        global$5.each(getSelectedTextBlocks(editor, rng, root2), function(block2) {
          var listBlock, sibling;
          sibling = block2.previousSibling;
          if (sibling && NodeType.isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {
            listBlock = sibling;
            block2 = dom.rename(block2, listItemName);
            sibling.appendChild(block2);
          } else {
            listBlock = dom.create(listName);
            block2.parentNode.insertBefore(listBlock, block2);
            listBlock.appendChild(block2);
            block2 = dom.rename(block2, listItemName);
          }
          removeStyles(dom, block2, [
            "margin",
            "margin-right",
            "margin-bottom",
            "margin-left",
            "margin-top",
            "padding",
            "padding-right",
            "padding-bottom",
            "padding-left",
            "padding-top"
          ]);
          updateListWithDetails(dom, listBlock, detail);
          mergeWithAdjacentLists(editor.dom, listBlock);
        });
        editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
      };
      var isValidLists = function(list1, list2) {
        return list1 && list2 && NodeType.isListNode(list1) && list1.nodeName === list2.nodeName;
      };
      var hasSameListStyle = function(dom, list1, list2) {
        var targetStyle = dom.getStyle(list1, "list-style-type", true);
        var style = dom.getStyle(list2, "list-style-type", true);
        return targetStyle === style;
      };
      var hasSameClasses = function(elm1, elm2) {
        return elm1.className === elm2.className;
      };
      var shouldMerge = function(dom, list1, list2) {
        return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);
      };
      var mergeWithAdjacentLists = function(dom, listBlock) {
        var sibling, node2;
        sibling = listBlock.nextSibling;
        if (shouldMerge(dom, listBlock, sibling)) {
          while (node2 = sibling.firstChild) {
            listBlock.appendChild(node2);
          }
          dom.remove(sibling);
        }
        sibling = listBlock.previousSibling;
        if (shouldMerge(dom, listBlock, sibling)) {
          while (node2 = sibling.lastChild) {
            listBlock.insertBefore(node2, listBlock.firstChild);
          }
          dom.remove(sibling);
        }
      };
      var updateList = function(dom, list2, listName, detail) {
        if (list2.nodeName !== listName) {
          var newList = dom.rename(list2, listName);
          updateListWithDetails(dom, newList, detail);
        } else {
          updateListWithDetails(dom, list2, detail);
        }
      };
      var toggleMultipleLists = function(editor, parentList, lists2, listName, detail) {
        if (parentList.nodeName === listName && !hasListStyleDetail(detail)) {
          flattenListSelection(editor);
        } else {
          var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));
          global$5.each([parentList].concat(lists2), function(elm) {
            updateList(editor.dom, elm, listName, detail);
          });
          editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
        }
      };
      var hasListStyleDetail = function(detail) {
        return "list-style-type" in detail;
      };
      var toggleSingleList = function(editor, parentList, listName, detail) {
        if (parentList === editor.getBody()) {
          return;
        }
        if (parentList) {
          if (parentList.nodeName === listName && !hasListStyleDetail(detail)) {
            flattenListSelection(editor);
          } else {
            var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));
            updateListWithDetails(editor.dom, parentList, detail);
            mergeWithAdjacentLists(editor.dom, editor.dom.rename(parentList, listName));
            editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
          }
        } else {
          applyList(editor, listName, detail);
        }
      };
      var toggleList = function(editor, listName, detail) {
        var parentList = Selection.getParentList(editor);
        var selectedSubLists = Selection.getSelectedSubLists(editor);
        detail = detail ? detail : {};
        if (parentList && selectedSubLists.length > 0) {
          toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);
        } else {
          toggleSingleList(editor, parentList, listName, detail);
        }
      };
      var ToggleList = {
        toggleList,
        mergeWithAdjacentLists
      };
      var DOM$2 = global$6.DOM;
      var normalizeList = function(dom, ul) {
        var sibling;
        var parentNode = ul.parentNode;
        if (parentNode.nodeName === "LI" && parentNode.firstChild === ul) {
          sibling = parentNode.previousSibling;
          if (sibling && sibling.nodeName === "LI") {
            sibling.appendChild(ul);
            if (NodeType.isEmpty(dom, parentNode)) {
              DOM$2.remove(parentNode);
            }
          } else {
            DOM$2.setStyle(parentNode, "listStyleType", "none");
          }
        }
        if (NodeType.isListNode(parentNode)) {
          sibling = parentNode.previousSibling;
          if (sibling && sibling.nodeName === "LI") {
            sibling.appendChild(ul);
          }
        }
      };
      var normalizeLists = function(dom, element) {
        global$5.each(global$5.grep(dom.select("ol,ul", element)), function(ul) {
          normalizeList(dom, ul);
        });
      };
      var NormalizeLists = {
        normalizeList,
        normalizeLists
      };
      var findNextCaretContainer = function(editor, rng, isForward, root2) {
        var node2 = rng.startContainer;
        var offset = rng.startOffset;
        var nonEmptyBlocks, walker;
        if (node2.nodeType === 3 && (isForward ? offset < node2.data.length : offset > 0)) {
          return node2;
        }
        nonEmptyBlocks = editor.schema.getNonEmptyElements();
        if (node2.nodeType === 1) {
          node2 = global$1.getNode(node2, offset);
        }
        walker = new global$2(node2, root2);
        if (isForward) {
          if (NodeType.isBogusBr(editor.dom, node2)) {
            walker.next();
          }
        }
        while (node2 = walker[isForward ? "next" : "prev2"]()) {
          if (node2.nodeName === "LI" && !node2.hasChildNodes()) {
            return node2;
          }
          if (nonEmptyBlocks[node2.nodeName]) {
            return node2;
          }
          if (node2.nodeType === 3 && node2.data.length > 0) {
            return node2;
          }
        }
      };
      var hasOnlyOneBlockChild = function(dom, elm) {
        var childNodes = elm.childNodes;
        return childNodes.length === 1 && !NodeType.isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);
      };
      var unwrapSingleBlockChild = function(dom, elm) {
        if (hasOnlyOneBlockChild(dom, elm)) {
          dom.remove(elm.firstChild, true);
        }
      };
      var moveChildren = function(dom, fromElm, toElm) {
        var node2, targetElm;
        targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;
        unwrapSingleBlockChild(dom, fromElm);
        if (!NodeType.isEmpty(dom, fromElm, true)) {
          while (node2 = fromElm.firstChild) {
            targetElm.appendChild(node2);
          }
        }
      };
      var mergeLiElements = function(dom, fromElm, toElm) {
        var node2, listNode;
        var ul = fromElm.parentNode;
        if (!NodeType.isChildOfBody(dom, fromElm) || !NodeType.isChildOfBody(dom, toElm)) {
          return;
        }
        if (NodeType.isListNode(toElm.lastChild)) {
          listNode = toElm.lastChild;
        }
        if (ul === toElm.lastChild) {
          if (NodeType.isBr(ul.previousSibling)) {
            dom.remove(ul.previousSibling);
          }
        }
        node2 = toElm.lastChild;
        if (node2 && NodeType.isBr(node2) && fromElm.hasChildNodes()) {
          dom.remove(node2);
        }
        if (NodeType.isEmpty(dom, toElm, true)) {
          dom.$(toElm).empty();
        }
        moveChildren(dom, fromElm, toElm);
        if (listNode) {
          toElm.appendChild(listNode);
        }
        var contains2 = contains$1(Element2.fromDom(toElm), Element2.fromDom(fromElm));
        var nestedLists = contains2 ? dom.getParents(fromElm, NodeType.isListNode, toElm) : [];
        dom.remove(fromElm);
        each(nestedLists, function(list2) {
          if (NodeType.isEmpty(dom, list2) && list2 !== dom.getRoot()) {
            dom.remove(list2);
          }
        });
      };
      var mergeIntoEmptyLi = function(editor, fromLi, toLi) {
        editor.dom.$(toLi).empty();
        mergeLiElements(editor.dom, fromLi, toLi);
        editor.selection.setCursorLocation(toLi);
      };
      var mergeForward = function(editor, rng, fromLi, toLi) {
        var dom = editor.dom;
        if (dom.isEmpty(toLi)) {
          mergeIntoEmptyLi(editor, fromLi, toLi);
        } else {
          var bookmark = Bookmark.createBookmark(rng);
          mergeLiElements(dom, fromLi, toLi);
          editor.selection.setRng(Bookmark.resolveBookmark(bookmark));
        }
      };
      var mergeBackward = function(editor, rng, fromLi, toLi) {
        var bookmark = Bookmark.createBookmark(rng);
        mergeLiElements(editor.dom, fromLi, toLi);
        var resolvedBookmark = Bookmark.resolveBookmark(bookmark);
        editor.selection.setRng(resolvedBookmark);
      };
      var backspaceDeleteFromListToListCaret = function(editor, isForward) {
        var dom = editor.dom, selection = editor.selection;
        var selectionStartElm = selection.getStart();
        var root2 = Selection.getClosestListRootElm(editor, selectionStartElm);
        var li = dom.getParent(selection.getStart(), "LI", root2);
        var ul, rng, otherLi;
        if (li) {
          ul = li.parentNode;
          if (ul === editor.getBody() && NodeType.isEmpty(dom, ul)) {
            return true;
          }
          rng = Range.normalizeRange(selection.getRng(true));
          otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root2), "LI", root2);
          if (otherLi && otherLi !== li) {
            if (isForward) {
              mergeForward(editor, rng, otherLi, li);
            } else {
              mergeBackward(editor, rng, li, otherLi);
            }
            return true;
          } else if (!otherLi) {
            if (!isForward) {
              flattenListSelection(editor);
              return true;
            }
          }
        }
        return false;
      };
      var removeBlock = function(dom, block2, root2) {
        var parentBlock = dom.getParent(block2.parentNode, dom.isBlock, root2);
        dom.remove(block2);
        if (parentBlock && dom.isEmpty(parentBlock)) {
          dom.remove(parentBlock);
        }
      };
      var backspaceDeleteIntoListCaret = function(editor, isForward) {
        var dom = editor.dom;
        var selectionStartElm = editor.selection.getStart();
        var root2 = Selection.getClosestListRootElm(editor, selectionStartElm);
        var block2 = dom.getParent(selectionStartElm, dom.isBlock, root2);
        if (block2 && dom.isEmpty(block2)) {
          var rng = Range.normalizeRange(editor.selection.getRng(true));
          var otherLi_1 = dom.getParent(findNextCaretContainer(editor, rng, isForward, root2), "LI", root2);
          if (otherLi_1) {
            editor.undoManager.transact(function() {
              removeBlock(dom, block2, root2);
              ToggleList.mergeWithAdjacentLists(dom, otherLi_1.parentNode);
              editor.selection.select(otherLi_1, true);
              editor.selection.collapse(isForward);
            });
            return true;
          }
        }
        return false;
      };
      var backspaceDeleteCaret = function(editor, isForward) {
        return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);
      };
      var backspaceDeleteRange = function(editor) {
        var selectionStartElm = editor.selection.getStart();
        var root2 = Selection.getClosestListRootElm(editor, selectionStartElm);
        var startListParent = editor.dom.getParent(selectionStartElm, "LI,DT,DD", root2);
        if (startListParent || Selection.getSelectedListItems(editor).length > 0) {
          editor.undoManager.transact(function() {
            editor.execCommand("Delete");
            NormalizeLists.normalizeLists(editor.dom, editor.getBody());
          });
          return true;
        }
        return false;
      };
      var backspaceDelete = function(editor, isForward) {
        return editor.selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor);
      };
      var setup = function(editor) {
        editor.on("keydown", function(e) {
          if (e.keyCode === global$3.BACKSPACE) {
            if (backspaceDelete(editor, false)) {
              e.preventDefault();
            }
          } else if (e.keyCode === global$3.DELETE) {
            if (backspaceDelete(editor, true)) {
              e.preventDefault();
            }
          }
        });
      };
      var Delete = {
        setup,
        backspaceDelete
      };
      var get = function(editor) {
        return {
          backspaceDelete: function(isForward) {
            Delete.backspaceDelete(editor, isForward);
          }
        };
      };
      var Api = { get };
      var queryListCommandState = function(editor, listName) {
        return function() {
          var parentList = editor.dom.getParent(editor.selection.getStart(), "UL,OL,DL");
          return parentList && parentList.nodeName === listName;
        };
      };
      var register = function(editor) {
        editor.on("BeforeExecCommand", function(e) {
          var cmd = e.command.toLowerCase();
          if (cmd === "indent") {
            indentListSelection(editor);
          } else if (cmd === "outdent") {
            outdentListSelection(editor);
          }
        });
        editor.addCommand("InsertUnorderedList", function(ui, detail) {
          ToggleList.toggleList(editor, "UL", detail);
        });
        editor.addCommand("InsertOrderedList", function(ui, detail) {
          ToggleList.toggleList(editor, "OL", detail);
        });
        editor.addCommand("InsertDefinitionList", function(ui, detail) {
          ToggleList.toggleList(editor, "DL", detail);
        });
        editor.addCommand("RemoveList", function() {
          flattenListSelection(editor);
        });
        editor.addQueryStateHandler("InsertUnorderedList", queryListCommandState(editor, "UL"));
        editor.addQueryStateHandler("InsertOrderedList", queryListCommandState(editor, "OL"));
        editor.addQueryStateHandler("InsertDefinitionList", queryListCommandState(editor, "DL"));
      };
      var Commands = { register };
      var shouldIndentOnTab = function(editor) {
        return editor.getParam("lists_indent_on_tab", true);
      };
      var Settings = { shouldIndentOnTab };
      var setupTabKey = function(editor) {
        editor.on("keydown", function(e) {
          if (e.keyCode !== global$3.TAB || global$3.metaKeyPressed(e)) {
            return;
          }
          editor.undoManager.transact(function() {
            if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {
              e.preventDefault();
            }
          });
        });
      };
      var setup$1 = function(editor) {
        if (Settings.shouldIndentOnTab(editor)) {
          setupTabKey(editor);
        }
        Delete.setup(editor);
      };
      var Keyboard = { setup: setup$1 };
      var findIndex = function(list2, predicate) {
        for (var index = 0; index < list2.length; index++) {
          var element = list2[index];
          if (predicate(element)) {
            return index;
          }
        }
        return -1;
      };
      var listState = function(editor, listName) {
        return function(e) {
          var ctrl = e.control;
          editor.on("NodeChange", function(e2) {
            var tableCellIndex = findIndex(e2.parents, NodeType.isTableCellNode);
            var parents = tableCellIndex !== -1 ? e2.parents.slice(0, tableCellIndex) : e2.parents;
            var lists2 = global$5.grep(parents, NodeType.isListNode);
            ctrl.active(lists2.length > 0 && lists2[0].nodeName === listName);
          });
        };
      };
      var register$1 = function(editor) {
        var hasPlugin = function(editor2, plugin2) {
          var plugins = editor2.settings.plugins ? editor2.settings.plugins : "";
          return global$5.inArray(plugins.split(/[ ,]/), plugin2) !== -1;
        };
        if (!hasPlugin(editor, "advlist")) {
          editor.addButton("numlist", {
            active: false,
            title: "Numbered list",
            cmd: "InsertOrderedList",
            onPostRender: listState(editor, "OL")
          });
          editor.addButton("bullist", {
            active: false,
            title: "Bullet list",
            cmd: "InsertUnorderedList",
            onPostRender: listState(editor, "UL")
          });
        }
        editor.addButton("indent", {
          icon: "indent",
          title: "Increase indent",
          cmd: "Indent"
        });
      };
      var Buttons = { register: register$1 };
      global2.add("lists", function(editor) {
        Keyboard.setup(editor);
        Buttons.register(editor);
        Commands.register(editor);
        return Api.get(editor);
      });
      function Plugin() {
      }
      return Plugin;
    })(window);
  })();
  return plugin$5;
}
var hasRequiredLists;
function requireLists() {
  if (hasRequiredLists) return lists;
  hasRequiredLists = 1;
  requirePlugin$5();
  return lists;
}
requireLists();
var table = {};
var plugin$4 = {};
var hasRequiredPlugin$4;
function requirePlugin$4() {
  if (hasRequiredPlugin$4) return plugin$4;
  hasRequiredPlugin$4 = 1;
  (function() {
    (function(domGlobals) {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var noop = function() {
      };
      var compose = function(fa, fb) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return fa(fb.apply(null, args));
        };
      };
      var constant = function(value2) {
        return function() {
          return value2;
        };
      };
      var identity = function(x) {
        return x;
      };
      function curry(fn) {
        var initialArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          initialArgs[_i - 1] = arguments[_i];
        }
        return function() {
          var restArgs = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            restArgs[_i2] = arguments[_i2];
          }
          var all2 = initialArgs.concat(restArgs);
          return fn.apply(null, all2);
        };
      }
      var not2 = function(f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return !f.apply(null, args);
        };
      };
      var die2 = function(msg) {
        return function() {
          throw new Error(msg);
        };
      };
      var never = constant(false);
      var always = constant(true);
      var none = function() {
        return NONE;
      };
      var NONE = (function() {
        var eq2 = function(o) {
          return o.isNone();
        };
        var call = function(thunk) {
          return thunk();
        };
        var id = function(n) {
          return n;
        };
        var me = {
          fold: function(n, s) {
            return n();
          },
          is: never,
          isSome: never,
          isNone: always,
          getOr: id,
          getOrThunk: call,
          getOrDie: function(msg) {
            throw new Error(msg || "error: getOrDie called on none.");
          },
          getOrNull: constant(null),
          getOrUndefined: constant(void 0),
          or: id,
          orThunk: call,
          map: none,
          each: noop,
          bind: none,
          exists: never,
          forall: always,
          filter: none,
          equals: eq2,
          equals_: eq2,
          toArray: function() {
            return [];
          },
          toString: constant("none()")
        };
        if (Object.freeze) {
          Object.freeze(me);
        }
        return me;
      })();
      var some = function(a) {
        var constant_a = constant(a);
        var self2 = function() {
          return me;
        };
        var bind2 = function(f) {
          return f(a);
        };
        var me = {
          fold: function(n, s) {
            return s(a);
          },
          is: function(v) {
            return a === v;
          },
          isSome: always,
          isNone: never,
          getOr: constant_a,
          getOrThunk: constant_a,
          getOrDie: constant_a,
          getOrNull: constant_a,
          getOrUndefined: constant_a,
          or: self2,
          orThunk: self2,
          map: function(f) {
            return some(f(a));
          },
          each: function(f) {
            f(a);
          },
          bind: bind2,
          exists: bind2,
          forall: bind2,
          filter: function(f) {
            return f(a) ? me : NONE;
          },
          toArray: function() {
            return [a];
          },
          toString: function() {
            return "some(" + a + ")";
          },
          equals: function(o) {
            return o.is(a);
          },
          equals_: function(o, elementEq) {
            return o.fold(never, function(b) {
              return elementEq(a, b);
            });
          }
        };
        return me;
      };
      var from = function(value2) {
        return value2 === null || value2 === void 0 ? NONE : some(value2);
      };
      var Option = {
        some,
        none,
        from
      };
      var typeOf = function(x) {
        if (x === null) {
          return "null";
        }
        var t = typeof x;
        if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
          return "array";
        }
        if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
          return "string";
        }
        return t;
      };
      var isType = function(type2) {
        return function(value2) {
          return typeOf(value2) === type2;
        };
      };
      var isString = isType("string");
      var isArray = isType("array");
      var isBoolean = isType("boolean");
      var isFunction = isType("function");
      var isNumber = isType("number");
      var nativeSlice = Array.prototype.slice;
      var nativeIndexOf = Array.prototype.indexOf;
      var nativePush = Array.prototype.push;
      var rawIndexOf = function(ts, t) {
        return nativeIndexOf.call(ts, t);
      };
      var contains = function(xs, x) {
        return rawIndexOf(xs, x) > -1;
      };
      var exists = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return true;
          }
        }
        return false;
      };
      var map2 = function(xs, f) {
        var len = xs.length;
        var r2 = new Array(len);
        for (var i = 0; i < len; i++) {
          var x = xs[i];
          r2[i] = f(x, i);
        }
        return r2;
      };
      var each = function(xs, f) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          f(x, i);
        }
      };
      var eachr = function(xs, f) {
        for (var i = xs.length - 1; i >= 0; i--) {
          var x = xs[i];
          f(x, i);
        }
      };
      var filter = function(xs, pred) {
        var r2 = [];
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            r2.push(x);
          }
        }
        return r2;
      };
      var foldr = function(xs, f, acc) {
        eachr(xs, function(x) {
          acc = f(acc, x);
        });
        return acc;
      };
      var foldl = function(xs, f, acc) {
        each(xs, function(x) {
          acc = f(acc, x);
        });
        return acc;
      };
      var find = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return Option.some(x);
          }
        }
        return Option.none();
      };
      var findIndex = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; i++) {
          var x = xs[i];
          if (pred(x, i)) {
            return Option.some(i);
          }
        }
        return Option.none();
      };
      var flatten = function(xs) {
        var r2 = [];
        for (var i = 0, len = xs.length; i < len; ++i) {
          if (!isArray(xs[i])) {
            throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
          }
          nativePush.apply(r2, xs[i]);
        }
        return r2;
      };
      var bind = function(xs, f) {
        var output2 = map2(xs, f);
        return flatten(output2);
      };
      var forall2 = function(xs, pred) {
        for (var i = 0, len = xs.length; i < len; ++i) {
          var x = xs[i];
          if (pred(x, i) !== true) {
            return false;
          }
        }
        return true;
      };
      var reverse = function(xs) {
        var r2 = nativeSlice.call(xs, 0);
        r2.reverse();
        return r2;
      };
      var last = function(xs) {
        return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
      };
      isFunction(Array.from) ? Array.from : function(x) {
        return nativeSlice.call(x);
      };
      var keys = Object.keys;
      var each$1 = function(obj, f) {
        var props = keys(obj);
        for (var k = 0, len = props.length; k < len; k++) {
          var i = props[k];
          var x = obj[i];
          f(x, i);
        }
      };
      var map$12 = function(obj, f) {
        return tupleMap(obj, function(x, i) {
          return {
            k: i,
            v: f(x, i)
          };
        });
      };
      var tupleMap = function(obj, f) {
        var r2 = {};
        each$1(obj, function(x, i) {
          var tuple = f(x, i);
          r2[tuple.k] = tuple.v;
        });
        return r2;
      };
      var Immutable = function() {
        var fields = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fields[_i] = arguments[_i];
        }
        return function() {
          var values = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            values[_i2] = arguments[_i2];
          }
          if (fields.length !== values.length) {
            throw new Error('Wrong number of arguments to struct. Expected "[' + fields.length + ']", got ' + values.length + " arguments");
          }
          var struct = {};
          each(fields, function(name2, i) {
            struct[name2] = constant(values[i]);
          });
          return struct;
        };
      };
      var sort = function(arr) {
        return arr.slice(0).sort();
      };
      var reqMessage = function(required, keys2) {
        throw new Error("All required keys (" + sort(required).join(", ") + ") were not specified. Specified keys were: " + sort(keys2).join(", ") + ".");
      };
      var unsuppMessage = function(unsupported) {
        throw new Error("Unsupported keys for object: " + sort(unsupported).join(", "));
      };
      var validateStrArr = function(label, array) {
        if (!isArray(array)) {
          throw new Error("The " + label + " fields must be an array. Was: " + array + ".");
        }
        each(array, function(a) {
          if (!isString(a)) {
            throw new Error("The value " + a + " in the " + label + " fields was not a string.");
          }
        });
      };
      var invalidTypeMessage = function(incorrect, type2) {
        throw new Error("All values need to be of type: " + type2 + ". Keys (" + sort(incorrect).join(", ") + ") were not.");
      };
      var checkDupes = function(everything) {
        var sorted = sort(everything);
        var dupe = find(sorted, function(s, i) {
          return i < sorted.length - 1 && s === sorted[i + 1];
        });
        dupe.each(function(d) {
          throw new Error("The field: " + d + " occurs more than once in the combined fields: [" + sorted.join(", ") + "].");
        });
      };
      var MixedBag = function(required, optional) {
        var everything = required.concat(optional);
        if (everything.length === 0) {
          throw new Error("You must specify at least one required or optional field.");
        }
        validateStrArr("required", required);
        validateStrArr("optional", optional);
        checkDupes(everything);
        return function(obj) {
          var keys$1 = keys(obj);
          var allReqd = forall2(required, function(req) {
            return contains(keys$1, req);
          });
          if (!allReqd) {
            reqMessage(required, keys$1);
          }
          var unsupported = filter(keys$1, function(key2) {
            return !contains(everything, key2);
          });
          if (unsupported.length > 0) {
            unsuppMessage(unsupported);
          }
          var r2 = {};
          each(required, function(req) {
            r2[req] = constant(obj[req]);
          });
          each(optional, function(opt) {
            r2[opt] = constant(Object.prototype.hasOwnProperty.call(obj, opt) ? Option.some(obj[opt]) : Option.none());
          });
          return r2;
        };
      };
      var COMMENT = domGlobals.Node.COMMENT_NODE;
      var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
      var ELEMENT = domGlobals.Node.ELEMENT_NODE;
      var TEXT = domGlobals.Node.TEXT_NODE;
      var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
      var path = function(parts, scope) {
        var o = scope !== void 0 && scope !== null ? scope : Global;
        for (var i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
          o = o[parts[i]];
        }
        return o;
      };
      var resolve = function(p, scope) {
        var parts = p.split(".");
        return path(parts, scope);
      };
      var unsafe = function(name2, scope) {
        return resolve(name2, scope);
      };
      var getOrDie = function(name2, scope) {
        var actual = unsafe(name2, scope);
        if (actual === void 0 || actual === null) {
          throw new Error(name2 + " not available on this browser");
        }
        return actual;
      };
      var Global$1 = { getOrDie };
      var name = function(element) {
        var r2 = element.dom().nodeName;
        return r2.toLowerCase();
      };
      var type = function(element) {
        return element.dom().nodeType;
      };
      var isType$1 = function(t) {
        return function(element) {
          return type(element) === t;
        };
      };
      var isComment = function(element) {
        return type(element) === COMMENT || name(element) === "#comment";
      };
      var isElement = isType$1(ELEMENT);
      var isText = isType$1(TEXT);
      var rawSet = function(dom, key2, value2) {
        if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
          dom.setAttribute(key2, value2 + "");
        } else {
          domGlobals.console.error("Invalid call to Attr.set. Key ", key2, ":: Value ", value2, ":: Element ", dom);
          throw new Error("Attribute value was not simple");
        }
      };
      var set = function(element, key2, value2) {
        rawSet(element.dom(), key2, value2);
      };
      var setAll = function(element, attrs) {
        var dom = element.dom();
        each$1(attrs, function(v, k) {
          rawSet(dom, k, v);
        });
      };
      var get = function(element, key2) {
        var v = element.dom().getAttribute(key2);
        return v === null ? void 0 : v;
      };
      var has2 = function(element, key2) {
        var dom = element.dom();
        return dom && dom.hasAttribute ? dom.hasAttribute(key2) : false;
      };
      var remove2 = function(element, key2) {
        element.dom().removeAttribute(key2);
      };
      var clone = function(element) {
        return foldl(element.dom().attributes, function(acc, attr2) {
          acc[attr2.name] = attr2.value;
          return acc;
        }, {});
      };
      var checkRange = function(str, substr, start) {
        if (str.length < substr.length) {
          return false;
        }
        var x = str.substr(start, start + substr.length);
        return x === substr;
      };
      var contains$1 = function(str, substr) {
        return str.indexOf(substr) !== -1;
      };
      var endsWith = function(str, suffix) {
        return checkRange(str, suffix, str.length - suffix.length);
      };
      var trim = function(str) {
        return str.replace(/^\s+|\s+$/g, "");
      };
      var isSupported = function(dom) {
        return dom.style !== void 0 && isFunction(dom.style.getPropertyValue);
      };
      var cached = function(f) {
        var called = false;
        var r2;
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (!called) {
            called = true;
            r2 = f.apply(null, args);
          }
          return r2;
        };
      };
      var fromHtml = function(html2, scope) {
        var doc = scope || domGlobals.document;
        var div2 = doc.createElement("div");
        div2.innerHTML = html2;
        if (!div2.hasChildNodes() || div2.childNodes.length > 1) {
          domGlobals.console.error("HTML does not have a single root node", html2);
          throw new Error("HTML must have a single root node");
        }
        return fromDom(div2.childNodes[0]);
      };
      var fromTag = function(tag, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createElement(tag);
        return fromDom(node2);
      };
      var fromText = function(text2, scope) {
        var doc = scope || domGlobals.document;
        var node2 = doc.createTextNode(text2);
        return fromDom(node2);
      };
      var fromDom = function(node2) {
        if (node2 === null || node2 === void 0) {
          throw new Error("Node cannot be null or undefined");
        }
        return { dom: constant(node2) };
      };
      var fromPoint = function(docElm, x, y) {
        var doc = docElm.dom();
        return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
      };
      var Element2 = {
        fromHtml,
        fromTag,
        fromText,
        fromDom,
        fromPoint
      };
      var inBody = function(element) {
        var dom = isText(element) ? element.dom().parentNode : element.dom();
        return dom !== void 0 && dom !== null && dom.ownerDocument.body.contains(dom);
      };
      var body = cached(function() {
        return getBody(Element2.fromDom(domGlobals.document));
      });
      var getBody = function(doc) {
        var b = doc.dom().body;
        if (b === null || b === void 0) {
          throw new Error("Body is not available yet");
        }
        return Element2.fromDom(b);
      };
      var internalSet = function(dom, property, value2) {
        if (!isString(value2)) {
          domGlobals.console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom);
          throw new Error("CSS value must be a string: " + value2);
        }
        if (isSupported(dom)) {
          dom.style.setProperty(property, value2);
        }
      };
      var internalRemove = function(dom, property) {
        if (isSupported(dom)) {
          dom.style.removeProperty(property);
        }
      };
      var set$1 = function(element, property, value2) {
        var dom = element.dom();
        internalSet(dom, property, value2);
      };
      var setAll$1 = function(element, css3) {
        var dom = element.dom();
        each$1(css3, function(v, k) {
          internalSet(dom, k, v);
        });
      };
      var get$1 = function(element, property) {
        var dom = element.dom();
        var styles2 = domGlobals.window.getComputedStyle(dom);
        var r2 = styles2.getPropertyValue(property);
        var v = r2 === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r2;
        return v === null ? void 0 : v;
      };
      var getUnsafeProperty = function(dom, property) {
        return isSupported(dom) ? dom.style.getPropertyValue(property) : "";
      };
      var getRaw = function(element, property) {
        var dom = element.dom();
        var raw = getUnsafeProperty(dom, property);
        return Option.from(raw).filter(function(r2) {
          return r2.length > 0;
        });
      };
      var remove$1 = function(element, property) {
        var dom = element.dom();
        internalRemove(dom, property);
        if (has2(element, "style") && trim(get(element, "style")) === "") {
          remove2(element, "style");
        }
      };
      var copy2 = function(source, target2) {
        var sourceDom = source.dom();
        var targetDom = target2.dom();
        if (isSupported(sourceDom) && isSupported(targetDom)) {
          targetDom.style.cssText = sourceDom.style.cssText;
        }
      };
      var node = function() {
        var f = Global$1.getOrDie("Node");
        return f;
      };
      var compareDocumentPosition = function(a, b, match) {
        return (a.compareDocumentPosition(b) & match) !== 0;
      };
      var documentPositionPreceding = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
      };
      var documentPositionContainedBy = function(a, b) {
        return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
      };
      var Node2 = {
        documentPositionPreceding,
        documentPositionContainedBy
      };
      var firstMatch = function(regexes, s) {
        for (var i = 0; i < regexes.length; i++) {
          var x = regexes[i];
          if (x.test(s)) {
            return x;
          }
        }
        return void 0;
      };
      var find$1 = function(regexes, agent) {
        var r2 = firstMatch(regexes, agent);
        if (!r2) {
          return {
            major: 0,
            minor: 0
          };
        }
        var group = function(i) {
          return Number(agent.replace(r2, "$" + i));
        };
        return nu2(group(1), group(2));
      };
      var detect = function(versionRegexes, agent) {
        var cleanedAgent = String(agent).toLowerCase();
        if (versionRegexes.length === 0) {
          return unknown();
        }
        return find$1(versionRegexes, cleanedAgent);
      };
      var unknown = function() {
        return nu2(0, 0);
      };
      var nu2 = function(major, minor) {
        return {
          major,
          minor
        };
      };
      var Version = {
        nu: nu2,
        detect,
        unknown
      };
      var edge = "Edge";
      var chrome = "Chrome";
      var ie = "IE";
      var opera = "Opera";
      var firefox = "Firefox";
      var safari = "Safari";
      var isBrowser = function(name2, current) {
        return function() {
          return current === name2;
        };
      };
      var unknown$1 = function() {
        return nu$1({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$1 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isEdge: isBrowser(edge, current),
          isChrome: isBrowser(chrome, current),
          isIE: isBrowser(ie, current),
          isOpera: isBrowser(opera, current),
          isFirefox: isBrowser(firefox, current),
          isSafari: isBrowser(safari, current)
        };
      };
      var Browser = {
        unknown: unknown$1,
        nu: nu$1
      };
      var windows = "Windows";
      var ios = "iOS";
      var android = "Android";
      var linux = "Linux";
      var osx = "OSX";
      var solaris = "Solaris";
      var freebsd = "FreeBSD";
      var isOS = function(name2, current) {
        return function() {
          return current === name2;
        };
      };
      var unknown$2 = function() {
        return nu$2({
          current: void 0,
          version: Version.unknown()
        });
      };
      var nu$2 = function(info) {
        var current = info.current;
        var version = info.version;
        return {
          current,
          version,
          isWindows: isOS(windows, current),
          isiOS: isOS(ios, current),
          isAndroid: isOS(android, current),
          isOSX: isOS(osx, current),
          isLinux: isOS(linux, current),
          isSolaris: isOS(solaris, current),
          isFreeBSD: isOS(freebsd, current)
        };
      };
      var OperatingSystem = {
        unknown: unknown$2,
        nu: nu$2
      };
      var DeviceType = function(os, browser2, userAgent) {
        var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
        var isiPhone = os.isiOS() && !isiPad;
        var isAndroid3 = os.isAndroid() && os.version.major === 3;
        var isAndroid4 = os.isAndroid() && os.version.major === 4;
        var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent) === true;
        var isTouch = os.isiOS() || os.isAndroid();
        var isPhone = isTouch && !isTablet;
        var iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
        return {
          isiPad: constant(isiPad),
          isiPhone: constant(isiPhone),
          isTablet: constant(isTablet),
          isPhone: constant(isPhone),
          isTouch: constant(isTouch),
          isAndroid: os.isAndroid,
          isiOS: os.isiOS,
          isWebView: constant(iOSwebview)
        };
      };
      var detect$1 = function(candidates, userAgent) {
        var agent = String(userAgent).toLowerCase();
        return find(candidates, function(candidate) {
          return candidate.search(agent);
        });
      };
      var detectBrowser = function(browsers2, userAgent) {
        return detect$1(browsers2, userAgent).map(function(browser2) {
          var version = Version.detect(browser2.versionRegexes, userAgent);
          return {
            current: browser2.name,
            version
          };
        });
      };
      var detectOs = function(oses2, userAgent) {
        return detect$1(oses2, userAgent).map(function(os) {
          var version = Version.detect(os.versionRegexes, userAgent);
          return {
            current: os.name,
            version
          };
        });
      };
      var UaString = {
        detectBrowser,
        detectOs
      };
      var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
      var checkContains = function(target2) {
        return function(uastring) {
          return contains$1(uastring, target2);
        };
      };
      var browsers = [
        {
          name: "Edge",
          versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
          search: function(uastring) {
            return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
          }
        },
        {
          name: "Chrome",
          versionRegexes: [
            /.*?chrome\/([0-9]+)\.([0-9]+).*/,
            normalVersionRegex
          ],
          search: function(uastring) {
            return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
          }
        },
        {
          name: "IE",
          versionRegexes: [
            /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
            /.*?rv:([0-9]+)\.([0-9]+).*/
          ],
          search: function(uastring) {
            return contains$1(uastring, "msie") || contains$1(uastring, "trident");
          }
        },
        {
          name: "Opera",
          versionRegexes: [
            normalVersionRegex,
            /.*?opera\/([0-9]+)\.([0-9]+).*/
          ],
          search: checkContains("opera")
        },
        {
          name: "Firefox",
          versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
          search: checkContains("firefox")
        },
        {
          name: "Safari",
          versionRegexes: [
            normalVersionRegex,
            /.*?cpu os ([0-9]+)_([0-9]+).*/
          ],
          search: function(uastring) {
            return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
          }
        }
      ];
      var oses = [
        {
          name: "Windows",
          search: checkContains("win"),
          versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "iOS",
          search: function(uastring) {
            return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
          },
          versionRegexes: [
            /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
            /.*cpu os ([0-9]+)_([0-9]+).*/,
            /.*cpu iphone os ([0-9]+)_([0-9]+).*/
          ]
        },
        {
          name: "Android",
          search: checkContains("android"),
          versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "OSX",
          search: checkContains("os x"),
          versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Linux",
          search: checkContains("linux"),
          versionRegexes: []
        },
        {
          name: "Solaris",
          search: checkContains("sunos"),
          versionRegexes: []
        },
        {
          name: "FreeBSD",
          search: checkContains("freebsd"),
          versionRegexes: []
        }
      ];
      var PlatformInfo = {
        browsers: constant(browsers),
        oses: constant(oses)
      };
      var detect$2 = function(userAgent) {
        var browsers2 = PlatformInfo.browsers();
        var oses2 = PlatformInfo.oses();
        var browser2 = UaString.detectBrowser(browsers2, userAgent).fold(Browser.unknown, Browser.nu);
        var os = UaString.detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
        var deviceType = DeviceType(os, browser2, userAgent);
        return {
          browser: browser2,
          os,
          deviceType
        };
      };
      var PlatformDetection = { detect: detect$2 };
      var detect$3 = cached(function() {
        var userAgent = domGlobals.navigator.userAgent;
        return PlatformDetection.detect(userAgent);
      });
      var PlatformDetection$1 = { detect: detect$3 };
      var ELEMENT$1 = ELEMENT;
      var DOCUMENT$1 = DOCUMENT;
      var is2 = function(element, selector) {
        var dom = element.dom();
        if (dom.nodeType !== ELEMENT$1) {
          return false;
        } else {
          var elem = dom;
          if (elem.matches !== void 0) {
            return elem.matches(selector);
          } else if (elem.msMatchesSelector !== void 0) {
            return elem.msMatchesSelector(selector);
          } else if (elem.webkitMatchesSelector !== void 0) {
            return elem.webkitMatchesSelector(selector);
          } else if (elem.mozMatchesSelector !== void 0) {
            return elem.mozMatchesSelector(selector);
          } else {
            throw new Error("Browser lacks native selectors");
          }
        }
      };
      var bypassSelector = function(dom) {
        return dom.nodeType !== ELEMENT$1 && dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
      };
      var all = function(selector, scope) {
        var base3 = scope === void 0 ? domGlobals.document : scope.dom();
        return bypassSelector(base3) ? [] : map2(base3.querySelectorAll(selector), Element2.fromDom);
      };
      var one = function(selector, scope) {
        var base3 = scope === void 0 ? domGlobals.document : scope.dom();
        return bypassSelector(base3) ? Option.none() : Option.from(base3.querySelector(selector)).map(Element2.fromDom);
      };
      var eq = function(e1, e2) {
        return e1.dom() === e2.dom();
      };
      var regularContains = function(e1, e2) {
        var d1 = e1.dom();
        var d2 = e2.dom();
        return d1 === d2 ? false : d1.contains(d2);
      };
      var ieContains = function(e1, e2) {
        return Node2.documentPositionContainedBy(e1.dom(), e2.dom());
      };
      var browser = PlatformDetection$1.detect().browser;
      var contains$2 = browser.isIE() ? ieContains : regularContains;
      var is$1 = is2;
      var owner = function(element) {
        return Element2.fromDom(element.dom().ownerDocument);
      };
      var defaultView = function(element) {
        return Element2.fromDom(element.dom().ownerDocument.defaultView);
      };
      var parent = function(element) {
        return Option.from(element.dom().parentNode).map(Element2.fromDom);
      };
      var parents = function(element, isRoot) {
        var stop = isFunction(isRoot) ? isRoot : never;
        var dom = element.dom();
        var ret = [];
        while (dom.parentNode !== null && dom.parentNode !== void 0) {
          var rawParent = dom.parentNode;
          var p = Element2.fromDom(rawParent);
          ret.push(p);
          if (stop(p) === true) {
            break;
          } else {
            dom = rawParent;
          }
        }
        return ret;
      };
      var prevSibling = function(element) {
        return Option.from(element.dom().previousSibling).map(Element2.fromDom);
      };
      var nextSibling = function(element) {
        return Option.from(element.dom().nextSibling).map(Element2.fromDom);
      };
      var children = function(element) {
        return map2(element.dom().childNodes, Element2.fromDom);
      };
      var child = function(element, index) {
        var cs = element.dom().childNodes;
        return Option.from(cs[index]).map(Element2.fromDom);
      };
      var firstChild = function(element) {
        return child(element, 0);
      };
      Immutable("element", "offset");
      var before = function(marker2, element) {
        var parent$1 = parent(marker2);
        parent$1.each(function(v) {
          v.dom().insertBefore(element.dom(), marker2.dom());
        });
      };
      var after = function(marker2, element) {
        var sibling = nextSibling(marker2);
        sibling.fold(function() {
          var parent$1 = parent(marker2);
          parent$1.each(function(v) {
            append(v, element);
          });
        }, function(v) {
          before(v, element);
        });
      };
      var prepend = function(parent2, element) {
        var firstChild$1 = firstChild(parent2);
        firstChild$1.fold(function() {
          append(parent2, element);
        }, function(v) {
          parent2.dom().insertBefore(element.dom(), v.dom());
        });
      };
      var append = function(parent2, element) {
        parent2.dom().appendChild(element.dom());
      };
      var wrap = function(element, wrapper) {
        before(element, wrapper);
        append(wrapper, element);
      };
      var before$1 = function(marker2, elements) {
        each(elements, function(x) {
          before(marker2, x);
        });
      };
      var after$1 = function(marker2, elements) {
        each(elements, function(x, i) {
          var e = i === 0 ? marker2 : elements[i - 1];
          after(e, x);
        });
      };
      var append$1 = function(parent2, elements) {
        each(elements, function(x) {
          append(parent2, x);
        });
      };
      var empty2 = function(element) {
        element.dom().textContent = "";
        each(children(element), function(rogue) {
          remove$2(rogue);
        });
      };
      var remove$2 = function(element) {
        var dom = element.dom();
        if (dom.parentNode !== null) {
          dom.parentNode.removeChild(dom);
        }
      };
      var unwrap = function(wrapper) {
        var children$12 = children(wrapper);
        if (children$12.length > 0) {
          before$1(wrapper, children$12);
        }
        remove$2(wrapper);
      };
      Immutable("width", "height");
      Immutable("width", "height");
      var grid = Immutable("rows", "columns");
      var address = Immutable("row", "column");
      Immutable("x", "y");
      var detail = Immutable("element", "rowspan", "colspan");
      var detailnew = Immutable("element", "rowspan", "colspan", "isNew");
      var extended = Immutable("element", "rowspan", "colspan", "row", "column");
      var rowdata = Immutable("element", "cells", "section");
      var elementnew = Immutable("element", "isNew");
      var rowdatanew = Immutable("element", "cells", "section", "isNew");
      var rowcells = Immutable("cells", "section");
      var rowdetails = Immutable("details", "section");
      var bounds = Immutable("startRow", "startCol", "finishRow", "finishCol");
      var ancestors = function(scope, predicate, isRoot) {
        return filter(parents(scope, isRoot), predicate);
      };
      var children$1 = function(scope, predicate) {
        return filter(children(scope), predicate);
      };
      var descendants = function(scope, predicate) {
        var result = [];
        each(children(scope), function(x) {
          if (predicate(x)) {
            result = result.concat([x]);
          }
          result = result.concat(descendants(x, predicate));
        });
        return result;
      };
      var ancestors$1 = function(scope, selector, isRoot) {
        return ancestors(scope, function(e) {
          return is2(e, selector);
        }, isRoot);
      };
      var children$2 = function(scope, selector) {
        return children$1(scope, function(e) {
          return is2(e, selector);
        });
      };
      var descendants$1 = function(scope, selector) {
        return all(selector, scope);
      };
      function ClosestOrAncestor(is3, ancestor2, scope, a, isRoot) {
        return is3(scope, a) ? Option.some(scope) : isFunction(isRoot) && isRoot(scope) ? Option.none() : ancestor2(scope, a, isRoot);
      }
      var ancestor = function(scope, predicate, isRoot) {
        var element = scope.dom();
        var stop = isFunction(isRoot) ? isRoot : constant(false);
        while (element.parentNode) {
          element = element.parentNode;
          var el2 = Element2.fromDom(element);
          if (predicate(el2)) {
            return Option.some(el2);
          } else if (stop(el2)) {
            break;
          }
        }
        return Option.none();
      };
      var closest = function(scope, predicate, isRoot) {
        var is3 = function(s, test) {
          return test(s);
        };
        return ClosestOrAncestor(is3, ancestor, scope, predicate, isRoot);
      };
      var child$1 = function(scope, predicate) {
        var pred = function(node2) {
          return predicate(Element2.fromDom(node2));
        };
        var result = find(scope.dom().childNodes, pred);
        return result.map(Element2.fromDom);
      };
      var descendant = function(scope, predicate) {
        var descend = function(node2) {
          for (var i = 0; i < node2.childNodes.length; i++) {
            var child_1 = Element2.fromDom(node2.childNodes[i]);
            if (predicate(child_1)) {
              return Option.some(child_1);
            }
            var res = descend(node2.childNodes[i]);
            if (res.isSome()) {
              return res;
            }
          }
          return Option.none();
        };
        return descend(scope.dom());
      };
      var ancestor$1 = function(scope, selector, isRoot) {
        return ancestor(scope, function(e) {
          return is2(e, selector);
        }, isRoot);
      };
      var child$2 = function(scope, selector) {
        return child$1(scope, function(e) {
          return is2(e, selector);
        });
      };
      var descendant$1 = function(scope, selector) {
        return one(selector, scope);
      };
      var closest$1 = function(scope, selector, isRoot) {
        return ClosestOrAncestor(is2, ancestor$1, scope, selector, isRoot);
      };
      var firstLayer = function(scope, selector) {
        return filterFirstLayer(scope, selector, constant(true));
      };
      var filterFirstLayer = function(scope, selector, predicate) {
        return bind(children(scope), function(x) {
          return is2(x, selector) ? predicate(x) ? [x] : [] : filterFirstLayer(x, selector, predicate);
        });
      };
      var LayerSelector = {
        firstLayer,
        filterFirstLayer
      };
      var lookup = function(tags, element, isRoot) {
        if (isRoot === void 0) {
          isRoot = never;
        }
        if (isRoot(element)) {
          return Option.none();
        }
        if (contains(tags, name(element))) {
          return Option.some(element);
        }
        var isRootOrUpperTable = function(elm) {
          return is2(elm, "table") || isRoot(elm);
        };
        return ancestor$1(element, tags.join(","), isRootOrUpperTable);
      };
      var cell2 = function(element, isRoot) {
        return lookup([
          "td",
          "th"
        ], element, isRoot);
      };
      var cells = function(ancestor2) {
        return LayerSelector.firstLayer(ancestor2, "th,td");
      };
      var notCell = function(element, isRoot) {
        return lookup([
          "caption",
          "tr",
          "tbody",
          "tfoot",
          "thead"
        ], element, isRoot);
      };
      var neighbours = function(selector, element) {
        return parent(element).map(function(parent2) {
          return children$2(parent2, selector);
        });
      };
      var neighbourCells = curry(neighbours, "th,td");
      var neighbourRows = curry(neighbours, "tr");
      var firstCell = function(ancestor2) {
        return descendant$1(ancestor2, "th,td");
      };
      var table2 = function(element, isRoot) {
        return closest$1(element, "table", isRoot);
      };
      var row = function(element, isRoot) {
        return lookup(["tr"], element, isRoot);
      };
      var rows = function(ancestor2) {
        return LayerSelector.firstLayer(ancestor2, "tr");
      };
      var attr = function(element, property) {
        return parseInt(get(element, property), 10);
      };
      var grid$1 = function(element, rowProp, colProp) {
        var rowsCount = attr(element, rowProp);
        var cols = attr(element, colProp);
        return grid(rowsCount, cols);
      };
      var TableLookup = {
        cell: cell2,
        firstCell,
        cells,
        neighbourCells,
        table: table2,
        row,
        rows,
        notCell,
        neighbourRows,
        attr,
        grid: grid$1
      };
      var fromTable = function(table3) {
        var rows2 = TableLookup.rows(table3);
        return map2(rows2, function(row2) {
          var element = row2;
          var parent$1 = parent(element);
          var parentSection = parent$1.map(function(p) {
            var parentName = name(p);
            return parentName === "tfoot" || parentName === "thead" || parentName === "tbody" ? parentName : "tbody";
          }).getOr("tbody");
          var cells2 = map2(TableLookup.cells(row2), function(cell3) {
            var rowspan = has2(cell3, "rowspan") ? parseInt(get(cell3, "rowspan"), 10) : 1;
            var colspan = has2(cell3, "colspan") ? parseInt(get(cell3, "colspan"), 10) : 1;
            return detail(cell3, rowspan, colspan);
          });
          return rowdata(element, cells2, parentSection);
        });
      };
      var fromPastedRows = function(rows2, example) {
        return map2(rows2, function(row2) {
          var cells2 = map2(TableLookup.cells(row2), function(cell3) {
            var rowspan = has2(cell3, "rowspan") ? parseInt(get(cell3, "rowspan"), 10) : 1;
            var colspan = has2(cell3, "colspan") ? parseInt(get(cell3, "colspan"), 10) : 1;
            return detail(cell3, rowspan, colspan);
          });
          return rowdata(row2, cells2, example.section());
        });
      };
      var DetailsList = {
        fromTable,
        fromPastedRows
      };
      var key = function(row2, column) {
        return row2 + "," + column;
      };
      var getAt = function(warehouse, row2, column) {
        var raw = warehouse.access()[key(row2, column)];
        return raw !== void 0 ? Option.some(raw) : Option.none();
      };
      var findItem = function(warehouse, item, comparator) {
        var filtered = filterItems(warehouse, function(detail2) {
          return comparator(item, detail2.element());
        });
        return filtered.length > 0 ? Option.some(filtered[0]) : Option.none();
      };
      var filterItems = function(warehouse, predicate) {
        var all2 = bind(warehouse.all(), function(r2) {
          return r2.cells();
        });
        return filter(all2, predicate);
      };
      var generate = function(list2) {
        var access = {};
        var cells2 = [];
        var maxRows = list2.length;
        var maxColumns = 0;
        each(list2, function(details, r2) {
          var currentRow = [];
          each(details.cells(), function(detail2) {
            var start = 0;
            while (access[key(r2, start)] !== void 0) {
              start++;
            }
            var current = extended(detail2.element(), detail2.rowspan(), detail2.colspan(), r2, start);
            for (var i = 0; i < detail2.colspan(); i++) {
              for (var j = 0; j < detail2.rowspan(); j++) {
                var cr = r2 + j;
                var cc = start + i;
                var newpos = key(cr, cc);
                access[newpos] = current;
                maxColumns = Math.max(maxColumns, cc + 1);
              }
            }
            currentRow.push(current);
          });
          cells2.push(rowdata(details.element(), currentRow, details.section()));
        });
        var grid$12 = grid(maxRows, maxColumns);
        return {
          grid: constant(grid$12),
          access: constant(access),
          all: constant(cells2)
        };
      };
      var justCells = function(warehouse) {
        var rows2 = map2(warehouse.all(), function(w) {
          return w.cells();
        });
        return flatten(rows2);
      };
      var Warehouse = {
        generate,
        getAt,
        findItem,
        filterItems,
        justCells
      };
      var statsStruct = Immutable("minRow", "minCol", "maxRow", "maxCol");
      var findSelectedStats = function(house, isSelected) {
        var totalColumns = house.grid().columns();
        var totalRows = house.grid().rows();
        var minRow = totalRows;
        var minCol = totalColumns;
        var maxRow = 0;
        var maxCol = 0;
        each$1(house.access(), function(detail2) {
          if (isSelected(detail2)) {
            var startRow = detail2.row();
            var endRow = startRow + detail2.rowspan() - 1;
            var startCol = detail2.column();
            var endCol = startCol + detail2.colspan() - 1;
            if (startRow < minRow) {
              minRow = startRow;
            } else if (endRow > maxRow) {
              maxRow = endRow;
            }
            if (startCol < minCol) {
              minCol = startCol;
            } else if (endCol > maxCol) {
              maxCol = endCol;
            }
          }
        });
        return statsStruct(minRow, minCol, maxRow, maxCol);
      };
      var makeCell = function(list2, seenSelected, rowIndex) {
        var row2 = list2[rowIndex].element();
        var td = Element2.fromTag("td");
        append(td, Element2.fromTag("br"));
        var f = seenSelected ? append : prepend;
        f(row2, td);
      };
      var fillInGaps = function(list2, house, stats, isSelected) {
        var totalColumns = house.grid().columns();
        var totalRows = house.grid().rows();
        for (var i = 0; i < totalRows; i++) {
          var seenSelected = false;
          for (var j = 0; j < totalColumns; j++) {
            if (!(i < stats.minRow() || i > stats.maxRow() || j < stats.minCol() || j > stats.maxCol())) {
              var needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();
              if (needCell) {
                makeCell(list2, seenSelected, i);
              } else {
                seenSelected = true;
              }
            }
          }
        }
      };
      var clean = function(table3, stats) {
        var emptyRows = filter(LayerSelector.firstLayer(table3, "tr"), function(row2) {
          return row2.dom().childElementCount === 0;
        });
        each(emptyRows, remove$2);
        if (stats.minCol() === stats.maxCol() || stats.minRow() === stats.maxRow()) {
          each(LayerSelector.firstLayer(table3, "th,td"), function(cell3) {
            remove2(cell3, "rowspan");
            remove2(cell3, "colspan");
          });
        }
        remove2(table3, "width");
        remove2(table3, "height");
        remove$1(table3, "width");
        remove$1(table3, "height");
      };
      var extract = function(table3, selectedSelector2) {
        var isSelected = function(detail2) {
          return is2(detail2.element(), selectedSelector2);
        };
        var list2 = DetailsList.fromTable(table3);
        var house = Warehouse.generate(list2);
        var stats = findSelectedStats(house, isSelected);
        var selector = "th:not(" + selectedSelector2 + "),td:not(" + selectedSelector2 + ")";
        var unselectedCells = LayerSelector.filterFirstLayer(table3, "th,td", function(cell3) {
          return is2(cell3, selector);
        });
        each(unselectedCells, remove$2);
        fillInGaps(list2, house, stats, isSelected);
        clean(table3, stats);
        return table3;
      };
      var CopySelected = { extract };
      function NodeValue(is3, name2) {
        var get2 = function(element) {
          if (!is3(element)) {
            throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
          }
          return getOption2(element).getOr("");
        };
        var getOption2 = function(element) {
          return is3(element) ? Option.from(element.dom().nodeValue) : Option.none();
        };
        var set2 = function(element, value2) {
          if (!is3(element)) {
            throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
          }
          element.dom().nodeValue = value2;
        };
        return {
          get: get2,
          getOption: getOption2,
          set: set2
        };
      }
      var api = NodeValue(isText, "text");
      var get$2 = function(element) {
        return api.get(element);
      };
      var getOption = function(element) {
        return api.getOption(element);
      };
      var set$2 = function(element, value2) {
        api.set(element, value2);
      };
      var getEnd = function(element) {
        return name(element) === "img" ? 1 : getOption(element).fold(function() {
          return children(element).length;
        }, function(v) {
          return v.length;
        });
      };
      var NBSP = "Â ";
      var isTextNodeWithCursorPosition = function(el2) {
        return getOption(el2).filter(function(text2) {
          return text2.trim().length !== 0 || text2.indexOf(NBSP) > -1;
        }).isSome();
      };
      var elementsWithCursorPosition = [
        "img",
        "br"
      ];
      var isCursorPosition = function(elem) {
        var hasCursorPosition = isTextNodeWithCursorPosition(elem);
        return hasCursorPosition || contains(elementsWithCursorPosition, name(elem));
      };
      var first = function(element) {
        return descendant(element, isCursorPosition);
      };
      var last$1 = function(element) {
        return descendantRtl(element, isCursorPosition);
      };
      var descendantRtl = function(scope, predicate) {
        var descend = function(element) {
          var children$12 = children(element);
          for (var i = children$12.length - 1; i >= 0; i--) {
            var child2 = children$12[i];
            if (predicate(child2)) {
              return Option.some(child2);
            }
            var res = descend(child2);
            if (res.isSome()) {
              return res;
            }
          }
          return Option.none();
        };
        return descend(scope);
      };
      var clone$1 = function(original, isDeep) {
        return Element2.fromDom(original.dom().cloneNode(isDeep));
      };
      var shallow = function(original) {
        return clone$1(original, false);
      };
      var deep = function(original) {
        return clone$1(original, true);
      };
      var shallowAs = function(original, tag) {
        var nu3 = Element2.fromTag(tag);
        var attributes = clone(original);
        setAll(nu3, attributes);
        return nu3;
      };
      var copy$1 = function(original, tag) {
        var nu3 = shallowAs(original, tag);
        var cloneChildren = children(deep(original));
        append$1(nu3, cloneChildren);
        return nu3;
      };
      var createCell = function() {
        var td = Element2.fromTag("td");
        append(td, Element2.fromTag("br"));
        return td;
      };
      var replace = function(cell3, tag, attrs) {
        var replica = copy$1(cell3, tag);
        each$1(attrs, function(v, k) {
          if (v === null) {
            remove2(replica, k);
          } else {
            set(replica, k, v);
          }
        });
        return replica;
      };
      var pasteReplace = function(cell3) {
        return cell3;
      };
      var newRow = function(doc) {
        return function() {
          return Element2.fromTag("tr", doc.dom());
        };
      };
      var cloneFormats = function(oldCell, newCell, formats) {
        var first$1 = first(oldCell);
        return first$1.map(function(firstText) {
          var formatSelector = formats.join(",");
          var parents2 = ancestors$1(firstText, formatSelector, function(element) {
            return eq(element, oldCell);
          });
          return foldr(parents2, function(last2, parent2) {
            var clonedFormat = shallow(parent2);
            remove2(clonedFormat, "contenteditable");
            append(last2, clonedFormat);
            return clonedFormat;
          }, newCell);
        }).getOr(newCell);
      };
      var cellOperations = function(mutate2, doc, formatsToClone) {
        var newCell = function(prev2) {
          var docu = owner(prev2.element());
          var td = Element2.fromTag(name(prev2.element()), docu.dom());
          var formats = formatsToClone.getOr([
            "strong",
            "em",
            "b",
            "i",
            "span",
            "font",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "p",
            "div"
          ]);
          var lastNode = formats.length > 0 ? cloneFormats(prev2.element(), td, formats) : td;
          append(lastNode, Element2.fromTag("br"));
          copy2(prev2.element(), td);
          remove$1(td, "height");
          if (prev2.colspan() !== 1) {
            remove$1(prev2.element(), "width");
          }
          mutate2(prev2.element(), td);
          return td;
        };
        return {
          row: newRow(doc),
          cell: newCell,
          replace,
          gap: createCell
        };
      };
      var paste = function(doc) {
        return {
          row: newRow(doc),
          cell: createCell,
          replace: pasteReplace,
          gap: createCell
        };
      };
      var TableFill = {
        cellOperations,
        paste
      };
      var fromHtml$1 = function(html2, scope) {
        var doc = domGlobals.document;
        var div2 = doc.createElement("div");
        div2.innerHTML = html2;
        return children(Element2.fromDom(div2));
      };
      var inSelection = function(bounds2, detail2) {
        var leftEdge = detail2.column();
        var rightEdge = detail2.column() + detail2.colspan() - 1;
        var topEdge = detail2.row();
        var bottomEdge = detail2.row() + detail2.rowspan() - 1;
        return leftEdge <= bounds2.finishCol() && rightEdge >= bounds2.startCol() && (topEdge <= bounds2.finishRow() && bottomEdge >= bounds2.startRow());
      };
      var isWithin = function(bounds2, detail2) {
        return detail2.column() >= bounds2.startCol() && detail2.column() + detail2.colspan() - 1 <= bounds2.finishCol() && detail2.row() >= bounds2.startRow() && detail2.row() + detail2.rowspan() - 1 <= bounds2.finishRow();
      };
      var isRectangular = function(warehouse, bounds2) {
        var isRect = true;
        var detailIsWithin = curry(isWithin, bounds2);
        for (var i = bounds2.startRow(); i <= bounds2.finishRow(); i++) {
          for (var j = bounds2.startCol(); j <= bounds2.finishCol(); j++) {
            isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
          }
        }
        return isRect ? Option.some(bounds2) : Option.none();
      };
      var CellBounds = {
        inSelection,
        isWithin,
        isRectangular
      };
      var getBounds = function(detailA, detailB) {
        return bounds(Math.min(detailA.row(), detailB.row()), Math.min(detailA.column(), detailB.column()), Math.max(detailA.row() + detailA.rowspan() - 1, detailB.row() + detailB.rowspan() - 1), Math.max(detailA.column() + detailA.colspan() - 1, detailB.column() + detailB.colspan() - 1));
      };
      var getAnyBox = function(warehouse, startCell, finishCell) {
        var startCoords = Warehouse.findItem(warehouse, startCell, eq);
        var finishCoords = Warehouse.findItem(warehouse, finishCell, eq);
        return startCoords.bind(function(sc2) {
          return finishCoords.map(function(fc) {
            return getBounds(sc2, fc);
          });
        });
      };
      var getBox = function(warehouse, startCell, finishCell) {
        return getAnyBox(warehouse, startCell, finishCell).bind(function(bounds2) {
          return CellBounds.isRectangular(warehouse, bounds2);
        });
      };
      var CellGroup = {
        getAnyBox,
        getBox
      };
      var moveBy = function(warehouse, cell3, row2, column) {
        return Warehouse.findItem(warehouse, cell3, eq).bind(function(detail2) {
          var startRow = row2 > 0 ? detail2.row() + detail2.rowspan() - 1 : detail2.row();
          var startCol = column > 0 ? detail2.column() + detail2.colspan() - 1 : detail2.column();
          var dest = Warehouse.getAt(warehouse, startRow + row2, startCol + column);
          return dest.map(function(d) {
            return d.element();
          });
        });
      };
      var intercepts = function(warehouse, start, finish) {
        return CellGroup.getAnyBox(warehouse, start, finish).map(function(bounds2) {
          var inside = Warehouse.filterItems(warehouse, curry(CellBounds.inSelection, bounds2));
          return map2(inside, function(detail2) {
            return detail2.element();
          });
        });
      };
      var parentCell = function(warehouse, innerCell) {
        var isContainedBy = function(c1, c2) {
          return contains$2(c2, c1);
        };
        return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(function(detail2) {
          return detail2.element();
        });
      };
      var CellFinder = {
        moveBy,
        intercepts,
        parentCell
      };
      var moveBy$1 = function(cell3, deltaRow, deltaColumn) {
        return TableLookup.table(cell3).bind(function(table3) {
          var warehouse = getWarehouse(table3);
          return CellFinder.moveBy(warehouse, cell3, deltaRow, deltaColumn);
        });
      };
      var intercepts$1 = function(table3, first2, last2) {
        var warehouse = getWarehouse(table3);
        return CellFinder.intercepts(warehouse, first2, last2);
      };
      var nestedIntercepts = function(table3, first2, firstTable, last2, lastTable) {
        var warehouse = getWarehouse(table3);
        var optStartCell = eq(table3, firstTable) ? Option.some(first2) : CellFinder.parentCell(warehouse, first2);
        var optLastCell = eq(table3, lastTable) ? Option.some(last2) : CellFinder.parentCell(warehouse, last2);
        return optStartCell.bind(function(startCell) {
          return optLastCell.bind(function(lastCell) {
            return CellFinder.intercepts(warehouse, startCell, lastCell);
          });
        });
      };
      var getBox$1 = function(table3, first2, last2) {
        var warehouse = getWarehouse(table3);
        return CellGroup.getBox(warehouse, first2, last2);
      };
      var getWarehouse = function(table3) {
        var list2 = DetailsList.fromTable(table3);
        return Warehouse.generate(list2);
      };
      var TablePositions = {
        moveBy: moveBy$1,
        intercepts: intercepts$1,
        nestedIntercepts,
        getBox: getBox$1
      };
      var TagBoundaries = [
        "body",
        "p",
        "div",
        "article",
        "aside",
        "figcaption",
        "figure",
        "footer",
        "header",
        "nav",
        "section",
        "ol",
        "ul",
        "li",
        "table",
        "thead",
        "tbody",
        "tfoot",
        "caption",
        "tr",
        "td",
        "th",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "blockquote",
        "pre",
        "address"
      ];
      function DomUniverse() {
        var clone$12 = function(element) {
          return Element2.fromDom(element.dom().cloneNode(false));
        };
        var document2 = function(element) {
          return element.dom().ownerDocument;
        };
        var isBoundary = function(element) {
          if (!isElement(element)) {
            return false;
          }
          if (name(element) === "body") {
            return true;
          }
          return contains(TagBoundaries, name(element));
        };
        var isEmptyTag2 = function(element) {
          if (!isElement(element)) {
            return false;
          }
          return contains([
            "br",
            "img",
            "hr",
            "input"
          ], name(element));
        };
        var comparePosition = function(element, other) {
          return element.dom().compareDocumentPosition(other.dom());
        };
        var copyAttributesTo = function(source, destination) {
          var as = clone(source);
          setAll(destination, as);
        };
        return {
          up: constant({
            selector: ancestor$1,
            closest: closest$1,
            predicate: ancestor,
            all: parents
          }),
          down: constant({
            selector: descendants$1,
            predicate: descendants
          }),
          styles: constant({
            get: get$1,
            getRaw,
            set: set$1,
            remove: remove$1
          }),
          attrs: constant({
            get,
            set,
            remove: remove2,
            copyTo: copyAttributesTo
          }),
          insert: constant({
            before,
            after,
            afterAll: after$1,
            append,
            appendAll: append$1,
            prepend,
            wrap
          }),
          remove: constant({
            unwrap,
            remove: remove$2
          }),
          create: constant({
            nu: Element2.fromTag,
            clone: clone$12,
            text: Element2.fromText
          }),
          query: constant({
            comparePosition,
            prevSibling,
            nextSibling
          }),
          property: constant({
            children,
            name,
            parent,
            document: document2,
            isText,
            isComment,
            isElement,
            getText: get$2,
            setText: set$2,
            isBoundary,
            isEmptyTag: isEmptyTag2
          }),
          eq,
          is: is$1
        };
      }
      var leftRight = Immutable("left", "right");
      var brokenPath = Immutable("first", "second", "splits");
      var bisect = function(universe2, parent2, child2) {
        var children2 = universe2.property().children(parent2);
        var index = findIndex(children2, curry(universe2.eq, child2));
        return index.map(function(ind) {
          return {
            before: constant(children2.slice(0, ind)),
            after: constant(children2.slice(ind + 1))
          };
        });
      };
      var breakToRight = function(universe2, parent2, child2) {
        return bisect(universe2, parent2, child2).map(function(parts) {
          var second = universe2.create().clone(parent2);
          universe2.insert().appendAll(second, parts.after());
          universe2.insert().after(parent2, second);
          return leftRight(parent2, second);
        });
      };
      var breakToLeft = function(universe2, parent2, child2) {
        return bisect(universe2, parent2, child2).map(function(parts) {
          var prior = universe2.create().clone(parent2);
          universe2.insert().appendAll(prior, parts.before().concat([child2]));
          universe2.insert().appendAll(parent2, parts.after());
          universe2.insert().before(parent2, prior);
          return leftRight(prior, parent2);
        });
      };
      var breakPath = function(universe2, item, isTop, breaker) {
        var next3 = function(child2, group, splits) {
          var fallback = brokenPath(child2, Option.none(), splits);
          if (isTop(child2)) {
            return brokenPath(child2, group, splits);
          } else {
            return universe2.property().parent(child2).bind(function(parent2) {
              return breaker(universe2, parent2, child2).map(function(breakage) {
                var extra = [{
                  first: breakage.left,
                  second: breakage.right
                }];
                var nextChild = isTop(parent2) ? parent2 : breakage.left();
                return next3(nextChild, Option.some(breakage.right()), splits.concat(extra));
              });
            }).getOr(fallback);
          }
        };
        return next3(item, Option.none(), []);
      };
      var all$1 = function(universe2, look, elements, f) {
        var head = elements[0];
        var tail = elements.slice(1);
        return f(universe2, look, head, tail);
      };
      var oneAll = function(universe2, look, elements) {
        return elements.length > 0 ? all$1(universe2, look, elements, unsafeOne) : Option.none();
      };
      var unsafeOne = function(universe2, look, head, tail) {
        var start = look(universe2, head);
        return foldr(tail, function(b, a) {
          var current = look(universe2, a);
          return commonElement(universe2, b, current);
        }, start);
      };
      var commonElement = function(universe2, start, end) {
        return start.bind(function(s) {
          return end.filter(curry(universe2.eq, s));
        });
      };
      var eq$1 = function(universe2, item) {
        return curry(universe2.eq, item);
      };
      var unsafeSubset = function(universe2, common, ps1, ps2) {
        var children2 = universe2.property().children(common);
        if (universe2.eq(common, ps1[0])) {
          return Option.some([ps1[0]]);
        }
        if (universe2.eq(common, ps2[0])) {
          return Option.some([ps2[0]]);
        }
        var finder = function(ps) {
          var topDown = reverse(ps);
          var index = findIndex(topDown, eq$1(universe2, common)).getOr(-1);
          var item = index < topDown.length - 1 ? topDown[index + 1] : topDown[index];
          return findIndex(children2, eq$1(universe2, item));
        };
        var startIndex = finder(ps1);
        var endIndex = finder(ps2);
        return startIndex.bind(function(sIndex) {
          return endIndex.map(function(eIndex) {
            var first2 = Math.min(sIndex, eIndex);
            var last2 = Math.max(sIndex, eIndex);
            return children2.slice(first2, last2 + 1);
          });
        });
      };
      var ancestors$2 = function(universe2, start, end, isRoot) {
        if (isRoot === void 0) {
          isRoot = never;
        }
        var ps1 = [start].concat(universe2.up().all(start));
        var ps2 = [end].concat(universe2.up().all(end));
        var prune2 = function(path2) {
          var index = findIndex(path2, isRoot);
          return index.fold(function() {
            return path2;
          }, function(ind) {
            return path2.slice(0, ind + 1);
          });
        };
        var pruned1 = prune2(ps1);
        var pruned2 = prune2(ps2);
        var shared = find(pruned1, function(x) {
          return exists(pruned2, eq$1(universe2, x));
        });
        return {
          firstpath: constant(pruned1),
          secondpath: constant(pruned2),
          shared: constant(shared)
        };
      };
      var subset2 = function(universe2, start, end) {
        var ancs = ancestors$2(universe2, start, end);
        return ancs.shared().bind(function(shared) {
          return unsafeSubset(universe2, shared, ancs.firstpath(), ancs.secondpath());
        });
      };
      var SubsetFn = {
        subset: subset2,
        ancestors: ancestors$2
      };
      var sharedOne = oneAll;
      var subset$1 = SubsetFn.subset;
      var ancestors$3 = SubsetFn.ancestors;
      var breakToLeft$1 = breakToLeft;
      var breakToRight$1 = breakToRight;
      var breakPath$1 = breakPath;
      var Parent = {
        sharedOne,
        subset: subset$1,
        ancestors: ancestors$3,
        breakToLeft: breakToLeft$1,
        breakToRight: breakToRight$1,
        breakPath: breakPath$1
      };
      var universe = DomUniverse();
      var sharedOne$1 = function(look, elements) {
        return Parent.sharedOne(universe, function(_universe, element) {
          return look(element);
        }, elements);
      };
      var subset$2 = function(start, finish) {
        return Parent.subset(universe, start, finish);
      };
      var ancestors$4 = function(start, finish, isRoot) {
        return Parent.ancestors(universe, start, finish, isRoot);
      };
      var breakToLeft$2 = function(parent2, child2) {
        return Parent.breakToLeft(universe, parent2, child2);
      };
      var breakToRight$2 = function(parent2, child2) {
        return Parent.breakToRight(universe, parent2, child2);
      };
      var breakPath$2 = function(child2, isTop, breaker) {
        return Parent.breakPath(universe, child2, isTop, function(u, p, c) {
          return breaker(p, c);
        });
      };
      var DomParent = {
        sharedOne: sharedOne$1,
        subset: subset$2,
        ancestors: ancestors$4,
        breakToLeft: breakToLeft$2,
        breakToRight: breakToRight$2,
        breakPath: breakPath$2
      };
      var create = MixedBag([
        "boxes",
        "start",
        "finish"
      ], []);
      var Identified = { create };
      var lookupTable = function(container) {
        return ancestor$1(container, "table");
      };
      var identify = function(start, finish, isRoot) {
        var getIsRoot2 = function(rootTable) {
          return function(element) {
            return isRoot !== void 0 && isRoot(element) || eq(element, rootTable);
          };
        };
        if (eq(start, finish)) {
          return Option.some(Identified.create({
            boxes: Option.some([start]),
            start,
            finish
          }));
        } else {
          return lookupTable(start).bind(function(startTable) {
            return lookupTable(finish).bind(function(finishTable) {
              if (eq(startTable, finishTable)) {
                return Option.some(Identified.create({
                  boxes: TablePositions.intercepts(startTable, start, finish),
                  start,
                  finish
                }));
              } else if (contains$2(startTable, finishTable)) {
                var ancestorCells = ancestors$1(finish, "td,th", getIsRoot2(startTable));
                var finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
                return Option.some(Identified.create({
                  boxes: TablePositions.nestedIntercepts(startTable, start, startTable, finish, finishTable),
                  start,
                  finish: finishCell
                }));
              } else if (contains$2(finishTable, startTable)) {
                var ancestorCells = ancestors$1(start, "td,th", getIsRoot2(finishTable));
                var startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;
                return Option.some(Identified.create({
                  boxes: TablePositions.nestedIntercepts(finishTable, start, startTable, finish, finishTable),
                  start,
                  finish: startCell
                }));
              } else {
                return DomParent.ancestors(start, finish).shared().bind(function(lca) {
                  return closest$1(lca, "table", isRoot).bind(function(lcaTable) {
                    var finishAncestorCells = ancestors$1(finish, "td,th", getIsRoot2(lcaTable));
                    var finishCell2 = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
                    var startAncestorCells = ancestors$1(start, "td,th", getIsRoot2(lcaTable));
                    var startCell2 = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;
                    return Option.some(Identified.create({
                      boxes: TablePositions.nestedIntercepts(lcaTable, start, startTable, finish, finishTable),
                      start: startCell2,
                      finish: finishCell2
                    }));
                  });
                });
              }
            });
          });
        }
      };
      var retrieve = function(container, selector) {
        var sels = descendants$1(container, selector);
        return sels.length > 0 ? Option.some(sels) : Option.none();
      };
      var getLast = function(boxes, lastSelectedSelector2) {
        return find(boxes, function(box) {
          return is2(box, lastSelectedSelector2);
        });
      };
      var getEdges = function(container, firstSelectedSelector2, lastSelectedSelector2) {
        return descendant$1(container, firstSelectedSelector2).bind(function(first2) {
          return descendant$1(container, lastSelectedSelector2).bind(function(last2) {
            return DomParent.sharedOne(lookupTable, [
              first2,
              last2
            ]).map(function(tbl) {
              return {
                first: constant(first2),
                last: constant(last2),
                table: constant(tbl)
              };
            });
          });
        });
      };
      var expandTo = function(finish, firstSelectedSelector2) {
        return ancestor$1(finish, "table").bind(function(table3) {
          return descendant$1(table3, firstSelectedSelector2).bind(function(start) {
            return identify(start, finish).bind(function(identified) {
              return identified.boxes().map(function(boxes) {
                return {
                  boxes: constant(boxes),
                  start: constant(identified.start()),
                  finish: constant(identified.finish())
                };
              });
            });
          });
        });
      };
      var shiftSelection = function(boxes, deltaRow, deltaColumn, firstSelectedSelector2, lastSelectedSelector2) {
        return getLast(boxes, lastSelectedSelector2).bind(function(last2) {
          return TablePositions.moveBy(last2, deltaRow, deltaColumn).bind(function(finish) {
            return expandTo(finish, firstSelectedSelector2);
          });
        });
      };
      var CellSelection = {
        identify,
        retrieve,
        shiftSelection,
        getEdges
      };
      var retrieve$1 = function(container, selector) {
        return CellSelection.retrieve(container, selector);
      };
      var retrieveBox = function(container, firstSelectedSelector2, lastSelectedSelector2) {
        return CellSelection.getEdges(container, firstSelectedSelector2, lastSelectedSelector2).bind(function(edges) {
          var isRoot = function(ancestor2) {
            return eq(container, ancestor2);
          };
          var firstAncestor = ancestor$1(edges.first(), "thead,tfoot,tbody,table", isRoot);
          var lastAncestor = ancestor$1(edges.last(), "thead,tfoot,tbody,table", isRoot);
          return firstAncestor.bind(function(fA) {
            return lastAncestor.bind(function(lA) {
              return eq(fA, lA) ? TablePositions.getBox(edges.table(), edges.first(), edges.last()) : Option.none();
            });
          });
        });
      };
      var TableSelection = {
        retrieve: retrieve$1,
        retrieveBox
      };
      var selected = "data-mce-selected";
      var selectedSelector = "td[" + selected + "],th[" + selected + "]";
      var attributeSelector = "[" + selected + "]";
      var firstSelected = "data-mce-first-selected";
      var firstSelectedSelector = "td[" + firstSelected + "],th[" + firstSelected + "]";
      var lastSelected = "data-mce-last-selected";
      var lastSelectedSelector = "td[" + lastSelected + "],th[" + lastSelected + "]";
      var Ephemera = {
        selected: constant(selected),
        selectedSelector: constant(selectedSelector),
        attributeSelector: constant(attributeSelector),
        firstSelected: constant(firstSelected),
        firstSelectedSelector: constant(firstSelectedSelector),
        lastSelected: constant(lastSelected),
        lastSelectedSelector: constant(lastSelectedSelector)
      };
      var generate$1 = function(cases) {
        if (!isArray(cases)) {
          throw new Error("cases must be an array");
        }
        if (cases.length === 0) {
          throw new Error("there must be at least one case");
        }
        var constructors = [];
        var adt2 = {};
        each(cases, function(acase, count) {
          var keys$1 = keys(acase);
          if (keys$1.length !== 1) {
            throw new Error("one and only one name per case");
          }
          var key2 = keys$1[0];
          var value2 = acase[key2];
          if (adt2[key2] !== void 0) {
            throw new Error("duplicate key detected:" + key2);
          } else if (key2 === "cata") {
            throw new Error("cannot have a case named cata (sorry)");
          } else if (!isArray(value2)) {
            throw new Error("case arguments must be an array");
          }
          constructors.push(key2);
          adt2[key2] = function() {
            var argLength = arguments.length;
            if (argLength !== value2.length) {
              throw new Error("Wrong number of arguments to case " + key2 + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
            }
            var args = new Array(argLength);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            var match = function(branches) {
              var branchKeys = keys(branches);
              if (constructors.length !== branchKeys.length) {
                throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
              }
              var allReqd = forall2(constructors, function(reqKey) {
                return contains(branchKeys, reqKey);
              });
              if (!allReqd) {
                throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
              }
              return branches[key2].apply(null, args);
            };
            return {
              fold: function() {
                if (arguments.length !== cases.length) {
                  throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + arguments.length);
                }
                var target2 = arguments[count];
                return target2.apply(null, args);
              },
              match,
              log: function(label) {
                domGlobals.console.log(label, {
                  constructors,
                  constructor: key2,
                  params: args
                });
              }
            };
          };
        });
        return adt2;
      };
      var Adt = { generate: generate$1 };
      var type$1 = Adt.generate([
        { none: [] },
        { multiple: ["elements"] },
        { single: ["selection"] }
      ]);
      var cata = function(subject, onNone, onMultiple, onSingle) {
        return subject.fold(onNone, onMultiple, onSingle);
      };
      var SelectionTypes = {
        cata,
        none: type$1.none,
        multiple: type$1.multiple,
        single: type$1.single
      };
      var selection = function(cell3, selections) {
        return SelectionTypes.cata(selections.get(), constant([]), identity, constant([cell3]));
      };
      var unmergable = function(cell3, selections) {
        var hasSpan = function(elem) {
          return has2(elem, "rowspan") && parseInt(get(elem, "rowspan"), 10) > 1 || has2(elem, "colspan") && parseInt(get(elem, "colspan"), 10) > 1;
        };
        var candidates = selection(cell3, selections);
        return candidates.length > 0 && forall2(candidates, hasSpan) ? Option.some(candidates) : Option.none();
      };
      var mergable = function(table3, selections) {
        return SelectionTypes.cata(selections.get(), Option.none, function(cells2, _env) {
          if (cells2.length === 0) {
            return Option.none();
          }
          return TableSelection.retrieveBox(table3, Ephemera.firstSelectedSelector(), Ephemera.lastSelectedSelector()).bind(function(bounds2) {
            return cells2.length > 1 ? Option.some({
              bounds: constant(bounds2),
              cells: constant(cells2)
            }) : Option.none();
          });
        }, Option.none);
      };
      var CellOperations = {
        mergable,
        unmergable,
        selection
      };
      var noMenu = function(cell3) {
        return {
          element: constant(cell3),
          mergable: Option.none,
          unmergable: Option.none,
          selection: constant([cell3])
        };
      };
      var forMenu = function(selections, table3, cell3) {
        return {
          element: constant(cell3),
          mergable: constant(CellOperations.mergable(table3, selections)),
          unmergable: constant(CellOperations.unmergable(cell3, selections)),
          selection: constant(CellOperations.selection(cell3, selections))
        };
      };
      var notCell$1 = function(element) {
        return noMenu(element);
      };
      var paste$1 = Immutable("element", "clipboard", "generators");
      var pasteRows = function(selections, table3, cell3, clipboard, generators) {
        return {
          element: constant(cell3),
          mergable: Option.none,
          unmergable: Option.none,
          selection: constant(CellOperations.selection(cell3, selections)),
          clipboard: constant(clipboard),
          generators: constant(generators)
        };
      };
      var TableTargets = {
        noMenu,
        forMenu,
        notCell: notCell$1,
        paste: paste$1,
        pasteRows
      };
      var extractSelected = function(cells2) {
        return TableLookup.table(cells2[0]).map(deep).map(function(replica) {
          return [CopySelected.extract(replica, Ephemera.attributeSelector())];
        });
      };
      var serializeElements = function(editor, elements) {
        return map2(elements, function(elm) {
          return editor.selection.serializer.serialize(elm.dom(), {});
        }).join("");
      };
      var getTextContent = function(elements) {
        return map2(elements, function(element) {
          return element.dom().innerText;
        }).join("");
      };
      var registerEvents = function(editor, selections, actions, cellSelection) {
        editor.on("BeforeGetContent", function(e) {
          var multiCellContext = function(cells2) {
            e.preventDefault();
            extractSelected(cells2).each(function(elements) {
              e.content = e.format === "text" ? getTextContent(elements) : serializeElements(editor, elements);
            });
          };
          if (e.selection === true) {
            SelectionTypes.cata(selections.get(), noop, multiCellContext, noop);
          }
        });
        editor.on("BeforeSetContent", function(e) {
          if (e.selection === true && e.paste === true) {
            var cellOpt = Option.from(editor.dom.getParent(editor.selection.getStart(), "th,td"));
            cellOpt.each(function(domCell) {
              var cell3 = Element2.fromDom(domCell);
              TableLookup.table(cell3).each(function(table3) {
                var elements = filter(fromHtml$1(e.content), function(content) {
                  return name(content) !== "meta";
                });
                if (elements.length === 1 && name(elements[0]) === "table") {
                  e.preventDefault();
                  var doc = Element2.fromDom(editor.getDoc());
                  var generators = TableFill.paste(doc);
                  var targets = TableTargets.paste(cell3, elements[0], generators);
                  actions.pasteCells(table3, targets).each(function(rng) {
                    editor.selection.setRng(rng);
                    editor.focus();
                    cellSelection.clear(table3);
                  });
                }
              });
            });
          }
        });
      };
      var Clipboard = { registerEvents };
      function Dimension(name2, getOffset) {
        var set2 = function(element, h) {
          if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
            throw new Error(name2 + ".set accepts only positive integer values. Value was " + h);
          }
          var dom = element.dom();
          if (isSupported(dom)) {
            dom.style[name2] = h + "px";
          }
        };
        var get2 = function(element) {
          var r2 = getOffset(element);
          if (r2 <= 0 || r2 === null) {
            var css3 = get$1(element, name2);
            return parseFloat(css3) || 0;
          }
          return r2;
        };
        var getOuter2 = get2;
        var aggregate = function(element, properties) {
          return foldl(properties, function(acc, property) {
            var val = get$1(element, property);
            var value2 = val === void 0 ? 0 : parseInt(val, 10);
            return isNaN(value2) ? acc : acc + value2;
          }, 0);
        };
        var max = function(element, value2, properties) {
          var cumulativeInclusions = aggregate(element, properties);
          var absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
          return absoluteMax;
        };
        return {
          set: set2,
          get: get2,
          getOuter: getOuter2,
          aggregate,
          max
        };
      }
      var api$1 = Dimension("height", function(element) {
        var dom = element.dom();
        return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
      });
      var get$3 = function(element) {
        return api$1.get(element);
      };
      var getOuter = function(element) {
        return api$1.getOuter(element);
      };
      var api$2 = Dimension("width", function(element) {
        return element.dom().offsetWidth;
      });
      var get$4 = function(element) {
        return api$2.get(element);
      };
      var getOuter$1 = function(element) {
        return api$2.getOuter(element);
      };
      var platform = PlatformDetection$1.detect();
      var needManualCalc = function() {
        return platform.browser.isIE() || platform.browser.isEdge();
      };
      var toNumber = function(px, fallback) {
        var num2 = parseFloat(px);
        return isNaN(num2) ? fallback : num2;
      };
      var getProp = function(elm, name2, fallback) {
        return toNumber(get$1(elm, name2), fallback);
      };
      var getCalculatedHeight = function(cell3) {
        var paddingTop = getProp(cell3, "padding-top", 0);
        var paddingBottom = getProp(cell3, "padding-bottom", 0);
        var borderTop = getProp(cell3, "border-top-width", 0);
        var borderBottom = getProp(cell3, "border-bottom-width", 0);
        var height2 = cell3.dom().getBoundingClientRect().height;
        var boxSizing = get$1(cell3, "box-sizing");
        var borders = borderTop + borderBottom;
        return boxSizing === "border-box" ? height2 : height2 - paddingTop - paddingBottom - borders;
      };
      var getWidth = function(cell3) {
        return getProp(cell3, "width", get$4(cell3));
      };
      var getHeight = function(cell3) {
        return needManualCalc() ? getCalculatedHeight(cell3) : getProp(cell3, "height", get$3(cell3));
      };
      var RuntimeSize = {
        getWidth,
        getHeight
      };
      var genericSizeRegex = /(\d+(\.\d+)?)(\w|%)*/;
      var percentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
      var pixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
      var setPixelWidth = function(cell3, amount) {
        set$1(cell3, "width", amount + "px");
      };
      var setPercentageWidth = function(cell3, amount) {
        set$1(cell3, "width", amount + "%");
      };
      var setHeight = function(cell3, amount) {
        set$1(cell3, "height", amount + "px");
      };
      var getHeightValue = function(cell3) {
        return getRaw(cell3, "height").getOrThunk(function() {
          return RuntimeSize.getHeight(cell3) + "px";
        });
      };
      var convert = function(cell3, number, getter, setter) {
        var newSize = TableLookup.table(cell3).map(function(table3) {
          var total2 = getter(table3);
          return Math.floor(number / 100 * total2);
        }).getOr(number);
        setter(cell3, newSize);
        return newSize;
      };
      var normalizePixelSize = function(value2, cell3, getter, setter) {
        var number = parseInt(value2, 10);
        return endsWith(value2, "%") && name(cell3) !== "table" ? convert(cell3, number, getter, setter) : number;
      };
      var getTotalHeight = function(cell3) {
        var value2 = getHeightValue(cell3);
        if (!value2) {
          return get$3(cell3);
        }
        return normalizePixelSize(value2, cell3, get$3, setHeight);
      };
      var get$5 = function(cell3, type2, f) {
        var v = f(cell3);
        var span = getSpan(cell3, type2);
        return v / span;
      };
      var getSpan = function(cell3, type2) {
        return has2(cell3, type2) ? parseInt(get(cell3, type2), 10) : 1;
      };
      var getRawWidth = function(element) {
        var cssWidth = getRaw(element, "width");
        return cssWidth.fold(function() {
          return Option.from(get(element, "width"));
        }, function(width) {
          return Option.some(width);
        });
      };
      var normalizePercentageWidth = function(cellWidth, tableSize) {
        return cellWidth / tableSize.pixelWidth() * 100;
      };
      var choosePercentageSize = function(element, width, tableSize) {
        var percentMatch = percentageBasedSizeRegex.exec(width);
        if (percentMatch !== null) {
          return parseFloat(percentMatch[1]);
        } else {
          var intWidth = get$4(element);
          return normalizePercentageWidth(intWidth, tableSize);
        }
      };
      var getPercentageWidth = function(cell3, tableSize) {
        var width = getRawWidth(cell3);
        return width.fold(function() {
          var intWidth = get$4(cell3);
          return normalizePercentageWidth(intWidth, tableSize);
        }, function(w) {
          return choosePercentageSize(cell3, w, tableSize);
        });
      };
      var normalizePixelWidth = function(cellWidth, tableSize) {
        return cellWidth / 100 * tableSize.pixelWidth();
      };
      var choosePixelSize = function(element, width, tableSize) {
        var pixelMatch = pixelBasedSizeRegex.exec(width);
        if (pixelMatch !== null) {
          return parseInt(pixelMatch[1], 10);
        }
        var percentMatch = percentageBasedSizeRegex.exec(width);
        if (percentMatch !== null) {
          var floatWidth = parseFloat(percentMatch[1]);
          return normalizePixelWidth(floatWidth, tableSize);
        }
        return get$4(element);
      };
      var getPixelWidth = function(cell3, tableSize) {
        var width = getRawWidth(cell3);
        return width.fold(function() {
          return get$4(cell3);
        }, function(w) {
          return choosePixelSize(cell3, w, tableSize);
        });
      };
      var getHeight$1 = function(cell3) {
        return get$5(cell3, "rowspan", getTotalHeight);
      };
      var getGenericWidth = function(cell3) {
        var width = getRawWidth(cell3);
        return width.bind(function(w) {
          var match = genericSizeRegex.exec(w);
          if (match !== null) {
            return Option.some({
              width: constant(parseFloat(match[1])),
              unit: constant(match[3])
            });
          } else {
            return Option.none();
          }
        });
      };
      var setGenericWidth = function(cell3, amount, unit) {
        set$1(cell3, "width", amount + unit);
      };
      var Sizes = {
        percentageBasedSizeRegex: constant(percentageBasedSizeRegex),
        pixelBasedSizeRegex: constant(pixelBasedSizeRegex),
        setPixelWidth,
        setPercentageWidth,
        setHeight,
        getPixelWidth,
        getPercentageWidth,
        getGenericWidth,
        setGenericWidth,
        getHeight: getHeight$1,
        getRawWidth
      };
      var halve = function(main, other) {
        var width = Sizes.getGenericWidth(main);
        width.each(function(w) {
          var newWidth = w.width() / 2;
          Sizes.setGenericWidth(main, newWidth, w.unit());
          Sizes.setGenericWidth(other, newWidth, w.unit());
        });
      };
      var CellMutations = { halve };
      var r = function(left2, top2) {
        var translate2 = function(x, y) {
          return r(left2 + x, top2 + y);
        };
        return {
          left: constant(left2),
          top: constant(top2),
          translate: translate2
        };
      };
      var Position = r;
      var boxPosition = function(dom) {
        var box = dom.getBoundingClientRect();
        return Position(box.left, box.top);
      };
      var firstDefinedOrZero = function(a, b) {
        return a !== void 0 ? a : b !== void 0 ? b : 0;
      };
      var absolute = function(element) {
        var doc = element.dom().ownerDocument;
        var body2 = doc.body;
        var win = doc.defaultView;
        var html2 = doc.documentElement;
        var scrollTop = firstDefinedOrZero(win.pageYOffset, html2.scrollTop);
        var scrollLeft = firstDefinedOrZero(win.pageXOffset, html2.scrollLeft);
        var clientTop = firstDefinedOrZero(html2.clientTop, body2.clientTop);
        var clientLeft = firstDefinedOrZero(html2.clientLeft, body2.clientLeft);
        return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
      };
      var viewport = function(element) {
        var dom = element.dom();
        var doc = dom.ownerDocument;
        var body2 = doc.body;
        if (body2 === dom) {
          return Position(body2.offsetLeft, body2.offsetTop);
        }
        if (!inBody(element)) {
          return Position(0, 0);
        }
        return boxPosition(dom);
      };
      var rowInfo = Immutable("row", "y");
      var colInfo = Immutable("col", "x");
      var rtlEdge = function(cell3) {
        var pos = absolute(cell3);
        return pos.left() + getOuter$1(cell3);
      };
      var ltrEdge = function(cell3) {
        return absolute(cell3).left();
      };
      var getLeftEdge = function(index, cell3) {
        return colInfo(index, ltrEdge(cell3));
      };
      var getRightEdge = function(index, cell3) {
        return colInfo(index, rtlEdge(cell3));
      };
      var getTop = function(cell3) {
        return absolute(cell3).top();
      };
      var getTopEdge = function(index, cell3) {
        return rowInfo(index, getTop(cell3));
      };
      var getBottomEdge = function(index, cell3) {
        return rowInfo(index, getTop(cell3) + getOuter(cell3));
      };
      var findPositions = function(getInnerEdge, getOuterEdge, array) {
        if (array.length === 0) {
          return [];
        }
        var lines = map2(array.slice(1), function(cellOption, index) {
          return cellOption.map(function(cell3) {
            return getInnerEdge(index, cell3);
          });
        });
        var lastLine = array[array.length - 1].map(function(cell3) {
          return getOuterEdge(array.length - 1, cell3);
        });
        return lines.concat([lastLine]);
      };
      var negate = function(step) {
        return -step;
      };
      var height = {
        delta: identity,
        positions: function(optElements) {
          return findPositions(getTopEdge, getBottomEdge, optElements);
        },
        edge: getTop
      };
      var ltr = {
        delta: identity,
        edge: ltrEdge,
        positions: function(optElements) {
          return findPositions(getLeftEdge, getRightEdge, optElements);
        }
      };
      var rtl = {
        delta: negate,
        edge: rtlEdge,
        positions: function(optElements) {
          return findPositions(getRightEdge, getLeftEdge, optElements);
        }
      };
      var BarPositions = {
        height,
        rtl,
        ltr
      };
      var ResizeDirection = {
        ltr: BarPositions.ltr,
        rtl: BarPositions.rtl
      };
      function TableDirection(directionAt2) {
        var auto = function(table3) {
          return directionAt2(table3).isRtl() ? ResizeDirection.rtl : ResizeDirection.ltr;
        };
        var delta2 = function(amount, table3) {
          return auto(table3).delta(amount, table3);
        };
        var positions = function(cols, table3) {
          return auto(table3).positions(cols, table3);
        };
        var edge2 = function(cell3) {
          return auto(cell3).edge(cell3);
        };
        return {
          delta: delta2,
          edge: edge2,
          positions
        };
      }
      var getGridSize = function(table3) {
        var input = DetailsList.fromTable(table3);
        var warehouse = Warehouse.generate(input);
        return warehouse.grid();
      };
      var TableGridSize = { getGridSize };
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var cat = function(arr) {
        var r2 = [];
        var push = function(x) {
          r2.push(x);
        };
        for (var i = 0; i < arr.length; i++) {
          arr[i].each(push);
        }
        return r2;
      };
      var findMap = function(arr, f) {
        for (var i = 0; i < arr.length; i++) {
          var r2 = f(arr[i], i);
          if (r2.isSome()) {
            return r2;
          }
        }
        return Option.none();
      };
      var setIfNot = function(element, property, value2, ignore) {
        if (value2 === ignore) {
          remove2(element, property);
        } else {
          set(element, property, value2);
        }
      };
      var render = function(table3, grid2) {
        var newRows = [];
        var newCells = [];
        var renderSection = function(gridSection, sectionName) {
          var section = child$2(table3, sectionName).getOrThunk(function() {
            var tb = Element2.fromTag(sectionName, owner(table3).dom());
            append(table3, tb);
            return tb;
          });
          empty2(section);
          var rows2 = map2(gridSection, function(row2) {
            if (row2.isNew()) {
              newRows.push(row2.element());
            }
            var tr = row2.element();
            empty2(tr);
            each(row2.cells(), function(cell3) {
              if (cell3.isNew()) {
                newCells.push(cell3.element());
              }
              setIfNot(cell3.element(), "colspan", cell3.colspan(), 1);
              setIfNot(cell3.element(), "rowspan", cell3.rowspan(), 1);
              append(tr, cell3.element());
            });
            return tr;
          });
          append$1(section, rows2);
        };
        var removeSection = function(sectionName) {
          child$2(table3, sectionName).each(remove$2);
        };
        var renderOrRemoveSection = function(gridSection, sectionName) {
          if (gridSection.length > 0) {
            renderSection(gridSection, sectionName);
          } else {
            removeSection(sectionName);
          }
        };
        var headSection = [];
        var bodySection = [];
        var footSection = [];
        each(grid2, function(row2) {
          switch (row2.section()) {
            case "thead":
              headSection.push(row2);
              break;
            case "tbody":
              bodySection.push(row2);
              break;
            case "tfoot":
              footSection.push(row2);
              break;
          }
        });
        renderOrRemoveSection(headSection, "thead");
        renderOrRemoveSection(bodySection, "tbody");
        renderOrRemoveSection(footSection, "tfoot");
        return {
          newRows: constant(newRows),
          newCells: constant(newCells)
        };
      };
      var copy$2 = function(grid2) {
        var rows2 = map2(grid2, function(row2) {
          var tr = shallow(row2.element());
          each(row2.cells(), function(cell3) {
            var clonedCell = deep(cell3.element());
            setIfNot(clonedCell, "colspan", cell3.colspan(), 1);
            setIfNot(clonedCell, "rowspan", cell3.rowspan(), 1);
            append(tr, clonedCell);
          });
          return tr;
        });
        return rows2;
      };
      var Redraw = {
        render,
        copy: copy$2
      };
      var read = function(element, attr2) {
        var value2 = get(element, attr2);
        return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
      };
      var add = function(element, attr2, id) {
        var old = read(element, attr2);
        var nu3 = old.concat([id]);
        set(element, attr2, nu3.join(" "));
        return true;
      };
      var remove$3 = function(element, attr2, id) {
        var nu3 = filter(read(element, attr2), function(v) {
          return v !== id;
        });
        if (nu3.length > 0) {
          set(element, attr2, nu3.join(" "));
        } else {
          remove2(element, attr2);
        }
        return false;
      };
      var supports = function(element) {
        return element.dom().classList !== void 0;
      };
      var get$6 = function(element) {
        return read(element, "class");
      };
      var add$1 = function(element, clazz) {
        return add(element, "class", clazz);
      };
      var remove$4 = function(element, clazz) {
        return remove$3(element, "class", clazz);
      };
      var add$2 = function(element, clazz) {
        if (supports(element)) {
          element.dom().classList.add(clazz);
        } else {
          add$1(element, clazz);
        }
      };
      var cleanClass = function(element) {
        var classList = supports(element) ? element.dom().classList : get$6(element);
        if (classList.length === 0) {
          remove2(element, "class");
        }
      };
      var remove$5 = function(element, clazz) {
        if (supports(element)) {
          var classList = element.dom().classList;
          classList.remove(clazz);
        } else {
          remove$4(element, clazz);
        }
        cleanClass(element);
      };
      var has$1 = function(element, clazz) {
        return supports(element) && element.dom().classList.contains(clazz);
      };
      var repeat2 = function(repititions, f) {
        var r2 = [];
        for (var i = 0; i < repititions; i++) {
          r2.push(f(i));
        }
        return r2;
      };
      var range2 = function(start, end) {
        var r2 = [];
        for (var i = start; i < end; i++) {
          r2.push(i);
        }
        return r2;
      };
      var deduce = function(xs, index) {
        if (index < 0 || index >= xs.length - 1) {
          return Option.none();
        }
        var current = xs[index].fold(function() {
          var rest = reverse(xs.slice(0, index));
          return findMap(rest, function(a, i) {
            return a.map(function(aa) {
              return {
                value: aa,
                delta: i + 1
              };
            });
          });
        }, function(c) {
          return Option.some({
            value: c,
            delta: 0
          });
        });
        var next3 = xs[index + 1].fold(function() {
          var rest = xs.slice(index + 1);
          return findMap(rest, function(a, i) {
            return a.map(function(aa) {
              return {
                value: aa,
                delta: i + 1
              };
            });
          });
        }, function(n) {
          return Option.some({
            value: n,
            delta: 1
          });
        });
        return current.bind(function(c) {
          return next3.map(function(n) {
            var extras = n.delta + c.delta;
            return Math.abs(n.value - c.value) / extras;
          });
        });
      };
      var columns = function(warehouse) {
        var grid2 = warehouse.grid();
        var cols = range2(0, grid2.columns());
        var rowsArr = range2(0, grid2.rows());
        return map2(cols, function(col2) {
          var getBlock = function() {
            return bind(rowsArr, function(r2) {
              return Warehouse.getAt(warehouse, r2, col2).filter(function(detail2) {
                return detail2.column() === col2;
              }).fold(constant([]), function(detail2) {
                return [detail2];
              });
            });
          };
          var isSingle = function(detail2) {
            return detail2.colspan() === 1;
          };
          var getFallback = function() {
            return Warehouse.getAt(warehouse, 0, col2);
          };
          return decide(getBlock, isSingle, getFallback);
        });
      };
      var decide = function(getBlock, isSingle, getFallback) {
        var inBlock = getBlock();
        var singleInBlock = find(inBlock, isSingle);
        var detailOption = singleInBlock.orThunk(function() {
          return Option.from(inBlock[0]).orThunk(getFallback);
        });
        return detailOption.map(function(detail2) {
          return detail2.element();
        });
      };
      var rows$1 = function(warehouse) {
        var grid2 = warehouse.grid();
        var rowsArr = range2(0, grid2.rows());
        var cols = range2(0, grid2.columns());
        return map2(rowsArr, function(row2) {
          var getBlock = function() {
            return bind(cols, function(c) {
              return Warehouse.getAt(warehouse, row2, c).filter(function(detail2) {
                return detail2.row() === row2;
              }).fold(constant([]), function(detail2) {
                return [detail2];
              });
            });
          };
          var isSingle = function(detail2) {
            return detail2.rowspan() === 1;
          };
          var getFallback = function() {
            return Warehouse.getAt(warehouse, row2, 0);
          };
          return decide(getBlock, isSingle, getFallback);
        });
      };
      var Blocks = {
        columns,
        rows: rows$1
      };
      var css2 = function(namespace) {
        var dashNamespace = namespace.replace(/\./g, "-");
        var resolve2 = function(str) {
          return dashNamespace + "-" + str;
        };
        return { resolve: resolve2 };
      };
      var styles = css2("ephox-snooker");
      var Styles = { resolve: styles.resolve };
      var col = function(column, x, y, w, h) {
        var blocker = Element2.fromTag("div");
        setAll$1(blocker, {
          position: "absolute",
          left: x - w / 2 + "px",
          top: y + "px",
          height: h + "px",
          width: w + "px"
        });
        setAll(blocker, {
          "data-column": column,
          "role": "presentation"
        });
        return blocker;
      };
      var row$1 = function(r2, x, y, w, h) {
        var blocker = Element2.fromTag("div");
        setAll$1(blocker, {
          position: "absolute",
          left: x + "px",
          top: y - h / 2 + "px",
          height: h + "px",
          width: w + "px"
        });
        setAll(blocker, {
          "data-row": r2,
          "role": "presentation"
        });
        return blocker;
      };
      var Bar = {
        col,
        row: row$1
      };
      var resizeBar = Styles.resolve("resizer-bar");
      var resizeRowBar = Styles.resolve("resizer-rows");
      var resizeColBar = Styles.resolve("resizer-cols");
      var BAR_THICKNESS = 7;
      var destroy = function(wire) {
        var previous = descendants$1(wire.parent(), "." + resizeBar);
        each(previous, remove$2);
      };
      var drawBar = function(wire, positions, create2) {
        var origin = wire.origin();
        each(positions, function(cpOption, i) {
          cpOption.each(function(cp) {
            var bar = create2(origin, cp);
            add$2(bar, resizeBar);
            append(wire.parent(), bar);
          });
        });
      };
      var refreshCol = function(wire, colPositions, position, tableHeight) {
        drawBar(wire, colPositions, function(origin, cp) {
          var colBar = Bar.col(cp.col(), cp.x() - origin.left(), position.top() - origin.top(), BAR_THICKNESS, tableHeight);
          add$2(colBar, resizeColBar);
          return colBar;
        });
      };
      var refreshRow = function(wire, rowPositions, position, tableWidth) {
        drawBar(wire, rowPositions, function(origin, cp) {
          var rowBar = Bar.row(cp.row(), position.left() - origin.left(), cp.y() - origin.top(), tableWidth, BAR_THICKNESS);
          add$2(rowBar, resizeRowBar);
          return rowBar;
        });
      };
      var refreshGrid = function(wire, table3, rows2, cols, hdirection, vdirection) {
        var position = absolute(table3);
        var rowPositions = rows2.length > 0 ? hdirection.positions(rows2, table3) : [];
        refreshRow(wire, rowPositions, position, getOuter$1(table3));
        var colPositions = cols.length > 0 ? vdirection.positions(cols, table3) : [];
        refreshCol(wire, colPositions, position, getOuter(table3));
      };
      var refresh = function(wire, table3, hdirection, vdirection) {
        destroy(wire);
        var list2 = DetailsList.fromTable(table3);
        var warehouse = Warehouse.generate(list2);
        var rows2 = Blocks.rows(warehouse);
        var cols = Blocks.columns(warehouse);
        refreshGrid(wire, table3, rows2, cols, hdirection, vdirection);
      };
      var each$2 = function(wire, f) {
        var bars = descendants$1(wire.parent(), "." + resizeBar);
        each(bars, f);
      };
      var hide = function(wire) {
        each$2(wire, function(bar) {
          set$1(bar, "display", "none");
        });
      };
      var show = function(wire) {
        each$2(wire, function(bar) {
          set$1(bar, "display", "block");
        });
      };
      var isRowBar = function(element) {
        return has$1(element, resizeRowBar);
      };
      var isColBar = function(element) {
        return has$1(element, resizeColBar);
      };
      var Bars = {
        refresh,
        hide,
        show,
        destroy,
        isRowBar,
        isColBar
      };
      var addCell = function(gridRow, index, cell3) {
        var cells2 = gridRow.cells();
        var before2 = cells2.slice(0, index);
        var after2 = cells2.slice(index);
        var newCells = before2.concat([cell3]).concat(after2);
        return setCells(gridRow, newCells);
      };
      var mutateCell = function(gridRow, index, cell3) {
        var cells2 = gridRow.cells();
        cells2[index] = cell3;
      };
      var setCells = function(gridRow, cells2) {
        return rowcells(cells2, gridRow.section());
      };
      var mapCells = function(gridRow, f) {
        var cells2 = gridRow.cells();
        var r2 = map2(cells2, f);
        return rowcells(r2, gridRow.section());
      };
      var getCell = function(gridRow, index) {
        return gridRow.cells()[index];
      };
      var getCellElement = function(gridRow, index) {
        return getCell(gridRow, index).element();
      };
      var cellLength = function(gridRow) {
        return gridRow.cells().length;
      };
      var GridRow = {
        addCell,
        setCells,
        mutateCell,
        getCell,
        getCellElement,
        mapCells,
        cellLength
      };
      var getColumn = function(grid2, index) {
        return map2(grid2, function(row2) {
          return GridRow.getCell(row2, index);
        });
      };
      var getRow = function(grid2, index) {
        return grid2[index];
      };
      var findDiff = function(xs, comp2) {
        if (xs.length === 0) {
          return 0;
        }
        var first2 = xs[0];
        var index = findIndex(xs, function(x) {
          return !comp2(first2.element(), x.element());
        });
        return index.fold(function() {
          return xs.length;
        }, function(ind) {
          return ind;
        });
      };
      var subgrid = function(grid2, row2, column, comparator) {
        var restOfRow = getRow(grid2, row2).cells().slice(column);
        var endColIndex = findDiff(restOfRow, comparator);
        var restOfColumn = getColumn(grid2, column).slice(row2);
        var endRowIndex = findDiff(restOfColumn, comparator);
        return {
          colspan: constant(endColIndex),
          rowspan: constant(endRowIndex)
        };
      };
      var TableGrid = { subgrid };
      var toDetails = function(grid2, comparator) {
        var seen = map2(grid2, function(row2, ri) {
          return map2(row2.cells(), function(col2, ci) {
            return false;
          });
        });
        var updateSeen = function(ri, ci, rowspan, colspan) {
          for (var r2 = ri; r2 < ri + rowspan; r2++) {
            for (var c = ci; c < ci + colspan; c++) {
              seen[r2][c] = true;
            }
          }
        };
        return map2(grid2, function(row2, ri) {
          var details = bind(row2.cells(), function(cell3, ci) {
            if (seen[ri][ci] === false) {
              var result = TableGrid.subgrid(grid2, ri, ci, comparator);
              updateSeen(ri, ci, result.rowspan(), result.colspan());
              return [detailnew(cell3.element(), result.rowspan(), result.colspan(), cell3.isNew())];
            } else {
              return [];
            }
          });
          return rowdetails(details, row2.section());
        });
      };
      var toGrid = function(warehouse, generators, isNew) {
        var grid2 = [];
        for (var i = 0; i < warehouse.grid().rows(); i++) {
          var rowCells = [];
          for (var j = 0; j < warehouse.grid().columns(); j++) {
            var element = Warehouse.getAt(warehouse, i, j).map(function(item) {
              return elementnew(item.element(), isNew);
            }).getOrThunk(function() {
              return elementnew(generators.gap(), true);
            });
            rowCells.push(element);
          }
          var row2 = rowcells(rowCells, warehouse.all()[i].section());
          grid2.push(row2);
        }
        return grid2;
      };
      var Transitions = {
        toDetails,
        toGrid
      };
      var fromWarehouse = function(warehouse, generators) {
        return Transitions.toGrid(warehouse, generators, false);
      };
      var deriveRows = function(rendered, generators) {
        var findRow = function(details) {
          var rowOfCells = findMap(details, function(detail2) {
            return parent(detail2.element()).map(function(row2) {
              var isNew = parent(row2).isNone();
              return elementnew(row2, isNew);
            });
          });
          return rowOfCells.getOrThunk(function() {
            return elementnew(generators.row(), true);
          });
        };
        return map2(rendered, function(details) {
          var row2 = findRow(details.details());
          return rowdatanew(row2.element(), details.details(), details.section(), row2.isNew());
        });
      };
      var toDetailList = function(grid2, generators) {
        var rendered = Transitions.toDetails(grid2, eq);
        return deriveRows(rendered, generators);
      };
      var findInWarehouse = function(warehouse, element) {
        var all2 = flatten(map2(warehouse.all(), function(r2) {
          return r2.cells();
        }));
        return find(all2, function(e) {
          return eq(element, e.element());
        });
      };
      var run = function(operation, extract2, adjustment, postAction, genWrappers) {
        return function(wire, table3, target2, generators, direction) {
          var input = DetailsList.fromTable(table3);
          var warehouse = Warehouse.generate(input);
          var output2 = extract2(warehouse, target2).map(function(info) {
            var model = fromWarehouse(warehouse, generators);
            var result = operation(model, info, eq, genWrappers(generators));
            var grid2 = toDetailList(result.grid(), generators);
            return {
              grid: constant(grid2),
              cursor: result.cursor
            };
          });
          return output2.fold(function() {
            return Option.none();
          }, function(out) {
            var newElements = Redraw.render(table3, out.grid());
            adjustment(table3, out.grid(), direction);
            postAction(table3);
            Bars.refresh(wire, table3, BarPositions.height, direction);
            return Option.some({
              cursor: out.cursor,
              newRows: newElements.newRows,
              newCells: newElements.newCells
            });
          });
        };
      };
      var onPaste = function(warehouse, target2) {
        return TableLookup.cell(target2.element()).bind(function(cell3) {
          return findInWarehouse(warehouse, cell3).map(function(details) {
            var value2 = __assign(__assign({}, details), {
              generators: target2.generators,
              clipboard: target2.clipboard
            });
            return value2;
          });
        });
      };
      var onPasteRows = function(warehouse, target2) {
        var details = map2(target2.selection(), function(cell3) {
          return TableLookup.cell(cell3).bind(function(lc) {
            return findInWarehouse(warehouse, lc);
          });
        });
        var cells2 = cat(details);
        return cells2.length > 0 ? Option.some({
          cells: cells2,
          generators: target2.generators,
          clipboard: target2.clipboard
        }) : Option.none();
      };
      var onMergable = function(_warehouse, target2) {
        return target2.mergable();
      };
      var onUnmergable = function(_warehouse, target2) {
        return target2.unmergable();
      };
      var onCells = function(warehouse, target2) {
        var details = map2(target2.selection(), function(cell3) {
          return TableLookup.cell(cell3).bind(function(lc) {
            return findInWarehouse(warehouse, lc);
          });
        });
        var cells2 = cat(details);
        return cells2.length > 0 ? Option.some(cells2) : Option.none();
      };
      var value = function(o) {
        var is3 = function(v) {
          return o === v;
        };
        var or2 = function(opt) {
          return value(o);
        };
        var orThunk = function(f) {
          return value(o);
        };
        var map3 = function(f) {
          return value(f(o));
        };
        var mapError = function(f) {
          return value(o);
        };
        var each2 = function(f) {
          f(o);
        };
        var bind2 = function(f) {
          return f(o);
        };
        var fold = function(_, onValue) {
          return onValue(o);
        };
        var exists2 = function(f) {
          return f(o);
        };
        var forall3 = function(f) {
          return f(o);
        };
        var toOption = function() {
          return Option.some(o);
        };
        return {
          is: is3,
          isValue: always,
          isError: never,
          getOr: constant(o),
          getOrThunk: constant(o),
          getOrDie: constant(o),
          or: or2,
          orThunk,
          fold,
          map: map3,
          mapError,
          each: each2,
          bind: bind2,
          exists: exists2,
          forall: forall3,
          toOption
        };
      };
      var error2 = function(message) {
        var getOrThunk = function(f) {
          return f();
        };
        var getOrDie2 = function() {
          return die2(String(message))();
        };
        var or2 = function(opt) {
          return opt;
        };
        var orThunk = function(f) {
          return f();
        };
        var map3 = function(f) {
          return error2(message);
        };
        var mapError = function(f) {
          return error2(f(message));
        };
        var bind2 = function(f) {
          return error2(message);
        };
        var fold = function(onError, _) {
          return onError(message);
        };
        return {
          is: never,
          isValue: never,
          isError: always,
          getOr: identity,
          getOrThunk,
          getOrDie: getOrDie2,
          or: or2,
          orThunk,
          fold,
          map: map3,
          mapError,
          each: noop,
          bind: bind2,
          exists: never,
          forall: always,
          toOption: Option.none
        };
      };
      var fromOption = function(opt, err) {
        return opt.fold(function() {
          return error2(err);
        }, value);
      };
      var Result = {
        value,
        error: error2,
        fromOption
      };
      var measure = function(startAddress, gridA, gridB) {
        if (startAddress.row() >= gridA.length || startAddress.column() > GridRow.cellLength(gridA[0])) {
          return Result.error("invalid start address out of table bounds, row: " + startAddress.row() + ", column: " + startAddress.column());
        }
        var rowRemainder = gridA.slice(startAddress.row());
        var colRemainder = rowRemainder[0].cells().slice(startAddress.column());
        var colRequired = GridRow.cellLength(gridB[0]);
        var rowRequired = gridB.length;
        return Result.value({
          rowDelta: constant(rowRemainder.length - rowRequired),
          colDelta: constant(colRemainder.length - colRequired)
        });
      };
      var measureWidth = function(gridA, gridB) {
        var colLengthA = GridRow.cellLength(gridA[0]);
        var colLengthB = GridRow.cellLength(gridB[0]);
        return {
          rowDelta: constant(0),
          colDelta: constant(colLengthA - colLengthB)
        };
      };
      var fill = function(cells2, generator) {
        return map2(cells2, function() {
          return elementnew(generator.cell(), true);
        });
      };
      var rowFill = function(grid2, amount, generator) {
        return grid2.concat(repeat2(amount, function(_row) {
          return GridRow.setCells(grid2[grid2.length - 1], fill(grid2[grid2.length - 1].cells(), generator));
        }));
      };
      var colFill = function(grid2, amount, generator) {
        return map2(grid2, function(row2) {
          return GridRow.setCells(row2, row2.cells().concat(fill(range2(0, amount), generator)));
        });
      };
      var tailor = function(gridA, delta2, generator) {
        var fillCols = delta2.colDelta() < 0 ? colFill : identity;
        var fillRows = delta2.rowDelta() < 0 ? rowFill : identity;
        var modifiedCols = fillCols(gridA, Math.abs(delta2.colDelta()), generator);
        var tailoredGrid = fillRows(modifiedCols, Math.abs(delta2.rowDelta()), generator);
        return tailoredGrid;
      };
      var Fitment = {
        measure,
        measureWidth,
        tailor
      };
      var merge = function(grid2, bounds2, comparator, substitution) {
        if (grid2.length === 0) {
          return grid2;
        }
        for (var i = bounds2.startRow(); i <= bounds2.finishRow(); i++) {
          for (var j = bounds2.startCol(); j <= bounds2.finishCol(); j++) {
            GridRow.mutateCell(grid2[i], j, elementnew(substitution(), false));
          }
        }
        return grid2;
      };
      var unmerge = function(grid2, target2, comparator, substitution) {
        var first2 = true;
        for (var i = 0; i < grid2.length; i++) {
          for (var j = 0; j < GridRow.cellLength(grid2[0]); j++) {
            var current = GridRow.getCellElement(grid2[i], j);
            var isToReplace = comparator(current, target2);
            if (isToReplace === true && first2 === false) {
              GridRow.mutateCell(grid2[i], j, elementnew(substitution(), true));
            } else if (isToReplace === true) {
              first2 = false;
            }
          }
        }
        return grid2;
      };
      var uniqueCells = function(row2, comparator) {
        return foldl(row2, function(rest, cell3) {
          return exists(rest, function(currentCell) {
            return comparator(currentCell.element(), cell3.element());
          }) ? rest : rest.concat([cell3]);
        }, []);
      };
      var splitRows = function(grid2, index, comparator, substitution) {
        if (index > 0 && index < grid2.length) {
          var rowPrevCells = grid2[index - 1].cells();
          var cells2 = uniqueCells(rowPrevCells, comparator);
          each(cells2, function(cell3) {
            var replacement = Option.none();
            var _loop_1 = function(i2) {
              var _loop_2 = function(j2) {
                var current = grid2[i2].cells()[j2];
                var isToReplace = comparator(current.element(), cell3.element());
                if (isToReplace) {
                  if (replacement.isNone()) {
                    replacement = Option.some(substitution());
                  }
                  replacement.each(function(sub2) {
                    GridRow.mutateCell(grid2[i2], j2, elementnew(sub2, true));
                  });
                }
              };
              for (var j = 0; j < GridRow.cellLength(grid2[0]); j++) {
                _loop_2(j);
              }
            };
            for (var i = index; i < grid2.length; i++) {
              _loop_1(i);
            }
          });
        }
        return grid2;
      };
      var MergingOperations = {
        merge,
        unmerge,
        splitRows
      };
      var isSpanning = function(grid2, row2, col2, comparator) {
        var candidate = GridRow.getCell(grid2[row2], col2);
        var matching = curry(comparator, candidate.element());
        var currentRow = grid2[row2];
        return grid2.length > 1 && GridRow.cellLength(currentRow) > 1 && (col2 > 0 && matching(GridRow.getCellElement(currentRow, col2 - 1)) || col2 < currentRow.cells().length - 1 && matching(GridRow.getCellElement(currentRow, col2 + 1)) || row2 > 0 && matching(GridRow.getCellElement(grid2[row2 - 1], col2)) || row2 < grid2.length - 1 && matching(GridRow.getCellElement(grid2[row2 + 1], col2)));
      };
      var mergeTables = function(startAddress, gridA, gridB, generator, comparator) {
        var startRow = startAddress.row();
        var startCol = startAddress.column();
        var mergeHeight = gridB.length;
        var mergeWidth = GridRow.cellLength(gridB[0]);
        var endRow = startRow + mergeHeight;
        var endCol = startCol + mergeWidth;
        for (var r2 = startRow; r2 < endRow; r2++) {
          for (var c = startCol; c < endCol; c++) {
            if (isSpanning(gridA, r2, c, comparator)) {
              MergingOperations.unmerge(gridA, GridRow.getCellElement(gridA[r2], c), comparator, generator.cell);
            }
            var newCell = GridRow.getCellElement(gridB[r2 - startRow], c - startCol);
            var replacement = generator.replace(newCell);
            GridRow.mutateCell(gridA[r2], c, elementnew(replacement, true));
          }
        }
        return gridA;
      };
      var merge$1 = function(startAddress, gridA, gridB, generator, comparator) {
        var result = Fitment.measure(startAddress, gridA, gridB);
        return result.map(function(delta2) {
          var fittedGrid = Fitment.tailor(gridA, delta2, generator);
          return mergeTables(startAddress, fittedGrid, gridB, generator, comparator);
        });
      };
      var insert = function(index, gridA, gridB, generator, comparator) {
        MergingOperations.splitRows(gridA, index, comparator, generator.cell);
        var delta2 = Fitment.measureWidth(gridB, gridA);
        var fittedNewGrid = Fitment.tailor(gridB, delta2, generator);
        var secondDelta = Fitment.measureWidth(gridA, fittedNewGrid);
        var fittedOldGrid = Fitment.tailor(gridA, secondDelta, generator);
        return fittedOldGrid.slice(0, index).concat(fittedNewGrid).concat(fittedOldGrid.slice(index, fittedOldGrid.length));
      };
      var TableMerge = {
        merge: merge$1,
        insert
      };
      var insertRowAt = function(grid2, index, example, comparator, substitution) {
        var before2 = grid2.slice(0, index);
        var after2 = grid2.slice(index);
        var between2 = GridRow.mapCells(grid2[example], function(ex, c) {
          var withinSpan = index > 0 && index < grid2.length && comparator(GridRow.getCellElement(grid2[index - 1], c), GridRow.getCellElement(grid2[index], c));
          var ret = withinSpan ? GridRow.getCell(grid2[index], c) : elementnew(substitution(ex.element(), comparator), true);
          return ret;
        });
        return before2.concat([between2]).concat(after2);
      };
      var insertColumnAt = function(grid2, index, example, comparator, substitution) {
        return map2(grid2, function(row2) {
          var withinSpan = index > 0 && index < GridRow.cellLength(row2) && comparator(GridRow.getCellElement(row2, index - 1), GridRow.getCellElement(row2, index));
          var sub2 = withinSpan ? GridRow.getCell(row2, index) : elementnew(substitution(GridRow.getCellElement(row2, example), comparator), true);
          return GridRow.addCell(row2, index, sub2);
        });
      };
      var splitCellIntoColumns = function(grid2, exampleRow, exampleCol, comparator, substitution) {
        var index = exampleCol + 1;
        return map2(grid2, function(row2, i) {
          var isTargetCell = i === exampleRow;
          var sub2 = isTargetCell ? elementnew(substitution(GridRow.getCellElement(row2, exampleCol), comparator), true) : GridRow.getCell(row2, exampleCol);
          return GridRow.addCell(row2, index, sub2);
        });
      };
      var splitCellIntoRows = function(grid2, exampleRow, exampleCol, comparator, substitution) {
        var index = exampleRow + 1;
        var before2 = grid2.slice(0, index);
        var after2 = grid2.slice(index);
        var between2 = GridRow.mapCells(grid2[exampleRow], function(ex, i) {
          var isTargetCell = i === exampleCol;
          return isTargetCell ? elementnew(substitution(ex.element(), comparator), true) : ex;
        });
        return before2.concat([between2]).concat(after2);
      };
      var deleteColumnsAt = function(grid2, start, finish) {
        var rows2 = map2(grid2, function(row2) {
          var cells2 = row2.cells().slice(0, start).concat(row2.cells().slice(finish + 1));
          return rowcells(cells2, row2.section());
        });
        return filter(rows2, function(row2) {
          return row2.cells().length > 0;
        });
      };
      var deleteRowsAt = function(grid2, start, finish) {
        return grid2.slice(0, start).concat(grid2.slice(finish + 1));
      };
      var ModificationOperations = {
        insertRowAt,
        insertColumnAt,
        splitCellIntoColumns,
        splitCellIntoRows,
        deleteRowsAt,
        deleteColumnsAt
      };
      var adt = Adt.generate([
        { none: [] },
        { only: ["index"] },
        {
          left: [
            "index",
            "next"
          ]
        },
        {
          middle: [
            "prev",
            "index",
            "next"
          ]
        },
        {
          right: [
            "prev",
            "index"
          ]
        }
      ]);
      var ColumnContext = __assign({}, adt);
      var neighbours$1 = function(input, index) {
        if (input.length === 0) {
          return ColumnContext.none();
        }
        if (input.length === 1) {
          return ColumnContext.only(0);
        }
        if (index === 0) {
          return ColumnContext.left(0, 1);
        }
        if (index === input.length - 1) {
          return ColumnContext.right(index - 1, index);
        }
        if (index > 0 && index < input.length - 1) {
          return ColumnContext.middle(index - 1, index, index + 1);
        }
        return ColumnContext.none();
      };
      var determine = function(input, column, step, tableSize) {
        var result = input.slice(0);
        var context = neighbours$1(input, column);
        var zero2 = function(array) {
          return map2(array, constant(0));
        };
        var onNone = constant(zero2(result));
        var onOnly = function(index) {
          return tableSize.singleColumnWidth(result[index], step);
        };
        var onChange = function(index, next3) {
          if (step >= 0) {
            var newNext = Math.max(tableSize.minCellWidth(), result[next3] - step);
            return zero2(result.slice(0, index)).concat([
              step,
              newNext - result[next3]
            ]).concat(zero2(result.slice(next3 + 1)));
          } else {
            var newThis = Math.max(tableSize.minCellWidth(), result[index] + step);
            var diffx = result[index] - newThis;
            return zero2(result.slice(0, index)).concat([
              newThis - result[index],
              diffx
            ]).concat(zero2(result.slice(next3 + 1)));
          }
        };
        var onLeft = onChange;
        var onMiddle = function(_prev, index, next3) {
          return onChange(index, next3);
        };
        var onRight = function(_prev, index) {
          if (step >= 0) {
            return zero2(result.slice(0, index)).concat([step]);
          } else {
            var size = Math.max(tableSize.minCellWidth(), result[index] + step);
            return zero2(result.slice(0, index)).concat([size - result[index]]);
          }
        };
        return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
      };
      var Deltas = { determine };
      var getSpan$1 = function(cell3, type2) {
        return has2(cell3, type2) && parseInt(get(cell3, type2), 10) > 1;
      };
      var hasColspan = function(cell3) {
        return getSpan$1(cell3, "colspan");
      };
      var hasRowspan = function(cell3) {
        return getSpan$1(cell3, "rowspan");
      };
      var getInt = function(element, property) {
        return parseInt(get$1(element, property), 10);
      };
      var CellUtils = {
        hasColspan,
        hasRowspan,
        minWidth: constant(10),
        minHeight: constant(10),
        getInt
      };
      var getRaw$1 = function(cell3, property, getter) {
        return getRaw(cell3, property).fold(function() {
          return getter(cell3) + "px";
        }, function(raw) {
          return raw;
        });
      };
      var getRawW = function(cell3, tableSize) {
        return getRaw$1(cell3, "width", function(e) {
          return Sizes.getPixelWidth(e, tableSize);
        });
      };
      var getRawH = function(cell3) {
        return getRaw$1(cell3, "height", Sizes.getHeight);
      };
      var getWidthFrom = function(warehouse, direction, getWidth2, fallback, tableSize) {
        var columns2 = Blocks.columns(warehouse);
        var backups = map2(columns2, function(cellOption) {
          return cellOption.map(direction.edge);
        });
        return map2(columns2, function(cellOption, c) {
          var columnCell = cellOption.filter(not2(CellUtils.hasColspan));
          return columnCell.fold(function() {
            var deduced = deduce(backups, c);
            return fallback(deduced);
          }, function(cell3) {
            return getWidth2(cell3, tableSize);
          });
        });
      };
      var getDeduced = function(deduced) {
        return deduced.map(function(d) {
          return d + "px";
        }).getOr("");
      };
      var getRawWidths = function(warehouse, direction, tableSize) {
        return getWidthFrom(warehouse, direction, getRawW, getDeduced, tableSize);
      };
      var getPercentageWidths = function(warehouse, direction, tableSize) {
        return getWidthFrom(warehouse, direction, Sizes.getPercentageWidth, function(deduced) {
          return deduced.fold(function() {
            return tableSize.minCellWidth();
          }, function(cellWidth) {
            return cellWidth / tableSize.pixelWidth() * 100;
          });
        }, tableSize);
      };
      var getPixelWidths = function(warehouse, direction, tableSize) {
        return getWidthFrom(warehouse, direction, Sizes.getPixelWidth, function(deduced) {
          return deduced.getOrThunk(tableSize.minCellWidth);
        }, tableSize);
      };
      var getHeightFrom = function(warehouse, direction, getHeight2, fallback) {
        var rows2 = Blocks.rows(warehouse);
        var backups = map2(rows2, function(cellOption) {
          return cellOption.map(direction.edge);
        });
        return map2(rows2, function(cellOption, c) {
          var rowCell = cellOption.filter(not2(CellUtils.hasRowspan));
          return rowCell.fold(function() {
            var deduced = deduce(backups, c);
            return fallback(deduced);
          }, function(cell3) {
            return getHeight2(cell3);
          });
        });
      };
      var getPixelHeights = function(warehouse, direction) {
        return getHeightFrom(warehouse, direction, Sizes.getHeight, function(deduced) {
          return deduced.getOrThunk(CellUtils.minHeight);
        });
      };
      var getRawHeights = function(warehouse, direction) {
        return getHeightFrom(warehouse, direction, getRawH, getDeduced);
      };
      var ColumnSizes = {
        getRawWidths,
        getPixelWidths,
        getPercentageWidths,
        getPixelHeights,
        getRawHeights
      };
      var total = function(start, end, measures) {
        var r2 = 0;
        for (var i = start; i < end; i++) {
          r2 += measures[i] !== void 0 ? measures[i] : 0;
        }
        return r2;
      };
      var recalculateWidth = function(warehouse, widths) {
        var all2 = Warehouse.justCells(warehouse);
        return map2(all2, function(cell3) {
          var width = total(cell3.column(), cell3.column() + cell3.colspan(), widths);
          return {
            element: cell3.element,
            width: constant(width),
            colspan: cell3.colspan
          };
        });
      };
      var recalculateHeight = function(warehouse, heights) {
        var all2 = Warehouse.justCells(warehouse);
        return map2(all2, function(cell3) {
          var height2 = total(cell3.row(), cell3.row() + cell3.rowspan(), heights);
          return {
            element: cell3.element,
            height: constant(height2),
            rowspan: cell3.rowspan
          };
        });
      };
      var matchRowHeight = function(warehouse, heights) {
        return map2(warehouse.all(), function(row2, i) {
          return {
            element: row2.element,
            height: constant(heights[i])
          };
        });
      };
      var Recalculations = {
        recalculateWidth,
        recalculateHeight,
        matchRowHeight
      };
      var percentageSize = function(width, element) {
        var floatWidth = parseFloat(width);
        var pixelWidth = get$4(element);
        var getCellDelta = function(delta2) {
          return delta2 / pixelWidth * 100;
        };
        var singleColumnWidth = function(w, _delta) {
          return [100 - w];
        };
        var minCellWidth = function() {
          return CellUtils.minWidth() / pixelWidth * 100;
        };
        var setTableWidth = function(table3, _newWidths, delta2) {
          var ratio2 = delta2 / 100;
          var change = ratio2 * floatWidth;
          Sizes.setPercentageWidth(table3, floatWidth + change);
        };
        return {
          width: constant(floatWidth),
          pixelWidth: constant(pixelWidth),
          getWidths: ColumnSizes.getPercentageWidths,
          getCellDelta,
          singleColumnWidth,
          minCellWidth,
          setElementWidth: Sizes.setPercentageWidth,
          setTableWidth
        };
      };
      var pixelSize = function(width) {
        var getCellDelta = identity;
        var singleColumnWidth = function(w, delta2) {
          var newNext = Math.max(CellUtils.minWidth(), w + delta2);
          return [newNext - w];
        };
        var setTableWidth = function(table3, newWidths, _delta) {
          var total2 = foldr(newWidths, function(b, a) {
            return b + a;
          }, 0);
          Sizes.setPixelWidth(table3, total2);
        };
        return {
          width: constant(width),
          pixelWidth: constant(width),
          getWidths: ColumnSizes.getPixelWidths,
          getCellDelta,
          singleColumnWidth,
          minCellWidth: CellUtils.minWidth,
          setElementWidth: Sizes.setPixelWidth,
          setTableWidth
        };
      };
      var chooseSize = function(element, width) {
        var percentMatch = Sizes.percentageBasedSizeRegex().exec(width);
        if (percentMatch !== null) {
          return percentageSize(percentMatch[1], element);
        }
        var pixelMatch = Sizes.pixelBasedSizeRegex().exec(width);
        if (pixelMatch !== null) {
          var intWidth = parseInt(pixelMatch[1], 10);
          return pixelSize(intWidth);
        }
        var fallbackWidth = get$4(element);
        return pixelSize(fallbackWidth);
      };
      var getTableSize = function(element) {
        var width = Sizes.getRawWidth(element);
        return width.fold(function() {
          var fallbackWidth = get$4(element);
          return pixelSize(fallbackWidth);
        }, function(w) {
          return chooseSize(element, w);
        });
      };
      var TableSize = { getTableSize };
      var getWarehouse$1 = function(list2) {
        return Warehouse.generate(list2);
      };
      var sumUp = function(newSize) {
        return foldr(newSize, function(b, a) {
          return b + a;
        }, 0);
      };
      var getTableWarehouse = function(table3) {
        var list2 = DetailsList.fromTable(table3);
        return getWarehouse$1(list2);
      };
      var adjustWidth = function(table3, delta2, index, direction) {
        var tableSize = TableSize.getTableSize(table3);
        var step = tableSize.getCellDelta(delta2);
        var warehouse = getTableWarehouse(table3);
        var widths = tableSize.getWidths(warehouse, direction, tableSize);
        var deltas = Deltas.determine(widths, index, step, tableSize);
        var newWidths = map2(deltas, function(dx, i) {
          return dx + widths[i];
        });
        var newSizes = Recalculations.recalculateWidth(warehouse, newWidths);
        each(newSizes, function(cell3) {
          tableSize.setElementWidth(cell3.element(), cell3.width());
        });
        if (index === warehouse.grid().columns() - 1) {
          tableSize.setTableWidth(table3, newWidths, step);
        }
      };
      var adjustHeight = function(table3, delta2, index, direction) {
        var warehouse = getTableWarehouse(table3);
        var heights = ColumnSizes.getPixelHeights(warehouse, direction);
        var newHeights = map2(heights, function(dy, i) {
          return index === i ? Math.max(delta2 + dy, CellUtils.minHeight()) : dy;
        });
        var newCellSizes = Recalculations.recalculateHeight(warehouse, newHeights);
        var newRowSizes = Recalculations.matchRowHeight(warehouse, newHeights);
        each(newRowSizes, function(row2) {
          Sizes.setHeight(row2.element(), row2.height());
        });
        each(newCellSizes, function(cell3) {
          Sizes.setHeight(cell3.element(), cell3.height());
        });
        var total2 = sumUp(newHeights);
        Sizes.setHeight(table3, total2);
      };
      var adjustWidthTo = function(table3, list2, direction) {
        var tableSize = TableSize.getTableSize(table3);
        var warehouse = getWarehouse$1(list2);
        var widths = tableSize.getWidths(warehouse, direction, tableSize);
        var newSizes = Recalculations.recalculateWidth(warehouse, widths);
        each(newSizes, function(cell3) {
          tableSize.setElementWidth(cell3.element(), cell3.width());
        });
        if (newSizes.length > 0) {
          tableSize.setTableWidth(table3, widths, tableSize.getCellDelta(0));
        }
      };
      var Adjustments = {
        adjustWidth,
        adjustHeight,
        adjustWidthTo
      };
      var Cell = function(initial) {
        var value2 = initial;
        var get2 = function() {
          return value2;
        };
        var set2 = function(v) {
          value2 = v;
        };
        var clone2 = function() {
          return Cell(get2());
        };
        return {
          get: get2,
          set: set2,
          clone: clone2
        };
      };
      var base2 = function(handleUnsupported, required) {
        return baseWith(handleUnsupported, required, {
          validate: isFunction,
          label: "function"
        });
      };
      var baseWith = function(handleUnsupported, required, pred) {
        if (required.length === 0) {
          throw new Error("You must specify at least one required field.");
        }
        validateStrArr("required", required);
        checkDupes(required);
        return function(obj) {
          var keys$1 = keys(obj);
          var allReqd = forall2(required, function(req) {
            return contains(keys$1, req);
          });
          if (!allReqd) {
            reqMessage(required, keys$1);
          }
          handleUnsupported(required, keys$1);
          var invalidKeys = filter(required, function(key2) {
            return !pred.validate(obj[key2], key2);
          });
          if (invalidKeys.length > 0) {
            invalidTypeMessage(invalidKeys, pred.label);
          }
          return obj;
        };
      };
      var handleExact = function(required, keys2) {
        var unsupported = filter(keys2, function(key2) {
          return !contains(required, key2);
        });
        if (unsupported.length > 0) {
          unsuppMessage(unsupported);
        }
      };
      var exactly = function(required) {
        return base2(handleExact, required);
      };
      var verifyGenerators = exactly([
        "cell",
        "row",
        "replace",
        "gap"
      ]);
      var elementToData = function(element) {
        var colspan = has2(element, "colspan") ? parseInt(get(element, "colspan"), 10) : 1;
        var rowspan = has2(element, "rowspan") ? parseInt(get(element, "rowspan"), 10) : 1;
        return {
          element: constant(element),
          colspan: constant(colspan),
          rowspan: constant(rowspan)
        };
      };
      var modification = function(generators, toData) {
        if (toData === void 0) {
          toData = elementToData;
        }
        verifyGenerators(generators);
        var position = Cell(Option.none());
        var nu3 = function(data) {
          return generators.cell(data);
        };
        var nuFrom = function(element) {
          var data = toData(element);
          return nu3(data);
        };
        var add2 = function(element) {
          var replacement = nuFrom(element);
          if (position.get().isNone()) {
            position.set(Option.some(replacement));
          }
          recent = Option.some({
            item: element,
            replacement
          });
          return replacement;
        };
        var recent = Option.none();
        var getOrInit = function(element, comparator) {
          return recent.fold(function() {
            return add2(element);
          }, function(p) {
            return comparator(element, p.item) ? p.replacement : add2(element);
          });
        };
        return {
          getOrInit,
          cursor: position.get
        };
      };
      var merging = function(generators) {
        verifyGenerators(generators);
        var position = Cell(Option.none());
        var combine = function(cell3) {
          if (position.get().isNone()) {
            position.set(Option.some(cell3));
          }
          return function() {
            var raw = generators.cell({
              element: constant(cell3),
              colspan: constant(1),
              rowspan: constant(1)
            });
            remove$1(raw, "width");
            remove$1(cell3, "width");
            return raw;
          };
        };
        return {
          combine,
          cursor: position.get
        };
      };
      var Generators = {
        modification,
        merging
      };
      var blockList = [
        "body",
        "p",
        "div",
        "article",
        "aside",
        "figcaption",
        "figure",
        "footer",
        "header",
        "nav",
        "section",
        "ol",
        "ul",
        "table",
        "thead",
        "tfoot",
        "tbody",
        "caption",
        "tr",
        "td",
        "th",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "blockquote",
        "pre",
        "address"
      ];
      var isList = function(universe2, item) {
        var tagName = universe2.property().name(item);
        return contains([
          "ol",
          "ul"
        ], tagName);
      };
      var isBlock2 = function(universe2, item) {
        var tagName = universe2.property().name(item);
        return contains(blockList, tagName);
      };
      var isFormatting = function(universe2, item) {
        var tagName = universe2.property().name(item);
        return contains([
          "address",
          "pre",
          "p",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6"
        ], tagName);
      };
      var isHeading = function(universe2, item) {
        var tagName = universe2.property().name(item);
        return contains([
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6"
        ], tagName);
      };
      var isContainer = function(universe2, item) {
        return contains([
          "div",
          "li",
          "td",
          "th",
          "blockquote",
          "body",
          "caption"
        ], universe2.property().name(item));
      };
      var isEmptyTag = function(universe2, item) {
        return contains([
          "br",
          "img",
          "hr",
          "input"
        ], universe2.property().name(item));
      };
      var isFrame = function(universe2, item) {
        return universe2.property().name(item) === "iframe";
      };
      var isInline = function(universe2, item) {
        return !(isBlock2(universe2, item) || isEmptyTag(universe2, item)) && universe2.property().name(item) !== "li";
      };
      var Structure = {
        isBlock: isBlock2,
        isList,
        isFormatting,
        isHeading,
        isContainer,
        isEmptyTag,
        isFrame,
        isInline
      };
      var universe$1 = DomUniverse();
      var isBlock$1 = function(element) {
        return Structure.isBlock(universe$1, element);
      };
      var isList$1 = function(element) {
        return Structure.isList(universe$1, element);
      };
      var isFormatting$1 = function(element) {
        return Structure.isFormatting(universe$1, element);
      };
      var isHeading$1 = function(element) {
        return Structure.isHeading(universe$1, element);
      };
      var isContainer$1 = function(element) {
        return Structure.isContainer(universe$1, element);
      };
      var isEmptyTag$1 = function(element) {
        return Structure.isEmptyTag(universe$1, element);
      };
      var isFrame$1 = function(element) {
        return Structure.isFrame(universe$1, element);
      };
      var isInline$1 = function(element) {
        return Structure.isInline(universe$1, element);
      };
      var DomStructure = {
        isBlock: isBlock$1,
        isList: isList$1,
        isFormatting: isFormatting$1,
        isHeading: isHeading$1,
        isContainer: isContainer$1,
        isEmptyTag: isEmptyTag$1,
        isFrame: isFrame$1,
        isInline: isInline$1
      };
      var merge$2 = function(cells2) {
        var isBr2 = function(el2) {
          return name(el2) === "br";
        };
        var advancedBr = function(children2) {
          return forall2(children2, function(c) {
            return isBr2(c) || isText(c) && get$2(c).trim().length === 0;
          });
        };
        var isListItem = function(el2) {
          return name(el2) === "li" || ancestor(el2, DomStructure.isList).isSome();
        };
        var siblingIsBlock = function(el2) {
          return nextSibling(el2).map(function(rightSibling) {
            if (DomStructure.isBlock(rightSibling)) {
              return true;
            }
            if (DomStructure.isEmptyTag(rightSibling)) {
              return name(rightSibling) === "img" ? false : true;
            }
            return false;
          }).getOr(false);
        };
        var markCell = function(cell3) {
          return last$1(cell3).bind(function(rightEdge) {
            var rightSiblingIsBlock = siblingIsBlock(rightEdge);
            return parent(rightEdge).map(function(parent2) {
              return rightSiblingIsBlock === true || isListItem(parent2) || isBr2(rightEdge) || DomStructure.isBlock(parent2) && !eq(cell3, parent2) ? [] : [Element2.fromTag("br")];
            });
          }).getOr([]);
        };
        var markContent = function() {
          var content = bind(cells2, function(cell3) {
            var children$12 = children(cell3);
            return advancedBr(children$12) ? [] : children$12.concat(markCell(cell3));
          });
          return content.length === 0 ? [Element2.fromTag("br")] : content;
        };
        var contents = markContent();
        empty2(cells2[0]);
        append$1(cells2[0], contents);
      };
      var TableContent = { merge: merge$2 };
      var prune = function(table3) {
        var cells2 = TableLookup.cells(table3);
        if (cells2.length === 0) {
          remove$2(table3);
        }
      };
      var outcome = Immutable("grid", "cursor");
      var elementFromGrid = function(grid2, row2, column) {
        return findIn(grid2, row2, column).orThunk(function() {
          return findIn(grid2, 0, 0);
        });
      };
      var findIn = function(grid2, row2, column) {
        return Option.from(grid2[row2]).bind(function(r2) {
          return Option.from(r2.cells()[column]).bind(function(c) {
            return Option.from(c.element());
          });
        });
      };
      var bundle = function(grid2, row2, column) {
        return outcome(grid2, findIn(grid2, row2, column));
      };
      var uniqueRows = function(details) {
        return foldl(details, function(rest, detail2) {
          return exists(rest, function(currentDetail) {
            return currentDetail.row() === detail2.row();
          }) ? rest : rest.concat([detail2]);
        }, []).sort(function(detailA, detailB) {
          return detailA.row() - detailB.row();
        });
      };
      var uniqueColumns = function(details) {
        return foldl(details, function(rest, detail2) {
          return exists(rest, function(currentDetail) {
            return currentDetail.column() === detail2.column();
          }) ? rest : rest.concat([detail2]);
        }, []).sort(function(detailA, detailB) {
          return detailA.column() - detailB.column();
        });
      };
      var insertRowsBefore = function(grid2, details, comparator, genWrappers) {
        var example = details[0].row();
        var targetIndex = details[0].row();
        var rows2 = uniqueRows(details);
        var newGrid = foldl(rows2, function(newG, _row) {
          return ModificationOperations.insertRowAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
        }, grid2);
        return bundle(newGrid, targetIndex, details[0].column());
      };
      var insertRowsAfter = function(grid2, details, comparator, genWrappers) {
        var rows2 = uniqueRows(details);
        var example = rows2[rows2.length - 1].row();
        var targetIndex = rows2[rows2.length - 1].row() + rows2[rows2.length - 1].rowspan();
        var newGrid = foldl(rows2, function(newG, _row) {
          return ModificationOperations.insertRowAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
        }, grid2);
        return bundle(newGrid, targetIndex, details[0].column());
      };
      var insertColumnsBefore = function(grid2, details, comparator, genWrappers) {
        var columns2 = uniqueColumns(details);
        var example = columns2[0].column();
        var targetIndex = columns2[0].column();
        var newGrid = foldl(columns2, function(newG, _row) {
          return ModificationOperations.insertColumnAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
        }, grid2);
        return bundle(newGrid, details[0].row(), targetIndex);
      };
      var insertColumnsAfter = function(grid2, details, comparator, genWrappers) {
        var example = details[details.length - 1].column();
        var targetIndex = details[details.length - 1].column() + details[details.length - 1].colspan();
        var columns2 = uniqueColumns(details);
        var newGrid = foldl(columns2, function(newG, _row) {
          return ModificationOperations.insertColumnAt(newG, targetIndex, example, comparator, genWrappers.getOrInit);
        }, grid2);
        return bundle(newGrid, details[0].row(), targetIndex);
      };
      var eraseColumns = function(grid2, details, _comparator, _genWrappers) {
        var columns2 = uniqueColumns(details);
        var newGrid = ModificationOperations.deleteColumnsAt(grid2, columns2[0].column(), columns2[columns2.length - 1].column());
        var cursor = elementFromGrid(newGrid, details[0].row(), details[0].column());
        return outcome(newGrid, cursor);
      };
      var eraseRows = function(grid2, details, _comparator, _genWrappers) {
        var rows2 = uniqueRows(details);
        var newGrid = ModificationOperations.deleteRowsAt(grid2, rows2[0].row(), rows2[rows2.length - 1].row());
        var cursor = elementFromGrid(newGrid, details[0].row(), details[0].column());
        return outcome(newGrid, cursor);
      };
      var mergeCells = function(grid2, mergable2, comparator, _genWrappers) {
        var cells2 = mergable2.cells();
        TableContent.merge(cells2);
        var newGrid = MergingOperations.merge(grid2, mergable2.bounds(), comparator, constant(cells2[0]));
        return outcome(newGrid, Option.from(cells2[0]));
      };
      var unmergeCells = function(grid2, unmergable2, comparator, genWrappers) {
        var newGrid = foldr(unmergable2, function(b, cell3) {
          return MergingOperations.unmerge(b, cell3, comparator, genWrappers.combine(cell3));
        }, grid2);
        return outcome(newGrid, Option.from(unmergable2[0]));
      };
      var pasteCells = function(grid2, pasteDetails, comparator, _genWrappers) {
        var gridify = function(table3, generators) {
          var list2 = DetailsList.fromTable(table3);
          var wh = Warehouse.generate(list2);
          return Transitions.toGrid(wh, generators, true);
        };
        var gridB = gridify(pasteDetails.clipboard(), pasteDetails.generators());
        var startAddress = address(pasteDetails.row(), pasteDetails.column());
        var mergedGrid = TableMerge.merge(startAddress, grid2, gridB, pasteDetails.generators(), comparator);
        return mergedGrid.fold(function() {
          return outcome(grid2, Option.some(pasteDetails.element()));
        }, function(nuGrid) {
          var cursor = elementFromGrid(nuGrid, pasteDetails.row(), pasteDetails.column());
          return outcome(nuGrid, cursor);
        });
      };
      var gridifyRows = function(rows2, generators, example) {
        var pasteDetails = DetailsList.fromPastedRows(rows2, example);
        var wh = Warehouse.generate(pasteDetails);
        return Transitions.toGrid(wh, generators, true);
      };
      var pasteRowsBefore = function(grid2, pasteDetails, comparator, _genWrappers) {
        var example = grid2[pasteDetails.cells[0].row()];
        var index = pasteDetails.cells[0].row();
        var gridB = gridifyRows(pasteDetails.clipboard(), pasteDetails.generators(), example);
        var mergedGrid = TableMerge.insert(index, grid2, gridB, pasteDetails.generators(), comparator);
        var cursor = elementFromGrid(mergedGrid, pasteDetails.cells[0].row(), pasteDetails.cells[0].column());
        return outcome(mergedGrid, cursor);
      };
      var pasteRowsAfter = function(grid2, pasteDetails, comparator, _genWrappers) {
        var example = grid2[pasteDetails.cells[0].row()];
        var index = pasteDetails.cells[pasteDetails.cells.length - 1].row() + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan();
        var gridB = gridifyRows(pasteDetails.clipboard(), pasteDetails.generators(), example);
        var mergedGrid = TableMerge.insert(index, grid2, gridB, pasteDetails.generators(), comparator);
        var cursor = elementFromGrid(mergedGrid, pasteDetails.cells[0].row(), pasteDetails.cells[0].column());
        return outcome(mergedGrid, cursor);
      };
      var resize = Adjustments.adjustWidthTo;
      var TableOperations = {
        insertRowsBefore: run(insertRowsBefore, onCells, noop, noop, Generators.modification),
        insertRowsAfter: run(insertRowsAfter, onCells, noop, noop, Generators.modification),
        insertColumnsBefore: run(insertColumnsBefore, onCells, resize, noop, Generators.modification),
        insertColumnsAfter: run(insertColumnsAfter, onCells, resize, noop, Generators.modification),
        eraseColumns: run(eraseColumns, onCells, resize, prune, Generators.modification),
        eraseRows: run(eraseRows, onCells, noop, prune, Generators.modification),
        mergeCells: run(mergeCells, onMergable, noop, noop, Generators.merging),
        unmergeCells: run(unmergeCells, onUnmergable, resize, noop, Generators.merging),
        pasteCells: run(pasteCells, onPaste, resize, noop, Generators.modification),
        pasteRowsBefore: run(pasteRowsBefore, onPasteRows, noop, noop, Generators.modification),
        pasteRowsAfter: run(pasteRowsAfter, onPasteRows, noop, noop, Generators.modification)
      };
      var getBody$1 = function(editor) {
        return Element2.fromDom(editor.getBody());
      };
      var getPixelWidth$1 = function(elm) {
        return elm.getBoundingClientRect().width;
      };
      var getPixelHeight = function(elm) {
        return elm.getBoundingClientRect().height;
      };
      var getIsRoot = function(editor) {
        return function(element) {
          return eq(element, getBody$1(editor));
        };
      };
      var removePxSuffix = function(size) {
        return size ? size.replace(/px$/, "") : "";
      };
      var addSizeSuffix = function(size) {
        if (/^[0-9]+$/.test(size)) {
          size += "px";
        }
        return size;
      };
      var removeDataStyle = function(table3) {
        var dataStyleCells = descendants$1(table3, "td[data-mce-style],th[data-mce-style]");
        remove2(table3, "data-mce-style");
        each(dataStyleCells, function(cell3) {
          remove2(cell3, "data-mce-style");
        });
      };
      var getDirection = function(element) {
        return get$1(element, "direction") === "rtl" ? "rtl" : "ltr";
      };
      var ltr$1 = { isRtl: constant(false) };
      var rtl$1 = { isRtl: constant(true) };
      var directionAt = function(element) {
        var dir = getDirection(element);
        return dir === "rtl" ? rtl$1 : ltr$1;
      };
      var Direction = { directionAt };
      var defaultTableToolbar = [
        "tableprops",
        "tabledelete",
        "|",
        "tableinsertrowbefore",
        "tableinsertrowafter",
        "tabledeleterow",
        "|",
        "tableinsertcolbefore",
        "tableinsertcolafter",
        "tabledeletecol"
      ];
      var defaultStyles = {
        "border-collapse": "collapse",
        "width": "100%"
      };
      var defaultAttributes = { border: "1" };
      var getDefaultAttributes = function(editor) {
        return editor.getParam("table_default_attributes", defaultAttributes, "object");
      };
      var getDefaultStyles = function(editor) {
        return editor.getParam("table_default_styles", defaultStyles, "object");
      };
      var hasTableResizeBars = function(editor) {
        return editor.getParam("table_resize_bars", true, "boolean");
      };
      var hasTabNavigation = function(editor) {
        return editor.getParam("table_tab_navigation", true, "boolean");
      };
      var hasAdvancedCellTab = function(editor) {
        return editor.getParam("table_cell_advtab", true, "boolean");
      };
      var hasAdvancedRowTab = function(editor) {
        return editor.getParam("table_row_advtab", true, "boolean");
      };
      var hasAdvancedTableTab = function(editor) {
        return editor.getParam("table_advtab", true, "boolean");
      };
      var hasAppearanceOptions = function(editor) {
        return editor.getParam("table_appearance_options", true, "boolean");
      };
      var hasTableGrid = function(editor) {
        return editor.getParam("table_grid", true, "boolean");
      };
      var shouldStyleWithCss = function(editor) {
        return editor.getParam("table_style_by_css", false, "boolean");
      };
      var getCellClassList = function(editor) {
        return editor.getParam("table_cell_class_list", [], "array");
      };
      var getRowClassList = function(editor) {
        return editor.getParam("table_row_class_list", [], "array");
      };
      var getTableClassList = function(editor) {
        return editor.getParam("table_class_list", [], "array");
      };
      var getColorPickerCallback = function(editor) {
        return editor.getParam("color_picker_callback");
      };
      var isPixelsForced = function(editor) {
        return editor.getParam("table_responsive_width") === false;
      };
      var getCloneElements = function(editor) {
        var cloneElements = editor.getParam("table_clone_elements");
        if (isString(cloneElements)) {
          return Option.some(cloneElements.split(/[ ,]/));
        } else if (Array.isArray(cloneElements)) {
          return Option.some(cloneElements);
        } else {
          return Option.none();
        }
      };
      var hasObjectResizing = function(editor) {
        var objectResizing = editor.getParam("object_resizing", true);
        return objectResizing === "table" || objectResizing;
      };
      var getToolbar = function(editor) {
        var toolbar = editor.getParam("table_toolbar", defaultTableToolbar);
        if (toolbar === "" || toolbar === false) {
          return [];
        } else if (isString(toolbar)) {
          return toolbar.split(/[ ,]/);
        } else if (isArray(toolbar)) {
          return toolbar;
        } else {
          return [];
        }
      };
      var fireNewRow = function(editor, row2) {
        return editor.fire("newrow", { node: row2 });
      };
      var fireNewCell = function(editor, cell3) {
        return editor.fire("newcell", { node: cell3 });
      };
      var fireObjectResizeStart = function(editor, target2, width, height2) {
        editor.fire("ObjectResizeStart", {
          target: target2,
          width,
          height: height2
        });
      };
      var fireObjectResized = function(editor, target2, width, height2) {
        editor.fire("ObjectResized", {
          target: target2,
          width,
          height: height2
        });
      };
      var TableActions = function(editor, lazyWire) {
        var isTableBody = function(editor2) {
          return name(getBody$1(editor2)) === "table";
        };
        var lastRowGuard = function(table3) {
          var size = TableGridSize.getGridSize(table3);
          return isTableBody(editor) === false || size.rows() > 1;
        };
        var lastColumnGuard = function(table3) {
          var size = TableGridSize.getGridSize(table3);
          return isTableBody(editor) === false || size.columns() > 1;
        };
        var cloneFormats2 = getCloneElements(editor);
        var execute = function(operation, guard, mutate2, lazyWire2) {
          return function(table3, target2) {
            removeDataStyle(table3);
            var wire = lazyWire2();
            var doc = Element2.fromDom(editor.getDoc());
            var direction = TableDirection(Direction.directionAt);
            var generators = TableFill.cellOperations(mutate2, doc, cloneFormats2);
            return guard(table3) ? operation(wire, table3, target2, generators, direction).bind(function(result) {
              each(result.newRows(), function(row2) {
                fireNewRow(editor, row2.dom());
              });
              each(result.newCells(), function(cell3) {
                fireNewCell(editor, cell3.dom());
              });
              return result.cursor().map(function(cell3) {
                var rng = editor.dom.createRng();
                rng.setStart(cell3.dom(), 0);
                rng.setEnd(cell3.dom(), 0);
                return rng;
              });
            }) : Option.none();
          };
        };
        var deleteRow = execute(TableOperations.eraseRows, lastRowGuard, noop, lazyWire);
        var deleteColumn = execute(TableOperations.eraseColumns, lastColumnGuard, noop, lazyWire);
        var insertRowsBefore2 = execute(TableOperations.insertRowsBefore, always, noop, lazyWire);
        var insertRowsAfter2 = execute(TableOperations.insertRowsAfter, always, noop, lazyWire);
        var insertColumnsBefore2 = execute(TableOperations.insertColumnsBefore, always, CellMutations.halve, lazyWire);
        var insertColumnsAfter2 = execute(TableOperations.insertColumnsAfter, always, CellMutations.halve, lazyWire);
        var mergeCells2 = execute(TableOperations.mergeCells, always, noop, lazyWire);
        var unmergeCells2 = execute(TableOperations.unmergeCells, always, noop, lazyWire);
        var pasteRowsBefore2 = execute(TableOperations.pasteRowsBefore, always, noop, lazyWire);
        var pasteRowsAfter2 = execute(TableOperations.pasteRowsAfter, always, noop, lazyWire);
        var pasteCells2 = execute(TableOperations.pasteCells, always, noop, lazyWire);
        return {
          deleteRow,
          deleteColumn,
          insertRowsBefore: insertRowsBefore2,
          insertRowsAfter: insertRowsAfter2,
          insertColumnsBefore: insertColumnsBefore2,
          insertColumnsAfter: insertColumnsAfter2,
          mergeCells: mergeCells2,
          unmergeCells: unmergeCells2,
          pasteRowsBefore: pasteRowsBefore2,
          pasteRowsAfter: pasteRowsAfter2,
          pasteCells: pasteCells2
        };
      };
      var copyRows = function(table3, target2, generators) {
        var list2 = DetailsList.fromTable(table3);
        var house = Warehouse.generate(list2);
        var details = onCells(house, target2);
        return details.map(function(selectedCells) {
          var grid2 = Transitions.toGrid(house, generators, false);
          var slicedGrid = grid2.slice(selectedCells[0].row(), selectedCells[selectedCells.length - 1].row() + selectedCells[selectedCells.length - 1].rowspan());
          var slicedDetails = toDetailList(slicedGrid, generators);
          return Redraw.copy(slicedDetails);
        });
      };
      var CopyRows = { copyRows };
      var global$1 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var getTDTHOverallStyle = function(dom, elm, name2) {
        var cells2 = dom.select("td,th", elm);
        var firstChildStyle;
        var checkChildren = function(firstChildStyle2, elms) {
          for (var i = 0; i < elms.length; i++) {
            var currentStyle = dom.getStyle(elms[i], name2);
            if (typeof firstChildStyle2 === "undefined") {
              firstChildStyle2 = currentStyle;
            }
            if (firstChildStyle2 !== currentStyle) {
              return "";
            }
          }
          return firstChildStyle2;
        };
        firstChildStyle = checkChildren(firstChildStyle, cells2);
        return firstChildStyle;
      };
      var applyAlign = function(editor, elm, name2) {
        if (name2) {
          editor.formatter.apply("align" + name2, {}, elm);
        }
      };
      var applyVAlign = function(editor, elm, name2) {
        if (name2) {
          editor.formatter.apply("valign" + name2, {}, elm);
        }
      };
      var unApplyAlign = function(editor, elm) {
        global$1.each("left center right".split(" "), function(name2) {
          editor.formatter.remove("align" + name2, {}, elm);
        });
      };
      var unApplyVAlign = function(editor, elm) {
        global$1.each("top middle bottom".split(" "), function(name2) {
          editor.formatter.remove("valign" + name2, {}, elm);
        });
      };
      var Styles$1 = {
        applyAlign,
        applyVAlign,
        unApplyAlign,
        unApplyVAlign,
        getTDTHOverallStyle
      };
      var buildListItems = function(inputList, itemCallback, startItems) {
        var appendItems = function(values, output2) {
          output2 = output2 || [];
          global$1.each(values, function(item) {
            var menuItem = { text: item.text || item.title };
            if (item.menu) {
              menuItem.menu = appendItems(item.menu);
            } else {
              menuItem.value = item.value;
              if (itemCallback) {
                itemCallback(menuItem);
              }
            }
            output2.push(menuItem);
          });
          return output2;
        };
        return appendItems(inputList, startItems || []);
      };
      function styleFieldHasFocus(e) {
        return e.control.rootControl.find("#style")[0].getEl().isEqualNode(domGlobals.document.activeElement);
      }
      var syncAdvancedStyleFields = function(editor, evt) {
        if (styleFieldHasFocus(evt)) {
          updateAdvancedFields(editor, evt);
        } else {
          updateStyleField(editor, evt);
        }
      };
      var updateStyleField = function(editor, evt) {
        var dom = editor.dom;
        var rootControl = evt.control.rootControl;
        var data = rootControl.toJSON();
        var css3 = dom.parseStyle(data.style);
        css3["border-style"] = data.borderStyle;
        css3["border-color"] = data.borderColor;
        css3["background-color"] = data.backgroundColor;
        css3.width = data.width ? addSizeSuffix(data.width) : "";
        css3.height = data.height ? addSizeSuffix(data.height) : "";
        rootControl.find("#style").value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css3))));
      };
      var updateAdvancedFields = function(editor, evt) {
        var dom = editor.dom;
        var rootControl = evt.control.rootControl;
        var data = rootControl.toJSON();
        var css3 = dom.parseStyle(data.style);
        rootControl.find("#borderStyle").value(css3["border-style"] || "");
        rootControl.find("#borderColor").value(css3["border-color"] || "");
        rootControl.find("#backgroundColor").value(css3["background-color"] || "");
        rootControl.find("#width").value(css3.width || "");
        rootControl.find("#height").value(css3.height || "");
      };
      var extractAdvancedStyles = function(dom, elm) {
        var css3 = dom.parseStyle(dom.getAttrib(elm, "style"));
        var data = {};
        if (css3["border-style"]) {
          data.borderStyle = css3["border-style"];
        }
        if (css3["border-color"]) {
          data.borderColor = css3["border-color"];
        }
        if (css3["background-color"]) {
          data.backgroundColor = css3["background-color"];
        }
        data.style = dom.serializeStyle(css3);
        return data;
      };
      var createStyleForm = function(editor) {
        var createColorPickAction = function() {
          var colorPickerCallback = getColorPickerCallback(editor);
          if (colorPickerCallback) {
            return function(evt) {
              return colorPickerCallback.call(editor, function(value2) {
                evt.control.value(value2).fire("change");
              }, evt.control.value());
            };
          }
        };
        return {
          title: "Advanced",
          type: "form",
          defaults: { onchange: curry(updateStyleField, editor) },
          items: [
            {
              label: "Style",
              name: "style",
              type: "textbox",
              onchange: curry(updateAdvancedFields, editor)
            },
            {
              type: "form",
              padding: 0,
              formItemDefaults: {
                layout: "grid",
                alignH: [
                  "start",
                  "right"
                ]
              },
              defaults: { size: 7 },
              items: [
                {
                  label: "Border style",
                  type: "listbox",
                  name: "borderStyle",
                  width: 90,
                  onselect: curry(updateStyleField, editor),
                  values: [
                    {
                      text: "Select...",
                      value: ""
                    },
                    {
                      text: "Solid",
                      value: "solid"
                    },
                    {
                      text: "Dotted",
                      value: "dotted"
                    },
                    {
                      text: "Dashed",
                      value: "dashed"
                    },
                    {
                      text: "Double",
                      value: "double"
                    },
                    {
                      text: "Groove",
                      value: "groove"
                    },
                    {
                      text: "Ridge",
                      value: "ridge"
                    },
                    {
                      text: "Inset",
                      value: "inset"
                    },
                    {
                      text: "Outset",
                      value: "outset"
                    },
                    {
                      text: "None",
                      value: "none"
                    },
                    {
                      text: "Hidden",
                      value: "hidden"
                    }
                  ]
                },
                {
                  label: "Border color",
                  type: "colorbox",
                  name: "borderColor",
                  onaction: createColorPickAction()
                },
                {
                  label: "Background color",
                  type: "colorbox",
                  name: "backgroundColor",
                  onaction: createColorPickAction()
                }
              ]
            }
          ]
        };
      };
      var Helpers = {
        createStyleForm,
        buildListItems,
        updateStyleField,
        extractAdvancedStyles,
        updateAdvancedFields,
        syncAdvancedStyleFields
      };
      var updateStyles = function(elm, cssText) {
        delete elm.dataset.mceStyle;
        elm.style.cssText += ";" + cssText;
      };
      var extractDataFromElement = function(editor, elm) {
        var dom = editor.dom;
        var data = {
          width: dom.getStyle(elm, "width") || dom.getAttrib(elm, "width"),
          height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
          scope: dom.getAttrib(elm, "scope"),
          class: dom.getAttrib(elm, "class"),
          type: elm.nodeName.toLowerCase(),
          style: "",
          align: "",
          valign: ""
        };
        global$1.each("left center right".split(" "), function(name2) {
          if (editor.formatter.matchNode(elm, "align" + name2)) {
            data.align = name2;
          }
        });
        global$1.each("top middle bottom".split(" "), function(name2) {
          if (editor.formatter.matchNode(elm, "valign" + name2)) {
            data.valign = name2;
          }
        });
        if (hasAdvancedCellTab(editor)) {
          global$1.extend(data, Helpers.extractAdvancedStyles(dom, elm));
        }
        return data;
      };
      var onSubmitCellForm = function(editor, cells2, evt) {
        var dom = editor.dom;
        var data;
        function setAttrib(elm, name2, value2) {
          if (cells2.length === 1 || value2) {
            dom.setAttrib(elm, name2, value2);
          }
        }
        function setStyle(elm, name2, value2) {
          if (cells2.length === 1 || value2) {
            dom.setStyle(elm, name2, value2);
          }
        }
        if (hasAdvancedCellTab(editor)) {
          Helpers.syncAdvancedStyleFields(editor, evt);
        }
        data = evt.control.rootControl.toJSON();
        editor.undoManager.transact(function() {
          global$1.each(cells2, function(cellElm) {
            setAttrib(cellElm, "scope", data.scope);
            if (cells2.length === 1) {
              setAttrib(cellElm, "style", data.style);
            } else {
              updateStyles(cellElm, data.style);
            }
            setAttrib(cellElm, "class", data.class);
            setStyle(cellElm, "width", addSizeSuffix(data.width));
            setStyle(cellElm, "height", addSizeSuffix(data.height));
            if (data.type && cellElm.nodeName.toLowerCase() !== data.type) {
              cellElm = dom.rename(cellElm, data.type);
            }
            if (cells2.length === 1) {
              Styles$1.unApplyAlign(editor, cellElm);
              Styles$1.unApplyVAlign(editor, cellElm);
            }
            if (data.align) {
              Styles$1.applyAlign(editor, cellElm, data.align);
            }
            if (data.valign) {
              Styles$1.applyVAlign(editor, cellElm, data.valign);
            }
          });
          editor.focus();
        });
      };
      var open = function(editor) {
        var cellElm, data, classListCtrl, cells2 = [];
        cells2 = editor.dom.select("td[data-mce-selected],th[data-mce-selected]");
        cellElm = editor.dom.getParent(editor.selection.getStart(), "td,th");
        if (!cells2.length && cellElm) {
          cells2.push(cellElm);
        }
        cellElm = cellElm || cells2[0];
        if (!cellElm) {
          return;
        }
        if (cells2.length > 1) {
          data = {
            width: "",
            height: "",
            scope: "",
            class: "",
            align: "",
            valign: "",
            style: "",
            type: cellElm.nodeName.toLowerCase()
          };
        } else {
          data = extractDataFromElement(editor, cellElm);
        }
        if (getCellClassList(editor).length > 0) {
          classListCtrl = {
            name: "class",
            type: "listbox",
            label: "Class",
            values: Helpers.buildListItems(getCellClassList(editor), function(item) {
              if (item.value) {
                item.textStyle = function() {
                  return editor.formatter.getCssText({
                    block: "td",
                    classes: [item.value]
                  });
                };
              }
            })
          };
        }
        var generalCellForm = {
          type: "form",
          layout: "flex",
          direction: "column",
          labelGapCalc: "children",
          padding: 0,
          items: [
            {
              type: "form",
              layout: "grid",
              columns: 2,
              labelGapCalc: false,
              padding: 0,
              defaults: {
                type: "textbox",
                maxWidth: 50
              },
              items: [
                {
                  label: "Width",
                  name: "width",
                  onchange: curry(Helpers.updateStyleField, editor)
                },
                {
                  label: "Height",
                  name: "height",
                  onchange: curry(Helpers.updateStyleField, editor)
                },
                {
                  label: "Cell type",
                  name: "type",
                  type: "listbox",
                  text: "None",
                  minWidth: 90,
                  maxWidth: null,
                  values: [
                    {
                      text: "Cell",
                      value: "td"
                    },
                    {
                      text: "Header cell",
                      value: "th"
                    }
                  ]
                },
                {
                  label: "Scope",
                  name: "scope",
                  type: "listbox",
                  text: "None",
                  minWidth: 90,
                  maxWidth: null,
                  values: [
                    {
                      text: "None",
                      value: ""
                    },
                    {
                      text: "Row",
                      value: "row"
                    },
                    {
                      text: "Column",
                      value: "col"
                    },
                    {
                      text: "Row group",
                      value: "rowgroup"
                    },
                    {
                      text: "Column group",
                      value: "colgroup"
                    }
                  ]
                },
                {
                  label: "H Align",
                  name: "align",
                  type: "listbox",
                  text: "None",
                  minWidth: 90,
                  maxWidth: null,
                  values: [
                    {
                      text: "None",
                      value: ""
                    },
                    {
                      text: "Left",
                      value: "left"
                    },
                    {
                      text: "Center",
                      value: "center"
                    },
                    {
                      text: "Right",
                      value: "right"
                    }
                  ]
                },
                {
                  label: "V Align",
                  name: "valign",
                  type: "listbox",
                  text: "None",
                  minWidth: 90,
                  maxWidth: null,
                  values: [
                    {
                      text: "None",
                      value: ""
                    },
                    {
                      text: "Top",
                      value: "top"
                    },
                    {
                      text: "Middle",
                      value: "middle"
                    },
                    {
                      text: "Bottom",
                      value: "bottom"
                    }
                  ]
                }
              ]
            },
            classListCtrl
          ]
        };
        if (hasAdvancedCellTab(editor)) {
          editor.windowManager.open({
            title: "Cell properties",
            bodyType: "tabpanel",
            data,
            body: [
              {
                title: "General",
                type: "form",
                items: generalCellForm
              },
              Helpers.createStyleForm(editor)
            ],
            onsubmit: curry(onSubmitCellForm, editor, cells2)
          });
        } else {
          editor.windowManager.open({
            title: "Cell properties",
            data,
            body: generalCellForm,
            onsubmit: curry(onSubmitCellForm, editor, cells2)
          });
        }
      };
      var CellDialog = { open };
      var extractDataFromElement$1 = function(editor, elm) {
        var dom = editor.dom;
        var data = {
          height: dom.getStyle(elm, "height") || dom.getAttrib(elm, "height"),
          scope: dom.getAttrib(elm, "scope"),
          class: dom.getAttrib(elm, "class"),
          align: "",
          style: "",
          type: elm.parentNode.nodeName.toLowerCase()
        };
        global$1.each("left center right".split(" "), function(name2) {
          if (editor.formatter.matchNode(elm, "align" + name2)) {
            data.align = name2;
          }
        });
        if (hasAdvancedRowTab(editor)) {
          global$1.extend(data, Helpers.extractAdvancedStyles(dom, elm));
        }
        return data;
      };
      var switchRowType = function(dom, rowElm, toType) {
        var tableElm = dom.getParent(rowElm, "table");
        var oldParentElm = rowElm.parentNode;
        var parentElm = dom.select(toType, tableElm)[0];
        if (!parentElm) {
          parentElm = dom.create(toType);
          if (tableElm.firstChild) {
            if (tableElm.firstChild.nodeName === "CAPTION") {
              dom.insertAfter(parentElm, tableElm.firstChild);
            } else {
              tableElm.insertBefore(parentElm, tableElm.firstChild);
            }
          } else {
            tableElm.appendChild(parentElm);
          }
        }
        parentElm.appendChild(rowElm);
        if (!oldParentElm.hasChildNodes()) {
          dom.remove(oldParentElm);
        }
      };
      function onSubmitRowForm(editor, rows2, oldData, evt) {
        var dom = editor.dom;
        function setAttrib(elm, name2, value2) {
          if (rows2.length === 1 || value2) {
            dom.setAttrib(elm, name2, value2);
          }
        }
        function setStyle(elm, name2, value2) {
          if (rows2.length === 1 || value2) {
            dom.setStyle(elm, name2, value2);
          }
        }
        if (hasAdvancedRowTab(editor)) {
          Helpers.syncAdvancedStyleFields(editor, evt);
        }
        var data = evt.control.rootControl.toJSON();
        editor.undoManager.transact(function() {
          global$1.each(rows2, function(rowElm) {
            setAttrib(rowElm, "scope", data.scope);
            setAttrib(rowElm, "style", data.style);
            setAttrib(rowElm, "class", data.class);
            setStyle(rowElm, "height", addSizeSuffix(data.height));
            if (data.type !== rowElm.parentNode.nodeName.toLowerCase()) {
              switchRowType(editor.dom, rowElm, data.type);
            }
            if (data.align !== oldData.align) {
              Styles$1.unApplyAlign(editor, rowElm);
              Styles$1.applyAlign(editor, rowElm, data.align);
            }
          });
          editor.focus();
        });
      }
      var open$1 = function(editor) {
        var dom = editor.dom;
        var tableElm, cellElm, rowElm, classListCtrl, data;
        var rows2 = [];
        var generalRowForm;
        tableElm = dom.getParent(editor.selection.getStart(), "table");
        cellElm = dom.getParent(editor.selection.getStart(), "td,th");
        global$1.each(tableElm.rows, function(row2) {
          global$1.each(row2.cells, function(cell3) {
            if (dom.getAttrib(cell3, "data-mce-selected") || cell3 === cellElm) {
              rows2.push(row2);
              return false;
            }
          });
        });
        rowElm = rows2[0];
        if (!rowElm) {
          return;
        }
        if (rows2.length > 1) {
          data = {
            height: "",
            scope: "",
            style: "",
            class: "",
            align: "",
            type: rowElm.parentNode.nodeName.toLowerCase()
          };
        } else {
          data = extractDataFromElement$1(editor, rowElm);
        }
        if (getRowClassList(editor).length > 0) {
          classListCtrl = {
            name: "class",
            type: "listbox",
            label: "Class",
            values: Helpers.buildListItems(getRowClassList(editor), function(item) {
              if (item.value) {
                item.textStyle = function() {
                  return editor.formatter.getCssText({
                    block: "tr",
                    classes: [item.value]
                  });
                };
              }
            })
          };
        }
        generalRowForm = {
          type: "form",
          columns: 2,
          padding: 0,
          defaults: { type: "textbox" },
          items: [
            {
              type: "listbox",
              name: "type",
              label: "Row type",
              text: "Header",
              maxWidth: null,
              values: [
                {
                  text: "Header",
                  value: "thead"
                },
                {
                  text: "Body",
                  value: "tbody"
                },
                {
                  text: "Footer",
                  value: "tfoot"
                }
              ]
            },
            {
              type: "listbox",
              name: "align",
              label: "Alignment",
              text: "None",
              maxWidth: null,
              values: [
                {
                  text: "None",
                  value: ""
                },
                {
                  text: "Left",
                  value: "left"
                },
                {
                  text: "Center",
                  value: "center"
                },
                {
                  text: "Right",
                  value: "right"
                }
              ]
            },
            {
              label: "Height",
              name: "height"
            },
            classListCtrl
          ]
        };
        if (hasAdvancedRowTab(editor)) {
          editor.windowManager.open({
            title: "Row properties",
            data,
            bodyType: "tabpanel",
            body: [
              {
                title: "General",
                type: "form",
                items: generalRowForm
              },
              Helpers.createStyleForm(editor)
            ],
            onsubmit: curry(onSubmitRowForm, editor, rows2, data)
          });
        } else {
          editor.windowManager.open({
            title: "Row properties",
            data,
            body: generalRowForm,
            onsubmit: curry(onSubmitRowForm, editor, rows2, data)
          });
        }
      };
      var RowDialog = { open: open$1 };
      var global$2 = tinymce.util.Tools.resolve("tinymce.Env");
      var DefaultRenderOptions = {
        styles: {
          "border-collapse": "collapse",
          "width": "100%"
        },
        attributes: { border: "1" },
        percentages: true
      };
      var makeTable = function() {
        return Element2.fromTag("table");
      };
      var tableBody = function() {
        return Element2.fromTag("tbody");
      };
      var tableRow = function() {
        return Element2.fromTag("tr");
      };
      var tableHeaderCell = function() {
        return Element2.fromTag("th");
      };
      var tableCell = function() {
        return Element2.fromTag("td");
      };
      var render$1 = function(rows2, columns2, rowHeaders, columnHeaders, renderOpts) {
        if (renderOpts === void 0) {
          renderOpts = DefaultRenderOptions;
        }
        var table3 = makeTable();
        setAll$1(table3, renderOpts.styles);
        setAll(table3, renderOpts.attributes);
        var tbody = tableBody();
        append(table3, tbody);
        var trs = [];
        for (var i = 0; i < rows2; i++) {
          var tr = tableRow();
          for (var j = 0; j < columns2; j++) {
            var td = i < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
            if (j < columnHeaders) {
              set(td, "scope", "row");
            }
            if (i < rowHeaders) {
              set(td, "scope", "col");
            }
            append(td, Element2.fromTag("br"));
            if (renderOpts.percentages) {
              set$1(td, "width", 100 / columns2 + "%");
            }
            append(tr, td);
          }
          trs.push(tr);
        }
        append$1(tbody, trs);
        return table3;
      };
      var get$7 = function(element) {
        return element.dom().innerHTML;
      };
      var getOuter$2 = function(element) {
        var container = Element2.fromTag("div");
        var clone2 = Element2.fromDom(element.dom().cloneNode(true));
        append(container, clone2);
        return get$7(container);
      };
      var placeCaretInCell = function(editor, cell3) {
        editor.selection.select(cell3.dom(), true);
        editor.selection.collapse(true);
      };
      var selectFirstCellInTable = function(editor, tableElm) {
        descendant$1(tableElm, "td,th").each(curry(placeCaretInCell, editor));
      };
      var fireEvents = function(editor, table3) {
        each(descendants$1(table3, "tr"), function(row2) {
          fireNewRow(editor, row2.dom());
          each(descendants$1(row2, "th,td"), function(cell3) {
            fireNewCell(editor, cell3.dom());
          });
        });
      };
      var isPercentage = function(width) {
        return isString(width) && width.indexOf("%") !== -1;
      };
      var insert$1 = function(editor, columns2, rows2) {
        var defaultStyles2 = getDefaultStyles(editor);
        var options2 = {
          styles: defaultStyles2,
          attributes: getDefaultAttributes(editor),
          percentages: isPercentage(defaultStyles2.width) && !isPixelsForced(editor)
        };
        var table3 = render$1(rows2, columns2, 0, 0, options2);
        set(table3, "data-mce-id", "__mce");
        var html2 = getOuter$2(table3);
        editor.insertContent(html2);
        return descendant$1(getBody$1(editor), 'table[data-mce-id="__mce"]').map(function(table4) {
          if (isPixelsForced(editor)) {
            set$1(table4, "width", get$1(table4, "width"));
          }
          remove2(table4, "data-mce-id");
          fireEvents(editor, table4);
          selectFirstCellInTable(editor, table4);
          return table4.dom();
        }).getOr(null);
      };
      var InsertTable = { insert: insert$1 };
      function styleTDTH(dom, elm, name2, value2) {
        if (elm.tagName === "TD" || elm.tagName === "TH") {
          dom.setStyle(elm, name2, value2);
        } else {
          if (elm.children) {
            for (var i = 0; i < elm.children.length; i++) {
              styleTDTH(dom, elm.children[i], name2, value2);
            }
          }
        }
      }
      var extractDataFromElement$2 = function(editor, tableElm) {
        var dom = editor.dom;
        var data = {
          width: dom.getStyle(tableElm, "width") || dom.getAttrib(tableElm, "width"),
          height: dom.getStyle(tableElm, "height") || dom.getAttrib(tableElm, "height"),
          cellspacing: dom.getStyle(tableElm, "border-spacing") || dom.getAttrib(tableElm, "cellspacing"),
          cellpadding: dom.getAttrib(tableElm, "data-mce-cell-padding") || dom.getAttrib(tableElm, "cellpadding") || Styles$1.getTDTHOverallStyle(editor.dom, tableElm, "padding"),
          border: dom.getAttrib(tableElm, "data-mce-border") || dom.getAttrib(tableElm, "border") || Styles$1.getTDTHOverallStyle(editor.dom, tableElm, "border"),
          borderColor: dom.getAttrib(tableElm, "data-mce-border-color"),
          caption: !!dom.select("caption", tableElm)[0],
          class: dom.getAttrib(tableElm, "class")
        };
        global$1.each("left center right".split(" "), function(name2) {
          if (editor.formatter.matchNode(tableElm, "align" + name2)) {
            data.align = name2;
          }
        });
        if (hasAdvancedTableTab(editor)) {
          global$1.extend(data, Helpers.extractAdvancedStyles(dom, tableElm));
        }
        return data;
      };
      var applyDataToElement = function(editor, tableElm, data) {
        var dom = editor.dom;
        var attrs = {};
        var styles2 = {};
        attrs.class = data.class;
        styles2.height = addSizeSuffix(data.height);
        if (dom.getAttrib(tableElm, "width") && !shouldStyleWithCss(editor)) {
          attrs.width = removePxSuffix(data.width);
        } else {
          styles2.width = addSizeSuffix(data.width);
        }
        if (shouldStyleWithCss(editor)) {
          styles2["border-width"] = addSizeSuffix(data.border);
          styles2["border-spacing"] = addSizeSuffix(data.cellspacing);
          global$1.extend(attrs, {
            "data-mce-border-color": data.borderColor,
            "data-mce-cell-padding": data.cellpadding,
            "data-mce-border": data.border
          });
        } else {
          global$1.extend(attrs, {
            border: data.border,
            cellpadding: data.cellpadding,
            cellspacing: data.cellspacing
          });
        }
        if (shouldStyleWithCss(editor)) {
          if (tableElm.children) {
            for (var i = 0; i < tableElm.children.length; i++) {
              styleTDTH(dom, tableElm.children[i], {
                "border-width": addSizeSuffix(data.border),
                "border-color": data.borderColor,
                "padding": addSizeSuffix(data.cellpadding)
              });
            }
          }
        }
        if (data.style) {
          global$1.extend(styles2, dom.parseStyle(data.style));
        } else {
          styles2 = global$1.extend({}, dom.parseStyle(dom.getAttrib(tableElm, "style")), styles2);
        }
        attrs.style = dom.serializeStyle(styles2);
        dom.setAttribs(tableElm, attrs);
      };
      var onSubmitTableForm = function(editor, tableElm, evt) {
        var dom = editor.dom;
        var captionElm;
        var data;
        if (hasAdvancedTableTab(editor)) {
          Helpers.syncAdvancedStyleFields(editor, evt);
        }
        data = evt.control.rootControl.toJSON();
        if (data.class === false) {
          delete data.class;
        }
        editor.undoManager.transact(function() {
          if (!tableElm) {
            tableElm = InsertTable.insert(editor, data.cols || 1, data.rows || 1);
          }
          applyDataToElement(editor, tableElm, data);
          captionElm = dom.select("caption", tableElm)[0];
          if (captionElm && !data.caption) {
            dom.remove(captionElm);
          }
          if (!captionElm && data.caption) {
            captionElm = dom.create("caption");
            captionElm.innerHTML = !global$2.ie ? '<br data-mce-bogus="1"/>' : "Â ";
            tableElm.insertBefore(captionElm, tableElm.firstChild);
          }
          Styles$1.unApplyAlign(editor, tableElm);
          if (data.align) {
            Styles$1.applyAlign(editor, tableElm, data.align);
          }
          editor.focus();
          editor.addVisual();
        });
      };
      var open$2 = function(editor, isProps) {
        var dom = editor.dom;
        var tableElm, colsCtrl, rowsCtrl, classListCtrl, data = {}, generalTableForm;
        if (isProps === true) {
          tableElm = dom.getParent(editor.selection.getStart(), "table");
          if (tableElm) {
            data = extractDataFromElement$2(editor, tableElm);
          }
        } else {
          colsCtrl = {
            label: "Cols",
            name: "cols"
          };
          rowsCtrl = {
            label: "Rows",
            name: "rows"
          };
        }
        if (getTableClassList(editor).length > 0) {
          if (data.class) {
            data.class = data.class.replace(/\s*mce\-item\-table\s*/g, "");
          }
          classListCtrl = {
            name: "class",
            type: "listbox",
            label: "Class",
            values: Helpers.buildListItems(getTableClassList(editor), function(item) {
              if (item.value) {
                item.textStyle = function() {
                  return editor.formatter.getCssText({
                    block: "table",
                    classes: [item.value]
                  });
                };
              }
            })
          };
        }
        generalTableForm = {
          type: "form",
          layout: "flex",
          direction: "column",
          labelGapCalc: "children",
          padding: 0,
          items: [
            {
              type: "form",
              labelGapCalc: false,
              padding: 0,
              layout: "grid",
              columns: 2,
              defaults: {
                type: "textbox",
                maxWidth: 50
              },
              items: hasAppearanceOptions(editor) ? [
                colsCtrl,
                rowsCtrl,
                {
                  label: "Width",
                  name: "width",
                  onchange: curry(Helpers.updateStyleField, editor)
                },
                {
                  label: "Height",
                  name: "height",
                  onchange: curry(Helpers.updateStyleField, editor)
                },
                {
                  label: "Cell spacing",
                  name: "cellspacing"
                },
                {
                  label: "Cell padding",
                  name: "cellpadding"
                },
                {
                  label: "Border",
                  name: "border"
                },
                {
                  label: "Caption",
                  name: "caption",
                  type: "checkbox"
                }
              ] : [
                colsCtrl,
                rowsCtrl,
                {
                  label: "Width",
                  name: "width",
                  onchange: curry(Helpers.updateStyleField, editor)
                },
                {
                  label: "Height",
                  name: "height",
                  onchange: curry(Helpers.updateStyleField, editor)
                }
              ]
            },
            {
              label: "Alignment",
              name: "align",
              type: "listbox",
              text: "None",
              values: [
                {
                  text: "None",
                  value: ""
                },
                {
                  text: "Left",
                  value: "left"
                },
                {
                  text: "Center",
                  value: "center"
                },
                {
                  text: "Right",
                  value: "right"
                }
              ]
            },
            classListCtrl
          ]
        };
        if (hasAdvancedTableTab(editor)) {
          editor.windowManager.open({
            title: "Table properties",
            data,
            bodyType: "tabpanel",
            body: [
              {
                title: "General",
                type: "form",
                items: generalTableForm
              },
              Helpers.createStyleForm(editor)
            ],
            onsubmit: curry(onSubmitTableForm, editor, tableElm)
          });
        } else {
          editor.windowManager.open({
            title: "Table properties",
            data,
            body: generalTableForm,
            onsubmit: curry(onSubmitTableForm, editor, tableElm)
          });
        }
      };
      var TableDialog = { open: open$2 };
      var each$3 = global$1.each;
      var registerCommands = function(editor, actions, cellSelection, selections, clipboardRows) {
        var isRoot = getIsRoot(editor);
        var eraseTable = function() {
          getSelectionStartCell().orThunk(getSelectionStartCaption).each(function(cellOrCaption) {
            var table3 = TableLookup.table(cellOrCaption, isRoot);
            table3.filter(not2(isRoot)).each(function(table4) {
              var cursor = Element2.fromText("");
              after(table4, cursor);
              remove$2(table4);
              var rng = editor.dom.createRng();
              rng.setStart(cursor.dom(), 0);
              rng.setEnd(cursor.dom(), 0);
              editor.selection.setRng(rng);
            });
          });
        };
        var getSelectionStartFromSelector = function(selector) {
          return function() {
            return Option.from(editor.dom.getParent(editor.selection.getStart(), selector)).map(Element2.fromDom);
          };
        };
        var getSelectionStartCaption = getSelectionStartFromSelector("caption");
        var getSelectionStartCell = getSelectionStartFromSelector("th,td");
        var getTableFromCell = function(cell3) {
          return TableLookup.table(cell3, isRoot);
        };
        var getSize = function(table3) {
          return {
            width: getPixelWidth$1(table3.dom()),
            height: getPixelWidth$1(table3.dom())
          };
        };
        var resizeChange = function(editor2, oldSize, table3) {
          var newSize = getSize(table3);
          if (oldSize.width !== newSize.width || oldSize.height !== newSize.height) {
            fireObjectResizeStart(editor2, table3.dom(), oldSize.width, oldSize.height);
            fireObjectResized(editor2, table3.dom(), newSize.width, newSize.height);
          }
        };
        var actOnSelection = function(execute) {
          getSelectionStartCell().each(function(cell3) {
            getTableFromCell(cell3).each(function(table3) {
              var targets = TableTargets.forMenu(selections, table3, cell3);
              var beforeSize = getSize(table3);
              execute(table3, targets).each(function(rng) {
                resizeChange(editor, beforeSize, table3);
                editor.selection.setRng(rng);
                editor.focus();
                cellSelection.clear(table3);
                removeDataStyle(table3);
              });
            });
          });
        };
        var copyRowSelection = function(execute) {
          return getSelectionStartCell().bind(function(cell3) {
            return getTableFromCell(cell3).bind(function(table3) {
              var doc = Element2.fromDom(editor.getDoc());
              var targets = TableTargets.forMenu(selections, table3, cell3);
              var generators = TableFill.cellOperations(noop, doc, Option.none());
              return CopyRows.copyRows(table3, targets, generators);
            });
          });
        };
        var pasteOnSelection = function(execute) {
          clipboardRows.get().each(function(rows2) {
            var clonedRows = map2(rows2, function(row2) {
              return deep(row2);
            });
            getSelectionStartCell().each(function(cell3) {
              getTableFromCell(cell3).each(function(table3) {
                var doc = Element2.fromDom(editor.getDoc());
                var generators = TableFill.paste(doc);
                var targets = TableTargets.pasteRows(selections, table3, cell3, clonedRows, generators);
                execute(table3, targets).each(function(rng) {
                  editor.selection.setRng(rng);
                  editor.focus();
                  cellSelection.clear(table3);
                });
              });
            });
          });
        };
        each$3({
          mceTableSplitCells: function() {
            actOnSelection(actions.unmergeCells);
          },
          mceTableMergeCells: function() {
            actOnSelection(actions.mergeCells);
          },
          mceTableInsertRowBefore: function() {
            actOnSelection(actions.insertRowsBefore);
          },
          mceTableInsertRowAfter: function() {
            actOnSelection(actions.insertRowsAfter);
          },
          mceTableInsertColBefore: function() {
            actOnSelection(actions.insertColumnsBefore);
          },
          mceTableInsertColAfter: function() {
            actOnSelection(actions.insertColumnsAfter);
          },
          mceTableDeleteCol: function() {
            actOnSelection(actions.deleteColumn);
          },
          mceTableDeleteRow: function() {
            actOnSelection(actions.deleteRow);
          },
          mceTableCutRow: function(grid2) {
            clipboardRows.set(copyRowSelection());
            actOnSelection(actions.deleteRow);
          },
          mceTableCopyRow: function(grid2) {
            clipboardRows.set(copyRowSelection());
          },
          mceTablePasteRowBefore: function(grid2) {
            pasteOnSelection(actions.pasteRowsBefore);
          },
          mceTablePasteRowAfter: function(grid2) {
            pasteOnSelection(actions.pasteRowsAfter);
          },
          mceTableDelete: eraseTable
        }, function(func, name2) {
          editor.addCommand(name2, func);
        });
        each$3({
          mceInsertTable: curry(TableDialog.open, editor),
          mceTableProps: curry(TableDialog.open, editor, true),
          mceTableRowProps: curry(RowDialog.open, editor),
          mceTableCellProps: curry(CellDialog.open, editor)
        }, function(func, name2) {
          editor.addCommand(name2, function(ui, val) {
            func(val);
          });
        });
      };
      var Commands = { registerCommands };
      var only = function(element) {
        var parent2 = Option.from(element.dom().documentElement).map(Element2.fromDom).getOr(element);
        return {
          parent: constant(parent2),
          view: constant(element),
          origin: constant(Position(0, 0))
        };
      };
      var detached = function(editable, chrome2) {
        var origin = function() {
          return absolute(chrome2);
        };
        return {
          parent: constant(chrome2),
          view: constant(editable),
          origin
        };
      };
      var body$1 = function(editable, chrome2) {
        return {
          parent: constant(chrome2),
          view: constant(editable),
          origin: constant(Position(0, 0))
        };
      };
      var ResizeWire = {
        only,
        detached,
        body: body$1
      };
      var Event = function(fields) {
        var struct = Immutable.apply(null, fields);
        var handlers = [];
        var bind2 = function(handler) {
          if (handler === void 0) {
            throw new Error("Event bind error: undefined handler");
          }
          handlers.push(handler);
        };
        var unbind2 = function(handler) {
          handlers = filter(handlers, function(h) {
            return h !== handler;
          });
        };
        var trigger = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var event = struct.apply(null, args);
          each(handlers, function(handler) {
            handler(event);
          });
        };
        return {
          bind: bind2,
          unbind: unbind2,
          trigger
        };
      };
      var create$1 = function(typeDefs) {
        var registry = map$12(typeDefs, function(event) {
          return {
            bind: event.bind,
            unbind: event.unbind
          };
        });
        var trigger = map$12(typeDefs, function(event) {
          return event.trigger;
        });
        return {
          registry,
          trigger
        };
      };
      var Events = { create: create$1 };
      var mkEvent = function(target2, x, y, stop, prevent, kill, raw) {
        return {
          target: constant(target2),
          x: constant(x),
          y: constant(y),
          stop,
          prevent,
          kill,
          raw: constant(raw)
        };
      };
      var handle = function(filter2, handler) {
        return function(rawEvent) {
          if (!filter2(rawEvent)) {
            return;
          }
          var target2 = Element2.fromDom(rawEvent.target);
          var stop = function() {
            rawEvent.stopPropagation();
          };
          var prevent = function() {
            rawEvent.preventDefault();
          };
          var kill = compose(prevent, stop);
          var evt = mkEvent(target2, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
          handler(evt);
        };
      };
      var binder = function(element, event, filter2, handler, useCapture) {
        var wrapped = handle(filter2, handler);
        element.dom().addEventListener(event, wrapped, useCapture);
        return { unbind: curry(unbind, element, event, wrapped, useCapture) };
      };
      var bind$1 = function(element, event, filter2, handler) {
        return binder(element, event, filter2, handler, false);
      };
      var unbind = function(element, event, handler, useCapture) {
        element.dom().removeEventListener(event, handler, useCapture);
      };
      var filter$1 = constant(true);
      var bind$2 = function(element, event, handler) {
        return bind$1(element, event, filter$1, handler);
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var shallow$1 = function(old, nu3) {
        return nu3;
      };
      var baseMerge = function(merger) {
        return function() {
          var objects = new Array(arguments.length);
          for (var i = 0; i < objects.length; i++) {
            objects[i] = arguments[i];
          }
          if (objects.length === 0) {
            throw new Error("Can't merge zero objects");
          }
          var ret = {};
          for (var j = 0; j < objects.length; j++) {
            var curObject = objects[j];
            for (var key2 in curObject) {
              if (hasOwnProperty.call(curObject, key2)) {
                ret[key2] = merger(ret[key2], curObject[key2]);
              }
            }
          }
          return ret;
        };
      };
      var merge$3 = baseMerge(shallow$1);
      var styles$1 = css2("ephox-dragster");
      var Styles$2 = { resolve: styles$1.resolve };
      var Blocker = function(options2) {
        var settings = merge$3({ layerClass: Styles$2.resolve("blocker") }, options2);
        var div2 = Element2.fromTag("div");
        set(div2, "role", "presentation");
        setAll$1(div2, {
          position: "fixed",
          left: "0px",
          top: "0px",
          width: "100%",
          height: "100%"
        });
        add$2(div2, Styles$2.resolve("blocker"));
        add$2(div2, settings.layerClass);
        var element = function() {
          return div2;
        };
        var destroy2 = function() {
          remove$2(div2);
        };
        return {
          element,
          destroy: destroy2
        };
      };
      var DragMode = exactly([
        "compare",
        "extract",
        "mutate",
        "sink"
      ]);
      var DragSink = exactly([
        "element",
        "start",
        "stop",
        "destroy"
      ]);
      var DragApi = exactly([
        "forceDrop",
        "drop",
        "move",
        "delayDrop"
      ]);
      var compare = function(old, nu3) {
        return Position(nu3.left() - old.left(), nu3.top() - old.top());
      };
      var extract$1 = function(event) {
        return Option.some(Position(event.x(), event.y()));
      };
      var mutate = function(mutation, info) {
        mutation.mutate(info.left(), info.top());
      };
      var sink = function(dragApi, settings) {
        var blocker = Blocker(settings);
        var mdown = bind$2(blocker.element(), "mousedown", dragApi.forceDrop);
        var mup = bind$2(blocker.element(), "mouseup", dragApi.drop);
        var mmove = bind$2(blocker.element(), "mousemove", dragApi.move);
        var mout = bind$2(blocker.element(), "mouseout", dragApi.delayDrop);
        var destroy2 = function() {
          blocker.destroy();
          mup.unbind();
          mmove.unbind();
          mout.unbind();
          mdown.unbind();
        };
        var start = function(parent2) {
          append(parent2, blocker.element());
        };
        var stop = function() {
          remove$2(blocker.element());
        };
        return DragSink({
          element: blocker.element,
          start,
          stop,
          destroy: destroy2
        });
      };
      var MouseDrag = DragMode({
        compare,
        extract: extract$1,
        sink,
        mutate
      });
      var last$2 = function(fn, rate) {
        var timer = null;
        var cancel = function() {
          if (timer !== null) {
            domGlobals.clearTimeout(timer);
            timer = null;
          }
        };
        var throttle = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (timer !== null) {
            domGlobals.clearTimeout(timer);
          }
          timer = domGlobals.setTimeout(function() {
            fn.apply(null, args);
            timer = null;
          }, rate);
        };
        return {
          cancel,
          throttle
        };
      };
      function InDrag() {
        var previous = Option.none();
        var reset = function() {
          previous = Option.none();
        };
        var update2 = function(mode, nu3) {
          var result = previous.map(function(old) {
            return mode.compare(old, nu3);
          });
          previous = Option.some(nu3);
          return result;
        };
        var onEvent = function(event, mode) {
          var dataOption = mode.extract(event);
          dataOption.each(function(data) {
            var offset = update2(mode, data);
            offset.each(function(d) {
              events.trigger.move(d);
            });
          });
        };
        var events = Events.create({ move: Event(["info"]) });
        return {
          onEvent,
          reset,
          events: events.registry
        };
      }
      function NoDrag() {
        return {
          onEvent: noop,
          reset: noop
        };
      }
      function Movement() {
        var noDragState = NoDrag();
        var inDragState = InDrag();
        var dragState = noDragState;
        var on2 = function() {
          dragState.reset();
          dragState = inDragState;
        };
        var off = function() {
          dragState.reset();
          dragState = noDragState;
        };
        var onEvent = function(event, mode) {
          dragState.onEvent(event, mode);
        };
        var isOn = function() {
          return dragState === inDragState;
        };
        return {
          on: on2,
          off,
          isOn,
          onEvent,
          events: inDragState.events
        };
      }
      var setup = function(mutation, mode, settings) {
        var active = false;
        var events = Events.create({
          start: Event([]),
          stop: Event([])
        });
        var movement = Movement();
        var drop = function() {
          sink2.stop();
          if (movement.isOn()) {
            movement.off();
            events.trigger.stop();
          }
        };
        var throttledDrop = last$2(drop, 200);
        var go2 = function(parent2) {
          sink2.start(parent2);
          movement.on();
          events.trigger.start();
        };
        var mousemove = function(event) {
          throttledDrop.cancel();
          movement.onEvent(event, mode);
        };
        movement.events.move.bind(function(event) {
          mode.mutate(mutation, event.info());
        });
        var on2 = function() {
          active = true;
        };
        var off = function() {
          active = false;
        };
        var runIfActive = function(f) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (active) {
              f.apply(null, args);
            }
          };
        };
        var sink2 = mode.sink(DragApi({
          forceDrop: drop,
          drop: runIfActive(drop),
          move: runIfActive(mousemove),
          delayDrop: runIfActive(throttledDrop.throttle)
        }), settings);
        var destroy2 = function() {
          sink2.destroy();
        };
        return {
          element: sink2.element,
          go: go2,
          on: on2,
          off,
          destroy: destroy2,
          events: events.registry
        };
      };
      var Dragging = { setup };
      var transform$1 = function(mutation, settings) {
        if (settings === void 0) {
          settings = {};
        }
        var mode = settings.mode !== void 0 ? settings.mode : MouseDrag;
        return Dragging.setup(mutation, mode, settings);
      };
      var Dragger = { transform: transform$1 };
      var Mutation = function() {
        var events = Events.create({
          drag: Event([
            "xDelta",
            "yDelta"
          ])
        });
        var mutate2 = function(x, y) {
          events.trigger.drag(x, y);
        };
        return {
          mutate: mutate2,
          events: events.registry
        };
      };
      var BarMutation = function() {
        var events = Events.create({
          drag: Event([
            "xDelta",
            "yDelta",
            "target"
          ])
        });
        var target2 = Option.none();
        var delegate = Mutation();
        delegate.events.drag.bind(function(event) {
          target2.each(function(t) {
            events.trigger.drag(event.xDelta(), event.yDelta(), t);
          });
        });
        var assign = function(t) {
          target2 = Option.some(t);
        };
        var get2 = function() {
          return target2;
        };
        return {
          assign,
          get: get2,
          mutate: delegate.mutate,
          events: events.registry
        };
      };
      var isContentEditableTrue = function(elm) {
        return get(elm, "contenteditable") === "true";
      };
      var findClosestContentEditable = function(target2, isRoot) {
        return closest$1(target2, "[contenteditable]", isRoot);
      };
      var resizeBarDragging = Styles.resolve("resizer-bar-dragging");
      var BarManager = function(wire, direction, hdirection) {
        var mutation = BarMutation();
        var resizing = Dragger.transform(mutation, {});
        var hoverTable = Option.none();
        var getResizer = function(element, type2) {
          return Option.from(get(element, type2));
        };
        mutation.events.drag.bind(function(event) {
          getResizer(event.target(), "data-row").each(function(_dataRow) {
            var currentRow = CellUtils.getInt(event.target(), "top");
            set$1(event.target(), "top", currentRow + event.yDelta() + "px");
          });
          getResizer(event.target(), "data-column").each(function(_dataCol) {
            var currentCol = CellUtils.getInt(event.target(), "left");
            set$1(event.target(), "left", currentCol + event.xDelta() + "px");
          });
        });
        var getDelta = function(target2, dir) {
          var newX = CellUtils.getInt(target2, dir);
          var oldX = parseInt(get(target2, "data-initial-" + dir), 10);
          return newX - oldX;
        };
        resizing.events.stop.bind(function() {
          mutation.get().each(function(target2) {
            hoverTable.each(function(table3) {
              getResizer(target2, "data-row").each(function(row2) {
                var delta2 = getDelta(target2, "top");
                remove2(target2, "data-initial-top");
                events.trigger.adjustHeight(table3, delta2, parseInt(row2, 10));
              });
              getResizer(target2, "data-column").each(function(column) {
                var delta2 = getDelta(target2, "left");
                remove2(target2, "data-initial-left");
                events.trigger.adjustWidth(table3, delta2, parseInt(column, 10));
              });
              Bars.refresh(wire, table3, hdirection, direction);
            });
          });
        });
        var handler = function(target2, dir) {
          events.trigger.startAdjust();
          mutation.assign(target2);
          set(target2, "data-initial-" + dir, parseInt(get$1(target2, dir), 10));
          add$2(target2, resizeBarDragging);
          set$1(target2, "opacity", "0.2");
          resizing.go(wire.parent());
        };
        var mousedown = bind$2(wire.parent(), "mousedown", function(event) {
          if (Bars.isRowBar(event.target())) {
            handler(event.target(), "top");
          }
          if (Bars.isColBar(event.target())) {
            handler(event.target(), "left");
          }
        });
        var isRoot = function(e) {
          return eq(e, wire.view());
        };
        var findClosestEditableTable = function(target2) {
          return closest$1(target2, "table", isRoot).filter(function(table3) {
            return findClosestContentEditable(table3, isRoot).exists(isContentEditableTrue);
          });
        };
        var mouseover = bind$2(wire.view(), "mouseover", function(event) {
          findClosestEditableTable(event.target()).fold(function() {
            if (inBody(event.target())) {
              Bars.destroy(wire);
            }
          }, function(table3) {
            hoverTable = Option.some(table3);
            Bars.refresh(wire, table3, hdirection, direction);
          });
        });
        var destroy2 = function() {
          mousedown.unbind();
          mouseover.unbind();
          resizing.destroy();
          Bars.destroy(wire);
        };
        var refresh2 = function(tbl) {
          Bars.refresh(wire, tbl, hdirection, direction);
        };
        var events = Events.create({
          adjustHeight: Event([
            "table",
            "delta",
            "row"
          ]),
          adjustWidth: Event([
            "table",
            "delta",
            "column"
          ]),
          startAdjust: Event([])
        });
        return {
          destroy: destroy2,
          refresh: refresh2,
          on: resizing.on,
          off: resizing.off,
          hideBars: curry(Bars.hide, wire),
          showBars: curry(Bars.show, wire),
          events: events.registry
        };
      };
      var create$2 = function(wire, vdirection) {
        var hdirection = BarPositions.height;
        var manager = BarManager(wire, vdirection, hdirection);
        var events = Events.create({
          beforeResize: Event(["table"]),
          afterResize: Event(["table"]),
          startDrag: Event([])
        });
        manager.events.adjustHeight.bind(function(event) {
          events.trigger.beforeResize(event.table());
          var delta2 = hdirection.delta(event.delta(), event.table());
          Adjustments.adjustHeight(event.table(), delta2, event.row(), hdirection);
          events.trigger.afterResize(event.table());
        });
        manager.events.startAdjust.bind(function(event) {
          events.trigger.startDrag();
        });
        manager.events.adjustWidth.bind(function(event) {
          events.trigger.beforeResize(event.table());
          var delta2 = vdirection.delta(event.delta(), event.table());
          Adjustments.adjustWidth(event.table(), delta2, event.column(), vdirection);
          events.trigger.afterResize(event.table());
        });
        return {
          on: manager.on,
          off: manager.off,
          hideBars: manager.hideBars,
          showBars: manager.showBars,
          destroy: manager.destroy,
          events: events.registry
        };
      };
      var TableResize = { create: create$2 };
      var createContainer = function() {
        var container = Element2.fromTag("div");
        setAll$1(container, {
          position: "static",
          height: "0",
          width: "0",
          padding: "0",
          margin: "0",
          border: "0"
        });
        append(body(), container);
        return container;
      };
      var get$8 = function(editor, container) {
        return editor.inline ? ResizeWire.body(getBody$1(editor), createContainer()) : ResizeWire.only(Element2.fromDom(editor.getDoc()));
      };
      var remove$6 = function(editor, wire) {
        if (editor.inline) {
          remove$2(wire.parent());
        }
      };
      var TableWire = {
        get: get$8,
        remove: remove$6
      };
      var ResizeHandler = function(editor) {
        var selectionRng = Option.none();
        var resize2 = Option.none();
        var wire = Option.none();
        var percentageBasedSizeRegex2 = /(\d+(\.\d+)?)%/;
        var startW, startRawW;
        var isTable = function(elm) {
          return elm.nodeName === "TABLE";
        };
        var getRawWidth2 = function(elm) {
          return editor.dom.getStyle(elm, "width") || editor.dom.getAttrib(elm, "width");
        };
        var lazyResize = function() {
          return resize2;
        };
        var lazyWire = function() {
          return wire.getOr(ResizeWire.only(Element2.fromDom(editor.getBody())));
        };
        var destroy2 = function() {
          resize2.each(function(sz) {
            sz.destroy();
          });
          wire.each(function(w) {
            TableWire.remove(editor, w);
          });
        };
        editor.on("init", function() {
          var direction = TableDirection(Direction.directionAt);
          var rawWire = TableWire.get(editor);
          wire = Option.some(rawWire);
          if (hasObjectResizing(editor) && hasTableResizeBars(editor)) {
            var sz = TableResize.create(rawWire, direction);
            sz.on();
            sz.events.startDrag.bind(function(event) {
              selectionRng = Option.some(editor.selection.getRng());
            });
            sz.events.beforeResize.bind(function(event) {
              var rawTable = event.table().dom();
              fireObjectResizeStart(editor, rawTable, getPixelWidth$1(rawTable), getPixelHeight(rawTable));
            });
            sz.events.afterResize.bind(function(event) {
              var table3 = event.table();
              var rawTable = table3.dom();
              removeDataStyle(table3);
              selectionRng.each(function(rng) {
                editor.selection.setRng(rng);
                editor.focus();
              });
              fireObjectResized(editor, rawTable, getPixelWidth$1(rawTable), getPixelHeight(rawTable));
              editor.undoManager.add();
            });
            resize2 = Option.some(sz);
          }
        });
        editor.on("ObjectResizeStart", function(e) {
          var targetElm = e.target;
          if (isTable(targetElm)) {
            startW = e.width;
            startRawW = getRawWidth2(targetElm);
          }
        });
        editor.on("ObjectResized", function(e) {
          var targetElm = e.target;
          if (isTable(targetElm)) {
            var table3 = targetElm;
            if (percentageBasedSizeRegex2.test(startRawW)) {
              var percentW = parseFloat(percentageBasedSizeRegex2.exec(startRawW)[1]);
              var targetPercentW = e.width * percentW / startW;
              editor.dom.setStyle(table3, "width", targetPercentW + "%");
            } else {
              var newCellSizes_1 = [];
              global$1.each(table3.rows, function(row2) {
                global$1.each(row2.cells, function(cell3) {
                  var width = editor.dom.getStyle(cell3, "width", true);
                  newCellSizes_1.push({
                    cell: cell3,
                    width
                  });
                });
              });
              global$1.each(newCellSizes_1, function(newCellSize) {
                editor.dom.setStyle(newCellSize.cell, "width", newCellSize.width);
                editor.dom.setAttrib(newCellSize.cell, "width", null);
              });
            }
          }
        });
        return {
          lazyResize,
          lazyWire,
          destroy: destroy2
        };
      };
      var adt$1 = Adt.generate([
        { none: ["current"] },
        { first: ["current"] },
        {
          middle: [
            "current",
            "target"
          ]
        },
        { last: ["current"] }
      ]);
      var none$1 = function(current) {
        if (current === void 0) {
          current = void 0;
        }
        return adt$1.none(current);
      };
      var CellLocation = __assign(__assign({}, adt$1), { none: none$1 });
      var detect$4 = function(current, isRoot) {
        return TableLookup.table(current, isRoot).bind(function(table3) {
          var all2 = TableLookup.cells(table3);
          var index = findIndex(all2, function(x) {
            return eq(current, x);
          });
          return index.map(function(ind) {
            return {
              index: constant(ind),
              all: constant(all2)
            };
          });
        });
      };
      var next2 = function(current, isRoot) {
        var detection2 = detect$4(current, isRoot);
        return detection2.fold(function() {
          return CellLocation.none(current);
        }, function(info) {
          return info.index() + 1 < info.all().length ? CellLocation.middle(current, info.all()[info.index() + 1]) : CellLocation.last(current);
        });
      };
      var prev = function(current, isRoot) {
        var detection2 = detect$4(current, isRoot);
        return detection2.fold(function() {
          return CellLocation.none();
        }, function(info) {
          return info.index() - 1 >= 0 ? CellLocation.middle(current, info.all()[info.index() - 1]) : CellLocation.first(current);
        });
      };
      var CellNavigation = {
        next: next2,
        prev
      };
      var create$3 = Immutable("start", "soffset", "finish", "foffset");
      var SimRange = { create: create$3 };
      var adt$2 = Adt.generate([
        { before: ["element"] },
        {
          on: [
            "element",
            "offset"
          ]
        },
        { after: ["element"] }
      ]);
      var cata$1 = function(subject, onBefore, onOn, onAfter) {
        return subject.fold(onBefore, onOn, onAfter);
      };
      var getStart = function(situ) {
        return situ.fold(identity, identity, identity);
      };
      var before$2 = adt$2.before;
      var on = adt$2.on;
      var after$2 = adt$2.after;
      var Situ = {
        before: before$2,
        on,
        after: after$2,
        cata: cata$1,
        getStart
      };
      var adt$3 = Adt.generate([
        { domRange: ["rng"] },
        {
          relative: [
            "startSitu",
            "finishSitu"
          ]
        },
        {
          exact: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        }
      ]);
      var exactFromRange = function(simRange) {
        return adt$3.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
      };
      var getStart$1 = function(selection2) {
        return selection2.match({
          domRange: function(rng) {
            return Element2.fromDom(rng.startContainer);
          },
          relative: function(startSitu, finishSitu) {
            return Situ.getStart(startSitu);
          },
          exact: function(start, soffset, finish, foffset) {
            return start;
          }
        });
      };
      var domRange = adt$3.domRange;
      var relative = adt$3.relative;
      var exact = adt$3.exact;
      var getWin = function(selection2) {
        var start = getStart$1(selection2);
        return defaultView(start);
      };
      var range$1 = SimRange.create;
      var Selection = {
        domRange,
        relative,
        exact,
        exactFromRange,
        getWin,
        range: range$1
      };
      var selectNodeContents = function(win, element) {
        var rng = win.document.createRange();
        selectNodeContentsUsing(rng, element);
        return rng;
      };
      var selectNodeContentsUsing = function(rng, element) {
        rng.selectNodeContents(element.dom());
      };
      var setStart = function(rng, situ) {
        situ.fold(function(e) {
          rng.setStartBefore(e.dom());
        }, function(e, o) {
          rng.setStart(e.dom(), o);
        }, function(e) {
          rng.setStartAfter(e.dom());
        });
      };
      var setFinish = function(rng, situ) {
        situ.fold(function(e) {
          rng.setEndBefore(e.dom());
        }, function(e, o) {
          rng.setEnd(e.dom(), o);
        }, function(e) {
          rng.setEndAfter(e.dom());
        });
      };
      var relativeToNative = function(win, startSitu, finishSitu) {
        var range3 = win.document.createRange();
        setStart(range3, startSitu);
        setFinish(range3, finishSitu);
        return range3;
      };
      var exactToNative = function(win, start, soffset, finish, foffset) {
        var rng = win.document.createRange();
        rng.setStart(start.dom(), soffset);
        rng.setEnd(finish.dom(), foffset);
        return rng;
      };
      var toRect = function(rect2) {
        return {
          left: constant(rect2.left),
          top: constant(rect2.top),
          right: constant(rect2.right),
          bottom: constant(rect2.bottom),
          width: constant(rect2.width),
          height: constant(rect2.height)
        };
      };
      var getFirstRect = function(rng) {
        var rects = rng.getClientRects();
        var rect2 = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
        return rect2.width > 0 || rect2.height > 0 ? Option.some(rect2).map(toRect) : Option.none();
      };
      var adt$4 = Adt.generate([
        {
          ltr: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        },
        {
          rtl: [
            "start",
            "soffset",
            "finish",
            "foffset"
          ]
        }
      ]);
      var fromRange = function(win, type2, range3) {
        return type2(Element2.fromDom(range3.startContainer), range3.startOffset, Element2.fromDom(range3.endContainer), range3.endOffset);
      };
      var getRanges = function(win, selection2) {
        return selection2.match({
          domRange: function(rng) {
            return {
              ltr: constant(rng),
              rtl: Option.none
            };
          },
          relative: function(startSitu, finishSitu) {
            return {
              ltr: cached(function() {
                return relativeToNative(win, startSitu, finishSitu);
              }),
              rtl: cached(function() {
                return Option.some(relativeToNative(win, finishSitu, startSitu));
              })
            };
          },
          exact: function(start, soffset, finish, foffset) {
            return {
              ltr: cached(function() {
                return exactToNative(win, start, soffset, finish, foffset);
              }),
              rtl: cached(function() {
                return Option.some(exactToNative(win, finish, foffset, start, soffset));
              })
            };
          }
        });
      };
      var doDiagnose = function(win, ranges) {
        var rng = ranges.ltr();
        if (rng.collapsed) {
          var reversed = ranges.rtl().filter(function(rev) {
            return rev.collapsed === false;
          });
          return reversed.map(function(rev) {
            return adt$4.rtl(Element2.fromDom(rev.endContainer), rev.endOffset, Element2.fromDom(rev.startContainer), rev.startOffset);
          }).getOrThunk(function() {
            return fromRange(win, adt$4.ltr, rng);
          });
        } else {
          return fromRange(win, adt$4.ltr, rng);
        }
      };
      var diagnose = function(win, selection2) {
        var ranges = getRanges(win, selection2);
        return doDiagnose(win, ranges);
      };
      var asLtrRange = function(win, selection2) {
        var diagnosis = diagnose(win, selection2);
        return diagnosis.match({
          ltr: function(start, soffset, finish, foffset) {
            var rng = win.document.createRange();
            rng.setStart(start.dom(), soffset);
            rng.setEnd(finish.dom(), foffset);
            return rng;
          },
          rtl: function(start, soffset, finish, foffset) {
            var rng = win.document.createRange();
            rng.setStart(finish.dom(), foffset);
            rng.setEnd(start.dom(), soffset);
            return rng;
          }
        });
      };
      var searchForPoint = function(rectForOffset, x, y, maxX, length) {
        if (length === 0) {
          return 0;
        } else if (x === maxX) {
          return length - 1;
        }
        var xDelta = maxX;
        for (var i = 1; i < length; i++) {
          var rect2 = rectForOffset(i);
          var curDeltaX = Math.abs(x - rect2.left);
          if (y <= rect2.bottom) {
            if (y < rect2.top || curDeltaX > xDelta) {
              return i - 1;
            } else {
              xDelta = curDeltaX;
            }
          }
        }
        return 0;
      };
      var inRect = function(rect2, x, y) {
        return x >= rect2.left && x <= rect2.right && y >= rect2.top && y <= rect2.bottom;
      };
      var locateOffset = function(doc, textnode, x, y, rect2) {
        var rangeForOffset = function(o) {
          var r2 = doc.dom().createRange();
          r2.setStart(textnode.dom(), o);
          r2.collapse(true);
          return r2;
        };
        var rectForOffset = function(o) {
          var r2 = rangeForOffset(o);
          return r2.getBoundingClientRect();
        };
        var length = get$2(textnode).length;
        var offset = searchForPoint(rectForOffset, x, y, rect2.right, length);
        return rangeForOffset(offset);
      };
      var locate = function(doc, node2, x, y) {
        var r2 = doc.dom().createRange();
        r2.selectNode(node2.dom());
        var rects = r2.getClientRects();
        var foundRect = findMap(rects, function(rect2) {
          return inRect(rect2, x, y) ? Option.some(rect2) : Option.none();
        });
        return foundRect.map(function(rect2) {
          return locateOffset(doc, node2, x, y, rect2);
        });
      };
      var searchInChildren = function(doc, node2, x, y) {
        var r2 = doc.dom().createRange();
        var nodes = children(node2);
        return findMap(nodes, function(n) {
          r2.selectNode(n.dom());
          return inRect(r2.getBoundingClientRect(), x, y) ? locateNode(doc, n, x, y) : Option.none();
        });
      };
      var locateNode = function(doc, node2, x, y) {
        return isText(node2) ? locate(doc, node2, x, y) : searchInChildren(doc, node2, x, y);
      };
      var locate$1 = function(doc, node2, x, y) {
        var r2 = doc.dom().createRange();
        r2.selectNode(node2.dom());
        var rect2 = r2.getBoundingClientRect();
        var boundedX = Math.max(rect2.left, Math.min(rect2.right, x));
        var boundedY = Math.max(rect2.top, Math.min(rect2.bottom, y));
        return locateNode(doc, node2, boundedX, boundedY);
      };
      var COLLAPSE_TO_LEFT = true;
      var COLLAPSE_TO_RIGHT = false;
      var getCollapseDirection = function(rect2, x) {
        return x - rect2.left < rect2.right - x ? COLLAPSE_TO_LEFT : COLLAPSE_TO_RIGHT;
      };
      var createCollapsedNode = function(doc, target2, collapseDirection) {
        var r2 = doc.dom().createRange();
        r2.selectNode(target2.dom());
        r2.collapse(collapseDirection);
        return r2;
      };
      var locateInElement = function(doc, node2, x) {
        var cursorRange = doc.dom().createRange();
        cursorRange.selectNode(node2.dom());
        var rect2 = cursorRange.getBoundingClientRect();
        var collapseDirection = getCollapseDirection(rect2, x);
        var f = collapseDirection === COLLAPSE_TO_LEFT ? first : last$1;
        return f(node2).map(function(target2) {
          return createCollapsedNode(doc, target2, collapseDirection);
        });
      };
      var locateInEmpty = function(doc, node2, x) {
        var rect2 = node2.dom().getBoundingClientRect();
        var collapseDirection = getCollapseDirection(rect2, x);
        return Option.some(createCollapsedNode(doc, node2, collapseDirection));
      };
      var search = function(doc, node2, x) {
        var f = children(node2).length === 0 ? locateInEmpty : locateInElement;
        return f(doc, node2, x);
      };
      var caretPositionFromPoint = function(doc, x, y) {
        return Option.from(doc.dom().caretPositionFromPoint(x, y)).bind(function(pos) {
          if (pos.offsetNode === null) {
            return Option.none();
          }
          var r2 = doc.dom().createRange();
          r2.setStart(pos.offsetNode, pos.offset);
          r2.collapse();
          return Option.some(r2);
        });
      };
      var caretRangeFromPoint = function(doc, x, y) {
        return Option.from(doc.dom().caretRangeFromPoint(x, y));
      };
      var searchTextNodes = function(doc, node2, x, y) {
        var r2 = doc.dom().createRange();
        r2.selectNode(node2.dom());
        var rect2 = r2.getBoundingClientRect();
        var boundedX = Math.max(rect2.left, Math.min(rect2.right, x));
        var boundedY = Math.max(rect2.top, Math.min(rect2.bottom, y));
        return locate$1(doc, node2, boundedX, boundedY);
      };
      var searchFromPoint = function(doc, x, y) {
        return Element2.fromPoint(doc, x, y).bind(function(elem) {
          var fallback = function() {
            return search(doc, elem, x);
          };
          return children(elem).length === 0 ? fallback() : searchTextNodes(doc, elem, x, y).orThunk(fallback);
        });
      };
      var availableSearch = document.caretPositionFromPoint ? caretPositionFromPoint : document.caretRangeFromPoint ? caretRangeFromPoint : searchFromPoint;
      var fromPoint$1 = function(win, x, y) {
        var doc = Element2.fromDom(win.document);
        return availableSearch(doc, x, y).map(function(rng) {
          return SimRange.create(Element2.fromDom(rng.startContainer), rng.startOffset, Element2.fromDom(rng.endContainer), rng.endOffset);
        });
      };
      var beforeSpecial = function(element, offset) {
        var name$1 = name(element);
        if ("input" === name$1) {
          return Situ.after(element);
        } else if (!contains([
          "br",
          "img"
        ], name$1)) {
          return Situ.on(element, offset);
        } else {
          return offset === 0 ? Situ.before(element) : Situ.after(element);
        }
      };
      var preprocessRelative = function(startSitu, finishSitu) {
        var start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
        var finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
        return Selection.relative(start, finish);
      };
      var preprocessExact = function(start, soffset, finish, foffset) {
        var startSitu = beforeSpecial(start, soffset);
        var finishSitu = beforeSpecial(finish, foffset);
        return Selection.relative(startSitu, finishSitu);
      };
      var preprocess = function(selection2) {
        return selection2.match({
          domRange: function(rng) {
            var start = Element2.fromDom(rng.startContainer);
            var finish = Element2.fromDom(rng.endContainer);
            return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
          },
          relative: preprocessRelative,
          exact: preprocessExact
        });
      };
      var makeRange = function(start, soffset, finish, foffset) {
        var doc = owner(start);
        var rng = doc.dom().createRange();
        rng.setStart(start.dom(), soffset);
        rng.setEnd(finish.dom(), foffset);
        return rng;
      };
      var after$3 = function(start, soffset, finish, foffset) {
        var r2 = makeRange(start, soffset, finish, foffset);
        var same = eq(start, finish) && soffset === foffset;
        return r2.collapsed && !same;
      };
      var doSetNativeRange = function(win, rng) {
        Option.from(win.getSelection()).each(function(selection2) {
          selection2.removeAllRanges();
          selection2.addRange(rng);
        });
      };
      var doSetRange = function(win, start, soffset, finish, foffset) {
        var rng = exactToNative(win, start, soffset, finish, foffset);
        doSetNativeRange(win, rng);
      };
      var setLegacyRtlRange = function(win, selection2, start, soffset, finish, foffset) {
        selection2.collapse(start.dom(), soffset);
        selection2.extend(finish.dom(), foffset);
      };
      var setRangeFromRelative = function(win, relative2) {
        return diagnose(win, relative2).match({
          ltr: function(start, soffset, finish, foffset) {
            doSetRange(win, start, soffset, finish, foffset);
          },
          rtl: function(start, soffset, finish, foffset) {
            var selection2 = win.getSelection();
            if (selection2.setBaseAndExtent) {
              selection2.setBaseAndExtent(start.dom(), soffset, finish.dom(), foffset);
            } else if (selection2.extend) {
              try {
                setLegacyRtlRange(win, selection2, start, soffset, finish, foffset);
              } catch (e) {
                doSetRange(win, finish, foffset, start, soffset);
              }
            } else {
              doSetRange(win, finish, foffset, start, soffset);
            }
          }
        });
      };
      var setExact = function(win, start, soffset, finish, foffset) {
        var relative2 = preprocessExact(start, soffset, finish, foffset);
        setRangeFromRelative(win, relative2);
      };
      var setRelative = function(win, startSitu, finishSitu) {
        var relative2 = preprocessRelative(startSitu, finishSitu);
        setRangeFromRelative(win, relative2);
      };
      var toNative = function(selection2) {
        var win = Selection.getWin(selection2).dom();
        var getDomRange = function(start, soffset, finish, foffset) {
          return exactToNative(win, start, soffset, finish, foffset);
        };
        var filtered = preprocess(selection2);
        return diagnose(win, filtered).match({
          ltr: getDomRange,
          rtl: getDomRange
        });
      };
      var readRange = function(selection2) {
        if (selection2.rangeCount > 0) {
          var firstRng = selection2.getRangeAt(0);
          var lastRng = selection2.getRangeAt(selection2.rangeCount - 1);
          return Option.some(SimRange.create(Element2.fromDom(firstRng.startContainer), firstRng.startOffset, Element2.fromDom(lastRng.endContainer), lastRng.endOffset));
        } else {
          return Option.none();
        }
      };
      var doGetExact = function(selection2) {
        var anchor = Element2.fromDom(selection2.anchorNode);
        var focus = Element2.fromDom(selection2.focusNode);
        return after$3(anchor, selection2.anchorOffset, focus, selection2.focusOffset) ? Option.some(SimRange.create(anchor, selection2.anchorOffset, focus, selection2.focusOffset)) : readRange(selection2);
      };
      var setToElement = function(win, element) {
        var rng = selectNodeContents(win, element);
        doSetNativeRange(win, rng);
      };
      var getExact = function(win) {
        return Option.from(win.getSelection()).filter(function(sel) {
          return sel.rangeCount > 0;
        }).bind(doGetExact);
      };
      var get$9 = function(win) {
        return getExact(win).map(function(range3) {
          return Selection.exact(range3.start(), range3.soffset(), range3.finish(), range3.foffset());
        });
      };
      var getFirstRect$1 = function(win, selection2) {
        var rng = asLtrRange(win, selection2);
        return getFirstRect(rng);
      };
      var getAtPoint = function(win, x, y) {
        return fromPoint$1(win, x, y);
      };
      var clear = function(win) {
        var selection2 = win.getSelection();
        selection2.removeAllRanges();
      };
      var global$3 = tinymce.util.Tools.resolve("tinymce.util.VK");
      var forward = function(editor, isRoot, cell3, lazyWire) {
        return go(editor, isRoot, CellNavigation.next(cell3), lazyWire);
      };
      var backward = function(editor, isRoot, cell3, lazyWire) {
        return go(editor, isRoot, CellNavigation.prev(cell3), lazyWire);
      };
      var getCellFirstCursorPosition = function(editor, cell3) {
        var selection2 = Selection.exact(cell3, 0, cell3, 0);
        return toNative(selection2);
      };
      var getNewRowCursorPosition = function(editor, table3) {
        var rows2 = descendants$1(table3, "tr");
        return last(rows2).bind(function(last2) {
          return descendant$1(last2, "td,th").map(function(first2) {
            return getCellFirstCursorPosition(editor, first2);
          });
        });
      };
      var go = function(editor, isRoot, cell3, actions, lazyWire) {
        return cell3.fold(Option.none, Option.none, function(current, next3) {
          return first(next3).map(function(cell4) {
            return getCellFirstCursorPosition(editor, cell4);
          });
        }, function(current) {
          return TableLookup.table(current, isRoot).bind(function(table3) {
            var targets = TableTargets.noMenu(current);
            editor.undoManager.transact(function() {
              actions.insertRowsAfter(table3, targets);
            });
            return getNewRowCursorPosition(editor, table3);
          });
        });
      };
      var rootElements = [
        "table",
        "li",
        "dl"
      ];
      var handle$1 = function(event, editor, actions, lazyWire) {
        if (event.keyCode === global$3.TAB) {
          var body_1 = getBody$1(editor);
          var isRoot_1 = function(element) {
            var name$1 = name(element);
            return eq(element, body_1) || contains(rootElements, name$1);
          };
          var rng = editor.selection.getRng();
          if (rng.collapsed) {
            var start = Element2.fromDom(rng.startContainer);
            TableLookup.cell(start, isRoot_1).each(function(cell3) {
              event.preventDefault();
              var navigation = event.shiftKey ? backward : forward;
              var rng2 = navigation(editor, isRoot_1, cell3, actions);
              rng2.each(function(range3) {
                editor.selection.setRng(range3);
              });
            });
          }
        }
      };
      var TabContext = { handle: handle$1 };
      var create$4 = Immutable("selection", "kill");
      var Response = { create: create$4 };
      var create$5 = function(start, soffset, finish, foffset) {
        return {
          start: constant(Situ.on(start, soffset)),
          finish: constant(Situ.on(finish, foffset))
        };
      };
      var Situs = { create: create$5 };
      var convertToRange = function(win, selection2) {
        var rng = asLtrRange(win, selection2);
        return SimRange.create(Element2.fromDom(rng.startContainer), rng.startOffset, Element2.fromDom(rng.endContainer), rng.endOffset);
      };
      var makeSitus = Situs.create;
      var Util = {
        convertToRange,
        makeSitus
      };
      var sync = function(container, isRoot, start, soffset, finish, foffset, selectRange) {
        if (!(eq(start, finish) && soffset === foffset)) {
          return closest$1(start, "td,th", isRoot).bind(function(s) {
            return closest$1(finish, "td,th", isRoot).bind(function(f) {
              return detect$5(container, isRoot, s, f, selectRange);
            });
          });
        } else {
          return Option.none();
        }
      };
      var detect$5 = function(container, isRoot, start, finish, selectRange) {
        if (!eq(start, finish)) {
          return CellSelection.identify(start, finish, isRoot).bind(function(cellSel) {
            var boxes = cellSel.boxes().getOr([]);
            if (boxes.length > 0) {
              selectRange(container, boxes, cellSel.start(), cellSel.finish());
              return Option.some(Response.create(Option.some(Util.makeSitus(start, 0, start, getEnd(start))), true));
            } else {
              return Option.none();
            }
          });
        } else {
          return Option.none();
        }
      };
      var update = function(rows2, columns2, container, selected2, annotations) {
        var updateSelection = function(newSels) {
          annotations.clear(container);
          annotations.selectRange(container, newSels.boxes(), newSels.start(), newSels.finish());
          return newSels.boxes();
        };
        return CellSelection.shiftSelection(selected2, rows2, columns2, annotations.firstSelectedSelector(), annotations.lastSelectedSelector()).map(updateSelection);
      };
      var KeySelection = {
        sync,
        detect: detect$5,
        update
      };
      var traverse = Immutable("item", "mode");
      var backtrack = function(universe2, item, _direction, transition) {
        if (transition === void 0) {
          transition = sidestep;
        }
        return universe2.property().parent(item).map(function(p) {
          return traverse(p, transition);
        });
      };
      var sidestep = function(universe2, item, direction, transition) {
        if (transition === void 0) {
          transition = advance;
        }
        return direction.sibling(universe2, item).map(function(p) {
          return traverse(p, transition);
        });
      };
      var advance = function(universe2, item, direction, transition) {
        if (transition === void 0) {
          transition = advance;
        }
        var children2 = universe2.property().children(item);
        var result = direction.first(children2);
        return result.map(function(r2) {
          return traverse(r2, transition);
        });
      };
      var successors = [
        {
          current: backtrack,
          next: sidestep,
          fallback: Option.none()
        },
        {
          current: sidestep,
          next: advance,
          fallback: Option.some(backtrack)
        },
        {
          current: advance,
          next: advance,
          fallback: Option.some(sidestep)
        }
      ];
      var go$1 = function(universe2, item, mode, direction, rules2) {
        if (rules2 === void 0) {
          rules2 = successors;
        }
        var ruleOpt = find(rules2, function(succ2) {
          return succ2.current === mode;
        });
        return ruleOpt.bind(function(rule) {
          return rule.current(universe2, item, direction, rule.next).orThunk(function() {
            return rule.fallback.bind(function(fb) {
              return go$1(universe2, item, fb, direction);
            });
          });
        });
      };
      var left = function() {
        var sibling = function(universe2, item) {
          return universe2.query().prevSibling(item);
        };
        var first2 = function(children2) {
          return children2.length > 0 ? Option.some(children2[children2.length - 1]) : Option.none();
        };
        return {
          sibling,
          first: first2
        };
      };
      var right = function() {
        var sibling = function(universe2, item) {
          return universe2.query().nextSibling(item);
        };
        var first2 = function(children2) {
          return children2.length > 0 ? Option.some(children2[0]) : Option.none();
        };
        return {
          sibling,
          first: first2
        };
      };
      var Walkers = {
        left,
        right
      };
      var hone = function(universe2, item, predicate, mode, direction, isRoot) {
        var next3 = go$1(universe2, item, mode, direction);
        return next3.bind(function(n) {
          if (isRoot(n.item())) {
            return Option.none();
          } else {
            return predicate(n.item()) ? Option.some(n.item()) : hone(universe2, n.item(), predicate, n.mode(), direction, isRoot);
          }
        });
      };
      var left$1 = function(universe2, item, predicate, isRoot) {
        return hone(universe2, item, predicate, sidestep, Walkers.left(), isRoot);
      };
      var right$1 = function(universe2, item, predicate, isRoot) {
        return hone(universe2, item, predicate, sidestep, Walkers.right(), isRoot);
      };
      var isLeaf = function(universe2) {
        return function(element) {
          return universe2.property().children(element).length === 0;
        };
      };
      var before$3 = function(universe2, item, isRoot) {
        return seekLeft(universe2, item, isLeaf(universe2), isRoot);
      };
      var after$4 = function(universe2, item, isRoot) {
        return seekRight(universe2, item, isLeaf(universe2), isRoot);
      };
      var seekLeft = left$1;
      var seekRight = right$1;
      var universe$2 = DomUniverse();
      var before$4 = function(element, isRoot) {
        return before$3(universe$2, element, isRoot);
      };
      var after$5 = function(element, isRoot) {
        return after$4(universe$2, element, isRoot);
      };
      var seekLeft$1 = function(element, predicate, isRoot) {
        return seekLeft(universe$2, element, predicate, isRoot);
      };
      var seekRight$1 = function(element, predicate, isRoot) {
        return seekRight(universe$2, element, predicate, isRoot);
      };
      var ancestor$2 = function(scope, predicate, isRoot) {
        return ancestor(scope, predicate, isRoot).isSome();
      };
      var point = Immutable("element", "offset");
      Immutable("element", "deltaOffset");
      Immutable("element", "start", "finish");
      Immutable("begin", "end");
      Immutable("element", "text");
      var adt$5 = Adt.generate([
        { none: ["message"] },
        { success: [] },
        { failedUp: ["cell"] },
        { failedDown: ["cell"] }
      ]);
      var isOverlapping = function(bridge, before2, after2) {
        var beforeBounds = bridge.getRect(before2);
        var afterBounds = bridge.getRect(after2);
        return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
      };
      var isRow = function(elem) {
        return closest$1(elem, "tr");
      };
      var verify = function(bridge, before2, beforeOffset, after2, afterOffset, failure, isRoot) {
        return closest$1(after2, "td,th", isRoot).bind(function(afterCell) {
          return closest$1(before2, "td,th", isRoot).map(function(beforeCell) {
            if (!eq(afterCell, beforeCell)) {
              return DomParent.sharedOne(isRow, [
                afterCell,
                beforeCell
              ]).fold(function() {
                return isOverlapping(bridge, beforeCell, afterCell) ? adt$5.success() : failure(beforeCell);
              }, function(_sharedRow) {
                return failure(beforeCell);
              });
            } else {
              return eq(after2, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$5.none("in same cell");
            }
          });
        }).getOr(adt$5.none("default"));
      };
      var cata$2 = function(subject, onNone, onSuccess, onFailedUp, onFailedDown) {
        return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
      };
      var BeforeAfter = __assign(__assign({}, adt$5), {
        verify,
        cata: cata$2
      });
      Immutable("ancestor", "descendants", "element", "index");
      var inParent = Immutable("parent", "children", "element", "index");
      var indexInParent = function(element) {
        return parent(element).bind(function(parent2) {
          var children$12 = children(parent2);
          return indexOf(children$12, element).map(function(index) {
            return inParent(parent2, children$12, element, index);
          });
        });
      };
      var indexOf = function(elements, element) {
        return findIndex(elements, curry(eq, element));
      };
      var isBr = function(elem) {
        return name(elem) === "br";
      };
      var gatherer = function(cand, gather, isRoot) {
        return gather(cand, isRoot).bind(function(target2) {
          return isText(target2) && get$2(target2).trim().length === 0 ? gatherer(target2, gather, isRoot) : Option.some(target2);
        });
      };
      var handleBr = function(isRoot, element, direction) {
        return direction.traverse(element).orThunk(function() {
          return gatherer(element, direction.gather, isRoot);
        }).map(direction.relative);
      };
      var findBr = function(element, offset) {
        return child(element, offset).filter(isBr).orThunk(function() {
          return child(element, offset - 1).filter(isBr);
        });
      };
      var handleParent = function(isRoot, element, offset, direction) {
        return findBr(element, offset).bind(function(br) {
          return direction.traverse(br).fold(function() {
            return gatherer(br, direction.gather, isRoot).map(direction.relative);
          }, function(adjacent) {
            return indexInParent(adjacent).map(function(info) {
              return Situ.on(info.parent(), info.index());
            });
          });
        });
      };
      var tryBr = function(isRoot, element, offset, direction) {
        var target2 = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);
        return target2.map(function(tgt) {
          return {
            start: constant(tgt),
            finish: constant(tgt)
          };
        });
      };
      var process2 = function(analysis) {
        return BeforeAfter.cata(analysis, function(message) {
          return Option.none();
        }, function() {
          return Option.none();
        }, function(cell3) {
          return Option.some(point(cell3, 0));
        }, function(cell3) {
          return Option.some(point(cell3, getEnd(cell3)));
        });
      };
      var BrTags = {
        tryBr,
        process: process2
      };
      var nu$3 = MixedBag([
        "left",
        "top",
        "right",
        "bottom"
      ], []);
      var moveDown = function(caret2, amount) {
        return nu$3({
          left: caret2.left(),
          top: caret2.top() + amount,
          right: caret2.right(),
          bottom: caret2.bottom() + amount
        });
      };
      var moveUp = function(caret2, amount) {
        return nu$3({
          left: caret2.left(),
          top: caret2.top() - amount,
          right: caret2.right(),
          bottom: caret2.bottom() - amount
        });
      };
      var moveBottomTo = function(caret2, bottom2) {
        var height2 = caret2.bottom() - caret2.top();
        return nu$3({
          left: caret2.left(),
          top: bottom2 - height2,
          right: caret2.right(),
          bottom: bottom2
        });
      };
      var moveTopTo = function(caret2, top2) {
        var height2 = caret2.bottom() - caret2.top();
        return nu$3({
          left: caret2.left(),
          top: top2,
          right: caret2.right(),
          bottom: top2 + height2
        });
      };
      var translate = function(caret2, xDelta, yDelta) {
        return nu$3({
          left: caret2.left() + xDelta,
          top: caret2.top() + yDelta,
          right: caret2.right() + xDelta,
          bottom: caret2.bottom() + yDelta
        });
      };
      var getTop$1 = function(caret2) {
        return caret2.top();
      };
      var getBottom = function(caret2) {
        return caret2.bottom();
      };
      var toString = function(caret2) {
        return "(" + caret2.left() + ", " + caret2.top() + ") -> (" + caret2.right() + ", " + caret2.bottom() + ")";
      };
      var Carets = {
        nu: nu$3,
        moveUp,
        moveDown,
        moveBottomTo,
        moveTopTo,
        getTop: getTop$1,
        getBottom,
        translate,
        toString
      };
      var getPartialBox = function(bridge, element, offset) {
        if (offset >= 0 && offset < getEnd(element)) {
          return bridge.getRangedRect(element, offset, element, offset + 1);
        } else if (offset > 0) {
          return bridge.getRangedRect(element, offset - 1, element, offset);
        }
        return Option.none();
      };
      var toCaret = function(rect2) {
        return Carets.nu({
          left: rect2.left,
          top: rect2.top,
          right: rect2.right,
          bottom: rect2.bottom
        });
      };
      var getElemBox = function(bridge, element) {
        return Option.some(bridge.getRect(element));
      };
      var getBoxAt = function(bridge, element, offset) {
        if (isElement(element)) {
          return getElemBox(bridge, element).map(toCaret);
        } else if (isText(element)) {
          return getPartialBox(bridge, element, offset).map(toCaret);
        } else {
          return Option.none();
        }
      };
      var getEntireBox = function(bridge, element) {
        if (isElement(element)) {
          return getElemBox(bridge, element).map(toCaret);
        } else if (isText(element)) {
          return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
        } else {
          return Option.none();
        }
      };
      var Rectangles = {
        getBoxAt,
        getEntireBox
      };
      var JUMP_SIZE = 5;
      var NUM_RETRIES = 100;
      var adt$6 = Adt.generate([
        { none: [] },
        { retry: ["caret"] }
      ]);
      var isOutside = function(caret2, box) {
        return caret2.left() < box.left() || Math.abs(box.right() - caret2.left()) < 1 || caret2.left() > box.right();
      };
      var inOutsideBlock = function(bridge, element, caret2) {
        return closest(element, DomStructure.isBlock).fold(constant(false), function(cell3) {
          return Rectangles.getEntireBox(bridge, cell3).exists(function(box) {
            return isOutside(caret2, box);
          });
        });
      };
      var adjustDown = function(bridge, element, guessBox, original, caret2) {
        var lowerCaret = Carets.moveDown(caret2, JUMP_SIZE);
        if (Math.abs(guessBox.bottom() - original.bottom()) < 1) {
          return adt$6.retry(lowerCaret);
        } else if (guessBox.top() > caret2.bottom()) {
          return adt$6.retry(lowerCaret);
        } else if (guessBox.top() === caret2.bottom()) {
          return adt$6.retry(Carets.moveDown(caret2, 1));
        } else {
          return inOutsideBlock(bridge, element, caret2) ? adt$6.retry(Carets.translate(lowerCaret, JUMP_SIZE, 0)) : adt$6.none();
        }
      };
      var adjustUp = function(bridge, element, guessBox, original, caret2) {
        var higherCaret = Carets.moveUp(caret2, JUMP_SIZE);
        if (Math.abs(guessBox.top() - original.top()) < 1) {
          return adt$6.retry(higherCaret);
        } else if (guessBox.bottom() < caret2.top()) {
          return adt$6.retry(higherCaret);
        } else if (guessBox.bottom() === caret2.top()) {
          return adt$6.retry(Carets.moveUp(caret2, 1));
        } else {
          return inOutsideBlock(bridge, element, caret2) ? adt$6.retry(Carets.translate(higherCaret, JUMP_SIZE, 0)) : adt$6.none();
        }
      };
      var upMovement = {
        point: Carets.getTop,
        adjuster: adjustUp,
        move: Carets.moveUp,
        gather: before$4
      };
      var downMovement = {
        point: Carets.getBottom,
        adjuster: adjustDown,
        move: Carets.moveDown,
        gather: after$5
      };
      var isAtTable = function(bridge, x, y) {
        return bridge.elementFromPoint(x, y).filter(function(elm) {
          return name(elm) === "table";
        }).isSome();
      };
      var adjustForTable = function(bridge, movement, original, caret2, numRetries) {
        return adjustTil(bridge, movement, original, movement.move(caret2, JUMP_SIZE), numRetries);
      };
      var adjustTil = function(bridge, movement, original, caret2, numRetries) {
        if (numRetries === 0) {
          return Option.some(caret2);
        }
        if (isAtTable(bridge, caret2.left(), movement.point(caret2))) {
          return adjustForTable(bridge, movement, original, caret2, numRetries - 1);
        }
        return bridge.situsFromPoint(caret2.left(), movement.point(caret2)).bind(function(guess) {
          return guess.start().fold(Option.none, function(element) {
            return Rectangles.getEntireBox(bridge, element).bind(function(guessBox) {
              return movement.adjuster(bridge, element, guessBox, original, caret2).fold(Option.none, function(newCaret) {
                return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
              });
            }).orThunk(function() {
              return Option.some(caret2);
            });
          }, Option.none);
        });
      };
      var ieTryDown = function(bridge, caret2) {
        return bridge.situsFromPoint(caret2.left(), caret2.bottom() + JUMP_SIZE);
      };
      var ieTryUp = function(bridge, caret2) {
        return bridge.situsFromPoint(caret2.left(), caret2.top() - JUMP_SIZE);
      };
      var checkScroll = function(movement, adjusted, bridge) {
        if (movement.point(adjusted) > bridge.getInnerHeight()) {
          return Option.some(movement.point(adjusted) - bridge.getInnerHeight());
        } else if (movement.point(adjusted) < 0) {
          return Option.some(-movement.point(adjusted));
        } else {
          return Option.none();
        }
      };
      var retry = function(movement, bridge, caret2) {
        var moved = movement.move(caret2, JUMP_SIZE);
        var adjusted = adjustTil(bridge, movement, caret2, moved, NUM_RETRIES).getOr(moved);
        return checkScroll(movement, adjusted, bridge).fold(function() {
          return bridge.situsFromPoint(adjusted.left(), movement.point(adjusted));
        }, function(delta2) {
          bridge.scrollBy(0, delta2);
          return bridge.situsFromPoint(adjusted.left(), movement.point(adjusted) - delta2);
        });
      };
      var Retries = {
        tryUp: curry(retry, upMovement),
        tryDown: curry(retry, downMovement),
        ieTryUp,
        ieTryDown,
        getJumpSize: constant(JUMP_SIZE)
      };
      var MAX_RETRIES = 20;
      var platform$1 = PlatformDetection$1.detect();
      var findSpot = function(bridge, isRoot, direction) {
        return bridge.getSelection().bind(function(sel) {
          return BrTags.tryBr(isRoot, sel.finish(), sel.foffset(), direction).fold(function() {
            return Option.some(point(sel.finish(), sel.foffset()));
          }, function(brNeighbour) {
            var range3 = bridge.fromSitus(brNeighbour);
            var analysis = BeforeAfter.verify(bridge, sel.finish(), sel.foffset(), range3.finish(), range3.foffset(), direction.failure, isRoot);
            return BrTags.process(analysis);
          });
        });
      };
      var scan = function(bridge, isRoot, element, offset, direction, numRetries) {
        if (numRetries === 0) {
          return Option.none();
        }
        return tryCursor(bridge, isRoot, element, offset, direction).bind(function(situs) {
          var range3 = bridge.fromSitus(situs);
          var analysis = BeforeAfter.verify(bridge, element, offset, range3.finish(), range3.foffset(), direction.failure, isRoot);
          return BeforeAfter.cata(analysis, function() {
            return Option.none();
          }, function() {
            return Option.some(situs);
          }, function(cell3) {
            if (eq(element, cell3) && offset === 0) {
              return tryAgain(bridge, element, offset, Carets.moveUp, direction);
            } else {
              return scan(bridge, isRoot, cell3, 0, direction, numRetries - 1);
            }
          }, function(cell3) {
            if (eq(element, cell3) && offset === getEnd(cell3)) {
              return tryAgain(bridge, element, offset, Carets.moveDown, direction);
            } else {
              return scan(bridge, isRoot, cell3, getEnd(cell3), direction, numRetries - 1);
            }
          });
        });
      };
      var tryAgain = function(bridge, element, offset, move, direction) {
        return Rectangles.getBoxAt(bridge, element, offset).bind(function(box) {
          return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
        });
      };
      var tryAt = function(bridge, direction, box) {
        if (platform$1.browser.isChrome() || platform$1.browser.isSafari() || platform$1.browser.isFirefox() || platform$1.browser.isEdge()) {
          return direction.otherRetry(bridge, box);
        } else if (platform$1.browser.isIE()) {
          return direction.ieRetry(bridge, box);
        } else {
          return Option.none();
        }
      };
      var tryCursor = function(bridge, isRoot, element, offset, direction) {
        return Rectangles.getBoxAt(bridge, element, offset).bind(function(box) {
          return tryAt(bridge, direction, box);
        });
      };
      var handle$2 = function(bridge, isRoot, direction) {
        return findSpot(bridge, isRoot, direction).bind(function(spot) {
          return scan(bridge, isRoot, spot.element(), spot.offset(), direction, MAX_RETRIES).map(bridge.fromSitus);
        });
      };
      var TableKeys = { handle: handle$2 };
      var detection = PlatformDetection$1.detect();
      var inSameTable = function(elem, table3) {
        return ancestor$2(elem, function(e) {
          return parent(e).exists(function(p) {
            return eq(p, table3);
          });
        });
      };
      var simulate = function(bridge, isRoot, direction, initial, anchor) {
        return closest$1(initial, "td,th", isRoot).bind(function(start) {
          return closest$1(start, "table", isRoot).bind(function(table3) {
            if (!inSameTable(anchor, table3)) {
              return Option.none();
            }
            return TableKeys.handle(bridge, isRoot, direction).bind(function(range3) {
              return closest$1(range3.finish(), "td,th", isRoot).map(function(finish) {
                return {
                  start: constant(start),
                  finish: constant(finish),
                  range: constant(range3)
                };
              });
            });
          });
        });
      };
      var navigate = function(bridge, isRoot, direction, initial, anchor, precheck) {
        if (detection.browser.isIE()) {
          return Option.none();
        } else {
          return precheck(initial, isRoot).orThunk(function() {
            return simulate(bridge, isRoot, direction, initial, anchor).map(function(info) {
              var range3 = info.range();
              return Response.create(Option.some(Util.makeSitus(range3.start(), range3.soffset(), range3.finish(), range3.foffset())), true);
            });
          });
        }
      };
      var firstUpCheck = function(initial, isRoot) {
        return closest$1(initial, "tr", isRoot).bind(function(startRow) {
          return closest$1(startRow, "table", isRoot).bind(function(table3) {
            var rows2 = descendants$1(table3, "tr");
            if (eq(startRow, rows2[0])) {
              return seekLeft$1(table3, function(element) {
                return last$1(element).isSome();
              }, isRoot).map(function(last2) {
                var lastOffset = getEnd(last2);
                return Response.create(Option.some(Util.makeSitus(last2, lastOffset, last2, lastOffset)), true);
              });
            } else {
              return Option.none();
            }
          });
        });
      };
      var lastDownCheck = function(initial, isRoot) {
        return closest$1(initial, "tr", isRoot).bind(function(startRow) {
          return closest$1(startRow, "table", isRoot).bind(function(table3) {
            var rows2 = descendants$1(table3, "tr");
            if (eq(startRow, rows2[rows2.length - 1])) {
              return seekRight$1(table3, function(element) {
                return first(element).isSome();
              }, isRoot).map(function(first2) {
                return Response.create(Option.some(Util.makeSitus(first2, 0, first2, 0)), true);
              });
            } else {
              return Option.none();
            }
          });
        });
      };
      var select = function(bridge, container, isRoot, direction, initial, anchor, selectRange) {
        return simulate(bridge, isRoot, direction, initial, anchor).bind(function(info) {
          return KeySelection.detect(container, isRoot, info.start(), info.finish(), selectRange);
        });
      };
      var VerticalMovement = {
        navigate,
        select,
        firstUpCheck,
        lastDownCheck
      };
      var findCell = function(target2, isRoot) {
        return closest$1(target2, "td,th", isRoot);
      };
      function MouseSelection(bridge, container, isRoot, annotations) {
        var cursor = Option.none();
        var clearState = function() {
          cursor = Option.none();
        };
        var mousedown = function(event) {
          annotations.clear(container);
          cursor = findCell(event.target(), isRoot);
        };
        var mouseover = function(event) {
          cursor.each(function(start) {
            annotations.clear(container);
            findCell(event.target(), isRoot).each(function(finish) {
              CellSelection.identify(start, finish, isRoot).each(function(cellSel) {
                var boxes = cellSel.boxes().getOr([]);
                if (boxes.length > 1 || boxes.length === 1 && !eq(start, finish)) {
                  annotations.selectRange(container, boxes, cellSel.start(), cellSel.finish());
                  bridge.selectContents(finish);
                }
              });
            });
          });
        };
        var mouseup = function(_event) {
          cursor.each(clearState);
        };
        return {
          mousedown,
          mouseover,
          mouseup
        };
      }
      var down = {
        traverse: nextSibling,
        gather: after$5,
        relative: Situ.before,
        otherRetry: Retries.tryDown,
        ieRetry: Retries.ieTryDown,
        failure: BeforeAfter.failedDown
      };
      var up = {
        traverse: prevSibling,
        gather: before$4,
        relative: Situ.before,
        otherRetry: Retries.tryUp,
        ieRetry: Retries.ieTryUp,
        failure: BeforeAfter.failedUp
      };
      var KeyDirection = {
        down,
        up
      };
      var isKey = function(key2) {
        return function(keycode) {
          return keycode === key2;
        };
      };
      var isUp = isKey(38);
      var isDown = isKey(40);
      var isNavigation = function(keycode) {
        return keycode >= 37 && keycode <= 40;
      };
      var SelectionKeys = {
        ltr: {
          isBackward: isKey(37),
          isForward: isKey(39)
        },
        rtl: {
          isBackward: isKey(39),
          isForward: isKey(37)
        },
        isUp,
        isDown,
        isNavigation
      };
      var toRaw = function(sr) {
        return {
          left: sr.left(),
          top: sr.top(),
          right: sr.right(),
          bottom: sr.bottom(),
          width: sr.width(),
          height: sr.height()
        };
      };
      var Rect = { toRaw };
      PlatformDetection$1.detect().browser.isSafari();
      var get$a = function(_DOC) {
        var doc = _DOC !== void 0 ? _DOC.dom() : domGlobals.document;
        var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
        var y = doc.body.scrollTop || doc.documentElement.scrollTop;
        return Position(x, y);
      };
      var by = function(x, y, _DOC) {
        var doc = _DOC !== void 0 ? _DOC.dom() : domGlobals.document;
        var win = doc.defaultView;
        win.scrollBy(x, y);
      };
      var WindowBridge = function(win) {
        var elementFromPoint = function(x, y) {
          return Element2.fromPoint(Element2.fromDom(win.document), x, y);
        };
        var getRect = function(element) {
          return element.dom().getBoundingClientRect();
        };
        var getRangedRect = function(start, soffset, finish, foffset) {
          var sel = Selection.exact(start, soffset, finish, foffset);
          return getFirstRect$1(win, sel).map(Rect.toRaw);
        };
        var getSelection = function() {
          return get$9(win).map(function(exactAdt) {
            return Util.convertToRange(win, exactAdt);
          });
        };
        var fromSitus = function(situs) {
          var relative2 = Selection.relative(situs.start(), situs.finish());
          return Util.convertToRange(win, relative2);
        };
        var situsFromPoint = function(x, y) {
          return getAtPoint(win, x, y).map(function(exact2) {
            return Situs.create(exact2.start(), exact2.soffset(), exact2.finish(), exact2.foffset());
          });
        };
        var clearSelection = function() {
          clear(win);
        };
        var selectContents = function(element) {
          setToElement(win, element);
        };
        var setSelection = function(sel) {
          setExact(win, sel.start(), sel.soffset(), sel.finish(), sel.foffset());
        };
        var setRelativeSelection = function(start, finish) {
          setRelative(win, start, finish);
        };
        var getInnerHeight = function() {
          return win.innerHeight;
        };
        var getScrollY = function() {
          var pos = get$a(Element2.fromDom(win.document));
          return pos.top();
        };
        var scrollBy = function(x, y) {
          by(x, y, Element2.fromDom(win.document));
        };
        return {
          elementFromPoint,
          getRect,
          getRangedRect,
          getSelection,
          fromSitus,
          situsFromPoint,
          clearSelection,
          setSelection,
          setRelativeSelection,
          selectContents,
          getInnerHeight,
          getScrollY,
          scrollBy
        };
      };
      var rc = Immutable("rows", "cols");
      var mouse = function(win, container, isRoot, annotations) {
        var bridge = WindowBridge(win);
        var handlers = MouseSelection(bridge, container, isRoot, annotations);
        return {
          mousedown: handlers.mousedown,
          mouseover: handlers.mouseover,
          mouseup: handlers.mouseup
        };
      };
      var keyboard = function(win, container, isRoot, annotations) {
        var bridge = WindowBridge(win);
        var clearToNavigate = function() {
          annotations.clear(container);
          return Option.none();
        };
        var keydown = function(event, start, soffset, finish, foffset, direction) {
          var realEvent = event.raw();
          var keycode = realEvent.which;
          var shiftKey = realEvent.shiftKey === true;
          var handler = CellSelection.retrieve(container, annotations.selectedSelector()).fold(function() {
            if (SelectionKeys.isDown(keycode) && shiftKey) {
              return curry(VerticalMovement.select, bridge, container, isRoot, KeyDirection.down, finish, start, annotations.selectRange);
            } else if (SelectionKeys.isUp(keycode) && shiftKey) {
              return curry(VerticalMovement.select, bridge, container, isRoot, KeyDirection.up, finish, start, annotations.selectRange);
            } else if (SelectionKeys.isDown(keycode)) {
              return curry(VerticalMovement.navigate, bridge, isRoot, KeyDirection.down, finish, start, VerticalMovement.lastDownCheck);
            } else if (SelectionKeys.isUp(keycode)) {
              return curry(VerticalMovement.navigate, bridge, isRoot, KeyDirection.up, finish, start, VerticalMovement.firstUpCheck);
            } else {
              return Option.none;
            }
          }, function(selected2) {
            var update2 = function(attempts) {
              return function() {
                var navigation = findMap(attempts, function(delta2) {
                  return KeySelection.update(delta2.rows(), delta2.cols(), container, selected2, annotations);
                });
                return navigation.fold(function() {
                  return CellSelection.getEdges(container, annotations.firstSelectedSelector(), annotations.lastSelectedSelector()).map(function(edges) {
                    var relative2 = SelectionKeys.isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
                    bridge.setRelativeSelection(Situ.on(edges.first(), 0), relative2(edges.table()));
                    annotations.clear(container);
                    return Response.create(Option.none(), true);
                  });
                }, function(_) {
                  return Option.some(Response.create(Option.none(), true));
                });
              };
            };
            if (SelectionKeys.isDown(keycode) && shiftKey) {
              return update2([rc(1, 0)]);
            } else if (SelectionKeys.isUp(keycode) && shiftKey) {
              return update2([rc(-1, 0)]);
            } else if (direction.isBackward(keycode) && shiftKey) {
              return update2([
                rc(0, -1),
                rc(-1, 0)
              ]);
            } else if (direction.isForward(keycode) && shiftKey) {
              return update2([
                rc(0, 1),
                rc(1, 0)
              ]);
            } else if (SelectionKeys.isNavigation(keycode) && shiftKey === false) {
              return clearToNavigate;
            } else {
              return Option.none;
            }
          });
          return handler();
        };
        var keyup = function(event, start, soffset, finish, foffset) {
          return CellSelection.retrieve(container, annotations.selectedSelector()).fold(function() {
            var realEvent = event.raw();
            var keycode = realEvent.which;
            var shiftKey = realEvent.shiftKey === true;
            if (shiftKey === false) {
              return Option.none();
            }
            if (SelectionKeys.isNavigation(keycode)) {
              return KeySelection.sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);
            } else {
              return Option.none();
            }
          }, Option.none);
        };
        return {
          keydown,
          keyup
        };
      };
      var InputHandlers = {
        mouse,
        keyboard
      };
      var remove$7 = function(element, classes) {
        each(classes, function(x) {
          remove$5(element, x);
        });
      };
      var addClass = function(clazz) {
        return function(element) {
          add$2(element, clazz);
        };
      };
      var removeClasses = function(classes) {
        return function(element) {
          remove$7(element, classes);
        };
      };
      var byClass = function(ephemera) {
        var addSelectionClass = addClass(ephemera.selected());
        var removeSelectionClasses = removeClasses([
          ephemera.selected(),
          ephemera.lastSelected(),
          ephemera.firstSelected()
        ]);
        var clear2 = function(container) {
          var sels = descendants$1(container, ephemera.selectedSelector());
          each(sels, removeSelectionClasses);
        };
        var selectRange = function(container, cells2, start, finish) {
          clear2(container);
          each(cells2, addSelectionClass);
          add$2(start, ephemera.firstSelected());
          add$2(finish, ephemera.lastSelected());
        };
        return {
          clear: clear2,
          selectRange,
          selectedSelector: ephemera.selectedSelector,
          firstSelectedSelector: ephemera.firstSelectedSelector,
          lastSelectedSelector: ephemera.lastSelectedSelector
        };
      };
      var byAttr = function(ephemera) {
        var removeSelectionAttributes = function(element) {
          remove2(element, ephemera.selected());
          remove2(element, ephemera.firstSelected());
          remove2(element, ephemera.lastSelected());
        };
        var addSelectionAttribute = function(element) {
          set(element, ephemera.selected(), "1");
        };
        var clear2 = function(container) {
          var sels = descendants$1(container, ephemera.selectedSelector());
          each(sels, removeSelectionAttributes);
        };
        var selectRange = function(container, cells2, start, finish) {
          clear2(container);
          each(cells2, addSelectionAttribute);
          set(start, ephemera.firstSelected(), "1");
          set(finish, ephemera.lastSelected(), "1");
        };
        return {
          clear: clear2,
          selectRange,
          selectedSelector: ephemera.selectedSelector,
          firstSelectedSelector: ephemera.firstSelectedSelector,
          lastSelectedSelector: ephemera.lastSelectedSelector
        };
      };
      var SelectionAnnotation = {
        byClass,
        byAttr
      };
      var hasInternalTarget = function(e) {
        return has$1(Element2.fromDom(e.target), "ephox-snooker-resizer-bar") === false;
      };
      function CellSelection$1(editor, lazyResize) {
        var handlerStruct = MixedBag([
          "mousedown",
          "mouseover",
          "mouseup",
          "keyup",
          "keydown"
        ], []);
        var handlers = Option.none();
        var annotations = SelectionAnnotation.byAttr(Ephemera);
        editor.on("init", function(e) {
          var win = editor.getWin();
          var body2 = getBody$1(editor);
          var isRoot = getIsRoot(editor);
          var syncSelection = function() {
            var sel = editor.selection;
            var start = Element2.fromDom(sel.getStart());
            var end = Element2.fromDom(sel.getEnd());
            var shared = DomParent.sharedOne(TableLookup.table, [
              start,
              end
            ]);
            shared.fold(function() {
              annotations.clear(body2);
            }, noop);
          };
          var mouseHandlers = InputHandlers.mouse(win, body2, isRoot, annotations);
          var keyHandlers = InputHandlers.keyboard(win, body2, isRoot, annotations);
          var hasShiftKey = function(event) {
            return event.raw().shiftKey === true;
          };
          var handleResponse = function(event, response) {
            if (!hasShiftKey(event)) {
              return;
            }
            if (response.kill()) {
              event.kill();
            }
            response.selection().each(function(ns) {
              var relative2 = Selection.relative(ns.start(), ns.finish());
              var rng = asLtrRange(win, relative2);
              editor.selection.setRng(rng);
            });
          };
          var keyup = function(event) {
            var wrappedEvent = wrapEvent(event);
            if (wrappedEvent.raw().shiftKey && SelectionKeys.isNavigation(wrappedEvent.raw().which)) {
              var rng = editor.selection.getRng();
              var start = Element2.fromDom(rng.startContainer);
              var end = Element2.fromDom(rng.endContainer);
              keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(function(response) {
                handleResponse(wrappedEvent, response);
              });
            }
          };
          var keydown = function(event) {
            var wrappedEvent = wrapEvent(event);
            lazyResize().each(function(resize2) {
              resize2.hideBars();
            });
            var rng = editor.selection.getRng();
            var startContainer = Element2.fromDom(editor.selection.getStart());
            var start = Element2.fromDom(rng.startContainer);
            var end = Element2.fromDom(rng.endContainer);
            var direction = Direction.directionAt(startContainer).isRtl() ? SelectionKeys.rtl : SelectionKeys.ltr;
            keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(function(response) {
              handleResponse(wrappedEvent, response);
            });
            lazyResize().each(function(resize2) {
              resize2.showBars();
            });
          };
          var isMouseEvent = function(event) {
            return event.hasOwnProperty("x") && event.hasOwnProperty("y");
          };
          var wrapEvent = function(event) {
            var target2 = Element2.fromDom(event.target);
            var stop = function() {
              event.stopPropagation();
            };
            var prevent = function() {
              event.preventDefault();
            };
            var kill = compose(prevent, stop);
            return {
              target: constant(target2),
              x: constant(isMouseEvent(event) ? event.x : null),
              y: constant(isMouseEvent(event) ? event.y : null),
              stop,
              prevent,
              kill,
              raw: constant(event)
            };
          };
          var isLeftMouse = function(raw) {
            return raw.button === 0;
          };
          var isLeftButtonPressed = function(raw) {
            if (raw.buttons === void 0) {
              return true;
            }
            if (global$2.ie && global$2.ie >= 12 && raw.buttons === 0) {
              return true;
            }
            return (raw.buttons & 1) !== 0;
          };
          var mouseDown = function(e2) {
            if (isLeftMouse(e2) && hasInternalTarget(e2)) {
              mouseHandlers.mousedown(wrapEvent(e2));
            }
          };
          var mouseOver = function(e2) {
            if (isLeftButtonPressed(e2) && hasInternalTarget(e2)) {
              mouseHandlers.mouseover(wrapEvent(e2));
            }
          };
          var mouseUp = function(e2) {
            if (isLeftMouse(e2) && hasInternalTarget(e2)) {
              mouseHandlers.mouseup(wrapEvent(e2));
            }
          };
          editor.on("mousedown", mouseDown);
          editor.on("mouseover", mouseOver);
          editor.on("mouseup", mouseUp);
          editor.on("keyup", keyup);
          editor.on("keydown", keydown);
          editor.on("nodechange", syncSelection);
          handlers = Option.some(handlerStruct({
            mousedown: mouseDown,
            mouseover: mouseOver,
            mouseup: mouseUp,
            keyup,
            keydown
          }));
        });
        var destroy2 = function() {
          handlers.each(function(handlers2) {
          });
        };
        return {
          clear: annotations.clear,
          destroy: destroy2
        };
      }
      var Selections = function(editor) {
        var get2 = function() {
          var body2 = getBody$1(editor);
          return TableSelection.retrieve(body2, Ephemera.selectedSelector()).fold(function() {
            if (editor.selection.getStart() === void 0) {
              return SelectionTypes.none();
            } else {
              return SelectionTypes.single(editor.selection);
            }
          }, function(cells2) {
            return SelectionTypes.multiple(cells2);
          });
        };
        return { get: get2 };
      };
      var each$4 = global$1.each;
      var addButtons = function(editor) {
        var menuItems = [];
        each$4("inserttable tableprops deletetable | cell row column".split(" "), function(name2) {
          if (name2 === "|") {
            menuItems.push({ text: "-" });
          } else {
            menuItems.push(editor.menuItems[name2]);
          }
        });
        editor.addButton("table", {
          type: "menubutton",
          title: "Table",
          menu: menuItems
        });
        function cmd(command) {
          return function() {
            editor.execCommand(command);
          };
        }
        editor.addButton("tableprops", {
          title: "Table properties",
          onclick: cmd("mceTableProps"),
          icon: "table"
        });
        editor.addButton("tabledelete", {
          title: "Delete table",
          onclick: cmd("mceTableDelete")
        });
        editor.addButton("tablecellprops", {
          title: "Cell properties",
          onclick: cmd("mceTableCellProps")
        });
        editor.addButton("tablemergecells", {
          title: "Merge cells",
          onclick: cmd("mceTableMergeCells")
        });
        editor.addButton("tablesplitcells", {
          title: "Split cell",
          onclick: cmd("mceTableSplitCells")
        });
        editor.addButton("tableinsertrowbefore", {
          title: "Insert row before",
          onclick: cmd("mceTableInsertRowBefore")
        });
        editor.addButton("tableinsertrowafter", {
          title: "Insert row after",
          onclick: cmd("mceTableInsertRowAfter")
        });
        editor.addButton("tabledeleterow", {
          title: "Delete row",
          onclick: cmd("mceTableDeleteRow")
        });
        editor.addButton("tablerowprops", {
          title: "Row properties",
          onclick: cmd("mceTableRowProps")
        });
        editor.addButton("tablecutrow", {
          title: "Cut row",
          onclick: cmd("mceTableCutRow")
        });
        editor.addButton("tablecopyrow", {
          title: "Copy row",
          onclick: cmd("mceTableCopyRow")
        });
        editor.addButton("tablepasterowbefore", {
          title: "Paste row before",
          onclick: cmd("mceTablePasteRowBefore")
        });
        editor.addButton("tablepasterowafter", {
          title: "Paste row after",
          onclick: cmd("mceTablePasteRowAfter")
        });
        editor.addButton("tableinsertcolbefore", {
          title: "Insert column before",
          onclick: cmd("mceTableInsertColBefore")
        });
        editor.addButton("tableinsertcolafter", {
          title: "Insert column after",
          onclick: cmd("mceTableInsertColAfter")
        });
        editor.addButton("tabledeletecol", {
          title: "Delete column",
          onclick: cmd("mceTableDeleteCol")
        });
      };
      var addToolbars = function(editor) {
        var isTable = function(table3) {
          var selectorMatched = editor.dom.is(table3, "table") && editor.getBody().contains(table3);
          return selectorMatched;
        };
        var toolbar = getToolbar(editor);
        if (toolbar.length > 0) {
          editor.addContextToolbar(isTable, toolbar.join(" "));
        }
      };
      var Buttons = {
        addButtons,
        addToolbars
      };
      var addMenuItems = function(editor, selections) {
        var targets = Option.none();
        var tableCtrls = [];
        var cellCtrls = [];
        var mergeCtrls = [];
        var unmergeCtrls = [];
        var noTargetDisable = function(ctrl) {
          ctrl.disabled(true);
        };
        var ctrlEnable = function(ctrl) {
          ctrl.disabled(false);
        };
        var pushTable = function() {
          var self2 = this;
          tableCtrls.push(self2);
          targets.fold(function() {
            noTargetDisable(self2);
          }, function(targets2) {
            ctrlEnable(self2);
          });
        };
        var pushCell = function() {
          var self2 = this;
          cellCtrls.push(self2);
          targets.fold(function() {
            noTargetDisable(self2);
          }, function(targets2) {
            ctrlEnable(self2);
          });
        };
        var pushMerge = function() {
          var self2 = this;
          mergeCtrls.push(self2);
          targets.fold(function() {
            noTargetDisable(self2);
          }, function(targets2) {
            self2.disabled(targets2.mergable().isNone());
          });
        };
        var pushUnmerge = function() {
          var self2 = this;
          unmergeCtrls.push(self2);
          targets.fold(function() {
            noTargetDisable(self2);
          }, function(targets2) {
            self2.disabled(targets2.unmergable().isNone());
          });
        };
        var setDisabledCtrls = function() {
          targets.fold(function() {
            each(tableCtrls, noTargetDisable);
            each(cellCtrls, noTargetDisable);
            each(mergeCtrls, noTargetDisable);
            each(unmergeCtrls, noTargetDisable);
          }, function(targets2) {
            each(tableCtrls, ctrlEnable);
            each(cellCtrls, ctrlEnable);
            each(mergeCtrls, function(mergeCtrl) {
              mergeCtrl.disabled(targets2.mergable().isNone());
            });
            each(unmergeCtrls, function(unmergeCtrl) {
              unmergeCtrl.disabled(targets2.unmergable().isNone());
            });
          });
        };
        editor.on("init", function() {
          editor.on("nodechange", function(e) {
            var cellOpt = Option.from(editor.dom.getParent(editor.selection.getStart(), "th,td"));
            targets = cellOpt.bind(function(cellDom) {
              var cell4 = Element2.fromDom(cellDom);
              var table3 = TableLookup.table(cell4);
              return table3.map(function(table4) {
                return TableTargets.forMenu(selections, table4, cell4);
              });
            });
            setDisabledCtrls();
          });
        });
        var generateTableGrid = function() {
          var html2 = "";
          html2 = '<table role="grid" class="mce-grid mce-grid-border" aria-readonly="true">';
          for (var y = 0; y < 10; y++) {
            html2 += "<tr>";
            for (var x = 0; x < 10; x++) {
              html2 += '<td role="gridcell" tabindex="-1"><a id="mcegrid' + (y * 10 + x) + '" href="#" data-mce-x="' + x + '" data-mce-y="' + y + '"></a></td>';
            }
            html2 += "</tr>";
          }
          html2 += "</table>";
          html2 += '<div class="mce-text-center" role="presentation">1 x 1</div>';
          return html2;
        };
        var selectGrid = function(editor2, tx, ty, control) {
          var table3 = control.getEl().getElementsByTagName("table")[0];
          var x, y, focusCell, cell4, active;
          var rtl2 = control.isRtl() || control.parent().rel === "tl-tr";
          table3.nextSibling.innerHTML = tx + 1 + " x " + (ty + 1);
          if (rtl2) {
            tx = 9 - tx;
          }
          for (y = 0; y < 10; y++) {
            for (x = 0; x < 10; x++) {
              cell4 = table3.rows[y].childNodes[x].firstChild;
              active = (rtl2 ? x >= tx : x <= tx) && y <= ty;
              editor2.dom.toggleClass(cell4, "mce-active", active);
              if (active) {
                focusCell = cell4;
              }
            }
          }
          return focusCell.parentNode;
        };
        var insertTable = hasTableGrid(editor) === false ? {
          text: "Table",
          icon: "table",
          context: "table",
          onclick: cmd("mceInsertTable")
        } : {
          text: "Table",
          icon: "table",
          context: "table",
          ariaHideMenu: true,
          onclick: function(e) {
            if (e.aria) {
              this.parent().hideAll();
              e.stopImmediatePropagation();
              editor.execCommand("mceInsertTable");
            }
          },
          onshow: function() {
            selectGrid(editor, 0, 0, this.menu.items()[0]);
          },
          onhide: function() {
            var elements = this.menu.items()[0].getEl().getElementsByTagName("a");
            editor.dom.removeClass(elements, "mce-active");
            editor.dom.addClass(elements[0], "mce-active");
          },
          menu: [{
            type: "container",
            html: generateTableGrid(),
            onPostRender: function() {
              this.lastX = this.lastY = 0;
            },
            onmousemove: function(e) {
              var target2 = e.target;
              var x, y;
              if (target2.tagName.toUpperCase() === "A") {
                x = parseInt(target2.getAttribute("data-mce-x"), 10);
                y = parseInt(target2.getAttribute("data-mce-y"), 10);
                if (this.isRtl() || this.parent().rel === "tl-tr") {
                  x = 9 - x;
                }
                if (x !== this.lastX || y !== this.lastY) {
                  selectGrid(editor, x, y, e.control);
                  this.lastX = x;
                  this.lastY = y;
                }
              }
            },
            onclick: function(e) {
              var self2 = this;
              if (e.target.tagName.toUpperCase() === "A") {
                e.preventDefault();
                e.stopPropagation();
                self2.parent().cancel();
                editor.undoManager.transact(function() {
                  InsertTable.insert(editor, self2.lastX + 1, self2.lastY + 1);
                });
                editor.addVisual();
              }
            }
          }]
        };
        function cmd(command) {
          return function() {
            editor.execCommand(command);
          };
        }
        var tableProperties = {
          text: "Table properties",
          context: "table",
          onPostRender: pushTable,
          onclick: cmd("mceTableProps")
        };
        var deleteTable = {
          text: "Delete table",
          context: "table",
          onPostRender: pushTable,
          cmd: "mceTableDelete"
        };
        var row2 = {
          text: "Row",
          context: "table",
          menu: [
            {
              text: "Insert row before",
              onclick: cmd("mceTableInsertRowBefore"),
              onPostRender: pushCell
            },
            {
              text: "Insert row after",
              onclick: cmd("mceTableInsertRowAfter"),
              onPostRender: pushCell
            },
            {
              text: "Delete row",
              onclick: cmd("mceTableDeleteRow"),
              onPostRender: pushCell
            },
            {
              text: "Row properties",
              onclick: cmd("mceTableRowProps"),
              onPostRender: pushCell
            },
            { text: "-" },
            {
              text: "Cut row",
              onclick: cmd("mceTableCutRow"),
              onPostRender: pushCell
            },
            {
              text: "Copy row",
              onclick: cmd("mceTableCopyRow"),
              onPostRender: pushCell
            },
            {
              text: "Paste row before",
              onclick: cmd("mceTablePasteRowBefore"),
              onPostRender: pushCell
            },
            {
              text: "Paste row after",
              onclick: cmd("mceTablePasteRowAfter"),
              onPostRender: pushCell
            }
          ]
        };
        var column = {
          text: "Column",
          context: "table",
          menu: [
            {
              text: "Insert column before",
              onclick: cmd("mceTableInsertColBefore"),
              onPostRender: pushCell
            },
            {
              text: "Insert column after",
              onclick: cmd("mceTableInsertColAfter"),
              onPostRender: pushCell
            },
            {
              text: "Delete column",
              onclick: cmd("mceTableDeleteCol"),
              onPostRender: pushCell
            }
          ]
        };
        var cell3 = {
          separator: "before",
          text: "Cell",
          context: "table",
          menu: [
            {
              text: "Cell properties",
              onclick: cmd("mceTableCellProps"),
              onPostRender: pushCell
            },
            {
              text: "Merge cells",
              onclick: cmd("mceTableMergeCells"),
              onPostRender: pushMerge
            },
            {
              text: "Split cell",
              onclick: cmd("mceTableSplitCells"),
              onPostRender: pushUnmerge
            }
          ]
        };
        editor.addMenuItem("inserttable", insertTable);
        editor.addMenuItem("tableprops", tableProperties);
        editor.addMenuItem("deletetable", deleteTable);
        editor.addMenuItem("row", row2);
        editor.addMenuItem("column", column);
        editor.addMenuItem("cell", cell3);
      };
      var MenuItems = { addMenuItems };
      var getClipboardRows = function(clipboardRows) {
        return clipboardRows.get().fold(function() {
          return;
        }, function(rows2) {
          return map2(rows2, function(row2) {
            return row2.dom();
          });
        });
      };
      var setClipboardRows = function(rows2, clipboardRows) {
        var sugarRows = map2(rows2, Element2.fromDom);
        clipboardRows.set(Option.from(sugarRows));
      };
      var getApi = function(editor, clipboardRows) {
        return {
          insertTable: function(columns2, rows2) {
            return InsertTable.insert(editor, columns2, rows2);
          },
          setClipboardRows: function(rows2) {
            return setClipboardRows(rows2, clipboardRows);
          },
          getClipboardRows: function() {
            return getClipboardRows(clipboardRows);
          }
        };
      };
      function Plugin(editor) {
        var resizeHandler = ResizeHandler(editor);
        var cellSelection = CellSelection$1(editor, resizeHandler.lazyResize);
        var actions = TableActions(editor, resizeHandler.lazyWire);
        var selections = Selections(editor);
        var clipboardRows = Cell(Option.none());
        Commands.registerCommands(editor, actions, cellSelection, selections, clipboardRows);
        Clipboard.registerEvents(editor, selections, actions, cellSelection);
        MenuItems.addMenuItems(editor, selections);
        Buttons.addButtons(editor);
        Buttons.addToolbars(editor);
        editor.on("PreInit", function() {
          editor.serializer.addTempAttr(Ephemera.firstSelected());
          editor.serializer.addTempAttr(Ephemera.lastSelected());
        });
        if (hasTabNavigation(editor)) {
          editor.on("keydown", function(e) {
            TabContext.handle(e, editor, actions, resizeHandler.lazyWire);
          });
        }
        editor.on("remove", function() {
          resizeHandler.destroy();
          cellSelection.destroy();
        });
        return getApi(editor, clipboardRows);
      }
      global2.add("table", Plugin);
      function Plugin$1() {
      }
      return Plugin$1;
    })(window);
  })();
  return plugin$4;
}
var hasRequiredTable;
function requireTable() {
  if (hasRequiredTable) return table;
  hasRequiredTable = 1;
  requirePlugin$4();
  return table;
}
requireTable();
var colorpicker = {};
var plugin$3 = {};
var hasRequiredPlugin$3;
function requirePlugin$3() {
  if (hasRequiredPlugin$3) return plugin$3;
  hasRequiredPlugin$3 = 1;
  (function() {
    (function() {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var global$1 = tinymce.util.Tools.resolve("tinymce.util.Color");
      var showPreview = function(win, hexColor) {
        win.find("#preview")[0].getEl().style.background = hexColor;
      };
      var setColor = function(win, value) {
        var color = global$1(value), rgb = color.toRgb();
        win.fromJSON({
          r: rgb.r,
          g: rgb.g,
          b: rgb.b,
          hex: color.toHex().substr(1)
        });
        showPreview(win, color.toHex());
      };
      var open = function(editor, callback, value) {
        var win = editor.windowManager.open({
          title: "Color",
          items: {
            type: "container",
            layout: "flex",
            direction: "row",
            align: "stretch",
            padding: 5,
            spacing: 10,
            items: [
              {
                type: "colorpicker",
                value,
                onchange: function() {
                  var rgb = this.rgb();
                  if (win) {
                    win.find("#r").value(rgb.r);
                    win.find("#g").value(rgb.g);
                    win.find("#b").value(rgb.b);
                    win.find("#hex").value(this.value().substr(1));
                    showPreview(win, this.value());
                  }
                }
              },
              {
                type: "form",
                padding: 0,
                labelGap: 5,
                defaults: {
                  type: "textbox",
                  size: 7,
                  value: "0",
                  flex: 1,
                  spellcheck: false,
                  onchange: function() {
                    var colorPickerCtrl = win.find("colorpicker")[0];
                    var name, value2;
                    name = this.name();
                    value2 = this.value();
                    if (name === "hex") {
                      value2 = "#" + value2;
                      setColor(win, value2);
                      colorPickerCtrl.value(value2);
                      return;
                    }
                    value2 = {
                      r: win.find("#r").value(),
                      g: win.find("#g").value(),
                      b: win.find("#b").value()
                    };
                    colorPickerCtrl.value(value2);
                    setColor(win, value2);
                  }
                },
                items: [
                  {
                    name: "r",
                    label: "R",
                    autofocus: 1
                  },
                  {
                    name: "g",
                    label: "G"
                  },
                  {
                    name: "b",
                    label: "B"
                  },
                  {
                    name: "hex",
                    label: "#",
                    value: "000000"
                  },
                  {
                    name: "preview",
                    type: "container",
                    border: 1
                  }
                ]
              }
            ]
          },
          onSubmit: function() {
            callback("#" + win.toJSON().hex);
          }
        });
        setColor(win, value);
      };
      var Dialog = { open };
      global2.add("colorpicker", function(editor) {
        if (!editor.settings.color_picker_callback) {
          editor.settings.color_picker_callback = function(callback, value) {
            Dialog.open(editor, callback, value);
          };
        }
      });
      function Plugin() {
      }
      return Plugin;
    })();
  })();
  return plugin$3;
}
var hasRequiredColorpicker;
function requireColorpicker() {
  if (hasRequiredColorpicker) return colorpicker;
  hasRequiredColorpicker = 1;
  requirePlugin$3();
  return colorpicker;
}
requireColorpicker();
var textcolor = {};
var plugin$2 = {};
var hasRequiredPlugin$2;
function requirePlugin$2() {
  if (hasRequiredPlugin$2) return plugin$2;
  hasRequiredPlugin$2 = 1;
  (function() {
    (function() {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var getCurrentColor = function(editor, format2) {
        var color;
        editor.dom.getParents(editor.selection.getStart(), function(elm) {
          var value;
          if (value = elm.style[format2 === "forecolor" ? "color" : "background-color"]) {
            color = color ? color : value;
          }
        });
        return color;
      };
      var mapColors = function(colorMap) {
        var i;
        var colors = [];
        for (i = 0; i < colorMap.length; i += 2) {
          colors.push({
            text: colorMap[i + 1],
            color: "#" + colorMap[i]
          });
        }
        return colors;
      };
      var applyFormat = function(editor, format2, value) {
        editor.undoManager.transact(function() {
          editor.focus();
          editor.formatter.apply(format2, { value });
          editor.nodeChanged();
        });
      };
      var removeFormat = function(editor, format2) {
        editor.undoManager.transact(function() {
          editor.focus();
          editor.formatter.remove(format2, { value: null }, null, true);
          editor.nodeChanged();
        });
      };
      var TextColor = {
        getCurrentColor,
        mapColors,
        applyFormat,
        removeFormat
      };
      var register = function(editor) {
        editor.addCommand("mceApplyTextcolor", function(format2, value) {
          TextColor.applyFormat(editor, format2, value);
        });
        editor.addCommand("mceRemoveTextcolor", function(format2) {
          TextColor.removeFormat(editor, format2);
        });
      };
      var Commands = { register };
      var global$1 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
      var global$2 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var defaultColorMap = [
        "000000",
        "Black",
        "993300",
        "Burnt orange",
        "333300",
        "Dark olive",
        "003300",
        "Dark green",
        "003366",
        "Dark azure",
        "000080",
        "Navy Blue",
        "333399",
        "Indigo",
        "333333",
        "Very dark gray",
        "800000",
        "Maroon",
        "FF6600",
        "Orange",
        "808000",
        "Olive",
        "008000",
        "Green",
        "008080",
        "Teal",
        "0000FF",
        "Blue",
        "666699",
        "Grayish blue",
        "808080",
        "Gray",
        "FF0000",
        "Red",
        "FF9900",
        "Amber",
        "99CC00",
        "Yellow green",
        "339966",
        "Sea green",
        "33CCCC",
        "Turquoise",
        "3366FF",
        "Royal blue",
        "800080",
        "Purple",
        "999999",
        "Medium gray",
        "FF00FF",
        "Magenta",
        "FFCC00",
        "Gold",
        "FFFF00",
        "Yellow",
        "00FF00",
        "Lime",
        "00FFFF",
        "Aqua",
        "00CCFF",
        "Sky blue",
        "993366",
        "Red violet",
        "FFFFFF",
        "White",
        "FF99CC",
        "Pink",
        "FFCC99",
        "Peach",
        "FFFF99",
        "Light yellow",
        "CCFFCC",
        "Pale green",
        "CCFFFF",
        "Pale cyan",
        "99CCFF",
        "Light sky blue",
        "CC99FF",
        "Plum"
      ];
      var getTextColorMap = function(editor) {
        return editor.getParam("textcolor_map", defaultColorMap);
      };
      var getForeColorMap = function(editor) {
        return editor.getParam("forecolor_map", getTextColorMap(editor));
      };
      var getBackColorMap = function(editor) {
        return editor.getParam("backcolor_map", getTextColorMap(editor));
      };
      var getTextColorRows = function(editor) {
        return editor.getParam("textcolor_rows", 5);
      };
      var getTextColorCols = function(editor) {
        return editor.getParam("textcolor_cols", 8);
      };
      var getForeColorRows = function(editor) {
        return editor.getParam("forecolor_rows", getTextColorRows(editor));
      };
      var getBackColorRows = function(editor) {
        return editor.getParam("backcolor_rows", getTextColorRows(editor));
      };
      var getForeColorCols = function(editor) {
        return editor.getParam("forecolor_cols", getTextColorCols(editor));
      };
      var getBackColorCols = function(editor) {
        return editor.getParam("backcolor_cols", getTextColorCols(editor));
      };
      var getColorPickerCallback = function(editor) {
        return editor.getParam("color_picker_callback", null);
      };
      var hasColorPicker = function(editor) {
        return typeof getColorPickerCallback(editor) === "function";
      };
      var Settings = {
        getForeColorMap,
        getBackColorMap,
        getForeColorRows,
        getBackColorRows,
        getForeColorCols,
        getBackColorCols,
        getColorPickerCallback,
        hasColorPicker
      };
      var global$3 = tinymce.util.Tools.resolve("tinymce.util.I18n");
      var getHtml = function(cols, rows, colorMap, hasColorPicker2) {
        var colors, color, html2, last, x, y, i, count = 0;
        var id = global$1.DOM.uniqueId("mcearia");
        var getColorCellHtml = function(color2, title) {
          var isNoColor = color2 === "transparent";
          return '<td class="mce-grid-cell' + (isNoColor ? " mce-colorbtn-trans" : "") + '"><div id="' + id + "-" + count++ + '" data-mce-color="' + (color2 ? color2 : "") + '" role="option" tabIndex="-1" style="' + (color2 ? "background-color: " + color2 : "") + '" title="' + global$3.translate(title) + '">' + (isNoColor ? "&#215;" : "") + "</div></td>";
        };
        colors = TextColor.mapColors(colorMap);
        colors.push({
          text: global$3.translate("No color"),
          color: "transparent"
        });
        html2 = '<table class="mce-grid mce-grid-border mce-colorbutton-grid" role="list" cellspacing="0"><tbody>';
        last = colors.length - 1;
        for (y = 0; y < rows; y++) {
          html2 += "<tr>";
          for (x = 0; x < cols; x++) {
            i = y * cols + x;
            if (i > last) {
              html2 += "<td></td>";
            } else {
              color = colors[i];
              html2 += getColorCellHtml(color.color, color.text);
            }
          }
          html2 += "</tr>";
        }
        if (hasColorPicker2) {
          html2 += '<tr><td colspan="' + cols + '" class="mce-custom-color-btn"><div id="' + id + '-c" class="mce-widget mce-btn mce-btn-small mce-btn-flat" role="button" tabindex="-1" aria-labelledby="' + id + '-c" style="width: 100%"><button type="button" role="presentation" tabindex="-1">' + global$3.translate("Custom...") + "</button></div></td></tr>";
          html2 += "<tr>";
          for (x = 0; x < cols; x++) {
            html2 += getColorCellHtml("", "Custom color");
          }
          html2 += "</tr>";
        }
        html2 += "</tbody></table>";
        return html2;
      };
      var ColorPickerHtml = { getHtml };
      var setDivColor = function setDivColor2(div2, value) {
        div2.style.background = value;
        div2.setAttribute("data-mce-color", value);
      };
      var onButtonClick = function(editor) {
        return function(e) {
          var ctrl = e.control;
          if (ctrl._color) {
            editor.execCommand("mceApplyTextcolor", ctrl.settings.format, ctrl._color);
          } else {
            editor.execCommand("mceRemoveTextcolor", ctrl.settings.format);
          }
        };
      };
      var onPanelClick = function(editor, cols) {
        return function(e) {
          var buttonCtrl = this.parent();
          var value;
          var currentColor = TextColor.getCurrentColor(editor, buttonCtrl.settings.format);
          var selectColor = function(value2) {
            editor.execCommand("mceApplyTextcolor", buttonCtrl.settings.format, value2);
            buttonCtrl.hidePanel();
            buttonCtrl.color(value2);
          };
          var resetColor = function() {
            editor.execCommand("mceRemoveTextcolor", buttonCtrl.settings.format);
            buttonCtrl.hidePanel();
            buttonCtrl.resetColor();
          };
          if (global$1.DOM.getParent(e.target, ".mce-custom-color-btn")) {
            buttonCtrl.hidePanel();
            var colorPickerCallback = Settings.getColorPickerCallback(editor);
            colorPickerCallback.call(editor, function(value2) {
              var tableElm = buttonCtrl.panel.getEl().getElementsByTagName("table")[0];
              var customColorCells, div2, i;
              customColorCells = global$2.map(tableElm.rows[tableElm.rows.length - 1].childNodes, function(elm) {
                return elm.firstChild;
              });
              for (i = 0; i < customColorCells.length; i++) {
                div2 = customColorCells[i];
                if (!div2.getAttribute("data-mce-color")) {
                  break;
                }
              }
              if (i === cols) {
                for (i = 0; i < cols - 1; i++) {
                  setDivColor(customColorCells[i], customColorCells[i + 1].getAttribute("data-mce-color"));
                }
              }
              setDivColor(div2, value2);
              selectColor(value2);
            }, currentColor);
          }
          value = e.target.getAttribute("data-mce-color");
          if (value) {
            if (this.lastId) {
              global$1.DOM.get(this.lastId).setAttribute("aria-selected", "false");
            }
            e.target.setAttribute("aria-selected", true);
            this.lastId = e.target.id;
            if (value === "transparent") {
              resetColor();
            } else {
              selectColor(value);
            }
          } else if (value !== null) {
            buttonCtrl.hidePanel();
          }
        };
      };
      var renderColorPicker = function(editor, foreColor) {
        return function() {
          var cols = foreColor ? Settings.getForeColorCols(editor) : Settings.getBackColorCols(editor);
          var rows = foreColor ? Settings.getForeColorRows(editor) : Settings.getBackColorRows(editor);
          var colorMap = foreColor ? Settings.getForeColorMap(editor) : Settings.getBackColorMap(editor);
          var hasColorPicker2 = Settings.hasColorPicker(editor);
          return ColorPickerHtml.getHtml(cols, rows, colorMap, hasColorPicker2);
        };
      };
      var register$1 = function(editor) {
        editor.addButton("forecolor", {
          type: "colorbutton",
          tooltip: "Text color",
          format: "forecolor",
          panel: {
            role: "application",
            ariaRemember: true,
            html: renderColorPicker(editor, true),
            onclick: onPanelClick(editor, Settings.getForeColorCols(editor))
          },
          onclick: onButtonClick(editor)
        });
        editor.addButton("backcolor", {
          type: "colorbutton",
          tooltip: "Background color",
          format: "hilitecolor",
          panel: {
            role: "application",
            ariaRemember: true,
            html: renderColorPicker(editor, false),
            onclick: onPanelClick(editor, Settings.getBackColorCols(editor))
          },
          onclick: onButtonClick(editor)
        });
      };
      var Buttons = { register: register$1 };
      global2.add("textcolor", function(editor) {
        Commands.register(editor);
        Buttons.register(editor);
      });
      function Plugin() {
      }
      return Plugin;
    })();
  })();
  return plugin$2;
}
var hasRequiredTextcolor;
function requireTextcolor() {
  if (hasRequiredTextcolor) return textcolor;
  hasRequiredTextcolor = 1;
  requirePlugin$2();
  return textcolor;
}
requireTextcolor();
var hr = {};
var plugin$1 = {};
var hasRequiredPlugin$1;
function requirePlugin$1() {
  if (hasRequiredPlugin$1) return plugin$1;
  hasRequiredPlugin$1 = 1;
  (function() {
    (function() {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var register = function(editor) {
        editor.addCommand("InsertHorizontalRule", function() {
          editor.execCommand("mceInsertContent", false, "<hr />");
        });
      };
      var Commands = { register };
      var register$1 = function(editor) {
        editor.addButton("hr", {
          icon: "hr",
          tooltip: "Horizontal line",
          cmd: "InsertHorizontalRule"
        });
        editor.addMenuItem("hr", {
          icon: "hr",
          text: "Horizontal line",
          cmd: "InsertHorizontalRule",
          context: "insert"
        });
      };
      var Buttons = { register: register$1 };
      global2.add("hr", function(editor) {
        Commands.register(editor);
        Buttons.register(editor);
      });
      function Plugin() {
      }
      return Plugin;
    })();
  })();
  return plugin$1;
}
var hasRequiredHr;
function requireHr() {
  if (hasRequiredHr) return hr;
  hasRequiredHr = 1;
  requirePlugin$1();
  return hr;
}
requireHr();
var image = {};
var plugin = {};
var hasRequiredPlugin;
function requirePlugin() {
  if (hasRequiredPlugin) return plugin;
  hasRequiredPlugin = 1;
  (function() {
    (function(domGlobals) {
      var global2 = tinymce.util.Tools.resolve("tinymce.PluginManager");
      var hasDimensions = function(editor) {
        return editor.settings.image_dimensions === false ? false : true;
      };
      var hasAdvTab = function(editor) {
        return editor.settings.image_advtab === true ? true : false;
      };
      var getPrependUrl = function(editor) {
        return editor.getParam("image_prepend_url", "");
      };
      var getClassList = function(editor) {
        return editor.getParam("image_class_list");
      };
      var hasDescription = function(editor) {
        return editor.settings.image_description === false ? false : true;
      };
      var hasImageTitle = function(editor) {
        return editor.settings.image_title === true ? true : false;
      };
      var hasImageCaption = function(editor) {
        return editor.settings.image_caption === true ? true : false;
      };
      var getImageList = function(editor) {
        return editor.getParam("image_list", false);
      };
      var hasUploadUrl = function(editor) {
        return editor.getParam("images_upload_url", false);
      };
      var hasUploadHandler = function(editor) {
        return editor.getParam("images_upload_handler", false);
      };
      var getUploadUrl = function(editor) {
        return editor.getParam("images_upload_url");
      };
      var getUploadHandler = function(editor) {
        return editor.getParam("images_upload_handler");
      };
      var getUploadBasePath = function(editor) {
        return editor.getParam("images_upload_base_path");
      };
      var getUploadCredentials = function(editor) {
        return editor.getParam("images_upload_credentials");
      };
      var Settings = {
        hasDimensions,
        hasAdvTab,
        getPrependUrl,
        getClassList,
        hasDescription,
        hasImageTitle,
        hasImageCaption,
        getImageList,
        hasUploadUrl,
        hasUploadHandler,
        getUploadUrl,
        getUploadHandler,
        getUploadBasePath,
        getUploadCredentials
      };
      var Global = typeof domGlobals.window !== "undefined" ? domGlobals.window : Function("return this;")();
      var path = function(parts, scope) {
        var o = scope !== void 0 && scope !== null ? scope : Global;
        for (var i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
          o = o[parts[i]];
        }
        return o;
      };
      var resolve = function(p, scope) {
        var parts = p.split(".");
        return path(parts, scope);
      };
      var unsafe = function(name, scope) {
        return resolve(name, scope);
      };
      var getOrDie = function(name, scope) {
        var actual = unsafe(name, scope);
        if (actual === void 0 || actual === null) {
          throw new Error(name + " not available on this browser");
        }
        return actual;
      };
      var Global$1 = { getOrDie };
      function FileReader() {
        var f = Global$1.getOrDie("FileReader");
        return new f();
      }
      var global$1 = tinymce.util.Tools.resolve("tinymce.util.Promise");
      var global$2 = tinymce.util.Tools.resolve("tinymce.util.Tools");
      var global$3 = tinymce.util.Tools.resolve("tinymce.util.XHR");
      var parseIntAndGetMax = function(val1, val2) {
        return Math.max(parseInt(val1, 10), parseInt(val2, 10));
      };
      var getImageSize = function(url2, callback) {
        var img = domGlobals.document.createElement("img");
        function done(width, height) {
          if (img.parentNode) {
            img.parentNode.removeChild(img);
          }
          callback({
            width,
            height
          });
        }
        img.onload = function() {
          var width = parseIntAndGetMax(img.width, img.clientWidth);
          var height = parseIntAndGetMax(img.height, img.clientHeight);
          done(width, height);
        };
        img.onerror = function() {
          done(0, 0);
        };
        var style = img.style;
        style.visibility = "hidden";
        style.position = "fixed";
        style.bottom = style.left = "0px";
        style.width = style.height = "auto";
        domGlobals.document.body.appendChild(img);
        img.src = url2;
      };
      var buildListItems = function(inputList, itemCallback, startItems) {
        function appendItems(values, output2) {
          output2 = output2 || [];
          global$2.each(values, function(item) {
            var menuItem = { text: item.text || item.title };
            if (item.menu) {
              menuItem.menu = appendItems(item.menu);
            } else {
              menuItem.value = item.value;
              itemCallback(menuItem);
            }
            output2.push(menuItem);
          });
          return output2;
        }
        return appendItems(inputList, startItems || []);
      };
      var removePixelSuffix = function(value) {
        if (value) {
          value = value.replace(/px$/, "");
        }
        return value;
      };
      var addPixelSuffix = function(value) {
        if (value.length > 0 && /^[0-9]+$/.test(value)) {
          value += "px";
        }
        return value;
      };
      var mergeMargins = function(css2) {
        if (css2.margin) {
          var splitMargin = css2.margin.split(" ");
          switch (splitMargin.length) {
            case 1:
              css2["margin-top"] = css2["margin-top"] || splitMargin[0];
              css2["margin-right"] = css2["margin-right"] || splitMargin[0];
              css2["margin-bottom"] = css2["margin-bottom"] || splitMargin[0];
              css2["margin-left"] = css2["margin-left"] || splitMargin[0];
              break;
            case 2:
              css2["margin-top"] = css2["margin-top"] || splitMargin[0];
              css2["margin-right"] = css2["margin-right"] || splitMargin[1];
              css2["margin-bottom"] = css2["margin-bottom"] || splitMargin[0];
              css2["margin-left"] = css2["margin-left"] || splitMargin[1];
              break;
            case 3:
              css2["margin-top"] = css2["margin-top"] || splitMargin[0];
              css2["margin-right"] = css2["margin-right"] || splitMargin[1];
              css2["margin-bottom"] = css2["margin-bottom"] || splitMargin[2];
              css2["margin-left"] = css2["margin-left"] || splitMargin[1];
              break;
            case 4:
              css2["margin-top"] = css2["margin-top"] || splitMargin[0];
              css2["margin-right"] = css2["margin-right"] || splitMargin[1];
              css2["margin-bottom"] = css2["margin-bottom"] || splitMargin[2];
              css2["margin-left"] = css2["margin-left"] || splitMargin[3];
          }
          delete css2.margin;
        }
        return css2;
      };
      var createImageList = function(editor, callback) {
        var imageList = Settings.getImageList(editor);
        if (typeof imageList === "string") {
          global$3.send({
            url: imageList,
            success: function(text2) {
              callback(JSON.parse(text2));
            }
          });
        } else if (typeof imageList === "function") {
          imageList(callback);
        } else {
          callback(imageList);
        }
      };
      var waitLoadImage = function(editor, data, imgElm) {
        function selectImage() {
          imgElm.onload = imgElm.onerror = null;
          if (editor.selection) {
            editor.selection.select(imgElm);
            editor.nodeChanged();
          }
        }
        imgElm.onload = function() {
          if (!data.width && !data.height && Settings.hasDimensions(editor)) {
            editor.dom.setAttribs(imgElm, {
              width: imgElm.clientWidth,
              height: imgElm.clientHeight
            });
          }
          selectImage();
        };
        imgElm.onerror = selectImage;
      };
      var blobToDataUri = function(blob) {
        return new global$1(function(resolve2, reject) {
          var reader = FileReader();
          reader.onload = function() {
            resolve2(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error.message);
          };
          reader.readAsDataURL(blob);
        });
      };
      var Utils = {
        getImageSize,
        buildListItems,
        removePixelSuffix,
        addPixelSuffix,
        mergeMargins,
        createImageList,
        waitLoadImage,
        blobToDataUri
      };
      var global$4 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var shallow = function(old, nu2) {
        return nu2;
      };
      var baseMerge = function(merger) {
        return function() {
          var objects = new Array(arguments.length);
          for (var i = 0; i < objects.length; i++) {
            objects[i] = arguments[i];
          }
          if (objects.length === 0) {
            throw new Error("Can't merge zero objects");
          }
          var ret = {};
          for (var j = 0; j < objects.length; j++) {
            var curObject = objects[j];
            for (var key in curObject) {
              if (hasOwnProperty.call(curObject, key)) {
                ret[key] = merger(ret[key], curObject[key]);
              }
            }
          }
          return ret;
        };
      };
      var merge = baseMerge(shallow);
      var DOM = global$4.DOM;
      var getHspace = function(image2) {
        if (image2.style.marginLeft && image2.style.marginRight && image2.style.marginLeft === image2.style.marginRight) {
          return Utils.removePixelSuffix(image2.style.marginLeft);
        } else {
          return "";
        }
      };
      var getVspace = function(image2) {
        if (image2.style.marginTop && image2.style.marginBottom && image2.style.marginTop === image2.style.marginBottom) {
          return Utils.removePixelSuffix(image2.style.marginTop);
        } else {
          return "";
        }
      };
      var getBorder = function(image2) {
        if (image2.style.borderWidth) {
          return Utils.removePixelSuffix(image2.style.borderWidth);
        } else {
          return "";
        }
      };
      var getAttrib = function(image2, name) {
        if (image2.hasAttribute(name)) {
          return image2.getAttribute(name);
        } else {
          return "";
        }
      };
      var getStyle = function(image2, name) {
        return image2.style[name] ? image2.style[name] : "";
      };
      var hasCaption = function(image2) {
        return image2.parentNode !== null && image2.parentNode.nodeName === "FIGURE";
      };
      var setAttrib = function(image2, name, value) {
        image2.setAttribute(name, value);
      };
      var wrapInFigure = function(image2) {
        var figureElm = DOM.create("figure", { class: "image" });
        DOM.insertAfter(figureElm, image2);
        figureElm.appendChild(image2);
        figureElm.appendChild(DOM.create("figcaption", { contentEditable: true }, "Caption"));
        figureElm.contentEditable = "false";
      };
      var removeFigure = function(image2) {
        var figureElm = image2.parentNode;
        DOM.insertAfter(image2, figureElm);
        DOM.remove(figureElm);
      };
      var toggleCaption = function(image2) {
        if (hasCaption(image2)) {
          removeFigure(image2);
        } else {
          wrapInFigure(image2);
        }
      };
      var normalizeStyle = function(image2, normalizeCss2) {
        var attrValue = image2.getAttribute("style");
        var value = normalizeCss2(attrValue !== null ? attrValue : "");
        if (value.length > 0) {
          image2.setAttribute("style", value);
          image2.setAttribute("data-mce-style", value);
        } else {
          image2.removeAttribute("style");
        }
      };
      var setSize = function(name, normalizeCss2) {
        return function(image2, name2, value) {
          if (image2.style[name2]) {
            image2.style[name2] = Utils.addPixelSuffix(value);
            normalizeStyle(image2, normalizeCss2);
          } else {
            setAttrib(image2, name2, value);
          }
        };
      };
      var getSize = function(image2, name) {
        if (image2.style[name]) {
          return Utils.removePixelSuffix(image2.style[name]);
        } else {
          return getAttrib(image2, name);
        }
      };
      var setHspace = function(image2, value) {
        var pxValue = Utils.addPixelSuffix(value);
        image2.style.marginLeft = pxValue;
        image2.style.marginRight = pxValue;
      };
      var setVspace = function(image2, value) {
        var pxValue = Utils.addPixelSuffix(value);
        image2.style.marginTop = pxValue;
        image2.style.marginBottom = pxValue;
      };
      var setBorder = function(image2, value) {
        var pxValue = Utils.addPixelSuffix(value);
        image2.style.borderWidth = pxValue;
      };
      var setBorderStyle = function(image2, value) {
        image2.style.borderStyle = value;
      };
      var getBorderStyle = function(image2) {
        return getStyle(image2, "borderStyle");
      };
      var isFigure = function(elm) {
        return elm.nodeName === "FIGURE";
      };
      var defaultData = function() {
        return {
          src: "",
          alt: "",
          title: "",
          width: "",
          height: "",
          class: "",
          style: "",
          caption: false,
          hspace: "",
          vspace: "",
          border: "",
          borderStyle: ""
        };
      };
      var getStyleValue = function(normalizeCss2, data) {
        var image2 = domGlobals.document.createElement("img");
        setAttrib(image2, "style", data.style);
        if (getHspace(image2) || data.hspace !== "") {
          setHspace(image2, data.hspace);
        }
        if (getVspace(image2) || data.vspace !== "") {
          setVspace(image2, data.vspace);
        }
        if (getBorder(image2) || data.border !== "") {
          setBorder(image2, data.border);
        }
        if (getBorderStyle(image2) || data.borderStyle !== "") {
          setBorderStyle(image2, data.borderStyle);
        }
        return normalizeCss2(image2.getAttribute("style"));
      };
      var create = function(normalizeCss2, data) {
        var image2 = domGlobals.document.createElement("img");
        write(normalizeCss2, merge(data, { caption: false }), image2);
        setAttrib(image2, "alt", data.alt);
        if (data.caption) {
          var figure = DOM.create("figure", { class: "image" });
          figure.appendChild(image2);
          figure.appendChild(DOM.create("figcaption", { contentEditable: true }, "Caption"));
          figure.contentEditable = "false";
          return figure;
        } else {
          return image2;
        }
      };
      var read = function(normalizeCss2, image2) {
        return {
          src: getAttrib(image2, "src"),
          alt: getAttrib(image2, "alt"),
          title: getAttrib(image2, "title"),
          width: getSize(image2, "width"),
          height: getSize(image2, "height"),
          class: getAttrib(image2, "class"),
          style: normalizeCss2(getAttrib(image2, "style")),
          caption: hasCaption(image2),
          hspace: getHspace(image2),
          vspace: getVspace(image2),
          border: getBorder(image2),
          borderStyle: getStyle(image2, "borderStyle")
        };
      };
      var updateProp = function(image2, oldData, newData, name, set) {
        if (newData[name] !== oldData[name]) {
          set(image2, name, newData[name]);
        }
      };
      var normalized = function(set, normalizeCss2) {
        return function(image2, name, value) {
          set(image2, value);
          normalizeStyle(image2, normalizeCss2);
        };
      };
      var write = function(normalizeCss2, newData, image2) {
        var oldData = read(normalizeCss2, image2);
        updateProp(image2, oldData, newData, "caption", function(image3, _name, _value) {
          return toggleCaption(image3);
        });
        updateProp(image2, oldData, newData, "src", setAttrib);
        updateProp(image2, oldData, newData, "alt", setAttrib);
        updateProp(image2, oldData, newData, "title", setAttrib);
        updateProp(image2, oldData, newData, "width", setSize("width", normalizeCss2));
        updateProp(image2, oldData, newData, "height", setSize("height", normalizeCss2));
        updateProp(image2, oldData, newData, "class", setAttrib);
        updateProp(image2, oldData, newData, "style", normalized(function(image3, value) {
          return setAttrib(image3, "style", value);
        }, normalizeCss2));
        updateProp(image2, oldData, newData, "hspace", normalized(setHspace, normalizeCss2));
        updateProp(image2, oldData, newData, "vspace", normalized(setVspace, normalizeCss2));
        updateProp(image2, oldData, newData, "border", normalized(setBorder, normalizeCss2));
        updateProp(image2, oldData, newData, "borderStyle", normalized(setBorderStyle, normalizeCss2));
      };
      var normalizeCss = function(editor, cssText) {
        var css2 = editor.dom.styles.parse(cssText);
        var mergedCss = Utils.mergeMargins(css2);
        var compressed = editor.dom.styles.parse(editor.dom.styles.serialize(mergedCss));
        return editor.dom.styles.serialize(compressed);
      };
      var getSelectedImage = function(editor) {
        var imgElm = editor.selection.getNode();
        var figureElm = editor.dom.getParent(imgElm, "figure.image");
        if (figureElm) {
          return editor.dom.select("img", figureElm)[0];
        }
        if (imgElm && (imgElm.nodeName !== "IMG" || imgElm.getAttribute("data-mce-object") || imgElm.getAttribute("data-mce-placeholder"))) {
          return null;
        }
        return imgElm;
      };
      var splitTextBlock = function(editor, figure) {
        var dom = editor.dom;
        var textBlock = dom.getParent(figure.parentNode, function(node) {
          return editor.schema.getTextBlockElements()[node.nodeName];
        }, editor.getBody());
        if (textBlock) {
          return dom.split(textBlock, figure);
        } else {
          return figure;
        }
      };
      var readImageDataFromSelection = function(editor) {
        var image2 = getSelectedImage(editor);
        return image2 ? read(function(css2) {
          return normalizeCss(editor, css2);
        }, image2) : defaultData();
      };
      var insertImageAtCaret = function(editor, data) {
        var elm = create(function(css2) {
          return normalizeCss(editor, css2);
        }, data);
        editor.dom.setAttrib(elm, "data-mce-id", "__mcenew");
        editor.focus();
        editor.selection.setContent(elm.outerHTML);
        var insertedElm = editor.dom.select('*[data-mce-id="__mcenew"]')[0];
        editor.dom.setAttrib(insertedElm, "data-mce-id", null);
        if (isFigure(insertedElm)) {
          var figure = splitTextBlock(editor, insertedElm);
          editor.selection.select(figure);
        } else {
          editor.selection.select(insertedElm);
        }
      };
      var syncSrcAttr = function(editor, image2) {
        editor.dom.setAttrib(image2, "src", image2.getAttribute("src"));
      };
      var deleteImage = function(editor, image2) {
        if (image2) {
          var elm = editor.dom.is(image2.parentNode, "figure.image") ? image2.parentNode : image2;
          editor.dom.remove(elm);
          editor.focus();
          editor.nodeChanged();
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            editor.selection.setCursorLocation();
          }
        }
      };
      var writeImageDataToSelection = function(editor, data) {
        var image2 = getSelectedImage(editor);
        write(function(css2) {
          return normalizeCss(editor, css2);
        }, data, image2);
        syncSrcAttr(editor, image2);
        if (isFigure(image2.parentNode)) {
          var figure = image2.parentNode;
          splitTextBlock(editor, figure);
          editor.selection.select(image2.parentNode);
        } else {
          editor.selection.select(image2);
          Utils.waitLoadImage(editor, data, image2);
        }
      };
      var insertOrUpdateImage = function(editor, data) {
        var image2 = getSelectedImage(editor);
        if (image2) {
          if (data.src) {
            writeImageDataToSelection(editor, data);
          } else {
            deleteImage(editor, image2);
          }
        } else if (data.src) {
          insertImageAtCaret(editor, data);
        }
      };
      var updateVSpaceHSpaceBorder = function(editor) {
        return function(evt) {
          var dom = editor.dom;
          var rootControl = evt.control.rootControl;
          if (!Settings.hasAdvTab(editor)) {
            return;
          }
          var data = rootControl.toJSON();
          var css2 = dom.parseStyle(data.style);
          rootControl.find("#vspace").value("");
          rootControl.find("#hspace").value("");
          css2 = Utils.mergeMargins(css2);
          if (css2["margin-top"] && css2["margin-bottom"] || css2["margin-right"] && css2["margin-left"]) {
            if (css2["margin-top"] === css2["margin-bottom"]) {
              rootControl.find("#vspace").value(Utils.removePixelSuffix(css2["margin-top"]));
            } else {
              rootControl.find("#vspace").value("");
            }
            if (css2["margin-right"] === css2["margin-left"]) {
              rootControl.find("#hspace").value(Utils.removePixelSuffix(css2["margin-right"]));
            } else {
              rootControl.find("#hspace").value("");
            }
          }
          if (css2["border-width"]) {
            rootControl.find("#border").value(Utils.removePixelSuffix(css2["border-width"]));
          } else {
            rootControl.find("#border").value("");
          }
          if (css2["border-style"]) {
            rootControl.find("#borderStyle").value(css2["border-style"]);
          } else {
            rootControl.find("#borderStyle").value("");
          }
          rootControl.find("#style").value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css2))));
        };
      };
      var updateStyle = function(editor, win) {
        win.find("#style").each(function(ctrl) {
          var value = getStyleValue(function(css2) {
            return normalizeCss(editor, css2);
          }, merge(defaultData(), win.toJSON()));
          ctrl.value(value);
        });
      };
      var makeTab = function(editor) {
        return {
          title: "Advanced",
          type: "form",
          pack: "start",
          items: [
            {
              label: "Style",
              name: "style",
              type: "textbox",
              onchange: updateVSpaceHSpaceBorder(editor)
            },
            {
              type: "form",
              layout: "grid",
              packV: "start",
              columns: 2,
              padding: 0,
              defaults: {
                type: "textbox",
                maxWidth: 50,
                onchange: function(evt) {
                  updateStyle(editor, evt.control.rootControl);
                }
              },
              items: [
                {
                  label: "Vertical space",
                  name: "vspace"
                },
                {
                  label: "Border width",
                  name: "border"
                },
                {
                  label: "Horizontal space",
                  name: "hspace"
                },
                {
                  label: "Border style",
                  type: "listbox",
                  name: "borderStyle",
                  width: 90,
                  maxWidth: 90,
                  onselect: function(evt) {
                    updateStyle(editor, evt.control.rootControl);
                  },
                  values: [
                    {
                      text: "Select...",
                      value: ""
                    },
                    {
                      text: "Solid",
                      value: "solid"
                    },
                    {
                      text: "Dotted",
                      value: "dotted"
                    },
                    {
                      text: "Dashed",
                      value: "dashed"
                    },
                    {
                      text: "Double",
                      value: "double"
                    },
                    {
                      text: "Groove",
                      value: "groove"
                    },
                    {
                      text: "Ridge",
                      value: "ridge"
                    },
                    {
                      text: "Inset",
                      value: "inset"
                    },
                    {
                      text: "Outset",
                      value: "outset"
                    },
                    {
                      text: "None",
                      value: "none"
                    },
                    {
                      text: "Hidden",
                      value: "hidden"
                    }
                  ]
                }
              ]
            }
          ]
        };
      };
      var AdvTab = { makeTab };
      var doSyncSize = function(widthCtrl, heightCtrl) {
        widthCtrl.state.set("oldVal", widthCtrl.value());
        heightCtrl.state.set("oldVal", heightCtrl.value());
      };
      var doSizeControls = function(win, f) {
        var widthCtrl = win.find("#width")[0];
        var heightCtrl = win.find("#height")[0];
        var constrained = win.find("#constrain")[0];
        if (widthCtrl && heightCtrl && constrained) {
          f(widthCtrl, heightCtrl, constrained.checked());
        }
      };
      var doUpdateSize = function(widthCtrl, heightCtrl, isContrained) {
        var oldWidth = widthCtrl.state.get("oldVal");
        var oldHeight = heightCtrl.state.get("oldVal");
        var newWidth = widthCtrl.value();
        var newHeight = heightCtrl.value();
        if (isContrained && oldWidth && oldHeight && newWidth && newHeight) {
          if (newWidth !== oldWidth) {
            newHeight = Math.round(newWidth / oldWidth * newHeight);
            if (!isNaN(newHeight)) {
              heightCtrl.value(newHeight);
            }
          } else {
            newWidth = Math.round(newHeight / oldHeight * newWidth);
            if (!isNaN(newWidth)) {
              widthCtrl.value(newWidth);
            }
          }
        }
        doSyncSize(widthCtrl, heightCtrl);
      };
      var syncSize = function(win) {
        doSizeControls(win, doSyncSize);
      };
      var updateSize = function(win) {
        doSizeControls(win, doUpdateSize);
      };
      var createUi = function() {
        var recalcSize = function(evt) {
          updateSize(evt.control.rootControl);
        };
        return {
          type: "container",
          label: "Dimensions",
          layout: "flex",
          align: "center",
          spacing: 5,
          items: [
            {
              name: "width",
              type: "textbox",
              maxLength: 5,
              size: 5,
              onchange: recalcSize,
              ariaLabel: "Width"
            },
            {
              type: "label",
              text: "x"
            },
            {
              name: "height",
              type: "textbox",
              maxLength: 5,
              size: 5,
              onchange: recalcSize,
              ariaLabel: "Height"
            },
            {
              name: "constrain",
              type: "checkbox",
              checked: true,
              text: "Constrain proportions"
            }
          ]
        };
      };
      var SizeManager = {
        createUi,
        syncSize,
        updateSize
      };
      var onSrcChange = function(evt, editor) {
        var srcURL, prependURL, absoluteURLPattern;
        var meta = evt.meta || {};
        var control = evt.control;
        var rootControl = control.rootControl;
        var imageListCtrl = rootControl.find("#image-list")[0];
        if (imageListCtrl) {
          imageListCtrl.value(editor.convertURL(control.value(), "src"));
        }
        global$2.each(meta, function(value, key) {
          rootControl.find("#" + key).value(value);
        });
        if (!meta.width && !meta.height) {
          srcURL = editor.convertURL(control.value(), "src");
          prependURL = Settings.getPrependUrl(editor);
          absoluteURLPattern = new RegExp("^(?:[a-z]+:)?//", "i");
          if (prependURL && !absoluteURLPattern.test(srcURL) && srcURL.substring(0, prependURL.length) !== prependURL) {
            srcURL = prependURL + srcURL;
          }
          control.value(srcURL);
          Utils.getImageSize(editor.documentBaseURI.toAbsolute(control.value()), function(data) {
            if (data.width && data.height && Settings.hasDimensions(editor)) {
              rootControl.find("#width").value(data.width);
              rootControl.find("#height").value(data.height);
              SizeManager.syncSize(rootControl);
            }
          });
        }
      };
      var onBeforeCall = function(evt) {
        evt.meta = evt.control.rootControl.toJSON();
      };
      var getGeneralItems = function(editor, imageListCtrl) {
        var generalFormItems = [
          {
            name: "src",
            type: "filepicker",
            filetype: "image",
            label: "Source",
            autofocus: true,
            onchange: function(evt) {
              onSrcChange(evt, editor);
            },
            onbeforecall: onBeforeCall
          },
          imageListCtrl
        ];
        if (Settings.hasDescription(editor)) {
          generalFormItems.push({
            name: "alt",
            type: "textbox",
            label: "Image description"
          });
        }
        if (Settings.hasImageTitle(editor)) {
          generalFormItems.push({
            name: "title",
            type: "textbox",
            label: "Image Title"
          });
        }
        if (Settings.hasDimensions(editor)) {
          generalFormItems.push(SizeManager.createUi());
        }
        if (Settings.getClassList(editor)) {
          generalFormItems.push({
            name: "class",
            type: "listbox",
            label: "Class",
            values: Utils.buildListItems(Settings.getClassList(editor), function(item) {
              if (item.value) {
                item.textStyle = function() {
                  return editor.formatter.getCssText({
                    inline: "img",
                    classes: [item.value]
                  });
                };
              }
            })
          });
        }
        if (Settings.hasImageCaption(editor)) {
          generalFormItems.push({
            name: "caption",
            type: "checkbox",
            label: "Caption"
          });
        }
        return generalFormItems;
      };
      var makeTab$1 = function(editor, imageListCtrl) {
        return {
          title: "General",
          type: "form",
          items: getGeneralItems(editor, imageListCtrl)
        };
      };
      var MainTab = {
        makeTab: makeTab$1,
        getGeneralItems
      };
      var url = function() {
        return Global$1.getOrDie("URL");
      };
      var createObjectURL = function(blob) {
        return url().createObjectURL(blob);
      };
      var revokeObjectURL = function(u) {
        url().revokeObjectURL(u);
      };
      var URL = {
        createObjectURL,
        revokeObjectURL
      };
      var global$5 = tinymce.util.Tools.resolve("tinymce.ui.Factory");
      function XMLHttpRequest() {
        var f = Global$1.getOrDie("XMLHttpRequest");
        return new f();
      }
      var noop = function() {
      };
      var pathJoin = function(path1, path2) {
        if (path1) {
          return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
        }
        return path2;
      };
      function Uploader(settings) {
        var defaultHandler = function(blobInfo, success, failure, progress) {
          var xhr, formData;
          xhr = XMLHttpRequest();
          xhr.open("POST", settings.url);
          xhr.withCredentials = settings.credentials;
          xhr.upload.onprogress = function(e) {
            progress(e.loaded / e.total * 100);
          };
          xhr.onerror = function() {
            failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
          };
          xhr.onload = function() {
            var json;
            if (xhr.status < 200 || xhr.status >= 300) {
              failure("HTTP Error: " + xhr.status);
              return;
            }
            json = JSON.parse(xhr.responseText);
            if (!json || typeof json.location !== "string") {
              failure("Invalid JSON: " + xhr.responseText);
              return;
            }
            success(pathJoin(settings.basePath, json.location));
          };
          formData = new domGlobals.FormData();
          formData.append("file", blobInfo.blob(), blobInfo.filename());
          xhr.send(formData);
        };
        var uploadBlob = function(blobInfo, handler) {
          return new global$1(function(resolve2, reject) {
            try {
              handler(blobInfo, resolve2, reject, noop);
            } catch (ex) {
              reject(ex.message);
            }
          });
        };
        var isDefaultHandler = function(handler) {
          return handler === defaultHandler;
        };
        var upload = function(blobInfo) {
          return !settings.url && isDefaultHandler(settings.handler) ? global$1.reject("Upload url missing from the settings.") : uploadBlob(blobInfo, settings.handler);
        };
        settings = global$2.extend({
          credentials: false,
          handler: defaultHandler
        }, settings);
        return { upload };
      }
      var onFileInput = function(editor) {
        return function(evt) {
          var Throbber = global$5.get("Throbber");
          var rootControl = evt.control.rootControl;
          var throbber = new Throbber(rootControl.getEl());
          var file = evt.control.value();
          var blobUri = URL.createObjectURL(file);
          var uploader = Uploader({
            url: Settings.getUploadUrl(editor),
            basePath: Settings.getUploadBasePath(editor),
            credentials: Settings.getUploadCredentials(editor),
            handler: Settings.getUploadHandler(editor)
          });
          var finalize = function() {
            throbber.hide();
            URL.revokeObjectURL(blobUri);
          };
          throbber.show();
          return Utils.blobToDataUri(file).then(function(dataUrl) {
            var blobInfo = editor.editorUpload.blobCache.create({
              blob: file,
              blobUri,
              name: file.name ? file.name.replace(/\.[^\.]+$/, "") : null,
              base64: dataUrl.split(",")[1]
            });
            return uploader.upload(blobInfo).then(function(url2) {
              var src2 = rootControl.find("#src");
              src2.value(url2);
              rootControl.find("tabpanel")[0].activateTab(0);
              src2.fire("change");
              finalize();
              return url2;
            });
          }).catch(function(err) {
            editor.windowManager.alert(err);
            finalize();
          });
        };
      };
      var acceptExts = ".jpg,.jpeg,.png,.gif";
      var makeTab$2 = function(editor) {
        return {
          title: "Upload",
          type: "form",
          layout: "flex",
          direction: "column",
          align: "stretch",
          padding: "20 20 20 20",
          items: [
            {
              type: "container",
              layout: "flex",
              direction: "column",
              align: "center",
              spacing: 10,
              items: [
                {
                  text: "Browse for an image",
                  type: "browsebutton",
                  accept: acceptExts,
                  onchange: onFileInput(editor)
                },
                {
                  text: "OR",
                  type: "label"
                }
              ]
            },
            {
              text: "Drop an image here",
              type: "dropzone",
              accept: acceptExts,
              height: 100,
              onchange: onFileInput(editor)
            }
          ]
        };
      };
      var UploadTab = { makeTab: makeTab$2 };
      function curry(fn) {
        var initialArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          initialArgs[_i - 1] = arguments[_i];
        }
        return function() {
          var restArgs = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            restArgs[_i2] = arguments[_i2];
          }
          var all = initialArgs.concat(restArgs);
          return fn.apply(null, all);
        };
      }
      var submitForm = function(editor, evt) {
        var win = evt.control.getRoot();
        SizeManager.updateSize(win);
        editor.undoManager.transact(function() {
          var data = merge(readImageDataFromSelection(editor), win.toJSON());
          insertOrUpdateImage(editor, data);
        });
        editor.editorUpload.uploadImagesAuto();
      };
      function Dialog(editor) {
        function showDialog(imageList) {
          var data = readImageDataFromSelection(editor);
          var win, imageListCtrl;
          if (imageList) {
            imageListCtrl = {
              type: "listbox",
              label: "Image list",
              name: "image-list",
              values: Utils.buildListItems(imageList, function(item) {
                item.value = editor.convertURL(item.value || item.url, "src");
              }, [{
                text: "None",
                value: ""
              }]),
              value: data.src && editor.convertURL(data.src, "src"),
              onselect: function(e) {
                var altCtrl = win.find("#alt");
                if (!altCtrl.value() || e.lastControl && altCtrl.value() === e.lastControl.text()) {
                  altCtrl.value(e.control.text());
                }
                win.find("#src").value(e.control.value()).fire("change");
              },
              onPostRender: function() {
                imageListCtrl = this;
              }
            };
          }
          if (Settings.hasAdvTab(editor) || Settings.hasUploadUrl(editor) || Settings.hasUploadHandler(editor)) {
            var body = [MainTab.makeTab(editor, imageListCtrl)];
            if (Settings.hasAdvTab(editor)) {
              body.push(AdvTab.makeTab(editor));
            }
            if (Settings.hasUploadUrl(editor) || Settings.hasUploadHandler(editor)) {
              body.push(UploadTab.makeTab(editor));
            }
            win = editor.windowManager.open({
              title: "Insert/edit image",
              data,
              bodyType: "tabpanel",
              body,
              onSubmit: curry(submitForm, editor)
            });
          } else {
            win = editor.windowManager.open({
              title: "Insert/edit image",
              data,
              body: MainTab.getGeneralItems(editor, imageListCtrl),
              onSubmit: curry(submitForm, editor)
            });
          }
          SizeManager.syncSize(win);
        }
        function open() {
          Utils.createImageList(editor, showDialog);
        }
        return { open };
      }
      var register = function(editor) {
        editor.addCommand("mceImage", Dialog(editor).open);
      };
      var Commands = { register };
      var hasImageClass = function(node) {
        var className = node.attr("class");
        return className && /\bimage\b/.test(className);
      };
      var toggleContentEditableState = function(state) {
        return function(nodes) {
          var i = nodes.length, node;
          var toggleContentEditable = function(node2) {
            node2.attr("contenteditable", state ? "true" : null);
          };
          while (i--) {
            node = nodes[i];
            if (hasImageClass(node)) {
              node.attr("contenteditable", state ? "false" : null);
              global$2.each(node.getAll("figcaption"), toggleContentEditable);
            }
          }
        };
      };
      var setup = function(editor) {
        editor.on("preInit", function() {
          editor.parser.addNodeFilter("figure", toggleContentEditableState(true));
          editor.serializer.addNodeFilter("figure", toggleContentEditableState(false));
        });
      };
      var FilterContent = { setup };
      var register$1 = function(editor) {
        editor.addButton("image", {
          icon: "image",
          tooltip: "Insert/edit image",
          onclick: Dialog(editor).open,
          stateSelector: "img:not([data-mce-object],[data-mce-placeholder]),figure.image"
        });
        editor.addMenuItem("image", {
          icon: "image",
          text: "Image",
          onclick: Dialog(editor).open,
          context: "insert",
          prependToContext: true
        });
      };
      var Buttons = { register: register$1 };
      global2.add("image", function(editor) {
        FilterContent.setup(editor);
        Buttons.register(editor);
        Commands.register(editor);
      });
      function Plugin() {
      }
      return Plugin;
    })(window);
  })();
  return plugin;
}
var hasRequiredImage;
function requireImage() {
  if (hasRequiredImage) return image;
  hasRequiredImage = 1;
  requirePlugin();
  return image;
}
requireImage();
tinymce.addI18n("ru", {
  "Redo": "ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  "Undo": "Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ",
  "Cut": "Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ",
  "Copy": "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  "Paste": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
  "Select all": "Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ",
  "New document": "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚",
  "Ok": "ĞĞº",
  "Cancel": "ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  "Visual aids": "ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ‚ÑƒÑ€Ñ‹",
  "Bold": "ĞŸĞ¾Ğ»ÑƒĞ¶Ğ¸Ñ€Ğ½Ñ‹Ğ¹",
  "Italic": "ĞšÑƒÑ€ÑĞ¸Ğ²",
  "Underline": "ĞŸĞ¾Ğ´Ñ‡ĞµÑ€ĞºĞ½ÑƒÑ‚Ñ‹Ğ¹",
  "Strikethrough": "Ğ—Ğ°Ñ‡ĞµÑ€ĞºĞ½ÑƒÑ‚Ñ‹Ğ¹",
  "Superscript": "Ğ’ĞµÑ€Ñ…Ğ½Ğ¸Ğ¹ Ğ¸Ğ½Ğ´ĞµĞºÑ",
  "Subscript": "ĞĞ¸Ğ¶Ğ½Ğ¸Ğ¹ Ğ¸Ğ½Ğ´ĞµĞºÑ",
  "Clear formatting": "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚",
  "Align left": "ĞŸĞ¾ Ğ»ĞµĞ²Ğ¾Ğ¼Ñƒ ĞºÑ€Ğ°Ñ",
  "Align center": "ĞŸĞ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ",
  "Align right": "ĞŸĞ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼Ñƒ ĞºÑ€Ğ°Ñ",
  "Justify": "ĞŸĞ¾ ÑˆĞ¸Ñ€Ğ¸Ğ½Ğµ",
  "Bullet list": "ĞœĞ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº",
  "Numbered list": "ĞÑƒĞ¼ĞµÑ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº",
  "Decrease indent": "Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿",
  "Increase indent": "Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿",
  "Close": "Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
  "Formats": "Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚",
  "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": "Ğ’Ğ°Ñˆ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¿Ñ€ÑĞ¼Ğ¾Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ±ÑƒÑ„ĞµÑ€Ñƒ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑĞ¾Ñ‡ĞµÑ‚Ğ°Ğ½Ğ¸Ñ ĞºĞ»Ğ°Ğ²Ğ¸Ñˆ: Ctrl+X/C/V.",
  "Headers": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸",
  "Header 1": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 1",
  "Header 2": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 2",
  "Header 3": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 3",
  "Header 4": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 4",
  "Header 5": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 5",
  "Header 6": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 6",
  "Headings": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸",
  "Heading 1": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 1",
  "Heading 2": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 2",
  "Heading 3": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 3",
  "Heading 4": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 4",
  "Heading 5": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 5",
  "Heading 6": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº 6",
  "Preformatted": "ĞŸÑ€ĞµĞ´Ğ²Ğ°Ñ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "Div": "Ğ‘Ğ»Ğ¾Ğº",
  "Pre": "ĞŸÑ€ĞµĞ´Ğ²Ğ°Ñ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "Code": "ĞšĞ¾Ğ´",
  "Paragraph": "ĞŸĞ°Ñ€Ğ°Ğ³Ñ€Ğ°Ñ„",
  "Blockquote": "Ğ¦Ğ¸Ñ‚Ğ°Ñ‚Ğ°",
  "Inline": "Ğ¡Ñ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ",
  "Blocks": "Ğ‘Ğ»Ğ¾ĞºĞ¸",
  "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "Ğ’ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ¾ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ»ÑĞµÑ‚ÑÑ Ğ² Ğ²Ğ¸Ğ´Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ‚ĞµĞºÑÑ‚Ğ°, Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½ÑƒÑ Ğ¾Ğ¿Ñ†Ğ¸Ñ.",
  "Font Family": "Ğ¨Ñ€Ğ¸Ñ„Ñ‚",
  "Font Sizes": "Ğ Ğ°Ğ·Ğ¼ĞµÑ€ ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°",
  "Class": "ĞšĞ»Ğ°ÑÑ",
  "Browse for an image": "Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ",
  "OR": "Ğ˜Ğ›Ğ˜",
  "Drop an image here": "ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑĞ´Ğ°",
  "Upload": "Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ",
  "Block": "Ğ‘Ğ»Ğ¾Ğº",
  "Align": "Ğ’Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "Default": "Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹",
  "Circle": "ĞĞºÑ€ÑƒĞ¶Ğ½Ğ¾ÑÑ‚Ğ¸",
  "Disc": "ĞšÑ€ÑƒĞ³Ğ¸",
  "Square": "ĞšĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ñ‹",
  "Lower Alpha": "Ğ¡Ñ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ğµ Ğ±ÑƒĞºĞ²Ñ‹",
  "Lower Greek": "Ğ¡Ñ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ³Ñ€ĞµÑ‡ĞµÑĞºĞ¸Ğµ Ğ±ÑƒĞºĞ²Ñ‹",
  "Lower Roman": "Ğ¡Ñ‚Ñ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ñ€Ğ¸Ğ¼ÑĞºĞ¸Ğµ Ñ†Ğ¸Ñ„Ñ€Ñ‹",
  "Upper Alpha": "Ğ—Ğ°Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ Ğ»Ğ°Ñ‚Ğ¸Ğ½ÑĞºĞ¸Ğµ Ğ±ÑƒĞºĞ²Ñ‹",
  "Upper Roman": "Ğ—Ğ°Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ Ñ€Ğ¸Ğ¼ÑĞºĞ¸Ğµ Ñ†Ğ¸Ñ„Ñ€Ñ‹",
  "Anchor": "Ğ¯ĞºĞ¾Ñ€ÑŒ",
  "Name": "Ğ˜Ğ¼Ñ",
  "Id": "Id",
  "Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "Id Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°Ñ‚ÑŒÑÑ Ñ Ğ±ÑƒĞºĞ²Ñ‹, Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ‚ÑŒÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ Ğ±ÑƒĞºĞ²Ñ‹, Ñ†Ğ¸Ñ„Ñ€Ñ‹, Ñ‚Ğ¸Ñ€Ğµ, Ñ‚Ğ¾Ñ‡ĞºĞ¸, Ğ´Ğ²Ğ¾ĞµÑ‚Ğ¾Ñ‡Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ´Ñ‡ĞµÑ€ĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ.",
  "You have unsaved changes are you sure you want to navigate away?": "Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ½Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ. Ğ’Ñ‹ ÑƒĞ²ĞµÑ€ĞµĞ½Ñ‹, Ñ‡Ñ‚Ğ¾ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ¹Ñ‚Ğ¸?",
  "Restore last draft": "Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°",
  "Special character": "Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹",
  "Source code": "Ğ˜ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´",
  "Insert/Edit code sample": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ/Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ ĞºĞ¾Ğ´Ğ°",
  "Language": "Ğ¯Ğ·Ñ‹Ğº",
  "Code sample": "ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ ĞºĞ¾Ğ´Ğ°",
  "Color": "Ğ¦Ğ²ĞµÑ‚",
  "R": "R",
  "G": "G",
  "B": "B",
  "Left to right": "ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ»ĞµĞ²Ğ° Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ¾",
  "Right to left": "ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ¿Ñ€Ğ°Ğ²Ğ° Ğ½Ğ°Ğ»ĞµĞ²Ğ¾",
  "Emoticons": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¼Ğ°Ğ¹Ğ»",
  "Document properties": "Ğ¡Ğ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°",
  "Title": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº",
  "Keywords": "ĞšĞ»ÑÑ‡Ğ¸Ğ²Ñ‹Ğµ ÑĞ»Ğ¾Ğ²Ğ°",
  "Description": "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
  "Robots": "Ğ Ğ¾Ğ±Ğ¾Ñ‚Ñ‹",
  "Author": "ĞĞ²Ñ‚Ğ¾Ñ€",
  "Encoding": "ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°",
  "Fullscreen": "ĞŸĞ¾Ğ»Ğ½Ğ¾ÑĞºÑ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼",
  "Action": "Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ",
  "Shortcut": "Ğ¯Ñ€Ğ»Ñ‹Ğº",
  "Help": "ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ",
  "Address": "ĞĞ´Ñ€ĞµÑ",
  "Focus to menubar": "Ğ¤Ğ¾ĞºÑƒÑ Ğ½Ğ° Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸ Ğ¼ĞµĞ½Ñ",
  "Focus to toolbar": "Ğ¤Ğ¾ĞºÑƒÑ Ğ½Ğ° Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²",
  "Focus to element path": "Ğ¤Ğ¾ĞºÑƒÑ Ğ½Ğ° ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğµ Ğ¿ÑƒÑ‚Ğ¸",
  "Focus to contextual toolbar": "Ğ¤Ğ¾ĞºÑƒÑ Ğ½Ğ° ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ğ½ĞµĞ»Ğ¸ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²",
  "Insert link (if link plugin activated)": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ (ĞµÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½ link Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)",
  "Save (if save plugin activated)": "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ (ĞµÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½ save Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)",
  "Find (if searchreplace plugin activated)": "ĞĞ°Ğ¹Ñ‚Ğ¸ (ĞµÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½ searchreplace Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)",
  "Plugins installed ({0}):": "Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ñ‹ ({0}):",
  "Premium plugins:": "ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ñ‹:",
  "Learn more...": "Ğ£Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ...",
  "You are using {0}": "Ğ’Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚Ğµ {0}",
  "Plugins": "ĞŸĞ»Ğ°Ğ³Ğ¸Ğ½Ñ‹",
  "Handy Shortcuts": "Ğ“Ğ¾Ñ€ÑÑ‡Ğ¸Ğµ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ¸",
  "Horizontal line": "Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ»Ğ¸Ğ½Ğ¸Ñ",
  "Insert/edit image": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ/Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  "Image description": "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ",
  "Source": "Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº",
  "Dimensions": "Ğ Ğ°Ğ·Ğ¼ĞµÑ€",
  "Constrain proportions": "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ğ¸Ğ¸",
  "General": "ĞĞ±Ñ‰ĞµĞµ",
  "Advanced": "Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ñ‹Ğµ",
  "Style": "Ğ¡Ñ‚Ğ¸Ğ»ÑŒ",
  "Vertical space": "Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»",
  "Horizontal space": "Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»",
  "Border": "Ğ Ğ°Ğ¼ĞºĞ°",
  "Insert image": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  "Image": "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ",
  "Image list": "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹",
  "Rotate counterclockwise": "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ² Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€ĞµĞ»ĞºĞ¸",
  "Rotate clockwise": "ĞŸĞ¾Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¿Ğ¾ Ñ‡Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€ĞµĞ»ĞºĞµ",
  "Flip vertically": "ĞÑ‚Ñ€Ğ°Ğ·Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ğ²ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»Ğ¸",
  "Flip horizontally": "ĞÑ‚Ñ€Ğ°Ğ·Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ğ³Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»Ğ¸",
  "Edit image": "Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  "Image options": "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ",
  "Zoom in": "ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ÑŒ",
  "Zoom out": "ĞÑ‚Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ",
  "Crop": "ĞĞ±Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ",
  "Resize": "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€",
  "Orientation": "ĞÑ€Ğ¸ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ",
  "Brightness": "Ğ¯Ñ€ĞºĞ¾ÑÑ‚ÑŒ",
  "Sharpen": "Ğ§ĞµÑ‚ĞºĞ¾ÑÑ‚ÑŒ",
  "Contrast": "ĞšĞ¾Ğ½Ñ‚Ñ€Ğ°ÑÑ‚",
  "Color levels": "Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸",
  "Gamma": "Ğ“Ğ°Ğ¼Ğ¼Ğ°",
  "Invert": "Ğ˜Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ",
  "Apply": "ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  "Back": "ĞĞ°Ğ·Ğ°Ğ´",
  "Insert date/time": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ñ‚Ñƒ/Ğ²Ñ€ĞµĞ¼Ñ",
  "Date/time": "Ğ”Ğ°Ñ‚Ğ°/Ğ²Ñ€ĞµĞ¼Ñ",
  "Insert link": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
  "Insert/edit link": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ/Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
  "Text to display": "ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚",
  "Url": "ĞĞ´Ñ€ĞµÑ ÑÑÑ‹Ğ»ĞºĞ¸",
  "Target": "ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
  "None": "ĞĞµÑ‚",
  "New window": "Ğ’ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ¾ĞºĞ½Ğµ",
  "Remove link": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ",
  "Anchors": "Ğ¯ĞºĞ¾Ñ€Ñ",
  "Link": "Ğ¡ÑÑ‹Ğ»ĞºĞ°",
  "Paste or type a link": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ»Ğ¸ Ğ²ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑÑ‹Ğ»ĞºÑƒ",
  "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "Ğ’Ğ²ĞµĞ´Ñ‘Ğ½Ğ½Ñ‹Ğ¹ URL ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¼ Ğ°Ğ´Ñ€ĞµÑĞ¾Ğ¼ ÑĞ»ĞµĞºÑ‚Ñ€Ğ¾Ğ½Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ñ‡Ñ‚Ñ‹. Ğ’Ñ‹ Ğ¶ĞµĞ»Ğ°ĞµÑ‚Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑ Â«mailto:Â»?",
  "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?": "Ğ’Ğ²ĞµĞ´Ñ‘Ğ½Ğ½Ñ‹Ğ¹ URL ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ²Ğ½ĞµÑˆĞ½ĞµĞ¹ ÑÑÑ‹Ğ»ĞºĞ¾Ğ¹. Ğ’Ñ‹ Ğ¶ĞµĞ»Ğ°ĞµÑ‚Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑ Â«http://Â»?",
  "Link list": "Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑÑÑ‹Ğ»Ğ¾Ğº",
  "Insert video": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾",
  "Insert/edit video": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ/Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾",
  "Insert/edit media": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ/Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ¸Ğ´ĞµĞ¾",
  "Alternative source": "ĞĞ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº",
  "Poster": "Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ",
  "Paste your embed code below:": "Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ²Ğ°Ñˆ ĞºĞ¾Ğ´ Ğ½Ğ¸Ğ¶Ğµ:",
  "Embed": "ĞšĞ¾Ğ´ Ğ´Ğ»Ñ Ğ²ÑÑ‚Ğ°Ğ²ĞºĞ¸",
  "Media": "Ğ’Ğ¸Ğ´ĞµĞ¾",
  "Nonbreaking space": "ĞĞµÑ€Ğ°Ğ·Ñ€Ñ‹Ğ²Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»",
  "Page break": "Ğ Ğ°Ğ·Ñ€Ñ‹Ğ² ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹",
  "Paste as text": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº Ñ‚ĞµĞºÑÑ‚",
  "Preview": "ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€",
  "Print": "ĞŸĞµÑ‡Ğ°Ñ‚ÑŒ",
  "Save": "Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ",
  "Find": "ĞĞ°Ğ¹Ñ‚Ğ¸",
  "Replace with": "Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ°",
  "Replace": "Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  "Replace all": "Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ",
  "Prev": "Ğ’Ğ²ĞµÑ€Ñ…",
  "Next": "Ğ’Ğ½Ğ¸Ğ·",
  "Find and replace": "ĞŸĞ¾Ğ¸ÑĞº Ğ¸ Ğ·Ğ°Ğ¼ĞµĞ½Ğ°",
  "Could not find the specified string.": "Ğ—Ğ°Ğ´Ğ°Ğ½Ğ½Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°",
  "Match case": "Ğ£Ñ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€",
  "Whole words": "Ğ¡Ğ»Ğ¾Ğ²Ğ¾ Ñ†ĞµĞ»Ğ¸ĞºĞ¾Ğ¼",
  "Spellcheck": "ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ",
  "Ignore": "Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ",
  "Ignore all": "Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ",
  "Finish": "Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑŒ",
  "Add to Dictionary": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ÑĞ»Ğ¾Ğ²Ğ°Ñ€ÑŒ",
  "Insert table": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ",
  "Table properties": "Ğ¡Ğ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹",
  "Delete table": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ",
  "Cell": "Ğ¯Ñ‡ĞµĞ¹ĞºĞ°",
  "Row": "Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ°",
  "Column": "Ğ¡Ñ‚Ğ¾Ğ»Ğ±ĞµÑ†",
  "Cell properties": "ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ÑÑ‡ĞµĞ¹ĞºĞ¸",
  "Merge cells": "ĞĞ±ÑŠĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒ ÑÑ‡ĞµĞ¹ĞºĞ¸",
  "Split cell": "Ğ Ğ°Ğ·Ğ±Ğ¸Ñ‚ÑŒ ÑÑ‡ĞµĞ¹ĞºÑƒ",
  "Insert row before": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ ÑĞ²ĞµÑ€Ñ…Ñƒ",
  "Insert row after": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ ÑĞ½Ğ¸Ğ·Ñƒ",
  "Delete row": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ",
  "Row properties": "ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸",
  "Cut row": "Ğ’Ñ‹Ñ€ĞµĞ·Ğ°Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ",
  "Copy row": "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ",
  "Paste row before": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ ÑĞ²ĞµÑ€Ñ…Ñƒ",
  "Paste row after": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ ÑĞ½Ğ¸Ğ·Ñƒ",
  "Insert column before": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† ÑĞ»ĞµĞ²Ğ°",
  "Insert column after": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ† ÑĞ¿Ñ€Ğ°Ğ²Ğ°",
  "Delete column": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ»Ğ±ĞµÑ†",
  "Cols": "Ğ¡Ñ‚Ğ¾Ğ»Ğ±Ñ†Ñ‹",
  "Rows": "Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ¸",
  "Width": "Ğ¨Ğ¸Ñ€Ğ¸Ğ½Ğ°",
  "Height": "Ğ’Ñ‹ÑĞ¾Ñ‚Ğ°",
  "Cell spacing": "Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿",
  "Cell padding": "Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿",
  "Caption": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº",
  "Left": "ĞŸĞ¾ Ğ»ĞµĞ²Ğ¾Ğ¼Ñƒ ĞºÑ€Ğ°Ñ",
  "Center": "ĞŸĞ¾ Ñ†ĞµĞ½Ñ‚Ñ€Ñƒ",
  "Right": "ĞŸĞ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ¼Ñƒ ĞºÑ€Ğ°Ñ",
  "Cell type": "Ğ¢Ğ¸Ğ¿ ÑÑ‡ĞµĞ¹ĞºĞ¸",
  "Scope": "Scope",
  "Alignment": "Ğ’Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "H Align": "Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "V Align": "Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ",
  "Top": "ĞŸĞ¾ Ğ²ĞµÑ€Ñ…Ñƒ",
  "Middle": "ĞŸĞ¾ ÑĞµÑ€ĞµĞ´Ğ¸Ğ½Ğµ",
  "Bottom": "ĞŸĞ¾ Ğ½Ğ¸Ğ·Ñƒ",
  "Header cell": "Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº",
  "Row group": "Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ÑÑ‚Ñ€Ğ¾Ğº",
  "Column group": "Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° ĞºĞ¾Ğ»Ğ¾Ğ½Ğ¾Ğº",
  "Row type": "Ğ¢Ğ¸Ğ¿ ÑÑ‚Ñ€Ğ¾ĞºĞ¸",
  "Header": "Ğ¨Ğ°Ğ¿ĞºĞ°",
  "Body": "Ğ¢ĞµĞ»Ğ¾",
  "Footer": "ĞĞ¸Ğ·",
  "Border color": "Ğ¦Ğ²ĞµÑ‚ Ñ€Ğ°Ğ¼ĞºĞ¸",
  "Insert template": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½",
  "Templates": "Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½Ñ‹",
  "Template": "Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½",
  "Text color": "Ğ¦Ğ²ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚Ğ°",
  "Background color": "Ğ¦Ğ²ĞµÑ‚ Ñ„Ğ¾Ğ½Ğ°",
  "Custom...": "Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒâ€¦",
  "Custom color": "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğ¹ Ñ†Ğ²ĞµÑ‚",
  "No color": "Ğ‘ĞµĞ· Ñ†Ğ²ĞµÑ‚Ğ°",
  "Table of Contents": "Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ",
  "Show blocks": "ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ»Ğ¾ĞºĞ¸",
  "Show invisible characters": "ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµĞ²Ğ¸Ğ´Ğ¸Ğ¼Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹",
  "Words: {0}": "ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ»Ğ¾Ğ²: {0}",
  "{0} words": "ÑĞ»Ğ¾Ğ²: {0}",
  "File": "Ğ¤Ğ°Ğ¹Ğ»",
  "Edit": "Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ",
  "Insert": "Ğ’ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ",
  "View": "Ğ’Ğ¸Ğ´",
  "Format": "Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚",
  "Table": "Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°",
  "Tools": "Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹",
  "Powered by {0}": "ĞŸÑ€Ğ¸ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞµ {0}",
  "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "Ğ¢ĞµĞºÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ğ¾Ğ»Ğµ. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ALT-F9 Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ¼ĞµĞ½Ñ, ALT-F10 Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ², ALT-0 Ğ´Ğ»Ñ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ° Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ¸."
});
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var sanitizeHtml = { exports: {} };
var hasRequiredSanitizeHtml;
function requireSanitizeHtml() {
  if (hasRequiredSanitizeHtml) return sanitizeHtml.exports;
  hasRequiredSanitizeHtml = 1;
  (function(module, exports$1) {
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray2(o)) || allowArrayLike) {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it2 = o[Symbol.iterator]();
      }, n: function n() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it2["return"] != null) it2["return"]();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    (function(f) {
      if (_typeof(exports$1) === "object" && true) {
        module.exports = f();
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof commonjsGlobal !== "undefined") {
          g = commonjsGlobal;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.sanitizeHtml = f();
      }
    })(function() {
      return (/* @__PURE__ */ (function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof commonjsRequire && commonjsRequire;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++) {
            o(t[i]);
          }
          return o;
        }
        return r;
      })())({ 1: [function(require2, module3, exports3) {
        exports3.byteLength = byteLength;
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code2.length; i < len; ++i) {
          lookup[i] = code2[i];
          revLookup[code2.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1) validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num2) {
          return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output2 = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output2.push(tripletToBase64(tmp));
          }
          return output2.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
          }
          return parts.join("");
        }
      }, {}], 2: [function(require2, module3, exports3) {
      }, {}], 3: [function(require2, module3, exports3) {
        (function(Buffer) {
          var base64 = require2("base64-js");
          var ieee754 = require2("ieee754");
          exports3.Buffer = Buffer;
          exports3.SlowBuffer = SlowBuffer;
          exports3.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 2147483647;
          exports3.kMaxLength = K_MAX_LENGTH;
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
          }
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
                return 42;
              } };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer.prototype, "parent", { enumerable: true, get: function get() {
            if (!Buffer.isBuffer(this)) return void 0;
            return this.buffer;
          } });
          Object.defineProperty(Buffer.prototype, "offset", { enumerable: true, get: function get() {
            if (!Buffer.isBuffer(this)) return void 0;
            return this.byteOffset;
          } });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer.prototype;
            return buf;
          }
          function Buffer(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }
          if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false });
          }
          Buffer.poolSize = 8192;
          function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b) return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
              return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            }
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof(value));
          }
          Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== void 0) {
              return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }
          Buffer.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }
          Buffer.allocUnsafe = function(size) {
            return allocUnsafe(size);
          };
          Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === void 0 && length === void 0) {
              buf = new Uint8Array(array);
            } else if (length === void 0) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }
            buf.__proto__ = Buffer.prototype;
            return buf;
          }
          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== void 0) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            if (length >= K_MAX_LENGTH) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype;
          };
          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list2, length) {
            if (!Array.isArray(list2)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list2.length === 0) {
              return Buffer.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list2.length; ++i) {
                length += list2[i].length;
              }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list2.length; ++i) {
              var buf = list2[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + _typeof(string));
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length;
                  }
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding) encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.toLocaleString = Buffer.prototype.toString;
          Buffer.prototype.equals = function equals2(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports3.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max) str += " ... ";
            return "<Buffer " + str + ">";
          };
          Buffer.prototype.compare = function compare(target2, start, end, thisStart, thisEnd) {
            if (isInstance(target2, Uint8Array)) {
              target2 = Buffer.from(target2, target2.offset, target2.byteLength);
            }
            if (!Buffer.isBuffer(target2)) {
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + _typeof(target2));
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target2 ? target2.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target2) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target2.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0) return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;
              else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;
              else return -1;
            }
            if (typeof val === "string") {
              val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }
            return -1;
          }
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === void 0) encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding) encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start) end = start;
            var newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub2 = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
                sub2 = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub2 & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub2 = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
                sub2 = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub2 & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy2(target2, targetStart, start, end) {
            if (!Buffer.isBuffer(target2)) throw new TypeError("argument should be a Buffer");
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target2.length) targetStart = target2.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target2.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target2.length - targetStart < end - start) {
              end = target2.length - targetStart + start;
            }
            var len = end - start;
            if (this === target2 && typeof Uint8Array.prototype.copyWithin === "function") {
              this.copyWithin(targetStart, start, end);
            } else if (this === target2 && start < targetStart && targetStart < end) {
              for (var i = len - 1; i >= 0; --i) {
                target2[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target2, this.subarray(start, end), targetStart);
            }
            return len;
          };
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val.length === 1) {
                var code2 = val.charCodeAt(0);
                if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
                  val = code2;
                }
              }
            } else if (typeof val === "number") {
              val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function toHex(n) {
            if (n < 16) return "0" + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0) break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0) break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0) break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src2, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src2.length) break;
              dst[i + offset] = src2[i];
            }
            return i;
          }
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            return obj !== obj;
          }
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 1, "buffer": 3, "ieee754": 32 }], 4: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.attributeNames = exports3.elementNames = void 0;
        exports3.elementNames = /* @__PURE__ */ new Map([["altglyph", "altGlyph"], ["altglyphdef", "altGlyphDef"], ["altglyphitem", "altGlyphItem"], ["animatecolor", "animateColor"], ["animatemotion", "animateMotion"], ["animatetransform", "animateTransform"], ["clippath", "clipPath"], ["feblend", "feBlend"], ["fecolormatrix", "feColorMatrix"], ["fecomponenttransfer", "feComponentTransfer"], ["fecomposite", "feComposite"], ["feconvolvematrix", "feConvolveMatrix"], ["fediffuselighting", "feDiffuseLighting"], ["fedisplacementmap", "feDisplacementMap"], ["fedistantlight", "feDistantLight"], ["fedropshadow", "feDropShadow"], ["feflood", "feFlood"], ["fefunca", "feFuncA"], ["fefuncb", "feFuncB"], ["fefuncg", "feFuncG"], ["fefuncr", "feFuncR"], ["fegaussianblur", "feGaussianBlur"], ["feimage", "feImage"], ["femerge", "feMerge"], ["femergenode", "feMergeNode"], ["femorphology", "feMorphology"], ["feoffset", "feOffset"], ["fepointlight", "fePointLight"], ["fespecularlighting", "feSpecularLighting"], ["fespotlight", "feSpotLight"], ["fetile", "feTile"], ["feturbulence", "feTurbulence"], ["foreignobject", "foreignObject"], ["glyphref", "glyphRef"], ["lineargradient", "linearGradient"], ["radialgradient", "radialGradient"], ["textpath", "textPath"]]);
        exports3.attributeNames = /* @__PURE__ */ new Map([["definitionurl", "definitionURL"], ["attributename", "attributeName"], ["attributetype", "attributeType"], ["basefrequency", "baseFrequency"], ["baseprofile", "baseProfile"], ["calcmode", "calcMode"], ["clippathunits", "clipPathUnits"], ["diffuseconstant", "diffuseConstant"], ["edgemode", "edgeMode"], ["filterunits", "filterUnits"], ["glyphref", "glyphRef"], ["gradienttransform", "gradientTransform"], ["gradientunits", "gradientUnits"], ["kernelmatrix", "kernelMatrix"], ["kernelunitlength", "kernelUnitLength"], ["keypoints", "keyPoints"], ["keysplines", "keySplines"], ["keytimes", "keyTimes"], ["lengthadjust", "lengthAdjust"], ["limitingconeangle", "limitingConeAngle"], ["markerheight", "markerHeight"], ["markerunits", "markerUnits"], ["markerwidth", "markerWidth"], ["maskcontentunits", "maskContentUnits"], ["maskunits", "maskUnits"], ["numoctaves", "numOctaves"], ["pathlength", "pathLength"], ["patterncontentunits", "patternContentUnits"], ["patterntransform", "patternTransform"], ["patternunits", "patternUnits"], ["pointsatx", "pointsAtX"], ["pointsaty", "pointsAtY"], ["pointsatz", "pointsAtZ"], ["preservealpha", "preserveAlpha"], ["preserveaspectratio", "preserveAspectRatio"], ["primitiveunits", "primitiveUnits"], ["refx", "refX"], ["refy", "refY"], ["repeatcount", "repeatCount"], ["repeatdur", "repeatDur"], ["requiredextensions", "requiredExtensions"], ["requiredfeatures", "requiredFeatures"], ["specularconstant", "specularConstant"], ["specularexponent", "specularExponent"], ["spreadmethod", "spreadMethod"], ["startoffset", "startOffset"], ["stddeviation", "stdDeviation"], ["stitchtiles", "stitchTiles"], ["surfacescale", "surfaceScale"], ["systemlanguage", "systemLanguage"], ["tablevalues", "tableValues"], ["targetx", "targetX"], ["targety", "targetY"], ["textlength", "textLength"], ["viewbox", "viewBox"], ["viewtarget", "viewTarget"], ["xchannelselector", "xChannelSelector"], ["ychannelselector", "yChannelSelector"], ["zoomandpan", "zoomAndPan"]]);
      }, {}], 5: [function(require2, module3, exports3) {
        var __assign = this && this.__assign || function() {
          __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function get() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) {
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var ElementType = __importStar(require2("domelementtype"));
        var entities_1 = require2("entities");
        var foreignNames_1 = require2("./foreignNames");
        var unencodedElements = /* @__PURE__ */ new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
        function formatAttributes(attributes, opts) {
          if (!attributes) return;
          return Object.keys(attributes).map(function(key) {
            var _a, _b;
            var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
              key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
              return key;
            }
            return key + '="' + (opts.decodeEntities ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
          }).join(" ");
        }
        var singleTag = /* @__PURE__ */ new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
        function render(node, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var nodes = Array.isArray(node) || node.cheerio ? node : [node];
          var output2 = "";
          for (var i = 0; i < nodes.length; i++) {
            output2 += renderNode(nodes[i], options2);
          }
          return output2;
        }
        exports3["default"] = render;
        function renderNode(node, options2) {
          switch (node.type) {
            case "root":
              return render(node.children, options2);
            case ElementType.Directive:
              return renderDirective(node);
            case ElementType.Comment:
              return renderComment(node);
            case ElementType.CDATA:
              return renderCdata(node);
            default:
              return ElementType.isTag(node) ? renderTag(node, options2) : renderText(node, options2);
          }
        }
        var foreignModeIntegrationPoints = /* @__PURE__ */ new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
        var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
        function renderTag(elem, opts) {
          var _a;
          if (opts.xmlMode === "foreign") {
            elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
            if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
              opts = __assign(__assign({}, opts), { xmlMode: false });
            }
          }
          if (!opts.xmlMode && foreignElements.has(elem.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
          }
          var tag = "<" + elem.name;
          var attribs = formatAttributes(elem.attribs, opts);
          if (attribs) {
            tag += " " + attribs;
          }
          if (elem.children.length === 0 && (opts.xmlMode ? (
            // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
            opts.selfClosingTags !== false
          ) : (
            // User explicitly asked for self-closing tags, even in HTML mode
            opts.selfClosingTags && singleTag.has(elem.name)
          ))) {
            if (!opts.xmlMode) tag += " ";
            tag += "/>";
          } else {
            tag += ">";
            if (elem.children.length > 0) {
              tag += render(elem.children, opts);
            }
            if (opts.xmlMode || !singleTag.has(elem.name)) {
              tag += "</" + elem.name + ">";
            }
          }
          return tag;
        }
        function renderDirective(elem) {
          return "<" + elem.data + ">";
        }
        function renderText(elem, opts) {
          var data = elem.data || "";
          if (opts.decodeEntities && !(elem.parent && unencodedElements.has(elem.parent.name))) {
            data = entities_1.encodeXML(data);
          }
          return data;
        }
        function renderCdata(elem) {
          return "<![CDATA[" + elem.children[0].data + "]]>";
        }
        function renderComment(elem) {
          return "<!--" + elem.data + "-->";
        }
      }, { "./foreignNames": 4, "domelementtype": 6, "entities": 20 }], 6: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.Doctype = exports3.CDATA = exports3.Tag = exports3.Style = exports3.Script = exports3.Comment = exports3.Directive = exports3.Text = exports3.isTag = void 0;
        function isTag(elem) {
          return elem.type === "tag" || elem.type === "script" || elem.type === "style";
        }
        exports3.isTag = isTag;
        exports3.Text = "text";
        exports3.Directive = "directive";
        exports3.Comment = "comment";
        exports3.Script = "script";
        exports3.Style = "style";
        exports3.Tag = "tag";
        exports3.CDATA = "cdata";
        exports3.Doctype = "doctype";
      }, {}], 7: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var node_1 = require2("./node");
        exports3.Node = node_1.Node;
        exports3.Element = node_1.Element;
        exports3.DataNode = node_1.DataNode;
        exports3.NodeWithChildren = node_1.NodeWithChildren;
        var reWhitespace = /\s+/g;
        var defaultOpts = { normalizeWhitespace: false, withStartIndices: false, withEndIndices: false };
        var DomHandler = (
          /** @class */
          (function() {
            function DomHandler2(callback, options2, elementCB) {
              this.dom = [];
              this._done = false;
              this._tagStack = [];
              this._lastNode = null;
              this._parser = null;
              if (typeof options2 === "function") {
                elementCB = options2;
                options2 = defaultOpts;
              }
              if (_typeof(callback) === "object") {
                options2 = callback;
                callback = void 0;
              }
              this._callback = callback || null;
              this._options = options2 || defaultOpts;
              this._elementCB = elementCB || null;
            }
            DomHandler2.prototype.onparserinit = function(parser) {
              this._parser = parser;
            };
            DomHandler2.prototype.onreset = function() {
              this.dom = [];
              this._done = false;
              this._tagStack = [];
              this._lastNode = null;
              this._parser = this._parser || null;
            };
            DomHandler2.prototype.onend = function() {
              if (this._done) return;
              this._done = true;
              this._parser = null;
              this.handleCallback(null);
            };
            DomHandler2.prototype.onerror = function(error2) {
              this.handleCallback(error2);
            };
            DomHandler2.prototype.onclosetag = function() {
              this._lastNode = null;
              var elem = this._tagStack.pop();
              if (!elem || !this._parser) {
                return;
              }
              if (this._options.withEndIndices) {
                elem.endIndex = this._parser.endIndex;
              }
              if (this._elementCB) this._elementCB(elem);
            };
            DomHandler2.prototype.onopentag = function(name, attribs) {
              var element = new node_1.Element(name, attribs);
              this.addNode(element);
              this._tagStack.push(element);
            };
            DomHandler2.prototype.ontext = function(data) {
              var normalize2 = this._options.normalizeWhitespace;
              var _lastNode = this._lastNode;
              if (_lastNode && _lastNode.type === "text") {
                if (normalize2) {
                  _lastNode.data = (_lastNode.data + data).replace(reWhitespace, " ");
                } else {
                  _lastNode.data += data;
                }
              } else {
                if (normalize2) {
                  data = data.replace(reWhitespace, " ");
                }
                var node = new node_1.DataNode("text", data);
                this.addNode(node);
                this._lastNode = node;
              }
            };
            DomHandler2.prototype.oncomment = function(data) {
              if (this._lastNode && this._lastNode.type === "comment") {
                this._lastNode.data += data;
                return;
              }
              var node = new node_1.DataNode("comment", data);
              this.addNode(node);
              this._lastNode = node;
            };
            DomHandler2.prototype.oncommentend = function() {
              this._lastNode = null;
            };
            DomHandler2.prototype.oncdatastart = function() {
              var text2 = new node_1.DataNode("text", "");
              var node = new node_1.NodeWithChildren("cdata", [text2]);
              this.addNode(node);
              text2.parent = node;
              this._lastNode = text2;
            };
            DomHandler2.prototype.oncdataend = function() {
              this._lastNode = null;
            };
            DomHandler2.prototype.onprocessinginstruction = function(name, data) {
              var node = new node_1.ProcessingInstruction(name, data);
              this.addNode(node);
            };
            DomHandler2.prototype.handleCallback = function(error2) {
              if (typeof this._callback === "function") {
                this._callback(error2, this.dom);
              } else if (error2) {
                throw error2;
              }
            };
            DomHandler2.prototype.addNode = function(node) {
              var parent = this._tagStack[this._tagStack.length - 1];
              var siblings = parent ? parent.children : this.dom;
              var previousSibling = siblings[siblings.length - 1];
              if (this._parser) {
                if (this._options.withStartIndices) {
                  node.startIndex = this._parser.startIndex;
                }
                if (this._options.withEndIndices) {
                  node.endIndex = this._parser.endIndex;
                }
              }
              siblings.push(node);
              if (previousSibling) {
                node.prev = previousSibling;
                previousSibling.next = node;
              }
              if (parent) {
                node.parent = parent;
              }
              this._lastNode = null;
            };
            DomHandler2.prototype.addDataNode = function(node) {
              this.addNode(node);
              this._lastNode = node;
            };
            return DomHandler2;
          })()
        );
        exports3.DomHandler = DomHandler;
        exports3["default"] = DomHandler;
      }, { "./node": 8 }], 8: [function(require2, module3, exports3) {
        var __extends = this && this.__extends || /* @__PURE__ */ (function() {
          var _extendStatics = function extendStatics(d, b) {
            _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2) {
                if (b2.hasOwnProperty(p)) d2[p] = b2[p];
              }
            };
            return _extendStatics(d, b);
          };
          return function(d, b) {
            _extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        })();
        Object.defineProperty(exports3, "__esModule", { value: true });
        var nodeTypes = /* @__PURE__ */ new Map([["tag", 1], ["script", 1], ["style", 1], ["directive", 1], ["text", 3], ["cdata", 4], ["comment", 8]]);
        var Node2 = (
          /** @class */
          (function() {
            function Node22(type) {
              this.type = type;
              this.parent = null;
              this.prev = null;
              this.next = null;
              this.startIndex = null;
              this.endIndex = null;
            }
            Object.defineProperty(Node22.prototype, "nodeType", {
              // Read-only aliases
              get: function get() {
                return nodeTypes.get(this.type) || 1;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(Node22.prototype, "parentNode", {
              // Read-write aliases for properties
              get: function get() {
                return this.parent || null;
              },
              set: function set(parent) {
                this.parent = parent;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(Node22.prototype, "previousSibling", { get: function get() {
              return this.prev || null;
            }, set: function set(prev) {
              this.prev = prev;
            }, enumerable: true, configurable: true });
            Object.defineProperty(Node22.prototype, "nextSibling", { get: function get() {
              return this.next || null;
            }, set: function set(next2) {
              this.next = next2;
            }, enumerable: true, configurable: true });
            return Node22;
          })()
        );
        exports3.Node = Node2;
        var DataNode = (
          /** @class */
          (function(_super) {
            __extends(DataNode2, _super);
            function DataNode2(type, data) {
              var _this = _super.call(this, type) || this;
              _this.data = data;
              return _this;
            }
            Object.defineProperty(DataNode2.prototype, "nodeValue", { get: function get() {
              return this.data;
            }, set: function set(data) {
              this.data = data;
            }, enumerable: true, configurable: true });
            return DataNode2;
          })(Node2)
        );
        exports3.DataNode = DataNode;
        var ProcessingInstruction = (
          /** @class */
          (function(_super) {
            __extends(ProcessingInstruction2, _super);
            function ProcessingInstruction2(name, data) {
              var _this = _super.call(this, "directive", data) || this;
              _this.name = name;
              return _this;
            }
            return ProcessingInstruction2;
          })(DataNode)
        );
        exports3.ProcessingInstruction = ProcessingInstruction;
        var NodeWithChildren = (
          /** @class */
          (function(_super) {
            __extends(NodeWithChildren2, _super);
            function NodeWithChildren2(type, children) {
              var _this = _super.call(this, type) || this;
              _this.children = children;
              return _this;
            }
            Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
              // Aliases
              get: function get() {
                return this.children[0] || null;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(NodeWithChildren2.prototype, "lastChild", { get: function get() {
              return this.children[this.children.length - 1] || null;
            }, enumerable: true, configurable: true });
            Object.defineProperty(NodeWithChildren2.prototype, "childNodes", { get: function get() {
              return this.children;
            }, set: function set(children) {
              this.children = children;
            }, enumerable: true, configurable: true });
            return NodeWithChildren2;
          })(Node2)
        );
        exports3.NodeWithChildren = NodeWithChildren;
        var Element2 = (
          /** @class */
          (function(_super) {
            __extends(Element22, _super);
            function Element22(name, attribs) {
              var _this = _super.call(this, name === "script" ? "script" : name === "style" ? "style" : "tag", []) || this;
              _this.name = name;
              _this.attribs = attribs;
              _this.attribs = attribs;
              return _this;
            }
            Object.defineProperty(Element22.prototype, "tagName", {
              // DOM Level 1 aliases
              get: function get() {
                return this.name;
              },
              set: function set(name) {
                this.name = name;
              },
              enumerable: true,
              configurable: true
            });
            return Element22;
          })(NodeWithChildren)
        );
        exports3.Element = Element2;
      }, {}], 9: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.uniqueSort = exports3.compareDocumentPosition = exports3.removeSubsets = void 0;
        var tagtypes_1 = require2("./tagtypes");
        function removeSubsets(nodes) {
          var idx = nodes.length;
          while (--idx >= 0) {
            var node = nodes[idx];
            if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
              nodes.splice(idx, 1);
              continue;
            }
            for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
              if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
              }
            }
          }
          return nodes;
        }
        exports3.removeSubsets = removeSubsets;
        function compareDocumentPosition(nodeA, nodeB) {
          var aParents = [];
          var bParents = [];
          if (nodeA === nodeB) {
            return 0;
          }
          var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;
          while (current) {
            aParents.unshift(current);
            current = current.parent;
          }
          current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;
          while (current) {
            bParents.unshift(current);
            current = current.parent;
          }
          var maxIdx = Math.min(aParents.length, bParents.length);
          var idx = 0;
          while (idx < maxIdx && aParents[idx] === bParents[idx]) {
            idx++;
          }
          if (idx === 0) {
            return 1;
          }
          var sharedParent = aParents[idx - 1];
          var siblings = sharedParent.children;
          var aSibling = aParents[idx];
          var bSibling = bParents[idx];
          if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
            if (sharedParent === nodeB) {
              return 4 | 16;
            }
            return 4;
          }
          if (sharedParent === nodeA) {
            return 2 | 8;
          }
          return 2;
        }
        exports3.compareDocumentPosition = compareDocumentPosition;
        function uniqueSort(nodes) {
          nodes = nodes.filter(function(node, i, arr) {
            return !arr.includes(node, i + 1);
          });
          nodes.sort(function(a, b) {
            var relative = compareDocumentPosition(a, b);
            if (relative & 2) {
              return -1;
            } else if (relative & 4) {
              return 1;
            }
            return 0;
          });
          return nodes;
        }
        exports3.uniqueSort = uniqueSort;
      }, { "./tagtypes": 15 }], 10: [function(require2, module3, exports3) {
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function get() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0) k2 = k;
          o[k2] = m[k];
        });
        var __exportStar = this && this.__exportStar || function(m, exports4) {
          for (var p in m) {
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p)) __createBinding(exports4, m, p);
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        __exportStar(require2("./stringify"), exports3);
        __exportStar(require2("./traversal"), exports3);
        __exportStar(require2("./manipulation"), exports3);
        __exportStar(require2("./querying"), exports3);
        __exportStar(require2("./legacy"), exports3);
        __exportStar(require2("./helpers"), exports3);
        __exportStar(require2("./tagtypes"), exports3);
      }, { "./helpers": 9, "./legacy": 11, "./manipulation": 12, "./querying": 13, "./stringify": 14, "./tagtypes": 15, "./traversal": 16 }], 11: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.getElementsByTagType = exports3.getElementsByTagName = exports3.getElementById = exports3.getElements = exports3.testElement = void 0;
        var querying_1 = require2("./querying");
        var tagtypes_1 = require2("./tagtypes");
        function isTextNode(node) {
          return node.type === "text";
        }
        var Checks = { tag_name: function tag_name(name) {
          if (typeof name === "function") {
            return function(elem) {
              return tagtypes_1.isTag(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return tagtypes_1.isTag;
          }
          return function(elem) {
            return tagtypes_1.isTag(elem) && elem.name === name;
          };
        }, tag_type: function tag_type(type) {
          if (typeof type === "function") {
            return function(elem) {
              return type(elem.type);
            };
          }
          return function(elem) {
            return elem.type === type;
          };
        }, tag_contains: function tag_contains(data) {
          if (typeof data === "function") {
            return function(elem) {
              return isTextNode(elem) && data(elem.data);
            };
          }
          return function(elem) {
            return isTextNode(elem) && elem.data === data;
          };
        } };
        function getAttribCheck(attrib, value) {
          if (typeof value === "function") {
            return function(elem) {
              return tagtypes_1.isTag(elem) && value(elem.attribs[attrib]);
            };
          }
          return function(elem) {
            return tagtypes_1.isTag(elem) && elem.attribs[attrib] === value;
          };
        }
        function combineFuncs(a, b) {
          return function(elem) {
            return a(elem) || b(elem);
          };
        }
        function compileTest(options2) {
          var funcs = Object.keys(options2).map(function(key) {
            var value = options2[key];
            return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
          });
          return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
        }
        function testElement(options2, element) {
          var test = compileTest(options2);
          return test ? test(element) : true;
        }
        exports3.testElement = testElement;
        function getElements(options2, element, recurse, limit) {
          if (limit === void 0) {
            limit = Infinity;
          }
          var test = compileTest(options2);
          return test ? querying_1.filter(test, element, recurse, limit) : [];
        }
        exports3.getElements = getElements;
        function getElementById(id, element, recurse) {
          if (recurse === void 0) {
            recurse = true;
          }
          if (!Array.isArray(element)) element = [element];
          return querying_1.findOne(getAttribCheck("id", id), element, recurse);
        }
        exports3.getElementById = getElementById;
        function getElementsByTagName(name, element, recurse, limit) {
          if (limit === void 0) {
            limit = Infinity;
          }
          return querying_1.filter(Checks.tag_name(name), element, recurse, limit);
        }
        exports3.getElementsByTagName = getElementsByTagName;
        function getElementsByTagType(type, element, recurse, limit) {
          if (recurse === void 0) {
            recurse = true;
          }
          if (limit === void 0) {
            limit = Infinity;
          }
          return querying_1.filter(Checks.tag_type(type), element, recurse, limit);
        }
        exports3.getElementsByTagType = getElementsByTagType;
      }, { "./querying": 13, "./tagtypes": 15 }], 12: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.prepend = exports3.append = exports3.appendChild = exports3.replaceElement = exports3.removeElement = void 0;
        function removeElement(elem) {
          if (elem.prev) elem.prev.next = elem.next;
          if (elem.next) elem.next.prev = elem.prev;
          if (elem.parent) {
            var childs = elem.parent.children;
            childs.splice(childs.lastIndexOf(elem), 1);
          }
        }
        exports3.removeElement = removeElement;
        function replaceElement(elem, replacement) {
          var prev = replacement.prev = elem.prev;
          if (prev) {
            prev.next = replacement;
          }
          var next2 = replacement.next = elem.next;
          if (next2) {
            next2.prev = replacement;
          }
          var parent = replacement.parent = elem.parent;
          if (parent) {
            var childs = parent.children;
            childs[childs.lastIndexOf(elem)] = replacement;
          }
        }
        exports3.replaceElement = replaceElement;
        function appendChild(elem, child) {
          removeElement(child);
          child.parent = elem;
          if (elem.children.push(child) !== 1) {
            var sibling = elem.children[elem.children.length - 2];
            sibling.next = child;
            child.prev = sibling;
            child.next = null;
          }
        }
        exports3.appendChild = appendChild;
        function append(elem, next2) {
          removeElement(next2);
          var parent = elem.parent;
          var currNext = elem.next;
          next2.next = currNext;
          next2.prev = elem;
          elem.next = next2;
          next2.parent = parent;
          if (currNext) {
            currNext.prev = next2;
            if (parent) {
              var childs = parent.children;
              childs.splice(childs.lastIndexOf(currNext), 0, next2);
            }
          } else if (parent) {
            parent.children.push(next2);
          }
        }
        exports3.append = append;
        function prepend(elem, prev) {
          var parent = elem.parent;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(elem), 0, prev);
          }
          if (elem.prev) {
            elem.prev.next = prev;
          }
          prev.parent = parent;
          prev.prev = elem.prev;
          prev.next = elem;
          elem.prev = prev;
        }
        exports3.prepend = prepend;
      }, {}], 13: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.findAll = exports3.existsOne = exports3.findOne = exports3.findOneChild = exports3.find = exports3.filter = void 0;
        var tagtypes_1 = require2("./tagtypes");
        function filter(test, node, recurse, limit) {
          if (recurse === void 0) {
            recurse = true;
          }
          if (limit === void 0) {
            limit = Infinity;
          }
          if (!Array.isArray(node)) node = [node];
          return find(test, node, recurse, limit);
        }
        exports3.filter = filter;
        function find(test, nodes, recurse, limit) {
          var result = [];
          for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var elem = nodes_1[_i];
            if (test(elem)) {
              result.push(elem);
              if (--limit <= 0) break;
            }
            if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {
              var children = find(test, elem.children, recurse, limit);
              result.push.apply(result, children);
              limit -= children.length;
              if (limit <= 0) break;
            }
          }
          return result;
        }
        exports3.find = find;
        function findOneChild(test, nodes) {
          return nodes.find(test);
        }
        exports3.findOneChild = findOneChild;
        function findOne(test, nodes, recurse) {
          if (recurse === void 0) {
            recurse = true;
          }
          var elem = null;
          for (var i = 0; i < nodes.length && !elem; i++) {
            var checked = nodes[i];
            if (!tagtypes_1.isTag(checked)) {
              continue;
            } else if (test(checked)) {
              elem = checked;
            } else if (recurse && checked.children.length > 0) {
              elem = findOne(test, checked.children);
            }
          }
          return elem;
        }
        exports3.findOne = findOne;
        function existsOne(test, nodes) {
          return nodes.some(function(checked) {
            return tagtypes_1.isTag(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
          });
        }
        exports3.existsOne = existsOne;
        function findAll(test, nodes) {
          var _a;
          var result = [];
          var stack = nodes.filter(tagtypes_1.isTag);
          var elem;
          while (elem = stack.shift()) {
            var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(tagtypes_1.isTag);
            if (children && children.length > 0) {
              stack.unshift.apply(stack, children);
            }
            if (test(elem)) result.push(elem);
          }
          return result;
        }
        exports3.findAll = findAll;
      }, { "./tagtypes": 15 }], 14: [function(require2, module3, exports3) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.getText = exports3.getInnerHTML = exports3.getOuterHTML = void 0;
        var tagtypes_1 = require2("./tagtypes");
        var dom_serializer_1 = __importDefault(require2("dom-serializer"));
        function getOuterHTML(node, options2) {
          return dom_serializer_1["default"](node, options2);
        }
        exports3.getOuterHTML = getOuterHTML;
        function getInnerHTML(node, options2) {
          return tagtypes_1.hasChildren(node) ? node.children.map(function(node2) {
            return getOuterHTML(node2, options2);
          }).join("") : "";
        }
        exports3.getInnerHTML = getInnerHTML;
        function getText(node) {
          if (Array.isArray(node)) return node.map(getText).join("");
          if (tagtypes_1.isTag(node)) return node.name === "br" ? "\n" : getText(node.children);
          if (tagtypes_1.isCDATA(node)) return getText(node.children);
          if (tagtypes_1.isText(node)) return node.data;
          return "";
        }
        exports3.getText = getText;
      }, { "./tagtypes": 15, "dom-serializer": 5 }], 15: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.hasChildren = exports3.isComment = exports3.isText = exports3.isCDATA = exports3.isTag = void 0;
        var domelementtype_1 = require2("domelementtype");
        function isTag(node) {
          return domelementtype_1.isTag(node);
        }
        exports3.isTag = isTag;
        function isCDATA(node) {
          return node.type === "cdata";
        }
        exports3.isCDATA = isCDATA;
        function isText(node) {
          return node.type === "text";
        }
        exports3.isText = isText;
        function isComment(node) {
          return node.type === "comment";
        }
        exports3.isComment = isComment;
        function hasChildren(node) {
          return Object.prototype.hasOwnProperty.call(node, "children");
        }
        exports3.hasChildren = hasChildren;
      }, { "domelementtype": 6 }], 16: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.nextElementSibling = exports3.getName = exports3.hasAttrib = exports3.getAttributeValue = exports3.getSiblings = exports3.getParent = exports3.getChildren = void 0;
        function getChildren(elem) {
          return elem.children || null;
        }
        exports3.getChildren = getChildren;
        function getParent(elem) {
          return elem.parent || null;
        }
        exports3.getParent = getParent;
        function getSiblings(elem) {
          var parent = getParent(elem);
          return parent ? getChildren(parent) : [elem];
        }
        exports3.getSiblings = getSiblings;
        function getAttributeValue(elem, name) {
          var _a;
          return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
        }
        exports3.getAttributeValue = getAttributeValue;
        function hasAttrib(elem, name) {
          return !!elem.attribs && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
        }
        exports3.hasAttrib = hasAttrib;
        function getName(elem) {
          return elem.name;
        }
        exports3.getName = getName;
        function nextElementSibling(elem) {
          var node = elem.next;
          while (node !== null && node.type !== "tag") {
            node = node.next;
          }
          return node;
        }
        exports3.nextElementSibling = nextElementSibling;
      }, {}], 17: [function(require2, module3, exports3) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.decodeHTML = exports3.decodeHTMLStrict = exports3.decodeXML = void 0;
        var entities_json_1 = __importDefault(require2("./maps/entities.json"));
        var legacy_json_1 = __importDefault(require2("./maps/legacy.json"));
        var xml_json_1 = __importDefault(require2("./maps/xml.json"));
        var decode_codepoint_1 = __importDefault(require2("./decode_codepoint"));
        exports3.decodeXML = getStrictDecoder(xml_json_1["default"]);
        exports3.decodeHTMLStrict = getStrictDecoder(entities_json_1["default"]);
        function getStrictDecoder(map2) {
          var keys = Object.keys(map2).join("|");
          var replace = getReplacer(map2);
          keys += "|#[xX][\\da-fA-F]+|#\\d+";
          var re2 = new RegExp("&(?:" + keys + ");", "g");
          return function(str) {
            return String(str).replace(re2, replace);
          };
        }
        var sorter = function sorter2(a, b) {
          return a < b ? 1 : -1;
        };
        exports3.decodeHTML = (function() {
          var legacy = Object.keys(legacy_json_1["default"]).sort(sorter);
          var keys = Object.keys(entities_json_1["default"]).sort(sorter);
          for (var i = 0, j = 0; i < keys.length; i++) {
            if (legacy[j] === keys[i]) {
              keys[i] += ";?";
              j++;
            } else {
              keys[i] += ";";
            }
          }
          var re2 = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
          var replace = getReplacer(entities_json_1["default"]);
          function replacer(str) {
            if (str.substr(-1) !== ";") str += ";";
            return replace(str);
          }
          return function(str) {
            return String(str).replace(re2, replacer);
          };
        })();
        function getReplacer(map2) {
          return function replace(str) {
            if (str.charAt(1) === "#") {
              var secondChar = str.charAt(2);
              if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1["default"](parseInt(str.substr(3), 16));
              }
              return decode_codepoint_1["default"](parseInt(str.substr(2), 10));
            }
            return map2[str.slice(1, -1)];
          };
        }
      }, { "./decode_codepoint": 18, "./maps/entities.json": 22, "./maps/legacy.json": 23, "./maps/xml.json": 24 }], 18: [function(require2, module3, exports3) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var decode_json_1 = __importDefault(require2("./maps/decode.json"));
        function decodeCodePoint(codePoint) {
          if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            return "ï¿½";
          }
          if (codePoint in decode_json_1["default"]) {
            codePoint = decode_json_1["default"][codePoint];
          }
          var output2 = "";
          if (codePoint > 65535) {
            codePoint -= 65536;
            output2 += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          output2 += String.fromCharCode(codePoint);
          return output2;
        }
        exports3["default"] = decodeCodePoint;
      }, { "./maps/decode.json": 21 }], 19: [function(require2, module3, exports3) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.escape = exports3.encodeHTML = exports3.encodeXML = void 0;
        var xml_json_1 = __importDefault(require2("./maps/xml.json"));
        var inverseXML = getInverseObj(xml_json_1["default"]);
        var xmlReplacer = getInverseReplacer(inverseXML);
        exports3.encodeXML = getInverse(inverseXML, xmlReplacer);
        var entities_json_1 = __importDefault(require2("./maps/entities.json"));
        var inverseHTML = getInverseObj(entities_json_1["default"]);
        var htmlReplacer = getInverseReplacer(inverseHTML);
        exports3.encodeHTML = getInverse(inverseHTML, htmlReplacer);
        function getInverseObj(obj) {
          return Object.keys(obj).sort().reduce(function(inverse, name) {
            inverse[obj[name]] = "&" + name + ";";
            return inverse;
          }, {});
        }
        function getInverseReplacer(inverse) {
          var single = [];
          var multiple = [];
          for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
            var k = _a[_i];
            if (k.length === 1) {
              single.push("\\" + k);
            } else {
              multiple.push(k);
            }
          }
          single.sort();
          for (var start = 0; start < single.length - 1; start++) {
            var end = start;
            while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
              end += 1;
            }
            var count = 1 + end - start;
            if (count < 3) continue;
            single.splice(start, count, single[start] + "-" + single[end]);
          }
          multiple.unshift("[" + single.join("") + "]");
          return new RegExp(multiple.join("|"), "g");
        }
        var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
        function singleCharReplacer(c) {
          return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
        }
        function getInverse(inverse, re2) {
          return function(data) {
            return data.replace(re2, function(name) {
              return inverse[name];
            }).replace(reNonASCII, singleCharReplacer);
          };
        }
        var reXmlChars = getInverseReplacer(inverseXML);
        function escape2(data) {
          return data.replace(reXmlChars, singleCharReplacer).replace(reNonASCII, singleCharReplacer);
        }
        exports3.escape = escape2;
      }, { "./maps/entities.json": 22, "./maps/xml.json": 24 }], 20: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.encode = exports3.decodeStrict = exports3.decode = void 0;
        var decode_12 = require2("./decode");
        var encode_12 = require2("./encode");
        function decode2(data, level) {
          return (!level || level <= 0 ? decode_12.decodeXML : decode_12.decodeHTML)(data);
        }
        exports3.decode = decode2;
        function decodeStrict(data, level) {
          return (!level || level <= 0 ? decode_12.decodeXML : decode_12.decodeHTMLStrict)(data);
        }
        exports3.decodeStrict = decodeStrict;
        function encode2(data, level) {
          return (!level || level <= 0 ? encode_12.encodeXML : encode_12.encodeHTML)(data);
        }
        exports3.encode = encode2;
        var encode_2 = require2("./encode");
        Object.defineProperty(exports3, "encodeXML", { enumerable: true, get: function get() {
          return encode_2.encodeXML;
        } });
        Object.defineProperty(exports3, "encodeHTML", { enumerable: true, get: function get() {
          return encode_2.encodeHTML;
        } });
        Object.defineProperty(exports3, "escape", { enumerable: true, get: function get() {
          return encode_2.escape;
        } });
        Object.defineProperty(exports3, "encodeHTML4", { enumerable: true, get: function get() {
          return encode_2.encodeHTML;
        } });
        Object.defineProperty(exports3, "encodeHTML5", { enumerable: true, get: function get() {
          return encode_2.encodeHTML;
        } });
        var decode_2 = require2("./decode");
        Object.defineProperty(exports3, "decodeXML", { enumerable: true, get: function get() {
          return decode_2.decodeXML;
        } });
        Object.defineProperty(exports3, "decodeHTML", { enumerable: true, get: function get() {
          return decode_2.decodeHTML;
        } });
        Object.defineProperty(exports3, "decodeHTMLStrict", { enumerable: true, get: function get() {
          return decode_2.decodeHTMLStrict;
        } });
        Object.defineProperty(exports3, "decodeHTML4", { enumerable: true, get: function get() {
          return decode_2.decodeHTML;
        } });
        Object.defineProperty(exports3, "decodeHTML5", { enumerable: true, get: function get() {
          return decode_2.decodeHTML;
        } });
        Object.defineProperty(exports3, "decodeHTML4Strict", { enumerable: true, get: function get() {
          return decode_2.decodeHTMLStrict;
        } });
        Object.defineProperty(exports3, "decodeHTML5Strict", { enumerable: true, get: function get() {
          return decode_2.decodeHTMLStrict;
        } });
        Object.defineProperty(exports3, "decodeXMLStrict", { enumerable: true, get: function get() {
          return decode_2.decodeXML;
        } });
      }, { "./decode": 17, "./encode": 19 }], 21: [function(require2, module3, exports3) {
        module3.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
      }, {}], 22: [function(require2, module3, exports3) {
        module3.exports = { "Aacute": "Ã", "aacute": "Ã¡", "Abreve": "Ä‚", "abreve": "Äƒ", "ac": "âˆ¾", "acd": "âˆ¿", "acE": "âˆ¾Ì³", "Acirc": "Ã‚", "acirc": "Ã¢", "acute": "Â´", "Acy": "Ğ", "acy": "Ğ°", "AElig": "Ã†", "aelig": "Ã¦", "af": "â¡", "Afr": "ğ”„", "afr": "ğ”", "Agrave": "Ã€", "agrave": "Ã ", "alefsym": "â„µ", "aleph": "â„µ", "Alpha": "Î‘", "alpha": "Î±", "Amacr": "Ä€", "amacr": "Ä", "amalg": "â¨¿", "amp": "&", "AMP": "&", "andand": "â©•", "And": "â©“", "and": "âˆ§", "andd": "â©œ", "andslope": "â©˜", "andv": "â©š", "ang": "âˆ ", "ange": "â¦¤", "angle": "âˆ ", "angmsdaa": "â¦¨", "angmsdab": "â¦©", "angmsdac": "â¦ª", "angmsdad": "â¦«", "angmsdae": "â¦¬", "angmsdaf": "â¦­", "angmsdag": "â¦®", "angmsdah": "â¦¯", "angmsd": "âˆ¡", "angrt": "âˆŸ", "angrtvb": "âŠ¾", "angrtvbd": "â¦", "angsph": "âˆ¢", "angst": "Ã…", "angzarr": "â¼", "Aogon": "Ä„", "aogon": "Ä…", "Aopf": "ğ”¸", "aopf": "ğ•’", "apacir": "â©¯", "ap": "â‰ˆ", "apE": "â©°", "ape": "â‰Š", "apid": "â‰‹", "apos": "'", "ApplyFunction": "â¡", "approx": "â‰ˆ", "approxeq": "â‰Š", "Aring": "Ã…", "aring": "Ã¥", "Ascr": "ğ’œ", "ascr": "ğ’¶", "Assign": "â‰”", "ast": "*", "asymp": "â‰ˆ", "asympeq": "â‰", "Atilde": "Ãƒ", "atilde": "Ã£", "Auml": "Ã„", "auml": "Ã¤", "awconint": "âˆ³", "awint": "â¨‘", "backcong": "â‰Œ", "backepsilon": "Ï¶", "backprime": "â€µ", "backsim": "âˆ½", "backsimeq": "â‹", "Backslash": "âˆ–", "Barv": "â«§", "barvee": "âŠ½", "barwed": "âŒ…", "Barwed": "âŒ†", "barwedge": "âŒ…", "bbrk": "âµ", "bbrktbrk": "â¶", "bcong": "â‰Œ", "Bcy": "Ğ‘", "bcy": "Ğ±", "bdquo": "â€", "becaus": "âˆµ", "because": "âˆµ", "Because": "âˆµ", "bemptyv": "â¦°", "bepsi": "Ï¶", "bernou": "â„¬", "Bernoullis": "â„¬", "Beta": "Î’", "beta": "Î²", "beth": "â„¶", "between": "â‰¬", "Bfr": "ğ”…", "bfr": "ğ”Ÿ", "bigcap": "â‹‚", "bigcirc": "â—¯", "bigcup": "â‹ƒ", "bigodot": "â¨€", "bigoplus": "â¨", "bigotimes": "â¨‚", "bigsqcup": "â¨†", "bigstar": "â˜…", "bigtriangledown": "â–½", "bigtriangleup": "â–³", "biguplus": "â¨„", "bigvee": "â‹", "bigwedge": "â‹€", "bkarow": "â¤", "blacklozenge": "â§«", "blacksquare": "â–ª", "blacktriangle": "â–´", "blacktriangledown": "â–¾", "blacktriangleleft": "â—‚", "blacktriangleright": "â–¸", "blank": "â£", "blk12": "â–’", "blk14": "â–‘", "blk34": "â–“", "block": "â–ˆ", "bne": "=âƒ¥", "bnequiv": "â‰¡âƒ¥", "bNot": "â«­", "bnot": "âŒ", "Bopf": "ğ”¹", "bopf": "ğ•“", "bot": "âŠ¥", "bottom": "âŠ¥", "bowtie": "â‹ˆ", "boxbox": "â§‰", "boxdl": "â”", "boxdL": "â••", "boxDl": "â•–", "boxDL": "â•—", "boxdr": "â”Œ", "boxdR": "â•’", "boxDr": "â•“", "boxDR": "â•”", "boxh": "â”€", "boxH": "â•", "boxhd": "â”¬", "boxHd": "â•¤", "boxhD": "â•¥", "boxHD": "â•¦", "boxhu": "â”´", "boxHu": "â•§", "boxhU": "â•¨", "boxHU": "â•©", "boxminus": "âŠŸ", "boxplus": "âŠ", "boxtimes": "âŠ ", "boxul": "â”˜", "boxuL": "â•›", "boxUl": "â•œ", "boxUL": "â•", "boxur": "â””", "boxuR": "â•˜", "boxUr": "â•™", "boxUR": "â•š", "boxv": "â”‚", "boxV": "â•‘", "boxvh": "â”¼", "boxvH": "â•ª", "boxVh": "â•«", "boxVH": "â•¬", "boxvl": "â”¤", "boxvL": "â•¡", "boxVl": "â•¢", "boxVL": "â•£", "boxvr": "â”œ", "boxvR": "â•", "boxVr": "â•Ÿ", "boxVR": "â• ", "bprime": "â€µ", "breve": "Ë˜", "Breve": "Ë˜", "brvbar": "Â¦", "bscr": "ğ’·", "Bscr": "â„¬", "bsemi": "â", "bsim": "âˆ½", "bsime": "â‹", "bsolb": "â§…", "bsol": "\\", "bsolhsub": "âŸˆ", "bull": "â€¢", "bullet": "â€¢", "bump": "â‰", "bumpE": "âª®", "bumpe": "â‰", "Bumpeq": "â‰", "bumpeq": "â‰", "Cacute": "Ä†", "cacute": "Ä‡", "capand": "â©„", "capbrcup": "â©‰", "capcap": "â©‹", "cap": "âˆ©", "Cap": "â‹’", "capcup": "â©‡", "capdot": "â©€", "CapitalDifferentialD": "â……", "caps": "âˆ©ï¸€", "caret": "â", "caron": "Ë‡", "Cayleys": "â„­", "ccaps": "â©", "Ccaron": "ÄŒ", "ccaron": "Ä", "Ccedil": "Ã‡", "ccedil": "Ã§", "Ccirc": "Äˆ", "ccirc": "Ä‰", "Cconint": "âˆ°", "ccups": "â©Œ", "ccupssm": "â©", "Cdot": "ÄŠ", "cdot": "Ä‹", "cedil": "Â¸", "Cedilla": "Â¸", "cemptyv": "â¦²", "cent": "Â¢", "centerdot": "Â·", "CenterDot": "Â·", "cfr": "ğ” ", "Cfr": "â„­", "CHcy": "Ğ§", "chcy": "Ñ‡", "check": "âœ“", "checkmark": "âœ“", "Chi": "Î§", "chi": "Ï‡", "circ": "Ë†", "circeq": "â‰—", "circlearrowleft": "â†º", "circlearrowright": "â†»", "circledast": "âŠ›", "circledcirc": "âŠš", "circleddash": "âŠ", "CircleDot": "âŠ™", "circledR": "Â®", "circledS": "â“ˆ", "CircleMinus": "âŠ–", "CirclePlus": "âŠ•", "CircleTimes": "âŠ—", "cir": "â—‹", "cirE": "â§ƒ", "cire": "â‰—", "cirfnint": "â¨", "cirmid": "â«¯", "cirscir": "â§‚", "ClockwiseContourIntegral": "âˆ²", "CloseCurlyDoubleQuote": "â€", "CloseCurlyQuote": "â€™", "clubs": "â™£", "clubsuit": "â™£", "colon": ":", "Colon": "âˆ·", "Colone": "â©´", "colone": "â‰”", "coloneq": "â‰”", "comma": ",", "commat": "@", "comp": "âˆ", "compfn": "âˆ˜", "complement": "âˆ", "complexes": "â„‚", "cong": "â‰…", "congdot": "â©­", "Congruent": "â‰¡", "conint": "âˆ®", "Conint": "âˆ¯", "ContourIntegral": "âˆ®", "copf": "ğ•”", "Copf": "â„‚", "coprod": "âˆ", "Coproduct": "âˆ", "copy": "Â©", "COPY": "Â©", "copysr": "â„—", "CounterClockwiseContourIntegral": "âˆ³", "crarr": "â†µ", "cross": "âœ—", "Cross": "â¨¯", "Cscr": "ğ’", "cscr": "ğ’¸", "csub": "â«", "csube": "â«‘", "csup": "â«", "csupe": "â«’", "ctdot": "â‹¯", "cudarrl": "â¤¸", "cudarrr": "â¤µ", "cuepr": "â‹", "cuesc": "â‹Ÿ", "cularr": "â†¶", "cularrp": "â¤½", "cupbrcap": "â©ˆ", "cupcap": "â©†", "CupCap": "â‰", "cup": "âˆª", "Cup": "â‹“", "cupcup": "â©Š", "cupdot": "âŠ", "cupor": "â©…", "cups": "âˆªï¸€", "curarr": "â†·", "curarrm": "â¤¼", "curlyeqprec": "â‹", "curlyeqsucc": "â‹Ÿ", "curlyvee": "â‹", "curlywedge": "â‹", "curren": "Â¤", "curvearrowleft": "â†¶", "curvearrowright": "â†·", "cuvee": "â‹", "cuwed": "â‹", "cwconint": "âˆ²", "cwint": "âˆ±", "cylcty": "âŒ­", "dagger": "â€ ", "Dagger": "â€¡", "daleth": "â„¸", "darr": "â†“", "Darr": "â†¡", "dArr": "â‡“", "dash": "â€", "Dashv": "â«¤", "dashv": "âŠ£", "dbkarow": "â¤", "dblac": "Ë", "Dcaron": "Ä", "dcaron": "Ä", "Dcy": "Ğ”", "dcy": "Ğ´", "ddagger": "â€¡", "ddarr": "â‡Š", "DD": "â……", "dd": "â…†", "DDotrahd": "â¤‘", "ddotseq": "â©·", "deg": "Â°", "Del": "âˆ‡", "Delta": "Î”", "delta": "Î´", "demptyv": "â¦±", "dfisht": "â¥¿", "Dfr": "ğ”‡", "dfr": "ğ”¡", "dHar": "â¥¥", "dharl": "â‡ƒ", "dharr": "â‡‚", "DiacriticalAcute": "Â´", "DiacriticalDot": "Ë™", "DiacriticalDoubleAcute": "Ë", "DiacriticalGrave": "`", "DiacriticalTilde": "Ëœ", "diam": "â‹„", "diamond": "â‹„", "Diamond": "â‹„", "diamondsuit": "â™¦", "diams": "â™¦", "die": "Â¨", "DifferentialD": "â…†", "digamma": "Ï", "disin": "â‹²", "div": "Ã·", "divide": "Ã·", "divideontimes": "â‹‡", "divonx": "â‹‡", "DJcy": "Ğ‚", "djcy": "Ñ’", "dlcorn": "âŒ", "dlcrop": "âŒ", "dollar": "$", "Dopf": "ğ”»", "dopf": "ğ••", "Dot": "Â¨", "dot": "Ë™", "DotDot": "âƒœ", "doteq": "â‰", "doteqdot": "â‰‘", "DotEqual": "â‰", "dotminus": "âˆ¸", "dotplus": "âˆ”", "dotsquare": "âŠ¡", "doublebarwedge": "âŒ†", "DoubleContourIntegral": "âˆ¯", "DoubleDot": "Â¨", "DoubleDownArrow": "â‡“", "DoubleLeftArrow": "â‡", "DoubleLeftRightArrow": "â‡”", "DoubleLeftTee": "â«¤", "DoubleLongLeftArrow": "âŸ¸", "DoubleLongLeftRightArrow": "âŸº", "DoubleLongRightArrow": "âŸ¹", "DoubleRightArrow": "â‡’", "DoubleRightTee": "âŠ¨", "DoubleUpArrow": "â‡‘", "DoubleUpDownArrow": "â‡•", "DoubleVerticalBar": "âˆ¥", "DownArrowBar": "â¤“", "downarrow": "â†“", "DownArrow": "â†“", "Downarrow": "â‡“", "DownArrowUpArrow": "â‡µ", "DownBreve": "Ì‘", "downdownarrows": "â‡Š", "downharpoonleft": "â‡ƒ", "downharpoonright": "â‡‚", "DownLeftRightVector": "â¥", "DownLeftTeeVector": "â¥", "DownLeftVectorBar": "â¥–", "DownLeftVector": "â†½", "DownRightTeeVector": "â¥Ÿ", "DownRightVectorBar": "â¥—", "DownRightVector": "â‡", "DownTeeArrow": "â†§", "DownTee": "âŠ¤", "drbkarow": "â¤", "drcorn": "âŒŸ", "drcrop": "âŒŒ", "Dscr": "ğ’Ÿ", "dscr": "ğ’¹", "DScy": "Ğ…", "dscy": "Ñ•", "dsol": "â§¶", "Dstrok": "Ä", "dstrok": "Ä‘", "dtdot": "â‹±", "dtri": "â–¿", "dtrif": "â–¾", "duarr": "â‡µ", "duhar": "â¥¯", "dwangle": "â¦¦", "DZcy": "Ğ", "dzcy": "ÑŸ", "dzigrarr": "âŸ¿", "Eacute": "Ã‰", "eacute": "Ã©", "easter": "â©®", "Ecaron": "Äš", "ecaron": "Ä›", "Ecirc": "ÃŠ", "ecirc": "Ãª", "ecir": "â‰–", "ecolon": "â‰•", "Ecy": "Ğ­", "ecy": "Ñ", "eDDot": "â©·", "Edot": "Ä–", "edot": "Ä—", "eDot": "â‰‘", "ee": "â…‡", "efDot": "â‰’", "Efr": "ğ”ˆ", "efr": "ğ”¢", "eg": "âªš", "Egrave": "Ãˆ", "egrave": "Ã¨", "egs": "âª–", "egsdot": "âª˜", "el": "âª™", "Element": "âˆˆ", "elinters": "â§", "ell": "â„“", "els": "âª•", "elsdot": "âª—", "Emacr": "Ä’", "emacr": "Ä“", "empty": "âˆ…", "emptyset": "âˆ…", "EmptySmallSquare": "â—»", "emptyv": "âˆ…", "EmptyVerySmallSquare": "â–«", "emsp13": "â€„", "emsp14": "â€…", "emsp": "â€ƒ", "ENG": "ÅŠ", "eng": "Å‹", "ensp": "â€‚", "Eogon": "Ä˜", "eogon": "Ä™", "Eopf": "ğ”¼", "eopf": "ğ•–", "epar": "â‹•", "eparsl": "â§£", "eplus": "â©±", "epsi": "Îµ", "Epsilon": "Î•", "epsilon": "Îµ", "epsiv": "Ïµ", "eqcirc": "â‰–", "eqcolon": "â‰•", "eqsim": "â‰‚", "eqslantgtr": "âª–", "eqslantless": "âª•", "Equal": "â©µ", "equals": "=", "EqualTilde": "â‰‚", "equest": "â‰Ÿ", "Equilibrium": "â‡Œ", "equiv": "â‰¡", "equivDD": "â©¸", "eqvparsl": "â§¥", "erarr": "â¥±", "erDot": "â‰“", "escr": "â„¯", "Escr": "â„°", "esdot": "â‰", "Esim": "â©³", "esim": "â‰‚", "Eta": "Î—", "eta": "Î·", "ETH": "Ã", "eth": "Ã°", "Euml": "Ã‹", "euml": "Ã«", "euro": "â‚¬", "excl": "!", "exist": "âˆƒ", "Exists": "âˆƒ", "expectation": "â„°", "exponentiale": "â…‡", "ExponentialE": "â…‡", "fallingdotseq": "â‰’", "Fcy": "Ğ¤", "fcy": "Ñ„", "female": "â™€", "ffilig": "ï¬ƒ", "fflig": "ï¬€", "ffllig": "ï¬„", "Ffr": "ğ”‰", "ffr": "ğ”£", "filig": "ï¬", "FilledSmallSquare": "â—¼", "FilledVerySmallSquare": "â–ª", "fjlig": "fj", "flat": "â™­", "fllig": "ï¬‚", "fltns": "â–±", "fnof": "Æ’", "Fopf": "ğ”½", "fopf": "ğ•—", "forall": "âˆ€", "ForAll": "âˆ€", "fork": "â‹”", "forkv": "â«™", "Fouriertrf": "â„±", "fpartint": "â¨", "frac12": "Â½", "frac13": "â…“", "frac14": "Â¼", "frac15": "â…•", "frac16": "â…™", "frac18": "â…›", "frac23": "â…”", "frac25": "â…–", "frac34": "Â¾", "frac35": "â…—", "frac38": "â…œ", "frac45": "â…˜", "frac56": "â…š", "frac58": "â…", "frac78": "â…", "frasl": "â„", "frown": "âŒ¢", "fscr": "ğ’»", "Fscr": "â„±", "gacute": "Çµ", "Gamma": "Î“", "gamma": "Î³", "Gammad": "Ïœ", "gammad": "Ï", "gap": "âª†", "Gbreve": "Ä", "gbreve": "ÄŸ", "Gcedil": "Ä¢", "Gcirc": "Äœ", "gcirc": "Ä", "Gcy": "Ğ“", "gcy": "Ğ³", "Gdot": "Ä ", "gdot": "Ä¡", "ge": "â‰¥", "gE": "â‰§", "gEl": "âªŒ", "gel": "â‹›", "geq": "â‰¥", "geqq": "â‰§", "geqslant": "â©¾", "gescc": "âª©", "ges": "â©¾", "gesdot": "âª€", "gesdoto": "âª‚", "gesdotol": "âª„", "gesl": "â‹›ï¸€", "gesles": "âª”", "Gfr": "ğ”Š", "gfr": "ğ”¤", "gg": "â‰«", "Gg": "â‹™", "ggg": "â‹™", "gimel": "â„·", "GJcy": "Ğƒ", "gjcy": "Ñ“", "gla": "âª¥", "gl": "â‰·", "glE": "âª’", "glj": "âª¤", "gnap": "âªŠ", "gnapprox": "âªŠ", "gne": "âªˆ", "gnE": "â‰©", "gneq": "âªˆ", "gneqq": "â‰©", "gnsim": "â‹§", "Gopf": "ğ”¾", "gopf": "ğ•˜", "grave": "`", "GreaterEqual": "â‰¥", "GreaterEqualLess": "â‹›", "GreaterFullEqual": "â‰§", "GreaterGreater": "âª¢", "GreaterLess": "â‰·", "GreaterSlantEqual": "â©¾", "GreaterTilde": "â‰³", "Gscr": "ğ’¢", "gscr": "â„Š", "gsim": "â‰³", "gsime": "âª", "gsiml": "âª", "gtcc": "âª§", "gtcir": "â©º", "gt": ">", "GT": ">", "Gt": "â‰«", "gtdot": "â‹—", "gtlPar": "â¦•", "gtquest": "â©¼", "gtrapprox": "âª†", "gtrarr": "â¥¸", "gtrdot": "â‹—", "gtreqless": "â‹›", "gtreqqless": "âªŒ", "gtrless": "â‰·", "gtrsim": "â‰³", "gvertneqq": "â‰©ï¸€", "gvnE": "â‰©ï¸€", "Hacek": "Ë‡", "hairsp": "â€Š", "half": "Â½", "hamilt": "â„‹", "HARDcy": "Ğª", "hardcy": "ÑŠ", "harrcir": "â¥ˆ", "harr": "â†”", "hArr": "â‡”", "harrw": "â†­", "Hat": "^", "hbar": "â„", "Hcirc": "Ä¤", "hcirc": "Ä¥", "hearts": "â™¥", "heartsuit": "â™¥", "hellip": "â€¦", "hercon": "âŠ¹", "hfr": "ğ”¥", "Hfr": "â„Œ", "HilbertSpace": "â„‹", "hksearow": "â¤¥", "hkswarow": "â¤¦", "hoarr": "â‡¿", "homtht": "âˆ»", "hookleftarrow": "â†©", "hookrightarrow": "â†ª", "hopf": "ğ•™", "Hopf": "â„", "horbar": "â€•", "HorizontalLine": "â”€", "hscr": "ğ’½", "Hscr": "â„‹", "hslash": "â„", "Hstrok": "Ä¦", "hstrok": "Ä§", "HumpDownHump": "â‰", "HumpEqual": "â‰", "hybull": "âƒ", "hyphen": "â€", "Iacute": "Ã", "iacute": "Ã­", "ic": "â£", "Icirc": "Ã", "icirc": "Ã®", "Icy": "Ğ˜", "icy": "Ğ¸", "Idot": "Ä°", "IEcy": "Ğ•", "iecy": "Ğµ", "iexcl": "Â¡", "iff": "â‡”", "ifr": "ğ”¦", "Ifr": "â„‘", "Igrave": "ÃŒ", "igrave": "Ã¬", "ii": "â…ˆ", "iiiint": "â¨Œ", "iiint": "âˆ­", "iinfin": "â§œ", "iiota": "â„©", "IJlig": "Ä²", "ijlig": "Ä³", "Imacr": "Äª", "imacr": "Ä«", "image": "â„‘", "ImaginaryI": "â…ˆ", "imagline": "â„", "imagpart": "â„‘", "imath": "Ä±", "Im": "â„‘", "imof": "âŠ·", "imped": "Æµ", "Implies": "â‡’", "incare": "â„…", "in": "âˆˆ", "infin": "âˆ", "infintie": "â§", "inodot": "Ä±", "intcal": "âŠº", "int": "âˆ«", "Int": "âˆ¬", "integers": "â„¤", "Integral": "âˆ«", "intercal": "âŠº", "Intersection": "â‹‚", "intlarhk": "â¨—", "intprod": "â¨¼", "InvisibleComma": "â£", "InvisibleTimes": "â¢", "IOcy": "Ğ", "iocy": "Ñ‘", "Iogon": "Ä®", "iogon": "Ä¯", "Iopf": "ğ•€", "iopf": "ğ•š", "Iota": "Î™", "iota": "Î¹", "iprod": "â¨¼", "iquest": "Â¿", "iscr": "ğ’¾", "Iscr": "â„", "isin": "âˆˆ", "isindot": "â‹µ", "isinE": "â‹¹", "isins": "â‹´", "isinsv": "â‹³", "isinv": "âˆˆ", "it": "â¢", "Itilde": "Ä¨", "itilde": "Ä©", "Iukcy": "Ğ†", "iukcy": "Ñ–", "Iuml": "Ã", "iuml": "Ã¯", "Jcirc": "Ä´", "jcirc": "Äµ", "Jcy": "Ğ™", "jcy": "Ğ¹", "Jfr": "ğ”", "jfr": "ğ”§", "jmath": "È·", "Jopf": "ğ•", "jopf": "ğ•›", "Jscr": "ğ’¥", "jscr": "ğ’¿", "Jsercy": "Ğˆ", "jsercy": "Ñ˜", "Jukcy": "Ğ„", "jukcy": "Ñ”", "Kappa": "Îš", "kappa": "Îº", "kappav": "Ï°", "Kcedil": "Ä¶", "kcedil": "Ä·", "Kcy": "Ğš", "kcy": "Ğº", "Kfr": "ğ”", "kfr": "ğ”¨", "kgreen": "Ä¸", "KHcy": "Ğ¥", "khcy": "Ñ…", "KJcy": "ĞŒ", "kjcy": "Ñœ", "Kopf": "ğ•‚", "kopf": "ğ•œ", "Kscr": "ğ’¦", "kscr": "ğ“€", "lAarr": "â‡š", "Lacute": "Ä¹", "lacute": "Äº", "laemptyv": "â¦´", "lagran": "â„’", "Lambda": "Î›", "lambda": "Î»", "lang": "âŸ¨", "Lang": "âŸª", "langd": "â¦‘", "langle": "âŸ¨", "lap": "âª…", "Laplacetrf": "â„’", "laquo": "Â«", "larrb": "â‡¤", "larrbfs": "â¤Ÿ", "larr": "â†", "Larr": "â†", "lArr": "â‡", "larrfs": "â¤", "larrhk": "â†©", "larrlp": "â†«", "larrpl": "â¤¹", "larrsim": "â¥³", "larrtl": "â†¢", "latail": "â¤™", "lAtail": "â¤›", "lat": "âª«", "late": "âª­", "lates": "âª­ï¸€", "lbarr": "â¤Œ", "lBarr": "â¤", "lbbrk": "â²", "lbrace": "{", "lbrack": "[", "lbrke": "â¦‹", "lbrksld": "â¦", "lbrkslu": "â¦", "Lcaron": "Ä½", "lcaron": "Ä¾", "Lcedil": "Ä»", "lcedil": "Ä¼", "lceil": "âŒˆ", "lcub": "{", "Lcy": "Ğ›", "lcy": "Ğ»", "ldca": "â¤¶", "ldquo": "â€œ", "ldquor": "â€", "ldrdhar": "â¥§", "ldrushar": "â¥‹", "ldsh": "â†²", "le": "â‰¤", "lE": "â‰¦", "LeftAngleBracket": "âŸ¨", "LeftArrowBar": "â‡¤", "leftarrow": "â†", "LeftArrow": "â†", "Leftarrow": "â‡", "LeftArrowRightArrow": "â‡†", "leftarrowtail": "â†¢", "LeftCeiling": "âŒˆ", "LeftDoubleBracket": "âŸ¦", "LeftDownTeeVector": "â¥¡", "LeftDownVectorBar": "â¥™", "LeftDownVector": "â‡ƒ", "LeftFloor": "âŒŠ", "leftharpoondown": "â†½", "leftharpoonup": "â†¼", "leftleftarrows": "â‡‡", "leftrightarrow": "â†”", "LeftRightArrow": "â†”", "Leftrightarrow": "â‡”", "leftrightarrows": "â‡†", "leftrightharpoons": "â‡‹", "leftrightsquigarrow": "â†­", "LeftRightVector": "â¥", "LeftTeeArrow": "â†¤", "LeftTee": "âŠ£", "LeftTeeVector": "â¥š", "leftthreetimes": "â‹‹", "LeftTriangleBar": "â§", "LeftTriangle": "âŠ²", "LeftTriangleEqual": "âŠ´", "LeftUpDownVector": "â¥‘", "LeftUpTeeVector": "â¥ ", "LeftUpVectorBar": "â¥˜", "LeftUpVector": "â†¿", "LeftVectorBar": "â¥’", "LeftVector": "â†¼", "lEg": "âª‹", "leg": "â‹š", "leq": "â‰¤", "leqq": "â‰¦", "leqslant": "â©½", "lescc": "âª¨", "les": "â©½", "lesdot": "â©¿", "lesdoto": "âª", "lesdotor": "âªƒ", "lesg": "â‹šï¸€", "lesges": "âª“", "lessapprox": "âª…", "lessdot": "â‹–", "lesseqgtr": "â‹š", "lesseqqgtr": "âª‹", "LessEqualGreater": "â‹š", "LessFullEqual": "â‰¦", "LessGreater": "â‰¶", "lessgtr": "â‰¶", "LessLess": "âª¡", "lesssim": "â‰²", "LessSlantEqual": "â©½", "LessTilde": "â‰²", "lfisht": "â¥¼", "lfloor": "âŒŠ", "Lfr": "ğ”", "lfr": "ğ”©", "lg": "â‰¶", "lgE": "âª‘", "lHar": "â¥¢", "lhard": "â†½", "lharu": "â†¼", "lharul": "â¥ª", "lhblk": "â–„", "LJcy": "Ğ‰", "ljcy": "Ñ™", "llarr": "â‡‡", "ll": "â‰ª", "Ll": "â‹˜", "llcorner": "âŒ", "Lleftarrow": "â‡š", "llhard": "â¥«", "lltri": "â—º", "Lmidot": "Ä¿", "lmidot": "Å€", "lmoustache": "â°", "lmoust": "â°", "lnap": "âª‰", "lnapprox": "âª‰", "lne": "âª‡", "lnE": "â‰¨", "lneq": "âª‡", "lneqq": "â‰¨", "lnsim": "â‹¦", "loang": "âŸ¬", "loarr": "â‡½", "lobrk": "âŸ¦", "longleftarrow": "âŸµ", "LongLeftArrow": "âŸµ", "Longleftarrow": "âŸ¸", "longleftrightarrow": "âŸ·", "LongLeftRightArrow": "âŸ·", "Longleftrightarrow": "âŸº", "longmapsto": "âŸ¼", "longrightarrow": "âŸ¶", "LongRightArrow": "âŸ¶", "Longrightarrow": "âŸ¹", "looparrowleft": "â†«", "looparrowright": "â†¬", "lopar": "â¦…", "Lopf": "ğ•ƒ", "lopf": "ğ•", "loplus": "â¨­", "lotimes": "â¨´", "lowast": "âˆ—", "lowbar": "_", "LowerLeftArrow": "â†™", "LowerRightArrow": "â†˜", "loz": "â—Š", "lozenge": "â—Š", "lozf": "â§«", "lpar": "(", "lparlt": "â¦“", "lrarr": "â‡†", "lrcorner": "âŒŸ", "lrhar": "â‡‹", "lrhard": "â¥­", "lrm": "â€", "lrtri": "âŠ¿", "lsaquo": "â€¹", "lscr": "ğ“", "Lscr": "â„’", "lsh": "â†°", "Lsh": "â†°", "lsim": "â‰²", "lsime": "âª", "lsimg": "âª", "lsqb": "[", "lsquo": "â€˜", "lsquor": "â€š", "Lstrok": "Å", "lstrok": "Å‚", "ltcc": "âª¦", "ltcir": "â©¹", "lt": "<", "LT": "<", "Lt": "â‰ª", "ltdot": "â‹–", "lthree": "â‹‹", "ltimes": "â‹‰", "ltlarr": "â¥¶", "ltquest": "â©»", "ltri": "â—ƒ", "ltrie": "âŠ´", "ltrif": "â—‚", "ltrPar": "â¦–", "lurdshar": "â¥Š", "luruhar": "â¥¦", "lvertneqq": "â‰¨ï¸€", "lvnE": "â‰¨ï¸€", "macr": "Â¯", "male": "â™‚", "malt": "âœ ", "maltese": "âœ ", "Map": "â¤…", "map": "â†¦", "mapsto": "â†¦", "mapstodown": "â†§", "mapstoleft": "â†¤", "mapstoup": "â†¥", "marker": "â–®", "mcomma": "â¨©", "Mcy": "Ğœ", "mcy": "Ğ¼", "mdash": "â€”", "mDDot": "âˆº", "measuredangle": "âˆ¡", "MediumSpace": "âŸ", "Mellintrf": "â„³", "Mfr": "ğ”", "mfr": "ğ”ª", "mho": "â„§", "micro": "Âµ", "midast": "*", "midcir": "â«°", "mid": "âˆ£", "middot": "Â·", "minusb": "âŠŸ", "minus": "âˆ’", "minusd": "âˆ¸", "minusdu": "â¨ª", "MinusPlus": "âˆ“", "mlcp": "â«›", "mldr": "â€¦", "mnplus": "âˆ“", "models": "âŠ§", "Mopf": "ğ•„", "mopf": "ğ•", "mp": "âˆ“", "mscr": "ğ“‚", "Mscr": "â„³", "mstpos": "âˆ¾", "Mu": "Îœ", "mu": "Î¼", "multimap": "âŠ¸", "mumap": "âŠ¸", "nabla": "âˆ‡", "Nacute": "Åƒ", "nacute": "Å„", "nang": "âˆ âƒ’", "nap": "â‰‰", "napE": "â©°Ì¸", "napid": "â‰‹Ì¸", "napos": "Å‰", "napprox": "â‰‰", "natural": "â™®", "naturals": "â„•", "natur": "â™®", "nbsp": "Â ", "nbump": "â‰Ì¸", "nbumpe": "â‰Ì¸", "ncap": "â©ƒ", "Ncaron": "Å‡", "ncaron": "Åˆ", "Ncedil": "Å…", "ncedil": "Å†", "ncong": "â‰‡", "ncongdot": "â©­Ì¸", "ncup": "â©‚", "Ncy": "Ğ", "ncy": "Ğ½", "ndash": "â€“", "nearhk": "â¤¤", "nearr": "â†—", "neArr": "â‡—", "nearrow": "â†—", "ne": "â‰ ", "nedot": "â‰Ì¸", "NegativeMediumSpace": "â€‹", "NegativeThickSpace": "â€‹", "NegativeThinSpace": "â€‹", "NegativeVeryThinSpace": "â€‹", "nequiv": "â‰¢", "nesear": "â¤¨", "nesim": "â‰‚Ì¸", "NestedGreaterGreater": "â‰«", "NestedLessLess": "â‰ª", "NewLine": "\n", "nexist": "âˆ„", "nexists": "âˆ„", "Nfr": "ğ”‘", "nfr": "ğ”«", "ngE": "â‰§Ì¸", "nge": "â‰±", "ngeq": "â‰±", "ngeqq": "â‰§Ì¸", "ngeqslant": "â©¾Ì¸", "nges": "â©¾Ì¸", "nGg": "â‹™Ì¸", "ngsim": "â‰µ", "nGt": "â‰«âƒ’", "ngt": "â‰¯", "ngtr": "â‰¯", "nGtv": "â‰«Ì¸", "nharr": "â†®", "nhArr": "â‡", "nhpar": "â«²", "ni": "âˆ‹", "nis": "â‹¼", "nisd": "â‹º", "niv": "âˆ‹", "NJcy": "ĞŠ", "njcy": "Ñš", "nlarr": "â†š", "nlArr": "â‡", "nldr": "â€¥", "nlE": "â‰¦Ì¸", "nle": "â‰°", "nleftarrow": "â†š", "nLeftarrow": "â‡", "nleftrightarrow": "â†®", "nLeftrightarrow": "â‡", "nleq": "â‰°", "nleqq": "â‰¦Ì¸", "nleqslant": "â©½Ì¸", "nles": "â©½Ì¸", "nless": "â‰®", "nLl": "â‹˜Ì¸", "nlsim": "â‰´", "nLt": "â‰ªâƒ’", "nlt": "â‰®", "nltri": "â‹ª", "nltrie": "â‹¬", "nLtv": "â‰ªÌ¸", "nmid": "âˆ¤", "NoBreak": "â ", "NonBreakingSpace": "Â ", "nopf": "ğ•Ÿ", "Nopf": "â„•", "Not": "â«¬", "not": "Â¬", "NotCongruent": "â‰¢", "NotCupCap": "â‰­", "NotDoubleVerticalBar": "âˆ¦", "NotElement": "âˆ‰", "NotEqual": "â‰ ", "NotEqualTilde": "â‰‚Ì¸", "NotExists": "âˆ„", "NotGreater": "â‰¯", "NotGreaterEqual": "â‰±", "NotGreaterFullEqual": "â‰§Ì¸", "NotGreaterGreater": "â‰«Ì¸", "NotGreaterLess": "â‰¹", "NotGreaterSlantEqual": "â©¾Ì¸", "NotGreaterTilde": "â‰µ", "NotHumpDownHump": "â‰Ì¸", "NotHumpEqual": "â‰Ì¸", "notin": "âˆ‰", "notindot": "â‹µÌ¸", "notinE": "â‹¹Ì¸", "notinva": "âˆ‰", "notinvb": "â‹·", "notinvc": "â‹¶", "NotLeftTriangleBar": "â§Ì¸", "NotLeftTriangle": "â‹ª", "NotLeftTriangleEqual": "â‹¬", "NotLess": "â‰®", "NotLessEqual": "â‰°", "NotLessGreater": "â‰¸", "NotLessLess": "â‰ªÌ¸", "NotLessSlantEqual": "â©½Ì¸", "NotLessTilde": "â‰´", "NotNestedGreaterGreater": "âª¢Ì¸", "NotNestedLessLess": "âª¡Ì¸", "notni": "âˆŒ", "notniva": "âˆŒ", "notnivb": "â‹¾", "notnivc": "â‹½", "NotPrecedes": "âŠ€", "NotPrecedesEqual": "âª¯Ì¸", "NotPrecedesSlantEqual": "â‹ ", "NotReverseElement": "âˆŒ", "NotRightTriangleBar": "â§Ì¸", "NotRightTriangle": "â‹«", "NotRightTriangleEqual": "â‹­", "NotSquareSubset": "âŠÌ¸", "NotSquareSubsetEqual": "â‹¢", "NotSquareSuperset": "âŠÌ¸", "NotSquareSupersetEqual": "â‹£", "NotSubset": "âŠ‚âƒ’", "NotSubsetEqual": "âŠˆ", "NotSucceeds": "âŠ", "NotSucceedsEqual": "âª°Ì¸", "NotSucceedsSlantEqual": "â‹¡", "NotSucceedsTilde": "â‰¿Ì¸", "NotSuperset": "âŠƒâƒ’", "NotSupersetEqual": "âŠ‰", "NotTilde": "â‰", "NotTildeEqual": "â‰„", "NotTildeFullEqual": "â‰‡", "NotTildeTilde": "â‰‰", "NotVerticalBar": "âˆ¤", "nparallel": "âˆ¦", "npar": "âˆ¦", "nparsl": "â«½âƒ¥", "npart": "âˆ‚Ì¸", "npolint": "â¨”", "npr": "âŠ€", "nprcue": "â‹ ", "nprec": "âŠ€", "npreceq": "âª¯Ì¸", "npre": "âª¯Ì¸", "nrarrc": "â¤³Ì¸", "nrarr": "â†›", "nrArr": "â‡", "nrarrw": "â†Ì¸", "nrightarrow": "â†›", "nRightarrow": "â‡", "nrtri": "â‹«", "nrtrie": "â‹­", "nsc": "âŠ", "nsccue": "â‹¡", "nsce": "âª°Ì¸", "Nscr": "ğ’©", "nscr": "ğ“ƒ", "nshortmid": "âˆ¤", "nshortparallel": "âˆ¦", "nsim": "â‰", "nsime": "â‰„", "nsimeq": "â‰„", "nsmid": "âˆ¤", "nspar": "âˆ¦", "nsqsube": "â‹¢", "nsqsupe": "â‹£", "nsub": "âŠ„", "nsubE": "â«…Ì¸", "nsube": "âŠˆ", "nsubset": "âŠ‚âƒ’", "nsubseteq": "âŠˆ", "nsubseteqq": "â«…Ì¸", "nsucc": "âŠ", "nsucceq": "âª°Ì¸", "nsup": "âŠ…", "nsupE": "â«†Ì¸", "nsupe": "âŠ‰", "nsupset": "âŠƒâƒ’", "nsupseteq": "âŠ‰", "nsupseteqq": "â«†Ì¸", "ntgl": "â‰¹", "Ntilde": "Ã‘", "ntilde": "Ã±", "ntlg": "â‰¸", "ntriangleleft": "â‹ª", "ntrianglelefteq": "â‹¬", "ntriangleright": "â‹«", "ntrianglerighteq": "â‹­", "Nu": "Î", "nu": "Î½", "num": "#", "numero": "â„–", "numsp": "â€‡", "nvap": "â‰âƒ’", "nvdash": "âŠ¬", "nvDash": "âŠ­", "nVdash": "âŠ®", "nVDash": "âŠ¯", "nvge": "â‰¥âƒ’", "nvgt": ">âƒ’", "nvHarr": "â¤„", "nvinfin": "â§", "nvlArr": "â¤‚", "nvle": "â‰¤âƒ’", "nvlt": "<âƒ’", "nvltrie": "âŠ´âƒ’", "nvrArr": "â¤ƒ", "nvrtrie": "âŠµâƒ’", "nvsim": "âˆ¼âƒ’", "nwarhk": "â¤£", "nwarr": "â†–", "nwArr": "â‡–", "nwarrow": "â†–", "nwnear": "â¤§", "Oacute": "Ã“", "oacute": "Ã³", "oast": "âŠ›", "Ocirc": "Ã”", "ocirc": "Ã´", "ocir": "âŠš", "Ocy": "Ğ", "ocy": "Ğ¾", "odash": "âŠ", "Odblac": "Å", "odblac": "Å‘", "odiv": "â¨¸", "odot": "âŠ™", "odsold": "â¦¼", "OElig": "Å’", "oelig": "Å“", "ofcir": "â¦¿", "Ofr": "ğ”’", "ofr": "ğ”¬", "ogon": "Ë›", "Ograve": "Ã’", "ograve": "Ã²", "ogt": "â§", "ohbar": "â¦µ", "ohm": "Î©", "oint": "âˆ®", "olarr": "â†º", "olcir": "â¦¾", "olcross": "â¦»", "oline": "â€¾", "olt": "â§€", "Omacr": "ÅŒ", "omacr": "Å", "Omega": "Î©", "omega": "Ï‰", "Omicron": "ÎŸ", "omicron": "Î¿", "omid": "â¦¶", "ominus": "âŠ–", "Oopf": "ğ•†", "oopf": "ğ• ", "opar": "â¦·", "OpenCurlyDoubleQuote": "â€œ", "OpenCurlyQuote": "â€˜", "operp": "â¦¹", "oplus": "âŠ•", "orarr": "â†»", "Or": "â©”", "or": "âˆ¨", "ord": "â©", "order": "â„´", "orderof": "â„´", "ordf": "Âª", "ordm": "Âº", "origof": "âŠ¶", "oror": "â©–", "orslope": "â©—", "orv": "â©›", "oS": "â“ˆ", "Oscr": "ğ’ª", "oscr": "â„´", "Oslash": "Ã˜", "oslash": "Ã¸", "osol": "âŠ˜", "Otilde": "Ã•", "otilde": "Ãµ", "otimesas": "â¨¶", "Otimes": "â¨·", "otimes": "âŠ—", "Ouml": "Ã–", "ouml": "Ã¶", "ovbar": "âŒ½", "OverBar": "â€¾", "OverBrace": "â", "OverBracket": "â´", "OverParenthesis": "âœ", "para": "Â¶", "parallel": "âˆ¥", "par": "âˆ¥", "parsim": "â«³", "parsl": "â«½", "part": "âˆ‚", "PartialD": "âˆ‚", "Pcy": "ĞŸ", "pcy": "Ğ¿", "percnt": "%", "period": ".", "permil": "â€°", "perp": "âŠ¥", "pertenk": "â€±", "Pfr": "ğ”“", "pfr": "ğ”­", "Phi": "Î¦", "phi": "Ï†", "phiv": "Ï•", "phmmat": "â„³", "phone": "â˜", "Pi": "Î ", "pi": "Ï€", "pitchfork": "â‹”", "piv": "Ï–", "planck": "â„", "planckh": "â„", "plankv": "â„", "plusacir": "â¨£", "plusb": "âŠ", "pluscir": "â¨¢", "plus": "+", "plusdo": "âˆ”", "plusdu": "â¨¥", "pluse": "â©²", "PlusMinus": "Â±", "plusmn": "Â±", "plussim": "â¨¦", "plustwo": "â¨§", "pm": "Â±", "Poincareplane": "â„Œ", "pointint": "â¨•", "popf": "ğ•¡", "Popf": "â„™", "pound": "Â£", "prap": "âª·", "Pr": "âª»", "pr": "â‰º", "prcue": "â‰¼", "precapprox": "âª·", "prec": "â‰º", "preccurlyeq": "â‰¼", "Precedes": "â‰º", "PrecedesEqual": "âª¯", "PrecedesSlantEqual": "â‰¼", "PrecedesTilde": "â‰¾", "preceq": "âª¯", "precnapprox": "âª¹", "precneqq": "âªµ", "precnsim": "â‹¨", "pre": "âª¯", "prE": "âª³", "precsim": "â‰¾", "prime": "â€²", "Prime": "â€³", "primes": "â„™", "prnap": "âª¹", "prnE": "âªµ", "prnsim": "â‹¨", "prod": "âˆ", "Product": "âˆ", "profalar": "âŒ®", "profline": "âŒ’", "profsurf": "âŒ“", "prop": "âˆ", "Proportional": "âˆ", "Proportion": "âˆ·", "propto": "âˆ", "prsim": "â‰¾", "prurel": "âŠ°", "Pscr": "ğ’«", "pscr": "ğ“…", "Psi": "Î¨", "psi": "Ïˆ", "puncsp": "â€ˆ", "Qfr": "ğ””", "qfr": "ğ”®", "qint": "â¨Œ", "qopf": "ğ•¢", "Qopf": "â„š", "qprime": "â—", "Qscr": "ğ’¬", "qscr": "ğ“†", "quaternions": "â„", "quatint": "â¨–", "quest": "?", "questeq": "â‰Ÿ", "quot": '"', "QUOT": '"', "rAarr": "â‡›", "race": "âˆ½Ì±", "Racute": "Å”", "racute": "Å•", "radic": "âˆš", "raemptyv": "â¦³", "rang": "âŸ©", "Rang": "âŸ«", "rangd": "â¦’", "range": "â¦¥", "rangle": "âŸ©", "raquo": "Â»", "rarrap": "â¥µ", "rarrb": "â‡¥", "rarrbfs": "â¤ ", "rarrc": "â¤³", "rarr": "â†’", "Rarr": "â† ", "rArr": "â‡’", "rarrfs": "â¤", "rarrhk": "â†ª", "rarrlp": "â†¬", "rarrpl": "â¥…", "rarrsim": "â¥´", "Rarrtl": "â¤–", "rarrtl": "â†£", "rarrw": "â†", "ratail": "â¤š", "rAtail": "â¤œ", "ratio": "âˆ¶", "rationals": "â„š", "rbarr": "â¤", "rBarr": "â¤", "RBarr": "â¤", "rbbrk": "â³", "rbrace": "}", "rbrack": "]", "rbrke": "â¦Œ", "rbrksld": "â¦", "rbrkslu": "â¦", "Rcaron": "Å˜", "rcaron": "Å™", "Rcedil": "Å–", "rcedil": "Å—", "rceil": "âŒ‰", "rcub": "}", "Rcy": "Ğ ", "rcy": "Ñ€", "rdca": "â¤·", "rdldhar": "â¥©", "rdquo": "â€", "rdquor": "â€", "rdsh": "â†³", "real": "â„œ", "realine": "â„›", "realpart": "â„œ", "reals": "â„", "Re": "â„œ", "rect": "â–­", "reg": "Â®", "REG": "Â®", "ReverseElement": "âˆ‹", "ReverseEquilibrium": "â‡‹", "ReverseUpEquilibrium": "â¥¯", "rfisht": "â¥½", "rfloor": "âŒ‹", "rfr": "ğ”¯", "Rfr": "â„œ", "rHar": "â¥¤", "rhard": "â‡", "rharu": "â‡€", "rharul": "â¥¬", "Rho": "Î¡", "rho": "Ï", "rhov": "Ï±", "RightAngleBracket": "âŸ©", "RightArrowBar": "â‡¥", "rightarrow": "â†’", "RightArrow": "â†’", "Rightarrow": "â‡’", "RightArrowLeftArrow": "â‡„", "rightarrowtail": "â†£", "RightCeiling": "âŒ‰", "RightDoubleBracket": "âŸ§", "RightDownTeeVector": "â¥", "RightDownVectorBar": "â¥•", "RightDownVector": "â‡‚", "RightFloor": "âŒ‹", "rightharpoondown": "â‡", "rightharpoonup": "â‡€", "rightleftarrows": "â‡„", "rightleftharpoons": "â‡Œ", "rightrightarrows": "â‡‰", "rightsquigarrow": "â†", "RightTeeArrow": "â†¦", "RightTee": "âŠ¢", "RightTeeVector": "â¥›", "rightthreetimes": "â‹Œ", "RightTriangleBar": "â§", "RightTriangle": "âŠ³", "RightTriangleEqual": "âŠµ", "RightUpDownVector": "â¥", "RightUpTeeVector": "â¥œ", "RightUpVectorBar": "â¥”", "RightUpVector": "â†¾", "RightVectorBar": "â¥“", "RightVector": "â‡€", "ring": "Ëš", "risingdotseq": "â‰“", "rlarr": "â‡„", "rlhar": "â‡Œ", "rlm": "â€", "rmoustache": "â±", "rmoust": "â±", "rnmid": "â«®", "roang": "âŸ­", "roarr": "â‡¾", "robrk": "âŸ§", "ropar": "â¦†", "ropf": "ğ•£", "Ropf": "â„", "roplus": "â¨®", "rotimes": "â¨µ", "RoundImplies": "â¥°", "rpar": ")", "rpargt": "â¦”", "rppolint": "â¨’", "rrarr": "â‡‰", "Rrightarrow": "â‡›", "rsaquo": "â€º", "rscr": "ğ“‡", "Rscr": "â„›", "rsh": "â†±", "Rsh": "â†±", "rsqb": "]", "rsquo": "â€™", "rsquor": "â€™", "rthree": "â‹Œ", "rtimes": "â‹Š", "rtri": "â–¹", "rtrie": "âŠµ", "rtrif": "â–¸", "rtriltri": "â§", "RuleDelayed": "â§´", "ruluhar": "â¥¨", "rx": "â„", "Sacute": "Åš", "sacute": "Å›", "sbquo": "â€š", "scap": "âª¸", "Scaron": "Å ", "scaron": "Å¡", "Sc": "âª¼", "sc": "â‰»", "sccue": "â‰½", "sce": "âª°", "scE": "âª´", "Scedil": "Å", "scedil": "ÅŸ", "Scirc": "Åœ", "scirc": "Å", "scnap": "âªº", "scnE": "âª¶", "scnsim": "â‹©", "scpolint": "â¨“", "scsim": "â‰¿", "Scy": "Ğ¡", "scy": "Ñ", "sdotb": "âŠ¡", "sdot": "â‹…", "sdote": "â©¦", "searhk": "â¤¥", "searr": "â†˜", "seArr": "â‡˜", "searrow": "â†˜", "sect": "Â§", "semi": ";", "seswar": "â¤©", "setminus": "âˆ–", "setmn": "âˆ–", "sext": "âœ¶", "Sfr": "ğ”–", "sfr": "ğ”°", "sfrown": "âŒ¢", "sharp": "â™¯", "SHCHcy": "Ğ©", "shchcy": "Ñ‰", "SHcy": "Ğ¨", "shcy": "Ñˆ", "ShortDownArrow": "â†“", "ShortLeftArrow": "â†", "shortmid": "âˆ£", "shortparallel": "âˆ¥", "ShortRightArrow": "â†’", "ShortUpArrow": "â†‘", "shy": "Â­", "Sigma": "Î£", "sigma": "Ïƒ", "sigmaf": "Ï‚", "sigmav": "Ï‚", "sim": "âˆ¼", "simdot": "â©ª", "sime": "â‰ƒ", "simeq": "â‰ƒ", "simg": "âª", "simgE": "âª ", "siml": "âª", "simlE": "âªŸ", "simne": "â‰†", "simplus": "â¨¤", "simrarr": "â¥²", "slarr": "â†", "SmallCircle": "âˆ˜", "smallsetminus": "âˆ–", "smashp": "â¨³", "smeparsl": "â§¤", "smid": "âˆ£", "smile": "âŒ£", "smt": "âªª", "smte": "âª¬", "smtes": "âª¬ï¸€", "SOFTcy": "Ğ¬", "softcy": "ÑŒ", "solbar": "âŒ¿", "solb": "â§„", "sol": "/", "Sopf": "ğ•Š", "sopf": "ğ•¤", "spades": "â™ ", "spadesuit": "â™ ", "spar": "âˆ¥", "sqcap": "âŠ“", "sqcaps": "âŠ“ï¸€", "sqcup": "âŠ”", "sqcups": "âŠ”ï¸€", "Sqrt": "âˆš", "sqsub": "âŠ", "sqsube": "âŠ‘", "sqsubset": "âŠ", "sqsubseteq": "âŠ‘", "sqsup": "âŠ", "sqsupe": "âŠ’", "sqsupset": "âŠ", "sqsupseteq": "âŠ’", "square": "â–¡", "Square": "â–¡", "SquareIntersection": "âŠ“", "SquareSubset": "âŠ", "SquareSubsetEqual": "âŠ‘", "SquareSuperset": "âŠ", "SquareSupersetEqual": "âŠ’", "SquareUnion": "âŠ”", "squarf": "â–ª", "squ": "â–¡", "squf": "â–ª", "srarr": "â†’", "Sscr": "ğ’®", "sscr": "ğ“ˆ", "ssetmn": "âˆ–", "ssmile": "âŒ£", "sstarf": "â‹†", "Star": "â‹†", "star": "â˜†", "starf": "â˜…", "straightepsilon": "Ïµ", "straightphi": "Ï•", "strns": "Â¯", "sub": "âŠ‚", "Sub": "â‹", "subdot": "âª½", "subE": "â«…", "sube": "âŠ†", "subedot": "â«ƒ", "submult": "â«", "subnE": "â«‹", "subne": "âŠŠ", "subplus": "âª¿", "subrarr": "â¥¹", "subset": "âŠ‚", "Subset": "â‹", "subseteq": "âŠ†", "subseteqq": "â«…", "SubsetEqual": "âŠ†", "subsetneq": "âŠŠ", "subsetneqq": "â«‹", "subsim": "â«‡", "subsub": "â«•", "subsup": "â«“", "succapprox": "âª¸", "succ": "â‰»", "succcurlyeq": "â‰½", "Succeeds": "â‰»", "SucceedsEqual": "âª°", "SucceedsSlantEqual": "â‰½", "SucceedsTilde": "â‰¿", "succeq": "âª°", "succnapprox": "âªº", "succneqq": "âª¶", "succnsim": "â‹©", "succsim": "â‰¿", "SuchThat": "âˆ‹", "sum": "âˆ‘", "Sum": "âˆ‘", "sung": "â™ª", "sup1": "Â¹", "sup2": "Â²", "sup3": "Â³", "sup": "âŠƒ", "Sup": "â‹‘", "supdot": "âª¾", "supdsub": "â«˜", "supE": "â«†", "supe": "âŠ‡", "supedot": "â«„", "Superset": "âŠƒ", "SupersetEqual": "âŠ‡", "suphsol": "âŸ‰", "suphsub": "â«—", "suplarr": "â¥»", "supmult": "â«‚", "supnE": "â«Œ", "supne": "âŠ‹", "supplus": "â«€", "supset": "âŠƒ", "Supset": "â‹‘", "supseteq": "âŠ‡", "supseteqq": "â«†", "supsetneq": "âŠ‹", "supsetneqq": "â«Œ", "supsim": "â«ˆ", "supsub": "â«”", "supsup": "â«–", "swarhk": "â¤¦", "swarr": "â†™", "swArr": "â‡™", "swarrow": "â†™", "swnwar": "â¤ª", "szlig": "ÃŸ", "Tab": "	", "target": "âŒ–", "Tau": "Î¤", "tau": "Ï„", "tbrk": "â´", "Tcaron": "Å¤", "tcaron": "Å¥", "Tcedil": "Å¢", "tcedil": "Å£", "Tcy": "Ğ¢", "tcy": "Ñ‚", "tdot": "âƒ›", "telrec": "âŒ•", "Tfr": "ğ”—", "tfr": "ğ”±", "there4": "âˆ´", "therefore": "âˆ´", "Therefore": "âˆ´", "Theta": "Î˜", "theta": "Î¸", "thetasym": "Ï‘", "thetav": "Ï‘", "thickapprox": "â‰ˆ", "thicksim": "âˆ¼", "ThickSpace": "âŸâ€Š", "ThinSpace": "â€‰", "thinsp": "â€‰", "thkap": "â‰ˆ", "thksim": "âˆ¼", "THORN": "Ã", "thorn": "Ã¾", "tilde": "Ëœ", "Tilde": "âˆ¼", "TildeEqual": "â‰ƒ", "TildeFullEqual": "â‰…", "TildeTilde": "â‰ˆ", "timesbar": "â¨±", "timesb": "âŠ ", "times": "Ã—", "timesd": "â¨°", "tint": "âˆ­", "toea": "â¤¨", "topbot": "âŒ¶", "topcir": "â«±", "top": "âŠ¤", "Topf": "ğ•‹", "topf": "ğ•¥", "topfork": "â«š", "tosa": "â¤©", "tprime": "â€´", "trade": "â„¢", "TRADE": "â„¢", "triangle": "â–µ", "triangledown": "â–¿", "triangleleft": "â—ƒ", "trianglelefteq": "âŠ´", "triangleq": "â‰œ", "triangleright": "â–¹", "trianglerighteq": "âŠµ", "tridot": "â—¬", "trie": "â‰œ", "triminus": "â¨º", "TripleDot": "âƒ›", "triplus": "â¨¹", "trisb": "â§", "tritime": "â¨»", "trpezium": "â¢", "Tscr": "ğ’¯", "tscr": "ğ“‰", "TScy": "Ğ¦", "tscy": "Ñ†", "TSHcy": "Ğ‹", "tshcy": "Ñ›", "Tstrok": "Å¦", "tstrok": "Å§", "twixt": "â‰¬", "twoheadleftarrow": "â†", "twoheadrightarrow": "â† ", "Uacute": "Ãš", "uacute": "Ãº", "uarr": "â†‘", "Uarr": "â†Ÿ", "uArr": "â‡‘", "Uarrocir": "â¥‰", "Ubrcy": "Ğ", "ubrcy": "Ñ", "Ubreve": "Å¬", "ubreve": "Å­", "Ucirc": "Ã›", "ucirc": "Ã»", "Ucy": "Ğ£", "ucy": "Ñƒ", "udarr": "â‡…", "Udblac": "Å°", "udblac": "Å±", "udhar": "â¥®", "ufisht": "â¥¾", "Ufr": "ğ”˜", "ufr": "ğ”²", "Ugrave": "Ã™", "ugrave": "Ã¹", "uHar": "â¥£", "uharl": "â†¿", "uharr": "â†¾", "uhblk": "â–€", "ulcorn": "âŒœ", "ulcorner": "âŒœ", "ulcrop": "âŒ", "ultri": "â—¸", "Umacr": "Åª", "umacr": "Å«", "uml": "Â¨", "UnderBar": "_", "UnderBrace": "âŸ", "UnderBracket": "âµ", "UnderParenthesis": "â", "Union": "â‹ƒ", "UnionPlus": "âŠ", "Uogon": "Å²", "uogon": "Å³", "Uopf": "ğ•Œ", "uopf": "ğ•¦", "UpArrowBar": "â¤’", "uparrow": "â†‘", "UpArrow": "â†‘", "Uparrow": "â‡‘", "UpArrowDownArrow": "â‡…", "updownarrow": "â†•", "UpDownArrow": "â†•", "Updownarrow": "â‡•", "UpEquilibrium": "â¥®", "upharpoonleft": "â†¿", "upharpoonright": "â†¾", "uplus": "âŠ", "UpperLeftArrow": "â†–", "UpperRightArrow": "â†—", "upsi": "Ï…", "Upsi": "Ï’", "upsih": "Ï’", "Upsilon": "Î¥", "upsilon": "Ï…", "UpTeeArrow": "â†¥", "UpTee": "âŠ¥", "upuparrows": "â‡ˆ", "urcorn": "âŒ", "urcorner": "âŒ", "urcrop": "âŒ", "Uring": "Å®", "uring": "Å¯", "urtri": "â—¹", "Uscr": "ğ’°", "uscr": "ğ“Š", "utdot": "â‹°", "Utilde": "Å¨", "utilde": "Å©", "utri": "â–µ", "utrif": "â–´", "uuarr": "â‡ˆ", "Uuml": "Ãœ", "uuml": "Ã¼", "uwangle": "â¦§", "vangrt": "â¦œ", "varepsilon": "Ïµ", "varkappa": "Ï°", "varnothing": "âˆ…", "varphi": "Ï•", "varpi": "Ï–", "varpropto": "âˆ", "varr": "â†•", "vArr": "â‡•", "varrho": "Ï±", "varsigma": "Ï‚", "varsubsetneq": "âŠŠï¸€", "varsubsetneqq": "â«‹ï¸€", "varsupsetneq": "âŠ‹ï¸€", "varsupsetneqq": "â«Œï¸€", "vartheta": "Ï‘", "vartriangleleft": "âŠ²", "vartriangleright": "âŠ³", "vBar": "â«¨", "Vbar": "â««", "vBarv": "â«©", "Vcy": "Ğ’", "vcy": "Ğ²", "vdash": "âŠ¢", "vDash": "âŠ¨", "Vdash": "âŠ©", "VDash": "âŠ«", "Vdashl": "â«¦", "veebar": "âŠ»", "vee": "âˆ¨", "Vee": "â‹", "veeeq": "â‰š", "vellip": "â‹®", "verbar": "|", "Verbar": "â€–", "vert": "|", "Vert": "â€–", "VerticalBar": "âˆ£", "VerticalLine": "|", "VerticalSeparator": "â˜", "VerticalTilde": "â‰€", "VeryThinSpace": "â€Š", "Vfr": "ğ”™", "vfr": "ğ”³", "vltri": "âŠ²", "vnsub": "âŠ‚âƒ’", "vnsup": "âŠƒâƒ’", "Vopf": "ğ•", "vopf": "ğ•§", "vprop": "âˆ", "vrtri": "âŠ³", "Vscr": "ğ’±", "vscr": "ğ“‹", "vsubnE": "â«‹ï¸€", "vsubne": "âŠŠï¸€", "vsupnE": "â«Œï¸€", "vsupne": "âŠ‹ï¸€", "Vvdash": "âŠª", "vzigzag": "â¦š", "Wcirc": "Å´", "wcirc": "Åµ", "wedbar": "â©Ÿ", "wedge": "âˆ§", "Wedge": "â‹€", "wedgeq": "â‰™", "weierp": "â„˜", "Wfr": "ğ”š", "wfr": "ğ”´", "Wopf": "ğ•", "wopf": "ğ•¨", "wp": "â„˜", "wr": "â‰€", "wreath": "â‰€", "Wscr": "ğ’²", "wscr": "ğ“Œ", "xcap": "â‹‚", "xcirc": "â—¯", "xcup": "â‹ƒ", "xdtri": "â–½", "Xfr": "ğ”›", "xfr": "ğ”µ", "xharr": "âŸ·", "xhArr": "âŸº", "Xi": "Î", "xi": "Î¾", "xlarr": "âŸµ", "xlArr": "âŸ¸", "xmap": "âŸ¼", "xnis": "â‹»", "xodot": "â¨€", "Xopf": "ğ•", "xopf": "ğ•©", "xoplus": "â¨", "xotime": "â¨‚", "xrarr": "âŸ¶", "xrArr": "âŸ¹", "Xscr": "ğ’³", "xscr": "ğ“", "xsqcup": "â¨†", "xuplus": "â¨„", "xutri": "â–³", "xvee": "â‹", "xwedge": "â‹€", "Yacute": "Ã", "yacute": "Ã½", "YAcy": "Ğ¯", "yacy": "Ñ", "Ycirc": "Å¶", "ycirc": "Å·", "Ycy": "Ğ«", "ycy": "Ñ‹", "yen": "Â¥", "Yfr": "ğ”œ", "yfr": "ğ”¶", "YIcy": "Ğ‡", "yicy": "Ñ—", "Yopf": "ğ•", "yopf": "ğ•ª", "Yscr": "ğ’´", "yscr": "ğ“", "YUcy": "Ğ®", "yucy": "Ñ", "yuml": "Ã¿", "Yuml": "Å¸", "Zacute": "Å¹", "zacute": "Åº", "Zcaron": "Å½", "zcaron": "Å¾", "Zcy": "Ğ—", "zcy": "Ğ·", "Zdot": "Å»", "zdot": "Å¼", "zeetrf": "â„¨", "ZeroWidthSpace": "â€‹", "Zeta": "Î–", "zeta": "Î¶", "zfr": "ğ”·", "Zfr": "â„¨", "ZHcy": "Ğ–", "zhcy": "Ğ¶", "zigrarr": "â‡", "zopf": "ğ•«", "Zopf": "â„¤", "Zscr": "ğ’µ", "zscr": "ğ“", "zwj": "â€", "zwnj": "â€Œ" };
      }, {}], 23: [function(require2, module3, exports3) {
        module3.exports = { "Aacute": "Ã", "aacute": "Ã¡", "Acirc": "Ã‚", "acirc": "Ã¢", "acute": "Â´", "AElig": "Ã†", "aelig": "Ã¦", "Agrave": "Ã€", "agrave": "Ã ", "amp": "&", "AMP": "&", "Aring": "Ã…", "aring": "Ã¥", "Atilde": "Ãƒ", "atilde": "Ã£", "Auml": "Ã„", "auml": "Ã¤", "brvbar": "Â¦", "Ccedil": "Ã‡", "ccedil": "Ã§", "cedil": "Â¸", "cent": "Â¢", "copy": "Â©", "COPY": "Â©", "curren": "Â¤", "deg": "Â°", "divide": "Ã·", "Eacute": "Ã‰", "eacute": "Ã©", "Ecirc": "ÃŠ", "ecirc": "Ãª", "Egrave": "Ãˆ", "egrave": "Ã¨", "ETH": "Ã", "eth": "Ã°", "Euml": "Ã‹", "euml": "Ã«", "frac12": "Â½", "frac14": "Â¼", "frac34": "Â¾", "gt": ">", "GT": ">", "Iacute": "Ã", "iacute": "Ã­", "Icirc": "Ã", "icirc": "Ã®", "iexcl": "Â¡", "Igrave": "ÃŒ", "igrave": "Ã¬", "iquest": "Â¿", "Iuml": "Ã", "iuml": "Ã¯", "laquo": "Â«", "lt": "<", "LT": "<", "macr": "Â¯", "micro": "Âµ", "middot": "Â·", "nbsp": "Â ", "not": "Â¬", "Ntilde": "Ã‘", "ntilde": "Ã±", "Oacute": "Ã“", "oacute": "Ã³", "Ocirc": "Ã”", "ocirc": "Ã´", "Ograve": "Ã’", "ograve": "Ã²", "ordf": "Âª", "ordm": "Âº", "Oslash": "Ã˜", "oslash": "Ã¸", "Otilde": "Ã•", "otilde": "Ãµ", "Ouml": "Ã–", "ouml": "Ã¶", "para": "Â¶", "plusmn": "Â±", "pound": "Â£", "quot": '"', "QUOT": '"', "raquo": "Â»", "reg": "Â®", "REG": "Â®", "sect": "Â§", "shy": "Â­", "sup1": "Â¹", "sup2": "Â²", "sup3": "Â³", "szlig": "ÃŸ", "THORN": "Ã", "thorn": "Ã¾", "times": "Ã—", "Uacute": "Ãš", "uacute": "Ãº", "Ucirc": "Ã›", "ucirc": "Ã»", "Ugrave": "Ã™", "ugrave": "Ã¹", "uml": "Â¨", "Uuml": "Ãœ", "uuml": "Ã¼", "Yacute": "Ã", "yacute": "Ã½", "yen": "Â¥", "yuml": "Ã¿" };
      }, {}], 24: [function(require2, module3, exports3) {
        module3.exports = { "amp": "&", "apos": "'", "gt": ">", "lt": "<", "quot": '"' };
      }, {}], 25: [function(require2, module3, exports3) {
        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;
        function EventEmitter() {
          if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        }
        module3.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        var hasDefineProperty;
        try {
          var o = {};
          if (Object.defineProperty) Object.defineProperty(o, "x", { value: 0 });
          hasDefineProperty = o.x === 0;
        } catch (err) {
          hasDefineProperty = false;
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function get() {
            return defaultMaxListeners;
          }, set: function set(arg) {
            if (typeof arg !== "number" || arg < 0 || arg !== arg) throw new TypeError('"defaultMaxListeners" must be a positive number');
            defaultMaxListeners = arg;
          } });
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
          this._maxListeners = n;
          return this;
        };
        function $getMaxListeners(that) {
          if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        };
        function emitNone(handler, isFn, self2) {
          if (isFn) handler.call(self2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) {
              listeners[i].call(self2);
            }
          }
        }
        function emitOne(handler, isFn, self2, arg1) {
          if (isFn) handler.call(self2, arg1);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) {
              listeners[i].call(self2, arg1);
            }
          }
        }
        function emitTwo(handler, isFn, self2, arg1, arg2) {
          if (isFn) handler.call(self2, arg1, arg2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) {
              listeners[i].call(self2, arg1, arg2);
            }
          }
        }
        function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
          if (isFn) handler.call(self2, arg1, arg2, arg3);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) {
              listeners[i].call(self2, arg1, arg2, arg3);
            }
          }
        }
        function emitMany(handler, isFn, self2, args) {
          if (isFn) handler.apply(self2, args);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i) {
              listeners[i].apply(self2, args);
            }
          }
        }
        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events;
          var doError = type === "error";
          events = this._events;
          if (events) doError = doError && events.error == null;
          else if (!doError) return false;
          if (doError) {
            if (arguments.length > 1) er = arguments[1];
            if (er instanceof Error) {
              throw er;
            } else {
              var err = new Error('Unhandled "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
          }
          handler = events[type];
          if (!handler) return false;
          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            // fast cases
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++) {
                args[i - 1] = arguments[i];
              }
              emitMany(handler, isFn, this, args);
          }
          return true;
        };
        function _addListener(target2, type, listener, prepend) {
          var m;
          var events;
          var existing;
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          events = target2._events;
          if (!events) {
            events = target2._events = objectCreate(null);
            target2._eventsCount = 0;
          } else {
            if (events.newListener) {
              target2.emit("newListener", type, listener.listener ? listener.listener : listener);
              events = target2._events;
            }
            existing = events[type];
          }
          if (!existing) {
            existing = events[type] = listener;
            ++target2._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else {
              if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
            }
            if (!existing.warned) {
              m = $getMaxListeners(target2);
              if (m && m > 0 && existing.length > m) {
                existing.warned = true;
                var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
                w.name = "MaxListenersExceededWarning";
                w.emitter = target2;
                w.type = type;
                w.count = existing.length;
                if ((typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message);
                }
              }
            }
          }
          return target2;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
              default:
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; ++i) {
                  args[i] = arguments[i];
                }
                this.listener.apply(this.target, args);
            }
          }
        }
        function _onceWrap(target2, type, listener) {
          var state = { fired: false, wrapFn: void 0, target: target2, type, listener };
          var wrapped = bind.call(onceWrapper, state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list2, events, position, i, originalListener;
          if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
          events = this._events;
          if (!events) return this;
          list2 = events[type];
          if (!list2) return this;
          if (list2 === listener || list2.listener === listener) {
            if (--this._eventsCount === 0) this._events = objectCreate(null);
            else {
              delete events[type];
              if (events.removeListener) this.emit("removeListener", type, list2.listener || listener);
            }
          } else if (typeof list2 !== "function") {
            position = -1;
            for (i = list2.length - 1; i >= 0; i--) {
              if (list2[i] === listener || list2[i].listener === listener) {
                originalListener = list2[i].listener;
                position = i;
                break;
              }
            }
            if (position < 0) return this;
            if (position === 0) list2.shift();
            else spliceOne(list2, position);
            if (list2.length === 1) events[type] = list2[0];
            if (events.removeListener) this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (!events) return this;
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0) this._events = objectCreate(null);
              else delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = objectKeys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener") continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = objectCreate(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
          return this;
        };
        function _listeners(target2, type, unwrap) {
          var events = target2._events;
          if (!events) return [];
          var evlistener = events[type];
          if (!evlistener) return [];
          if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;
          if (events) {
            var evlistener = events[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function spliceOne(list2, index) {
          for (var i = index, k = i + 1, n = list2.length; k < n; i += 1, k += 1) {
            list2[i] = list2[k];
          }
          list2.pop();
        }
        function arrayClone(arr, n) {
          var copy2 = new Array(n);
          for (var i = 0; i < n; ++i) {
            copy2[i] = arr[i];
          }
          return copy2;
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        function objectCreatePolyfill(proto) {
          var F = function F2() {
          };
          F.prototype = proto;
          return new F();
        }
        function objectKeysPolyfill(obj) {
          for (var k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) ;
          }
          return k;
        }
        function functionBindPolyfill(context) {
          var fn = this;
          return function() {
            return fn.apply(context, arguments);
          };
        }
      }, {}], 26: [function(require2, module3, exports3) {
        var __extends = this && this.__extends || /* @__PURE__ */ (function() {
          var _extendStatics2 = function extendStatics(d, b) {
            _extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2) {
                if (b2.hasOwnProperty(p)) d2[p] = b2[p];
              }
            };
            return _extendStatics2(d, b);
          };
          return function(d, b) {
            _extendStatics2(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        })();
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var MultiplexHandler_1 = __importDefault(require2("./MultiplexHandler"));
        var CollectingHandler = (
          /** @class */
          (function(_super) {
            __extends(CollectingHandler2, _super);
            function CollectingHandler2(cbs) {
              if (cbs === void 0) {
                cbs = {};
              }
              var _this = _super.call(this, function(name) {
                var _a;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  args[_i - 1] = arguments[_i];
                }
                _this.events.push([name].concat(args));
                if (_this._cbs[name]) (_a = _this._cbs)[name].apply(_a, args);
              }) || this;
              _this._cbs = cbs;
              _this.events = [];
              return _this;
            }
            CollectingHandler2.prototype.onreset = function() {
              this.events = [];
              if (this._cbs.onreset) this._cbs.onreset();
            };
            CollectingHandler2.prototype.restart = function() {
              var _a;
              if (this._cbs.onreset) this._cbs.onreset();
              for (var i = 0; i < this.events.length; i++) {
                var _b = this.events[i], name_1 = _b[0], args = _b.slice(1);
                if (!this._cbs[name_1]) {
                  continue;
                }
                (_a = this._cbs)[name_1].apply(_a, args);
              }
            };
            return CollectingHandler2;
          })(MultiplexHandler_1["default"])
        );
        exports3.CollectingHandler = CollectingHandler;
      }, { "./MultiplexHandler": 28 }], 27: [function(require2, module3, exports3) {
        var __extends = this && this.__extends || /* @__PURE__ */ (function() {
          var _extendStatics3 = function extendStatics(d, b) {
            _extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2) {
                if (b2.hasOwnProperty(p)) d2[p] = b2[p];
              }
            };
            return _extendStatics3(d, b);
          };
          return function(d, b) {
            _extendStatics3(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        })();
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        var __importStar = this && this.__importStar || function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) {
            if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var domhandler_1 = __importDefault(require2("domhandler"));
        var DomUtils = __importStar(require2("domutils"));
        var Parser_1 = require2("./Parser");
        var FeedHandler = (
          /** @class */
          (function(_super) {
            __extends(FeedHandler2, _super);
            function FeedHandler2(callback, options2) {
              var _this = this;
              if (_typeof(callback) === "object" && callback !== null) {
                callback = void 0;
                options2 = callback;
              }
              _this = _super.call(this, callback, options2) || this;
              return _this;
            }
            FeedHandler2.prototype.onend = function() {
              var feed = {};
              var feedRoot = getOneElement(isValidFeed, this.dom);
              if (feedRoot) {
                if (feedRoot.name === "feed") {
                  var childs = feedRoot.children;
                  feed.type = "atom";
                  addConditionally(feed, "id", "id", childs);
                  addConditionally(feed, "title", "title", childs);
                  var href = getAttribute("href", getOneElement("link", childs));
                  if (href) {
                    feed.link = href;
                  }
                  addConditionally(feed, "description", "subtitle", childs);
                  var updated = fetch("updated", childs);
                  if (updated) {
                    feed.updated = new Date(updated);
                  }
                  addConditionally(feed, "author", "email", childs, true);
                  feed.items = getElements("entry", childs).map(function(item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "id", children);
                    addConditionally(entry, "title", "title", children);
                    var href2 = getAttribute("href", getOneElement("link", children));
                    if (href2) {
                      entry.link = href2;
                    }
                    var description = fetch("summary", children) || fetch("content", children);
                    if (description) {
                      entry.description = description;
                    }
                    var pubDate = fetch("updated", children);
                    if (pubDate) {
                      entry.pubDate = new Date(pubDate);
                    }
                    return entry;
                  });
                } else {
                  var childs = getOneElement("channel", feedRoot.children).children;
                  feed.type = feedRoot.name.substr(0, 3);
                  feed.id = "";
                  addConditionally(feed, "title", "title", childs);
                  addConditionally(feed, "link", "link", childs);
                  addConditionally(feed, "description", "description", childs);
                  var updated = fetch("lastBuildDate", childs);
                  if (updated) {
                    feed.updated = new Date(updated);
                  }
                  addConditionally(feed, "author", "managingEditor", childs, true);
                  feed.items = getElements("item", feedRoot.children).map(function(item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "guid", children);
                    addConditionally(entry, "title", "title", children);
                    addConditionally(entry, "link", "link", children);
                    addConditionally(entry, "description", "description", children);
                    var pubDate = fetch("pubDate", children);
                    if (pubDate) entry.pubDate = new Date(pubDate);
                    return entry;
                  });
                }
              }
              this.feed = feed;
              this.handleCallback(feedRoot ? null : Error("couldn't find root of feed"));
            };
            return FeedHandler2;
          })(domhandler_1["default"])
        );
        exports3.FeedHandler = FeedHandler;
        function getElements(what, where) {
          return DomUtils.getElementsByTagName(what, where, true);
        }
        function getOneElement(what, where) {
          return DomUtils.getElementsByTagName(what, where, true, 1)[0];
        }
        function fetch(what, where, recurse) {
          if (recurse === void 0) {
            recurse = false;
          }
          return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
        }
        function getAttribute(name, elem) {
          if (!elem) {
            return null;
          }
          var attribs = elem.attribs;
          return attribs[name];
        }
        function addConditionally(obj, prop2, what, where, recurse) {
          if (recurse === void 0) {
            recurse = false;
          }
          var tmp = fetch(what, where, recurse);
          if (tmp) obj[prop2] = tmp;
        }
        function isValidFeed(value) {
          return value === "rss" || value === "feed" || value === "rdf:RDF";
        }
        var defaultOptions = { xmlMode: true };
        function parseFeed(feed, options2) {
          if (options2 === void 0) {
            options2 = defaultOptions;
          }
          var handler = new FeedHandler(options2);
          new Parser_1.Parser(handler, options2).end(feed);
          return handler.feed;
        }
        exports3.parseFeed = parseFeed;
      }, { "./Parser": 29, "domhandler": 7, "domutils": 10 }], 28: [function(require2, module3, exports3) {
        Object.defineProperty(exports3, "__esModule", { value: true });
        var MultiplexHandler = (
          /** @class */
          (function() {
            function MultiplexHandler2(func) {
              this._func = func;
            }
            MultiplexHandler2.prototype.onattribute = function(name, value) {
              this._func("onattribute", name, value);
            };
            MultiplexHandler2.prototype.oncdatastart = function() {
              this._func("oncdatastart");
            };
            MultiplexHandler2.prototype.oncdataend = function() {
              this._func("oncdataend");
            };
            MultiplexHandler2.prototype.ontext = function(text2) {
              this._func("ontext", text2);
            };
            MultiplexHandler2.prototype.onprocessinginstruction = function(name, value) {
              this._func("onprocessinginstruction", name, value);
            };
            MultiplexHandler2.prototype.oncomment = function(comment) {
              this._func("oncomment", comment);
            };
            MultiplexHandler2.prototype.oncommentend = function() {
              this._func("oncommentend");
            };
            MultiplexHandler2.prototype.onclosetag = function(name) {
              this._func("onclosetag", name);
            };
            MultiplexHandler2.prototype.onopentag = function(name, attribs) {
              this._func("onopentag", name, attribs);
            };
            MultiplexHandler2.prototype.onopentagname = function(name) {
              this._func("onopentagname", name);
            };
            MultiplexHandler2.prototype.onerror = function(error2) {
              this._func("onerror", error2);
            };
            MultiplexHandler2.prototype.onend = function() {
              this._func("onend");
            };
            MultiplexHandler2.prototype.onparserinit = function(parser) {
              this._func("onparserinit", parser);
            };
            MultiplexHandler2.prototype.onreset = function() {
              this._func("onreset");
            };
            return MultiplexHandler2;
          })()
        );
        exports3["default"] = MultiplexHandler;
      }, {}], 29: [function(require2, module3, exports3) {
        var __extends = this && this.__extends || /* @__PURE__ */ (function() {
          var _extendStatics4 = function extendStatics(d, b) {
            _extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2) {
                if (b2.hasOwnProperty(p)) d2[p] = b2[p];
              }
            };
            return _extendStatics4(d, b);
          };
          return function(d, b) {
            _extendStatics4(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        })();
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var Tokenizer_1 = __importDefault(require2("./Tokenizer"));
        var events_1 = require2("events");
        var formTags = /* @__PURE__ */ new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]);
        var pTag = /* @__PURE__ */ new Set(["p"]);
        var openImpliesClose = { tr: /* @__PURE__ */ new Set(["tr", "th", "td"]), th: /* @__PURE__ */ new Set(["th"]), td: /* @__PURE__ */ new Set(["thead", "th", "td"]), body: /* @__PURE__ */ new Set(["head", "link", "script"]), li: /* @__PURE__ */ new Set(["li"]), p: pTag, h1: pTag, h2: pTag, h3: pTag, h4: pTag, h5: pTag, h6: pTag, select: formTags, input: formTags, output: formTags, button: formTags, datalist: formTags, textarea: formTags, option: /* @__PURE__ */ new Set(["option"]), optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]), dd: /* @__PURE__ */ new Set(["dt", "dd"]), dt: /* @__PURE__ */ new Set(["dt", "dd"]), address: pTag, article: pTag, aside: pTag, blockquote: pTag, details: pTag, div: pTag, dl: pTag, fieldset: pTag, figcaption: pTag, figure: pTag, footer: pTag, form: pTag, header: pTag, hr: pTag, main: pTag, nav: pTag, ol: pTag, pre: pTag, section: pTag, table: pTag, ul: pTag, rt: /* @__PURE__ */ new Set(["rt", "rp"]), rp: /* @__PURE__ */ new Set(["rt", "rp"]), tbody: /* @__PURE__ */ new Set(["thead", "tbody"]), tfoot: /* @__PURE__ */ new Set(["thead", "tbody"]) };
        var voidElements2 = /* @__PURE__ */ new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
        var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
        var htmlIntegrationElements = /* @__PURE__ */ new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
        var reNameEnd = /\s|\//;
        var Parser = (
          /** @class */
          (function(_super) {
            __extends(Parser2, _super);
            function Parser2(cbs, options2) {
              var _this = _super.call(this) || this;
              _this._tagname = "";
              _this._attribname = "";
              _this._attribvalue = "";
              _this._attribs = null;
              _this._stack = [];
              _this._foreignContext = [];
              _this.startIndex = 0;
              _this.endIndex = null;
              _this.parseChunk = Parser2.prototype.write;
              _this.done = Parser2.prototype.end;
              _this._options = options2 || {};
              _this._cbs = cbs || {};
              _this._tagname = "";
              _this._attribname = "";
              _this._attribvalue = "";
              _this._attribs = null;
              _this._stack = [];
              _this._foreignContext = [];
              _this.startIndex = 0;
              _this.endIndex = null;
              _this._lowerCaseTagNames = "lowerCaseTags" in _this._options ? !!_this._options.lowerCaseTags : !_this._options.xmlMode;
              _this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in _this._options ? !!_this._options.lowerCaseAttributeNames : !_this._options.xmlMode;
              _this._tokenizer = new (_this._options.Tokenizer || Tokenizer_1["default"])(_this._options, _this);
              if (_this._cbs.onparserinit) _this._cbs.onparserinit(_this);
              return _this;
            }
            Parser2.prototype._updatePosition = function(initialOffset) {
              if (this.endIndex === null) {
                if (this._tokenizer._sectionStart <= initialOffset) {
                  this.startIndex = 0;
                } else {
                  this.startIndex = this._tokenizer._sectionStart - initialOffset;
                }
              } else this.startIndex = this.endIndex + 1;
              this.endIndex = this._tokenizer.getAbsoluteIndex();
            };
            Parser2.prototype.ontext = function(data) {
              this._updatePosition(1);
              this.endIndex--;
              if (this._cbs.ontext) this._cbs.ontext(data);
            };
            Parser2.prototype.onopentagname = function(name) {
              if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
              }
              this._tagname = name;
              if (!this._options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
                for (
                  var el2 = void 0;
                  // @ts-ignore
                  openImpliesClose[name].has(el2 = this._stack[this._stack.length - 1]);
                  this.onclosetag(el2)
                ) {
                }
              }
              if (this._options.xmlMode || !voidElements2.has(name)) {
                this._stack.push(name);
                if (foreignContextElements.has(name)) {
                  this._foreignContext.push(true);
                } else if (htmlIntegrationElements.has(name)) {
                  this._foreignContext.push(false);
                }
              }
              if (this._cbs.onopentagname) this._cbs.onopentagname(name);
              if (this._cbs.onopentag) this._attribs = {};
            };
            Parser2.prototype.onopentagend = function() {
              this._updatePosition(1);
              if (this._attribs) {
                if (this._cbs.onopentag) {
                  this._cbs.onopentag(this._tagname, this._attribs);
                }
                this._attribs = null;
              }
              if (!this._options.xmlMode && this._cbs.onclosetag && voidElements2.has(this._tagname)) {
                this._cbs.onclosetag(this._tagname);
              }
              this._tagname = "";
            };
            Parser2.prototype.onclosetag = function(name) {
              this._updatePosition(1);
              if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
              }
              if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
                this._foreignContext.pop();
              }
              if (this._stack.length && (this._options.xmlMode || !voidElements2.has(name))) {
                var pos = this._stack.lastIndexOf(name);
                if (pos !== -1) {
                  if (this._cbs.onclosetag) {
                    pos = this._stack.length - pos;
                    while (pos--) {
                      this._cbs.onclosetag(this._stack.pop());
                    }
                  } else this._stack.length = pos;
                } else if (name === "p" && !this._options.xmlMode) {
                  this.onopentagname(name);
                  this._closeCurrentTag();
                }
              } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
                this.onopentagname(name);
                this._closeCurrentTag();
              }
            };
            Parser2.prototype.onselfclosingtag = function() {
              if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
                this._closeCurrentTag();
              } else {
                this.onopentagend();
              }
            };
            Parser2.prototype._closeCurrentTag = function() {
              var name = this._tagname;
              this.onopentagend();
              if (this._stack[this._stack.length - 1] === name) {
                if (this._cbs.onclosetag) {
                  this._cbs.onclosetag(name);
                }
                this._stack.pop();
              }
            };
            Parser2.prototype.onattribname = function(name) {
              if (this._lowerCaseAttributeNames) {
                name = name.toLowerCase();
              }
              this._attribname = name;
            };
            Parser2.prototype.onattribdata = function(value) {
              this._attribvalue += value;
            };
            Parser2.prototype.onattribend = function() {
              if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
              if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
                this._attribs[this._attribname] = this._attribvalue;
              }
              this._attribname = "";
              this._attribvalue = "";
            };
            Parser2.prototype._getInstructionName = function(value) {
              var idx = value.search(reNameEnd);
              var name = idx < 0 ? value : value.substr(0, idx);
              if (this._lowerCaseTagNames) {
                name = name.toLowerCase();
              }
              return name;
            };
            Parser2.prototype.ondeclaration = function(value) {
              if (this._cbs.onprocessinginstruction) {
                var name_1 = this._getInstructionName(value);
                this._cbs.onprocessinginstruction("!" + name_1, "!" + value);
              }
            };
            Parser2.prototype.onprocessinginstruction = function(value) {
              if (this._cbs.onprocessinginstruction) {
                var name_2 = this._getInstructionName(value);
                this._cbs.onprocessinginstruction("?" + name_2, "?" + value);
              }
            };
            Parser2.prototype.oncomment = function(value) {
              this._updatePosition(4);
              if (this._cbs.oncomment) this._cbs.oncomment(value);
              if (this._cbs.oncommentend) this._cbs.oncommentend();
            };
            Parser2.prototype.oncdata = function(value) {
              this._updatePosition(1);
              if (this._options.xmlMode || this._options.recognizeCDATA) {
                if (this._cbs.oncdatastart) this._cbs.oncdatastart();
                if (this._cbs.ontext) this._cbs.ontext(value);
                if (this._cbs.oncdataend) this._cbs.oncdataend();
              } else {
                this.oncomment("[CDATA[" + value + "]]");
              }
            };
            Parser2.prototype.onerror = function(err) {
              if (this._cbs.onerror) this._cbs.onerror(err);
            };
            Parser2.prototype.onend = function() {
              if (this._cbs.onclosetag) {
                for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i])) {
                }
              }
              if (this._cbs.onend) this._cbs.onend();
            };
            Parser2.prototype.reset = function() {
              if (this._cbs.onreset) this._cbs.onreset();
              this._tokenizer.reset();
              this._tagname = "";
              this._attribname = "";
              this._attribs = null;
              this._stack = [];
              if (this._cbs.onparserinit) this._cbs.onparserinit(this);
            };
            Parser2.prototype.parseComplete = function(data) {
              this.reset();
              this.end(data);
            };
            Parser2.prototype.write = function(chunk) {
              this._tokenizer.write(chunk);
            };
            Parser2.prototype.end = function(chunk) {
              this._tokenizer.end(chunk);
            };
            Parser2.prototype.pause = function() {
              this._tokenizer.pause();
            };
            Parser2.prototype.resume = function() {
              this._tokenizer.resume();
            };
            return Parser2;
          })(events_1.EventEmitter)
        );
        exports3.Parser = Parser;
      }, { "./Tokenizer": 30, "events": 25 }], 30: [function(require2, module3, exports3) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var decode_codepoint_1 = __importDefault(require2("entities/lib/decode_codepoint"));
        var entities_json_1 = __importDefault(require2("entities/lib/maps/entities.json"));
        var legacy_json_1 = __importDefault(require2("entities/lib/maps/legacy.json"));
        var xml_json_1 = __importDefault(require2("entities/lib/maps/xml.json"));
        function whitespace(c) {
          return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
        }
        function ifElseState(upper, SUCCESS, FAILURE) {
          var lower = upper.toLowerCase();
          if (upper === lower) {
            return function(t, c) {
              if (c === lower) {
                t._state = SUCCESS;
              } else {
                t._state = FAILURE;
                t._index--;
              }
            };
          } else {
            return function(t, c) {
              if (c === lower || c === upper) {
                t._state = SUCCESS;
              } else {
                t._state = FAILURE;
                t._index--;
              }
            };
          }
        }
        function consumeSpecialNameChar(upper, NEXT_STATE) {
          var lower = upper.toLowerCase();
          return function(t, c) {
            if (c === lower || c === upper) {
              t._state = NEXT_STATE;
            } else {
              t._state = 3;
              t._index--;
            }
          };
        }
        var stateBeforeCdata1 = ifElseState(
          "C",
          23,
          16
          /* InDeclaration */
        );
        var stateBeforeCdata2 = ifElseState(
          "D",
          24,
          16
          /* InDeclaration */
        );
        var stateBeforeCdata3 = ifElseState(
          "A",
          25,
          16
          /* InDeclaration */
        );
        var stateBeforeCdata4 = ifElseState(
          "T",
          26,
          16
          /* InDeclaration */
        );
        var stateBeforeCdata5 = ifElseState(
          "A",
          27,
          16
          /* InDeclaration */
        );
        var stateBeforeScript1 = consumeSpecialNameChar(
          "R",
          34
          /* BeforeScript2 */
        );
        var stateBeforeScript2 = consumeSpecialNameChar(
          "I",
          35
          /* BeforeScript3 */
        );
        var stateBeforeScript3 = consumeSpecialNameChar(
          "P",
          36
          /* BeforeScript4 */
        );
        var stateBeforeScript4 = consumeSpecialNameChar(
          "T",
          37
          /* BeforeScript5 */
        );
        var stateAfterScript1 = ifElseState(
          "R",
          39,
          1
          /* Text */
        );
        var stateAfterScript2 = ifElseState(
          "I",
          40,
          1
          /* Text */
        );
        var stateAfterScript3 = ifElseState(
          "P",
          41,
          1
          /* Text */
        );
        var stateAfterScript4 = ifElseState(
          "T",
          42,
          1
          /* Text */
        );
        var stateBeforeStyle1 = consumeSpecialNameChar(
          "Y",
          44
          /* BeforeStyle2 */
        );
        var stateBeforeStyle2 = consumeSpecialNameChar(
          "L",
          45
          /* BeforeStyle3 */
        );
        var stateBeforeStyle3 = consumeSpecialNameChar(
          "E",
          46
          /* BeforeStyle4 */
        );
        var stateAfterStyle1 = ifElseState(
          "Y",
          48,
          1
          /* Text */
        );
        var stateAfterStyle2 = ifElseState(
          "L",
          49,
          1
          /* Text */
        );
        var stateAfterStyle3 = ifElseState(
          "E",
          50,
          1
          /* Text */
        );
        var stateBeforeEntity = ifElseState(
          "#",
          52,
          53
          /* InNamedEntity */
        );
        var stateBeforeNumericEntity = ifElseState(
          "X",
          55,
          54
          /* InNumericEntity */
        );
        var Tokenizer = (
          /** @class */
          (function() {
            function Tokenizer2(options2, cbs) {
              this._state = 1;
              this._buffer = "";
              this._sectionStart = 0;
              this._index = 0;
              this._bufferOffset = 0;
              this._baseState = 1;
              this._special = 1;
              this._running = true;
              this._ended = false;
              this._cbs = cbs;
              this._xmlMode = !!(options2 && options2.xmlMode);
              this._decodeEntities = !!(options2 && options2.decodeEntities);
            }
            Tokenizer2.prototype.reset = function() {
              this._state = 1;
              this._buffer = "";
              this._sectionStart = 0;
              this._index = 0;
              this._bufferOffset = 0;
              this._baseState = 1;
              this._special = 1;
              this._running = true;
              this._ended = false;
            };
            Tokenizer2.prototype._stateText = function(c) {
              if (c === "<") {
                if (this._index > this._sectionStart) {
                  this._cbs.ontext(this._getSection());
                }
                this._state = 2;
                this._sectionStart = this._index;
              } else if (this._decodeEntities && this._special === 1 && c === "&") {
                if (this._index > this._sectionStart) {
                  this._cbs.ontext(this._getSection());
                }
                this._baseState = 1;
                this._state = 51;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateBeforeTagName = function(c) {
              if (c === "/") {
                this._state = 5;
              } else if (c === "<") {
                this._cbs.ontext(this._getSection());
                this._sectionStart = this._index;
              } else if (c === ">" || this._special !== 1 || whitespace(c)) {
                this._state = 1;
              } else if (c === "!") {
                this._state = 15;
                this._sectionStart = this._index + 1;
              } else if (c === "?") {
                this._state = 17;
                this._sectionStart = this._index + 1;
              } else {
                this._state = !this._xmlMode && (c === "s" || c === "S") ? 31 : 3;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateInTagName = function(c) {
              if (c === "/" || c === ">" || whitespace(c)) {
                this._emitToken("onopentagname");
                this._state = 8;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateBeforeClosingTagName = function(c) {
              if (whitespace(c)) ;
              else if (c === ">") {
                this._state = 1;
              } else if (this._special !== 1) {
                if (c === "s" || c === "S") {
                  this._state = 32;
                } else {
                  this._state = 1;
                  this._index--;
                }
              } else {
                this._state = 6;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateInClosingTagName = function(c) {
              if (c === ">" || whitespace(c)) {
                this._emitToken("onclosetag");
                this._state = 7;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateAfterClosingTagName = function(c) {
              if (c === ">") {
                this._state = 1;
                this._sectionStart = this._index + 1;
              }
            };
            Tokenizer2.prototype._stateBeforeAttributeName = function(c) {
              if (c === ">") {
                this._cbs.onopentagend();
                this._state = 1;
                this._sectionStart = this._index + 1;
              } else if (c === "/") {
                this._state = 4;
              } else if (!whitespace(c)) {
                this._state = 9;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateInSelfClosingTag = function(c) {
              if (c === ">") {
                this._cbs.onselfclosingtag();
                this._state = 1;
                this._sectionStart = this._index + 1;
              } else if (!whitespace(c)) {
                this._state = 8;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateInAttributeName = function(c) {
              if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
                this._cbs.onattribname(this._getSection());
                this._sectionStart = -1;
                this._state = 10;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateAfterAttributeName = function(c) {
              if (c === "=") {
                this._state = 11;
              } else if (c === "/" || c === ">") {
                this._cbs.onattribend();
                this._state = 8;
                this._index--;
              } else if (!whitespace(c)) {
                this._cbs.onattribend();
                this._state = 9;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateBeforeAttributeValue = function(c) {
              if (c === '"') {
                this._state = 12;
                this._sectionStart = this._index + 1;
              } else if (c === "'") {
                this._state = 13;
                this._sectionStart = this._index + 1;
              } else if (!whitespace(c)) {
                this._state = 14;
                this._sectionStart = this._index;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateInAttributeValueDoubleQuotes = function(c) {
              if (c === '"') {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = 8;
              } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = 51;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateInAttributeValueSingleQuotes = function(c) {
              if (c === "'") {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = 8;
              } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = 51;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateInAttributeValueNoQuotes = function(c) {
              if (whitespace(c) || c === ">") {
                this._emitToken("onattribdata");
                this._cbs.onattribend();
                this._state = 8;
                this._index--;
              } else if (this._decodeEntities && c === "&") {
                this._emitToken("onattribdata");
                this._baseState = this._state;
                this._state = 51;
                this._sectionStart = this._index;
              }
            };
            Tokenizer2.prototype._stateBeforeDeclaration = function(c) {
              this._state = c === "[" ? 22 : c === "-" ? 18 : 16;
            };
            Tokenizer2.prototype._stateInDeclaration = function(c) {
              if (c === ">") {
                this._cbs.ondeclaration(this._getSection());
                this._state = 1;
                this._sectionStart = this._index + 1;
              }
            };
            Tokenizer2.prototype._stateInProcessingInstruction = function(c) {
              if (c === ">") {
                this._cbs.onprocessinginstruction(this._getSection());
                this._state = 1;
                this._sectionStart = this._index + 1;
              }
            };
            Tokenizer2.prototype._stateBeforeComment = function(c) {
              if (c === "-") {
                this._state = 19;
                this._sectionStart = this._index + 1;
              } else {
                this._state = 16;
              }
            };
            Tokenizer2.prototype._stateInComment = function(c) {
              if (c === "-") this._state = 20;
            };
            Tokenizer2.prototype._stateAfterComment1 = function(c) {
              if (c === "-") {
                this._state = 21;
              } else {
                this._state = 19;
              }
            };
            Tokenizer2.prototype._stateAfterComment2 = function(c) {
              if (c === ">") {
                this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
                this._state = 1;
                this._sectionStart = this._index + 1;
              } else if (c !== "-") {
                this._state = 19;
              }
            };
            Tokenizer2.prototype._stateBeforeCdata6 = function(c) {
              if (c === "[") {
                this._state = 28;
                this._sectionStart = this._index + 1;
              } else {
                this._state = 16;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateInCdata = function(c) {
              if (c === "]") this._state = 29;
            };
            Tokenizer2.prototype._stateAfterCdata1 = function(c) {
              if (c === "]") this._state = 30;
              else this._state = 28;
            };
            Tokenizer2.prototype._stateAfterCdata2 = function(c) {
              if (c === ">") {
                this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
                this._state = 1;
                this._sectionStart = this._index + 1;
              } else if (c !== "]") {
                this._state = 28;
              }
            };
            Tokenizer2.prototype._stateBeforeSpecial = function(c) {
              if (c === "c" || c === "C") {
                this._state = 33;
              } else if (c === "t" || c === "T") {
                this._state = 43;
              } else {
                this._state = 3;
                this._index--;
              }
            };
            Tokenizer2.prototype._stateBeforeSpecialEnd = function(c) {
              if (this._special === 2 && (c === "c" || c === "C")) {
                this._state = 38;
              } else if (this._special === 3 && (c === "t" || c === "T")) {
                this._state = 47;
              } else this._state = 1;
            };
            Tokenizer2.prototype._stateBeforeScript5 = function(c) {
              if (c === "/" || c === ">" || whitespace(c)) {
                this._special = 2;
              }
              this._state = 3;
              this._index--;
            };
            Tokenizer2.prototype._stateAfterScript5 = function(c) {
              if (c === ">" || whitespace(c)) {
                this._special = 1;
                this._state = 6;
                this._sectionStart = this._index - 6;
                this._index--;
              } else this._state = 1;
            };
            Tokenizer2.prototype._stateBeforeStyle4 = function(c) {
              if (c === "/" || c === ">" || whitespace(c)) {
                this._special = 3;
              }
              this._state = 3;
              this._index--;
            };
            Tokenizer2.prototype._stateAfterStyle4 = function(c) {
              if (c === ">" || whitespace(c)) {
                this._special = 1;
                this._state = 6;
                this._sectionStart = this._index - 5;
                this._index--;
              } else this._state = 1;
            };
            Tokenizer2.prototype._parseNamedEntityStrict = function() {
              if (this._sectionStart + 1 < this._index) {
                var entity2 = this._buffer.substring(this._sectionStart + 1, this._index), map2 = this._xmlMode ? xml_json_1["default"] : entities_json_1["default"];
                if (Object.prototype.hasOwnProperty.call(map2, entity2)) {
                  this._emitPartial(map2[entity2]);
                  this._sectionStart = this._index + 1;
                }
              }
            };
            Tokenizer2.prototype._parseLegacyEntity = function() {
              var start = this._sectionStart + 1;
              var limit = this._index - start;
              if (limit > 6) limit = 6;
              while (limit >= 2) {
                var entity2 = this._buffer.substr(start, limit);
                if (Object.prototype.hasOwnProperty.call(legacy_json_1["default"], entity2)) {
                  this._emitPartial(legacy_json_1["default"][entity2]);
                  this._sectionStart += limit + 1;
                  return;
                } else {
                  limit--;
                }
              }
            };
            Tokenizer2.prototype._stateInNamedEntity = function(c) {
              if (c === ";") {
                this._parseNamedEntityStrict();
                if (this._sectionStart + 1 < this._index && !this._xmlMode) {
                  this._parseLegacyEntity();
                }
                this._state = this._baseState;
              } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
                if (this._xmlMode || this._sectionStart + 1 === this._index) ;
                else if (this._baseState !== 1) {
                  if (c !== "=") {
                    this._parseNamedEntityStrict();
                  }
                } else {
                  this._parseLegacyEntity();
                }
                this._state = this._baseState;
                this._index--;
              }
            };
            Tokenizer2.prototype._decodeNumericEntity = function(offset, base2) {
              var sectionStart = this._sectionStart + offset;
              if (sectionStart !== this._index) {
                var entity2 = this._buffer.substring(sectionStart, this._index);
                var parsed = parseInt(entity2, base2);
                this._emitPartial(decode_codepoint_1["default"](parsed));
                this._sectionStart = this._index;
              } else {
                this._sectionStart--;
              }
              this._state = this._baseState;
            };
            Tokenizer2.prototype._stateInNumericEntity = function(c) {
              if (c === ";") {
                this._decodeNumericEntity(2, 10);
                this._sectionStart++;
              } else if (c < "0" || c > "9") {
                if (!this._xmlMode) {
                  this._decodeNumericEntity(2, 10);
                } else {
                  this._state = this._baseState;
                }
                this._index--;
              }
            };
            Tokenizer2.prototype._stateInHexEntity = function(c) {
              if (c === ";") {
                this._decodeNumericEntity(3, 16);
                this._sectionStart++;
              } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
                if (!this._xmlMode) {
                  this._decodeNumericEntity(3, 16);
                } else {
                  this._state = this._baseState;
                }
                this._index--;
              }
            };
            Tokenizer2.prototype._cleanup = function() {
              if (this._sectionStart < 0) {
                this._buffer = "";
                this._bufferOffset += this._index;
                this._index = 0;
              } else if (this._running) {
                if (this._state === 1) {
                  if (this._sectionStart !== this._index) {
                    this._cbs.ontext(this._buffer.substr(this._sectionStart));
                  }
                  this._buffer = "";
                  this._bufferOffset += this._index;
                  this._index = 0;
                } else if (this._sectionStart === this._index) {
                  this._buffer = "";
                  this._bufferOffset += this._index;
                  this._index = 0;
                } else {
                  this._buffer = this._buffer.substr(this._sectionStart);
                  this._index -= this._sectionStart;
                  this._bufferOffset += this._sectionStart;
                }
                this._sectionStart = 0;
              }
            };
            Tokenizer2.prototype.write = function(chunk) {
              if (this._ended) this._cbs.onerror(Error(".write() after done!"));
              this._buffer += chunk;
              this._parse();
            };
            Tokenizer2.prototype._parse = function() {
              while (this._index < this._buffer.length && this._running) {
                var c = this._buffer.charAt(this._index);
                if (this._state === 1) {
                  this._stateText(c);
                } else if (this._state === 12) {
                  this._stateInAttributeValueDoubleQuotes(c);
                } else if (this._state === 9) {
                  this._stateInAttributeName(c);
                } else if (this._state === 19) {
                  this._stateInComment(c);
                } else if (this._state === 8) {
                  this._stateBeforeAttributeName(c);
                } else if (this._state === 3) {
                  this._stateInTagName(c);
                } else if (this._state === 6) {
                  this._stateInClosingTagName(c);
                } else if (this._state === 2) {
                  this._stateBeforeTagName(c);
                } else if (this._state === 10) {
                  this._stateAfterAttributeName(c);
                } else if (this._state === 13) {
                  this._stateInAttributeValueSingleQuotes(c);
                } else if (this._state === 11) {
                  this._stateBeforeAttributeValue(c);
                } else if (this._state === 5) {
                  this._stateBeforeClosingTagName(c);
                } else if (this._state === 7) {
                  this._stateAfterClosingTagName(c);
                } else if (this._state === 31) {
                  this._stateBeforeSpecial(c);
                } else if (this._state === 20) {
                  this._stateAfterComment1(c);
                } else if (this._state === 14) {
                  this._stateInAttributeValueNoQuotes(c);
                } else if (this._state === 4) {
                  this._stateInSelfClosingTag(c);
                } else if (this._state === 16) {
                  this._stateInDeclaration(c);
                } else if (this._state === 15) {
                  this._stateBeforeDeclaration(c);
                } else if (this._state === 21) {
                  this._stateAfterComment2(c);
                } else if (this._state === 18) {
                  this._stateBeforeComment(c);
                } else if (this._state === 32) {
                  this._stateBeforeSpecialEnd(c);
                } else if (this._state === 38) {
                  stateAfterScript1(this, c);
                } else if (this._state === 39) {
                  stateAfterScript2(this, c);
                } else if (this._state === 40) {
                  stateAfterScript3(this, c);
                } else if (this._state === 33) {
                  stateBeforeScript1(this, c);
                } else if (this._state === 34) {
                  stateBeforeScript2(this, c);
                } else if (this._state === 35) {
                  stateBeforeScript3(this, c);
                } else if (this._state === 36) {
                  stateBeforeScript4(this, c);
                } else if (this._state === 37) {
                  this._stateBeforeScript5(c);
                } else if (this._state === 41) {
                  stateAfterScript4(this, c);
                } else if (this._state === 42) {
                  this._stateAfterScript5(c);
                } else if (this._state === 43) {
                  stateBeforeStyle1(this, c);
                } else if (this._state === 28) {
                  this._stateInCdata(c);
                } else if (this._state === 44) {
                  stateBeforeStyle2(this, c);
                } else if (this._state === 45) {
                  stateBeforeStyle3(this, c);
                } else if (this._state === 46) {
                  this._stateBeforeStyle4(c);
                } else if (this._state === 47) {
                  stateAfterStyle1(this, c);
                } else if (this._state === 48) {
                  stateAfterStyle2(this, c);
                } else if (this._state === 49) {
                  stateAfterStyle3(this, c);
                } else if (this._state === 50) {
                  this._stateAfterStyle4(c);
                } else if (this._state === 17) {
                  this._stateInProcessingInstruction(c);
                } else if (this._state === 53) {
                  this._stateInNamedEntity(c);
                } else if (this._state === 22) {
                  stateBeforeCdata1(this, c);
                } else if (this._state === 51) {
                  stateBeforeEntity(this, c);
                } else if (this._state === 23) {
                  stateBeforeCdata2(this, c);
                } else if (this._state === 24) {
                  stateBeforeCdata3(this, c);
                } else if (this._state === 29) {
                  this._stateAfterCdata1(c);
                } else if (this._state === 30) {
                  this._stateAfterCdata2(c);
                } else if (this._state === 25) {
                  stateBeforeCdata4(this, c);
                } else if (this._state === 26) {
                  stateBeforeCdata5(this, c);
                } else if (this._state === 27) {
                  this._stateBeforeCdata6(c);
                } else if (this._state === 55) {
                  this._stateInHexEntity(c);
                } else if (this._state === 54) {
                  this._stateInNumericEntity(c);
                } else if (this._state === 52) {
                  stateBeforeNumericEntity(this, c);
                } else {
                  this._cbs.onerror(Error("unknown _state"), this._state);
                }
                this._index++;
              }
              this._cleanup();
            };
            Tokenizer2.prototype.pause = function() {
              this._running = false;
            };
            Tokenizer2.prototype.resume = function() {
              this._running = true;
              if (this._index < this._buffer.length) {
                this._parse();
              }
              if (this._ended) {
                this._finish();
              }
            };
            Tokenizer2.prototype.end = function(chunk) {
              if (this._ended) this._cbs.onerror(Error(".end() after done!"));
              if (chunk) this.write(chunk);
              this._ended = true;
              if (this._running) this._finish();
            };
            Tokenizer2.prototype._finish = function() {
              if (this._sectionStart < this._index) {
                this._handleTrailingData();
              }
              this._cbs.onend();
            };
            Tokenizer2.prototype._handleTrailingData = function() {
              var data = this._buffer.substr(this._sectionStart);
              if (this._state === 28 || this._state === 29 || this._state === 30) {
                this._cbs.oncdata(data);
              } else if (this._state === 19 || this._state === 20 || this._state === 21) {
                this._cbs.oncomment(data);
              } else if (this._state === 53 && !this._xmlMode) {
                this._parseLegacyEntity();
                if (this._sectionStart < this._index) {
                  this._state = this._baseState;
                  this._handleTrailingData();
                }
              } else if (this._state === 54 && !this._xmlMode) {
                this._decodeNumericEntity(2, 10);
                if (this._sectionStart < this._index) {
                  this._state = this._baseState;
                  this._handleTrailingData();
                }
              } else if (this._state === 55 && !this._xmlMode) {
                this._decodeNumericEntity(3, 16);
                if (this._sectionStart < this._index) {
                  this._state = this._baseState;
                  this._handleTrailingData();
                }
              } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
                this._cbs.ontext(data);
              }
            };
            Tokenizer2.prototype.getAbsoluteIndex = function() {
              return this._bufferOffset + this._index;
            };
            Tokenizer2.prototype._getSection = function() {
              return this._buffer.substring(this._sectionStart, this._index);
            };
            Tokenizer2.prototype._emitToken = function(name) {
              this._cbs[name](this._getSection());
              this._sectionStart = -1;
            };
            Tokenizer2.prototype._emitPartial = function(value) {
              if (this._baseState !== 1) {
                this._cbs.onattribdata(value);
              } else {
                this._cbs.ontext(value);
              }
            };
            return Tokenizer2;
          })()
        );
        exports3["default"] = Tokenizer;
      }, { "entities/lib/decode_codepoint": 18, "entities/lib/maps/entities.json": 22, "entities/lib/maps/legacy.json": 23, "entities/lib/maps/xml.json": 24 }], 31: [function(require2, module3, exports3) {
        function __export(m) {
          for (var p in m) {
            if (!exports3.hasOwnProperty(p)) exports3[p] = m[p];
          }
        }
        var __importStar = this && this.__importStar || function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) {
            if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var Parser_1 = require2("./Parser");
        exports3.Parser = Parser_1.Parser;
        var domhandler_1 = require2("domhandler");
        exports3.DomHandler = domhandler_1.DomHandler;
        exports3.DefaultHandler = domhandler_1.DomHandler;
        function parseDOM(data, options2) {
          var handler = new domhandler_1.DomHandler(void 0, options2);
          new Parser_1.Parser(handler, options2).end(data);
          return handler.dom;
        }
        exports3.parseDOM = parseDOM;
        function createDomStream(cb, options2, elementCb) {
          var handler = new domhandler_1.DomHandler(cb, options2, elementCb);
          return new Parser_1.Parser(handler, options2);
        }
        exports3.createDomStream = createDomStream;
        var Tokenizer_1 = require2("./Tokenizer");
        exports3.Tokenizer = Tokenizer_1["default"];
        var ElementType = __importStar(require2("domelementtype"));
        exports3.ElementType = ElementType;
        exports3.EVENTS = { attribute: 2, cdatastart: 0, cdataend: 0, text: 1, processinginstruction: 2, comment: 1, commentend: 0, closetag: 1, opentag: 2, opentagname: 1, error: 1, end: 0 };
        __export(require2("./FeedHandler"));
        __export(require2("./WritableStream"));
        __export(require2("./CollectingHandler"));
        var DomUtils = __importStar(require2("domutils"));
        exports3.DomUtils = DomUtils;
        var FeedHandler_1 = require2("./FeedHandler");
        exports3.RssHandler = FeedHandler_1.FeedHandler;
      }, { "./CollectingHandler": 26, "./FeedHandler": 27, "./Parser": 29, "./Tokenizer": 30, "./WritableStream": 2, "domelementtype": 6, "domhandler": 7, "domutils": 10 }], 32: [function(require2, module3, exports3) {
        exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 33: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative"), root2 = require2("./_root");
        var DataView = getNative(root2, "DataView");
        module3.exports = DataView;
      }, { "./_getNative": 93, "./_root": 130 }], 34: [function(require2, module3, exports3) {
        var hashClear = require2("./_hashClear"), hashDelete = require2("./_hashDelete"), hashGet = require2("./_hashGet"), hashHas = require2("./_hashHas"), hashSet = require2("./_hashSet");
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        module3.exports = Hash;
      }, { "./_hashClear": 100, "./_hashDelete": 101, "./_hashGet": 102, "./_hashHas": 103, "./_hashSet": 104 }], 35: [function(require2, module3, exports3) {
        var listCacheClear = require2("./_listCacheClear"), listCacheDelete = require2("./_listCacheDelete"), listCacheGet = require2("./_listCacheGet"), listCacheHas = require2("./_listCacheHas"), listCacheSet = require2("./_listCacheSet");
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        module3.exports = ListCache;
      }, { "./_listCacheClear": 113, "./_listCacheDelete": 114, "./_listCacheGet": 115, "./_listCacheHas": 116, "./_listCacheSet": 117 }], 36: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative"), root2 = require2("./_root");
        var Map2 = getNative(root2, "Map");
        module3.exports = Map2;
      }, { "./_getNative": 93, "./_root": 130 }], 37: [function(require2, module3, exports3) {
        var mapCacheClear = require2("./_mapCacheClear"), mapCacheDelete = require2("./_mapCacheDelete"), mapCacheGet = require2("./_mapCacheGet"), mapCacheHas = require2("./_mapCacheHas"), mapCacheSet = require2("./_mapCacheSet");
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        module3.exports = MapCache;
      }, { "./_mapCacheClear": 118, "./_mapCacheDelete": 119, "./_mapCacheGet": 120, "./_mapCacheHas": 121, "./_mapCacheSet": 122 }], 38: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative"), root2 = require2("./_root");
        var Promise2 = getNative(root2, "Promise");
        module3.exports = Promise2;
      }, { "./_getNative": 93, "./_root": 130 }], 39: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative"), root2 = require2("./_root");
        var Set2 = getNative(root2, "Set");
        module3.exports = Set2;
      }, { "./_getNative": 93, "./_root": 130 }], 40: [function(require2, module3, exports3) {
        var ListCache = require2("./_ListCache"), stackClear = require2("./_stackClear"), stackDelete = require2("./_stackDelete"), stackGet = require2("./_stackGet"), stackHas = require2("./_stackHas"), stackSet = require2("./_stackSet");
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        module3.exports = Stack;
      }, { "./_ListCache": 35, "./_stackClear": 134, "./_stackDelete": 135, "./_stackGet": 136, "./_stackHas": 137, "./_stackSet": 138 }], 41: [function(require2, module3, exports3) {
        var root2 = require2("./_root");
        var _Symbol = root2.Symbol;
        module3.exports = _Symbol;
      }, { "./_root": 130 }], 42: [function(require2, module3, exports3) {
        var root2 = require2("./_root");
        var Uint8Array2 = root2.Uint8Array;
        module3.exports = Uint8Array2;
      }, { "./_root": 130 }], 43: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative"), root2 = require2("./_root");
        var WeakMap = getNative(root2, "WeakMap");
        module3.exports = WeakMap;
      }, { "./_getNative": 93, "./_root": 130 }], 44: [function(require2, module3, exports3) {
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        module3.exports = apply;
      }, {}], 45: [function(require2, module3, exports3) {
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        module3.exports = arrayEach;
      }, {}], 46: [function(require2, module3, exports3) {
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        module3.exports = arrayFilter;
      }, {}], 47: [function(require2, module3, exports3) {
        var baseTimes = require2("./_baseTimes"), isArguments = require2("./isArguments"), isArray = require2("./isArray"), isBuffer = require2("./isBuffer"), isIndex = require2("./_isIndex"), isTypedArray = require2("./isTypedArray");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        module3.exports = arrayLikeKeys;
      }, { "./_baseTimes": 72, "./_isIndex": 108, "./isArguments": 145, "./isArray": 146, "./isBuffer": 149, "./isTypedArray": 159 }], 48: [function(require2, module3, exports3) {
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        module3.exports = arrayMap;
      }, {}], 49: [function(require2, module3, exports3) {
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        module3.exports = arrayPush;
      }, {}], 50: [function(require2, module3, exports3) {
        var baseAssignValue = require2("./_baseAssignValue"), eq = require2("./eq");
        function assignMergeValue(object, key, value) {
          if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        module3.exports = assignMergeValue;
      }, { "./_baseAssignValue": 55, "./eq": 142 }], 51: [function(require2, module3, exports3) {
        var baseAssignValue = require2("./_baseAssignValue"), eq = require2("./eq");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        module3.exports = assignValue;
      }, { "./_baseAssignValue": 55, "./eq": 142 }], 52: [function(require2, module3, exports3) {
        var eq = require2("./eq");
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        module3.exports = assocIndexOf;
      }, { "./eq": 142 }], 53: [function(require2, module3, exports3) {
        var copyObject = require2("./_copyObject"), keys = require2("./keys");
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        module3.exports = baseAssign;
      }, { "./_copyObject": 82, "./keys": 160 }], 54: [function(require2, module3, exports3) {
        var copyObject = require2("./_copyObject"), keysIn = require2("./keysIn");
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        module3.exports = baseAssignIn;
      }, { "./_copyObject": 82, "./keysIn": 161 }], 55: [function(require2, module3, exports3) {
        var defineProperty = require2("./_defineProperty");
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, { "configurable": true, "enumerable": true, "value": value, "writable": true });
          } else {
            object[key] = value;
          }
        }
        module3.exports = baseAssignValue;
      }, { "./_defineProperty": 88 }], 56: [function(require2, module3, exports3) {
        var Stack = require2("./_Stack"), arrayEach = require2("./_arrayEach"), assignValue = require2("./_assignValue"), baseAssign = require2("./_baseAssign"), baseAssignIn = require2("./_baseAssignIn"), cloneBuffer = require2("./_cloneBuffer"), copyArray = require2("./_copyArray"), copySymbols = require2("./_copySymbols"), copySymbolsIn = require2("./_copySymbolsIn"), getAllKeys = require2("./_getAllKeys"), getAllKeysIn = require2("./_getAllKeysIn"), getTag = require2("./_getTag"), initCloneArray = require2("./_initCloneArray"), initCloneByTag = require2("./_initCloneByTag"), initCloneObject = require2("./_initCloneObject"), isArray = require2("./isArray"), isBuffer = require2("./isBuffer"), isMap = require2("./isMap"), isObject = require2("./isObject"), isSet = require2("./isSet"), keys = require2("./keys"), keysIn = require2("./keysIn");
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== void 0) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? void 0 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result;
        }
        module3.exports = baseClone;
      }, { "./_Stack": 40, "./_arrayEach": 45, "./_assignValue": 51, "./_baseAssign": 53, "./_baseAssignIn": 54, "./_cloneBuffer": 76, "./_copyArray": 81, "./_copySymbols": 83, "./_copySymbolsIn": 84, "./_getAllKeys": 90, "./_getAllKeysIn": 91, "./_getTag": 98, "./_initCloneArray": 105, "./_initCloneByTag": 106, "./_initCloneObject": 107, "./isArray": 146, "./isBuffer": 149, "./isMap": 152, "./isObject": 153, "./isSet": 156, "./keys": 160, "./keysIn": 161 }], 57: [function(require2, module3, exports3) {
        var isObject = require2("./isObject");
        var objectCreate = Object.create;
        var baseCreate = /* @__PURE__ */ (function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object();
            object.prototype = void 0;
            return result;
          };
        })();
        module3.exports = baseCreate;
      }, { "./isObject": 153 }], 58: [function(require2, module3, exports3) {
        var createBaseFor = require2("./_createBaseFor");
        var baseFor = createBaseFor();
        module3.exports = baseFor;
      }, { "./_createBaseFor": 87 }], 59: [function(require2, module3, exports3) {
        var arrayPush = require2("./_arrayPush"), isArray = require2("./isArray");
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        module3.exports = baseGetAllKeys;
      }, { "./_arrayPush": 49, "./isArray": 146 }], 60: [function(require2, module3, exports3) {
        var _Symbol2 = require2("./_Symbol"), getRawTag = require2("./_getRawTag"), objectToString = require2("./_objectToString");
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var symToStringTag = _Symbol2 ? _Symbol2.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        module3.exports = baseGetTag;
      }, { "./_Symbol": 41, "./_getRawTag": 95, "./_objectToString": 127 }], 61: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isObjectLike = require2("./isObjectLike");
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        module3.exports = baseIsArguments;
      }, { "./_baseGetTag": 60, "./isObjectLike": 154 }], 62: [function(require2, module3, exports3) {
        var getTag = require2("./_getTag"), isObjectLike = require2("./isObjectLike");
        var mapTag = "[object Map]";
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        module3.exports = baseIsMap;
      }, { "./_getTag": 98, "./isObjectLike": 154 }], 63: [function(require2, module3, exports3) {
        var isFunction = require2("./isFunction"), isMasked = require2("./_isMasked"), isObject = require2("./isObject"), toSource = require2("./_toSource");
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var funcProto = Function.prototype, objectProto = Object.prototype;
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern2.test(toSource(value));
        }
        module3.exports = baseIsNative;
      }, { "./_isMasked": 111, "./_toSource": 139, "./isFunction": 150, "./isObject": 153 }], 64: [function(require2, module3, exports3) {
        var getTag = require2("./_getTag"), isObjectLike = require2("./isObjectLike");
        var setTag = "[object Set]";
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        module3.exports = baseIsSet;
      }, { "./_getTag": 98, "./isObjectLike": 154 }], 65: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isLength = require2("./isLength"), isObjectLike = require2("./isObjectLike");
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        module3.exports = baseIsTypedArray;
      }, { "./_baseGetTag": 60, "./isLength": 151, "./isObjectLike": 154 }], 66: [function(require2, module3, exports3) {
        var isPrototype = require2("./_isPrototype"), nativeKeys = require2("./_nativeKeys");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        module3.exports = baseKeys;
      }, { "./_isPrototype": 112, "./_nativeKeys": 124 }], 67: [function(require2, module3, exports3) {
        var isObject = require2("./isObject"), isPrototype = require2("./_isPrototype"), nativeKeysIn = require2("./_nativeKeysIn");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        module3.exports = baseKeysIn;
      }, { "./_isPrototype": 112, "./_nativeKeysIn": 125, "./isObject": 153 }], 68: [function(require2, module3, exports3) {
        var Stack = require2("./_Stack"), assignMergeValue = require2("./_assignMergeValue"), baseFor = require2("./_baseFor"), baseMergeDeep = require2("./_baseMergeDeep"), isObject = require2("./isObject"), keysIn = require2("./keysIn"), safeGet = require2("./_safeGet");
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
              if (newValue === void 0) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        module3.exports = baseMerge;
      }, { "./_Stack": 40, "./_assignMergeValue": 50, "./_baseFor": 58, "./_baseMergeDeep": 69, "./_safeGet": 131, "./isObject": 153, "./keysIn": 161 }], 69: [function(require2, module3, exports3) {
        var assignMergeValue = require2("./_assignMergeValue"), cloneBuffer = require2("./_cloneBuffer"), cloneTypedArray = require2("./_cloneTypedArray"), copyArray = require2("./_copyArray"), initCloneObject = require2("./_initCloneObject"), isArguments = require2("./isArguments"), isArray = require2("./isArray"), isArrayLikeObject = require2("./isArrayLikeObject"), isBuffer = require2("./isBuffer"), isFunction = require2("./isFunction"), isObject = require2("./isObject"), isPlainObject = require2("./isPlainObject"), isTypedArray = require2("./isTypedArray"), safeGet = require2("./_safeGet"), toPlainObject = require2("./toPlainObject");
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
          var isCommon = newValue === void 0;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        module3.exports = baseMergeDeep;
      }, { "./_assignMergeValue": 50, "./_cloneBuffer": 76, "./_cloneTypedArray": 80, "./_copyArray": 81, "./_initCloneObject": 107, "./_safeGet": 131, "./isArguments": 145, "./isArray": 146, "./isArrayLikeObject": 148, "./isBuffer": 149, "./isFunction": 150, "./isObject": 153, "./isPlainObject": 155, "./isTypedArray": 159, "./toPlainObject": 165 }], 70: [function(require2, module3, exports3) {
        var identity = require2("./identity"), overRest = require2("./_overRest"), setToString = require2("./_setToString");
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        module3.exports = baseRest;
      }, { "./_overRest": 129, "./_setToString": 132, "./identity": 144 }], 71: [function(require2, module3, exports3) {
        var constant = require2("./constant"), defineProperty = require2("./_defineProperty"), identity = require2("./identity");
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", { "configurable": true, "enumerable": false, "value": constant(string), "writable": true });
        };
        module3.exports = baseSetToString;
      }, { "./_defineProperty": 88, "./constant": 141, "./identity": 144 }], 72: [function(require2, module3, exports3) {
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        module3.exports = baseTimes;
      }, {}], 73: [function(require2, module3, exports3) {
        var _Symbol3 = require2("./_Symbol"), arrayMap = require2("./_arrayMap"), isArray = require2("./isArray"), isSymbol = require2("./isSymbol");
        var symbolProto = _Symbol3 ? _Symbol3.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -Infinity ? "-0" : result;
        }
        module3.exports = baseToString;
      }, { "./_Symbol": 41, "./_arrayMap": 48, "./isArray": 146, "./isSymbol": 158 }], 74: [function(require2, module3, exports3) {
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        module3.exports = baseUnary;
      }, {}], 75: [function(require2, module3, exports3) {
        var Uint8Array2 = require2("./_Uint8Array");
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
          return result;
        }
        module3.exports = cloneArrayBuffer;
      }, { "./_Uint8Array": 42 }], 76: [function(require2, module3, exports3) {
        var root2 = require2("./_root");
        var freeExports = _typeof(exports3) == "object" && exports3 && !exports3.nodeType && exports3;
        var freeModule = freeExports && _typeof(module3) == "object" && module3 && !module3.nodeType && module3;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result);
          return result;
        }
        module3.exports = cloneBuffer;
      }, { "./_root": 130 }], 77: [function(require2, module3, exports3) {
        var cloneArrayBuffer = require2("./_cloneArrayBuffer");
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        module3.exports = cloneDataView;
      }, { "./_cloneArrayBuffer": 75 }], 78: [function(require2, module3, exports3) {
        var reFlags = /\w*$/;
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        module3.exports = cloneRegExp;
      }, {}], 79: [function(require2, module3, exports3) {
        var _Symbol4 = require2("./_Symbol");
        var symbolProto = _Symbol4 ? _Symbol4.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        module3.exports = cloneSymbol;
      }, { "./_Symbol": 41 }], 80: [function(require2, module3, exports3) {
        var cloneArrayBuffer = require2("./_cloneArrayBuffer");
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        module3.exports = cloneTypedArray;
      }, { "./_cloneArrayBuffer": 75 }], 81: [function(require2, module3, exports3) {
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        module3.exports = copyArray;
      }, {}], 82: [function(require2, module3, exports3) {
        var assignValue = require2("./_assignValue"), baseAssignValue = require2("./_baseAssignValue");
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
            if (newValue === void 0) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        module3.exports = copyObject;
      }, { "./_assignValue": 51, "./_baseAssignValue": 55 }], 83: [function(require2, module3, exports3) {
        var copyObject = require2("./_copyObject"), getSymbols = require2("./_getSymbols");
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        module3.exports = copySymbols;
      }, { "./_copyObject": 82, "./_getSymbols": 96 }], 84: [function(require2, module3, exports3) {
        var copyObject = require2("./_copyObject"), getSymbolsIn = require2("./_getSymbolsIn");
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        module3.exports = copySymbolsIn;
      }, { "./_copyObject": 82, "./_getSymbolsIn": 97 }], 85: [function(require2, module3, exports3) {
        var root2 = require2("./_root");
        var coreJsData = root2["__core-js_shared__"];
        module3.exports = coreJsData;
      }, { "./_root": 130 }], 86: [function(require2, module3, exports3) {
        var baseRest = require2("./_baseRest"), isIterateeCall = require2("./_isIterateeCall");
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? void 0 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        module3.exports = createAssigner;
      }, { "./_baseRest": 70, "./_isIterateeCall": 109 }], 87: [function(require2, module3, exports3) {
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        module3.exports = createBaseFor;
      }, {}], 88: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative");
        var defineProperty = (function() {
          try {
            var func = getNative(Object, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        })();
        module3.exports = defineProperty;
      }, { "./_getNative": 93 }], 89: [function(require2, module3, exports3) {
        (function(global2) {
          var freeGlobal = _typeof(global2) == "object" && global2 && global2.Object === Object && global2;
          module3.exports = freeGlobal;
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 90: [function(require2, module3, exports3) {
        var baseGetAllKeys = require2("./_baseGetAllKeys"), getSymbols = require2("./_getSymbols"), keys = require2("./keys");
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        module3.exports = getAllKeys;
      }, { "./_baseGetAllKeys": 59, "./_getSymbols": 96, "./keys": 160 }], 91: [function(require2, module3, exports3) {
        var baseGetAllKeys = require2("./_baseGetAllKeys"), getSymbolsIn = require2("./_getSymbolsIn"), keysIn = require2("./keysIn");
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        module3.exports = getAllKeysIn;
      }, { "./_baseGetAllKeys": 59, "./_getSymbolsIn": 97, "./keysIn": 161 }], 92: [function(require2, module3, exports3) {
        var isKeyable = require2("./_isKeyable");
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        module3.exports = getMapData;
      }, { "./_isKeyable": 110 }], 93: [function(require2, module3, exports3) {
        var baseIsNative = require2("./_baseIsNative"), getValue = require2("./_getValue");
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        module3.exports = getNative;
      }, { "./_baseIsNative": 63, "./_getValue": 99 }], 94: [function(require2, module3, exports3) {
        var overArg = require2("./_overArg");
        var getPrototype = overArg(Object.getPrototypeOf, Object);
        module3.exports = getPrototype;
      }, { "./_overArg": 128 }], 95: [function(require2, module3, exports3) {
        var _Symbol5 = require2("./_Symbol");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = _Symbol5 ? _Symbol5.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        module3.exports = getRawTag;
      }, { "./_Symbol": 41 }], 96: [function(require2, module3, exports3) {
        var arrayFilter = require2("./_arrayFilter"), stubArray = require2("./stubArray");
        var objectProto = Object.prototype;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        module3.exports = getSymbols;
      }, { "./_arrayFilter": 46, "./stubArray": 163 }], 97: [function(require2, module3, exports3) {
        var arrayPush = require2("./_arrayPush"), getPrototype = require2("./_getPrototype"), getSymbols = require2("./_getSymbols"), stubArray = require2("./stubArray");
        var nativeGetSymbols = Object.getOwnPropertySymbols;
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };
        module3.exports = getSymbolsIn;
      }, { "./_arrayPush": 49, "./_getPrototype": 94, "./_getSymbols": 96, "./stubArray": 163 }], 98: [function(require2, module3, exports3) {
        var DataView = require2("./_DataView"), Map2 = require2("./_Map"), Promise2 = require2("./_Promise"), Set2 = require2("./_Set"), WeakMap = require2("./_WeakMap"), baseGetTag = require2("./_baseGetTag"), toSource = require2("./_toSource");
        var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
        var dataViewTag = "[object DataView]";
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function getTag2(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        module3.exports = getTag;
      }, { "./_DataView": 33, "./_Map": 36, "./_Promise": 38, "./_Set": 39, "./_WeakMap": 43, "./_baseGetTag": 60, "./_toSource": 139 }], 99: [function(require2, module3, exports3) {
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        module3.exports = getValue;
      }, {}], 100: [function(require2, module3, exports3) {
        var nativeCreate = require2("./_nativeCreate");
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        module3.exports = hashClear;
      }, { "./_nativeCreate": 123 }], 101: [function(require2, module3, exports3) {
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }
        module3.exports = hashDelete;
      }, {}], 102: [function(require2, module3, exports3) {
        var nativeCreate = require2("./_nativeCreate");
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }
        module3.exports = hashGet;
      }, { "./_nativeCreate": 123 }], 103: [function(require2, module3, exports3) {
        var nativeCreate = require2("./_nativeCreate");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
        }
        module3.exports = hashHas;
      }, { "./_nativeCreate": 123 }], 104: [function(require2, module3, exports3) {
        var nativeCreate = require2("./_nativeCreate");
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        module3.exports = hashSet;
      }, { "./_nativeCreate": 123 }], 105: [function(require2, module3, exports3) {
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        function initCloneArray(array) {
          var length = array.length, result = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        module3.exports = initCloneArray;
      }, {}], 106: [function(require2, module3, exports3) {
        var cloneArrayBuffer = require2("./_cloneArrayBuffer"), cloneDataView = require2("./_cloneDataView"), cloneRegExp = require2("./_cloneRegExp"), cloneSymbol = require2("./_cloneSymbol"), cloneTypedArray = require2("./_cloneTypedArray");
        var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        module3.exports = initCloneByTag;
      }, { "./_cloneArrayBuffer": 75, "./_cloneDataView": 77, "./_cloneRegExp": 78, "./_cloneSymbol": 79, "./_cloneTypedArray": 80 }], 107: [function(require2, module3, exports3) {
        var baseCreate = require2("./_baseCreate"), getPrototype = require2("./_getPrototype"), isPrototype = require2("./_isPrototype");
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        module3.exports = initCloneObject;
      }, { "./_baseCreate": 57, "./_getPrototype": 94, "./_isPrototype": 112 }], 108: [function(require2, module3, exports3) {
        var MAX_SAFE_INTEGER = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
          var type = _typeof(value);
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        module3.exports = isIndex;
      }, {}], 109: [function(require2, module3, exports3) {
        var eq = require2("./eq"), isArrayLike = require2("./isArrayLike"), isIndex = require2("./_isIndex"), isObject = require2("./isObject");
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = _typeof(index);
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        module3.exports = isIterateeCall;
      }, { "./_isIndex": 108, "./eq": 142, "./isArrayLike": 147, "./isObject": 153 }], 110: [function(require2, module3, exports3) {
        function isKeyable(value) {
          var type = _typeof(value);
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        module3.exports = isKeyable;
      }, {}], 111: [function(require2, module3, exports3) {
        var coreJsData = require2("./_coreJsData");
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        module3.exports = isMasked;
      }, { "./_coreJsData": 85 }], 112: [function(require2, module3, exports3) {
        var objectProto = Object.prototype;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        module3.exports = isPrototype;
      }, {}], 113: [function(require2, module3, exports3) {
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        module3.exports = listCacheClear;
      }, {}], 114: [function(require2, module3, exports3) {
        var assocIndexOf = require2("./_assocIndexOf");
        var arrayProto = Array.prototype;
        var splice = arrayProto.splice;
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        module3.exports = listCacheDelete;
      }, { "./_assocIndexOf": 52 }], 115: [function(require2, module3, exports3) {
        var assocIndexOf = require2("./_assocIndexOf");
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? void 0 : data[index][1];
        }
        module3.exports = listCacheGet;
      }, { "./_assocIndexOf": 52 }], 116: [function(require2, module3, exports3) {
        var assocIndexOf = require2("./_assocIndexOf");
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        module3.exports = listCacheHas;
      }, { "./_assocIndexOf": 52 }], 117: [function(require2, module3, exports3) {
        var assocIndexOf = require2("./_assocIndexOf");
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        module3.exports = listCacheSet;
      }, { "./_assocIndexOf": 52 }], 118: [function(require2, module3, exports3) {
        var Hash = require2("./_Hash"), ListCache = require2("./_ListCache"), Map2 = require2("./_Map");
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
        }
        module3.exports = mapCacheClear;
      }, { "./_Hash": 34, "./_ListCache": 35, "./_Map": 36 }], 119: [function(require2, module3, exports3) {
        var getMapData = require2("./_getMapData");
        function mapCacheDelete(key) {
          var result = getMapData(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }
        module3.exports = mapCacheDelete;
      }, { "./_getMapData": 92 }], 120: [function(require2, module3, exports3) {
        var getMapData = require2("./_getMapData");
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        module3.exports = mapCacheGet;
      }, { "./_getMapData": 92 }], 121: [function(require2, module3, exports3) {
        var getMapData = require2("./_getMapData");
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        module3.exports = mapCacheHas;
      }, { "./_getMapData": 92 }], 122: [function(require2, module3, exports3) {
        var getMapData = require2("./_getMapData");
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }
        module3.exports = mapCacheSet;
      }, { "./_getMapData": 92 }], 123: [function(require2, module3, exports3) {
        var getNative = require2("./_getNative");
        var nativeCreate = getNative(Object, "create");
        module3.exports = nativeCreate;
      }, { "./_getNative": 93 }], 124: [function(require2, module3, exports3) {
        var overArg = require2("./_overArg");
        var nativeKeys = overArg(Object.keys, Object);
        module3.exports = nativeKeys;
      }, { "./_overArg": 128 }], 125: [function(require2, module3, exports3) {
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }
        module3.exports = nativeKeysIn;
      }, {}], 126: [function(require2, module3, exports3) {
        var freeGlobal = require2("./_freeGlobal");
        var freeExports = _typeof(exports3) == "object" && exports3 && !exports3.nodeType && exports3;
        var freeModule = freeExports && _typeof(module3) == "object" && module3 && !module3.nodeType && module3;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = (function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        })();
        module3.exports = nodeUtil;
      }, { "./_freeGlobal": 89 }], 127: [function(require2, module3, exports3) {
        var objectProto = Object.prototype;
        var nativeObjectToString = objectProto.toString;
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        module3.exports = objectToString;
      }, {}], 128: [function(require2, module3, exports3) {
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        module3.exports = overArg;
      }, {}], 129: [function(require2, module3, exports3) {
        var apply = require2("./_apply");
        var nativeMax = Math.max;
        function overRest(func, start, transform) {
          start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }
        module3.exports = overRest;
      }, { "./_apply": 44 }], 130: [function(require2, module3, exports3) {
        var freeGlobal = require2("./_freeGlobal");
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal || freeSelf || Function("return this")();
        module3.exports = root2;
      }, { "./_freeGlobal": 89 }], 131: [function(require2, module3, exports3) {
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        module3.exports = safeGet;
      }, {}], 132: [function(require2, module3, exports3) {
        var baseSetToString = require2("./_baseSetToString"), shortOut = require2("./_shortOut");
        var setToString = shortOut(baseSetToString);
        module3.exports = setToString;
      }, { "./_baseSetToString": 71, "./_shortOut": 133 }], 133: [function(require2, module3, exports3) {
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var nativeNow = Date.now;
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(void 0, arguments);
          };
        }
        module3.exports = shortOut;
      }, {}], 134: [function(require2, module3, exports3) {
        var ListCache = require2("./_ListCache");
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        module3.exports = stackClear;
      }, { "./_ListCache": 35 }], 135: [function(require2, module3, exports3) {
        function stackDelete(key) {
          var data = this.__data__, result = data["delete"](key);
          this.size = data.size;
          return result;
        }
        module3.exports = stackDelete;
      }, {}], 136: [function(require2, module3, exports3) {
        function stackGet(key) {
          return this.__data__.get(key);
        }
        module3.exports = stackGet;
      }, {}], 137: [function(require2, module3, exports3) {
        function stackHas(key) {
          return this.__data__.has(key);
        }
        module3.exports = stackHas;
      }, {}], 138: [function(require2, module3, exports3) {
        var ListCache = require2("./_ListCache"), Map2 = require2("./_Map"), MapCache = require2("./_MapCache");
        var LARGE_ARRAY_SIZE = 200;
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        module3.exports = stackSet;
      }, { "./_ListCache": 35, "./_Map": 36, "./_MapCache": 37 }], 139: [function(require2, module3, exports3) {
        var funcProto = Function.prototype;
        var funcToString = funcProto.toString;
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        module3.exports = toSource;
      }, {}], 140: [function(require2, module3, exports3) {
        var baseClone = require2("./_baseClone");
        var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        module3.exports = cloneDeep;
      }, { "./_baseClone": 56 }], 141: [function(require2, module3, exports3) {
        function constant(value) {
          return function() {
            return value;
          };
        }
        module3.exports = constant;
      }, {}], 142: [function(require2, module3, exports3) {
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        module3.exports = eq;
      }, {}], 143: [function(require2, module3, exports3) {
        var toString = require2("./toString");
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        module3.exports = escapeRegExp;
      }, { "./toString": 166 }], 144: [function(require2, module3, exports3) {
        function identity(value) {
          return value;
        }
        module3.exports = identity;
      }, {}], 145: [function(require2, module3, exports3) {
        var baseIsArguments = require2("./_baseIsArguments"), isObjectLike = require2("./isObjectLike");
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        module3.exports = isArguments;
      }, { "./_baseIsArguments": 61, "./isObjectLike": 154 }], 146: [function(require2, module3, exports3) {
        var isArray = Array.isArray;
        module3.exports = isArray;
      }, {}], 147: [function(require2, module3, exports3) {
        var isFunction = require2("./isFunction"), isLength = require2("./isLength");
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        module3.exports = isArrayLike;
      }, { "./isFunction": 150, "./isLength": 151 }], 148: [function(require2, module3, exports3) {
        var isArrayLike = require2("./isArrayLike"), isObjectLike = require2("./isObjectLike");
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        module3.exports = isArrayLikeObject;
      }, { "./isArrayLike": 147, "./isObjectLike": 154 }], 149: [function(require2, module3, exports3) {
        var root2 = require2("./_root"), stubFalse = require2("./stubFalse");
        var freeExports = _typeof(exports3) == "object" && exports3 && !exports3.nodeType && exports3;
        var freeModule = freeExports && _typeof(module3) == "object" && module3 && !module3.nodeType && module3;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer = moduleExports ? root2.Buffer : void 0;
        var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || stubFalse;
        module3.exports = isBuffer;
      }, { "./_root": 130, "./stubFalse": 164 }], 150: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isObject = require2("./isObject");
        var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        module3.exports = isFunction;
      }, { "./_baseGetTag": 60, "./isObject": 153 }], 151: [function(require2, module3, exports3) {
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        module3.exports = isLength;
      }, {}], 152: [function(require2, module3, exports3) {
        var baseIsMap = require2("./_baseIsMap"), baseUnary = require2("./_baseUnary"), nodeUtil = require2("./_nodeUtil");
        var nodeIsMap = nodeUtil && nodeUtil.isMap;
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        module3.exports = isMap;
      }, { "./_baseIsMap": 62, "./_baseUnary": 74, "./_nodeUtil": 126 }], 153: [function(require2, module3, exports3) {
        function isObject(value) {
          var type = _typeof(value);
          return value != null && (type == "object" || type == "function");
        }
        module3.exports = isObject;
      }, {}], 154: [function(require2, module3, exports3) {
        function isObjectLike(value) {
          return value != null && _typeof(value) == "object";
        }
        module3.exports = isObjectLike;
      }, {}], 155: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), getPrototype = require2("./_getPrototype"), isObjectLike = require2("./isObjectLike");
        var objectTag = "[object Object]";
        var funcProto = Function.prototype, objectProto = Object.prototype;
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var objectCtorString = funcToString.call(Object);
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        module3.exports = isPlainObject;
      }, { "./_baseGetTag": 60, "./_getPrototype": 94, "./isObjectLike": 154 }], 156: [function(require2, module3, exports3) {
        var baseIsSet = require2("./_baseIsSet"), baseUnary = require2("./_baseUnary"), nodeUtil = require2("./_nodeUtil");
        var nodeIsSet = nodeUtil && nodeUtil.isSet;
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        module3.exports = isSet;
      }, { "./_baseIsSet": 64, "./_baseUnary": 74, "./_nodeUtil": 126 }], 157: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isArray = require2("./isArray"), isObjectLike = require2("./isObjectLike");
        var stringTag = "[object String]";
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        module3.exports = isString;
      }, { "./_baseGetTag": 60, "./isArray": 146, "./isObjectLike": 154 }], 158: [function(require2, module3, exports3) {
        var baseGetTag = require2("./_baseGetTag"), isObjectLike = require2("./isObjectLike");
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
          return _typeof(value) == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        module3.exports = isSymbol;
      }, { "./_baseGetTag": 60, "./isObjectLike": 154 }], 159: [function(require2, module3, exports3) {
        var baseIsTypedArray = require2("./_baseIsTypedArray"), baseUnary = require2("./_baseUnary"), nodeUtil = require2("./_nodeUtil");
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        module3.exports = isTypedArray;
      }, { "./_baseIsTypedArray": 65, "./_baseUnary": 74, "./_nodeUtil": 126 }], 160: [function(require2, module3, exports3) {
        var arrayLikeKeys = require2("./_arrayLikeKeys"), baseKeys = require2("./_baseKeys"), isArrayLike = require2("./isArrayLike");
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        module3.exports = keys;
      }, { "./_arrayLikeKeys": 47, "./_baseKeys": 66, "./isArrayLike": 147 }], 161: [function(require2, module3, exports3) {
        var arrayLikeKeys = require2("./_arrayLikeKeys"), baseKeysIn = require2("./_baseKeysIn"), isArrayLike = require2("./isArrayLike");
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        module3.exports = keysIn;
      }, { "./_arrayLikeKeys": 47, "./_baseKeysIn": 67, "./isArrayLike": 147 }], 162: [function(require2, module3, exports3) {
        var baseMerge = require2("./_baseMerge"), createAssigner = require2("./_createAssigner");
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        module3.exports = mergeWith;
      }, { "./_baseMerge": 68, "./_createAssigner": 86 }], 163: [function(require2, module3, exports3) {
        function stubArray() {
          return [];
        }
        module3.exports = stubArray;
      }, {}], 164: [function(require2, module3, exports3) {
        function stubFalse() {
          return false;
        }
        module3.exports = stubFalse;
      }, {}], 165: [function(require2, module3, exports3) {
        var copyObject = require2("./_copyObject"), keysIn = require2("./keysIn");
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        module3.exports = toPlainObject;
      }, { "./_copyObject": 82, "./keysIn": 161 }], 166: [function(require2, module3, exports3) {
        var baseToString = require2("./_baseToString");
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        module3.exports = toString;
      }, { "./_baseToString": 73 }], 167: [function(require2, module3, exports3) {
        (function(root2, factory) {
          if (_typeof(module3) === "object" && module3.exports) {
            module3.exports = factory();
          } else {
            root2.parseSrcset = factory();
          }
        })(this, function() {
          return function(input) {
            function isSpace(c2) {
              return c2 === " " || // space
              c2 === "	" || // horizontal tab
              c2 === "\n" || // new line
              c2 === "\f" || // form feed
              c2 === "\r";
            }
            function collectCharacters(regEx) {
              var chars, match = regEx.exec(input.substring(pos));
              if (match) {
                chars = match[0];
                pos += chars.length;
                return chars;
              }
            }
            var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
            while (true) {
              collectCharacters(regexLeadingCommasOrSpaces);
              if (pos >= inputLength) {
                return candidates;
              }
              url = collectCharacters(regexLeadingNotSpaces);
              descriptors = [];
              if (url.slice(-1) === ",") {
                url = url.replace(regexTrailingCommas, "");
                parseDescriptors();
              } else {
                tokenize();
              }
            }
            function tokenize() {
              collectCharacters(regexLeadingSpaces);
              currentDescriptor = "";
              state = "in descriptor";
              while (true) {
                c = input.charAt(pos);
                if (state === "in descriptor") {
                  if (isSpace(c)) {
                    if (currentDescriptor) {
                      descriptors.push(currentDescriptor);
                      currentDescriptor = "";
                      state = "after descriptor";
                    }
                  } else if (c === ",") {
                    pos += 1;
                    if (currentDescriptor) {
                      descriptors.push(currentDescriptor);
                    }
                    parseDescriptors();
                    return;
                  } else if (c === "(") {
                    currentDescriptor = currentDescriptor + c;
                    state = "in parens";
                  } else if (c === "") {
                    if (currentDescriptor) {
                      descriptors.push(currentDescriptor);
                    }
                    parseDescriptors();
                    return;
                  } else {
                    currentDescriptor = currentDescriptor + c;
                  }
                } else if (state === "in parens") {
                  if (c === ")") {
                    currentDescriptor = currentDescriptor + c;
                    state = "in descriptor";
                  } else if (c === "") {
                    descriptors.push(currentDescriptor);
                    parseDescriptors();
                    return;
                  } else {
                    currentDescriptor = currentDescriptor + c;
                  }
                } else if (state === "after descriptor") {
                  if (isSpace(c)) ;
                  else if (c === "") {
                    parseDescriptors();
                    return;
                  } else {
                    state = "in descriptor";
                    pos -= 1;
                  }
                }
                pos += 1;
              }
            }
            function parseDescriptors() {
              var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
              for (i = 0; i < descriptors.length; i++) {
                desc = descriptors[i];
                lastChar = desc[desc.length - 1];
                value = desc.substring(0, desc.length - 1);
                intVal = parseInt(value, 10);
                floatVal = parseFloat(value);
                if (regexNonNegativeInteger.test(value) && lastChar === "w") {
                  if (w || d) {
                    pError = true;
                  }
                  if (intVal === 0) {
                    pError = true;
                  } else {
                    w = intVal;
                  }
                } else if (regexFloatingPoint.test(value) && lastChar === "x") {
                  if (w || d || h) {
                    pError = true;
                  }
                  if (floatVal < 0) {
                    pError = true;
                  } else {
                    d = floatVal;
                  }
                } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
                  if (h || d) {
                    pError = true;
                  }
                  if (intVal === 0) {
                    pError = true;
                  } else {
                    h = intVal;
                  }
                } else {
                  pError = true;
                }
              }
              if (!pError) {
                candidate.url = url;
                if (w) {
                  candidate.w = w;
                }
                if (d) {
                  candidate.d = d;
                }
                if (h) {
                  candidate.h = h;
                }
                candidates.push(candidate);
              } else if (console && console.log) {
                console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
              }
            }
          };
        });
      }, {}], 168: [function(require2, module3, exports3) {
        (function(process2) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports3.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process2.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports3.normalize = function(path) {
            var isAbsolute = exports3.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports3.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports3.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports3.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports3.relative = function(from, to) {
            from = exports3.resolve(from).substr(1);
            to = exports3.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports3.sep = "/";
          exports3.delimiter = ":";
          exports3.dirname = function(path) {
            if (typeof path !== "string") path = path + "";
            if (path.length === 0) return ".";
            var code2 = path.charCodeAt(0);
            var hasRoot = code2 === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code2 = path.charCodeAt(i);
              if (code2 === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1) return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string") path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1) return "";
            return path.slice(start, end);
          }
          exports3.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports3.extname = function(path) {
            if (typeof path !== "string") path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code2 = path.charCodeAt(i);
              if (code2 === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code2 === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter) return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs)) res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { "_process": 193 }], 169: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _container = _interopRequireDefault(require2("./container"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var AtRule = /* @__PURE__ */ (function(_Container) {
          _inheritsLoose(AtRule2, _Container);
          function AtRule2(defaults) {
            var _this;
            _this = _Container.call(this, defaults) || this;
            _this.type = "atrule";
            return _this;
          }
          var _proto = AtRule2.prototype;
          _proto.append = function append() {
            var _Container$prototype$;
            if (!this.nodes) this.nodes = [];
            for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
              children[_key] = arguments[_key];
            }
            return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
          };
          _proto.prepend = function prepend() {
            var _Container$prototype$2;
            if (!this.nodes) this.nodes = [];
            for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              children[_key2] = arguments[_key2];
            }
            return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
          };
          return AtRule2;
        })(_container["default"]);
        var _default2 = AtRule;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./container": 171 }], 170: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _node = _interopRequireDefault(require2("./node"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Comment = /* @__PURE__ */ (function(_Node) {
          _inheritsLoose(Comment2, _Node);
          function Comment2(defaults) {
            var _this;
            _this = _Node.call(this, defaults) || this;
            _this.type = "comment";
            return _this;
          }
          return Comment2;
        })(_node["default"]);
        var _default2 = Comment;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./node": 178 }], 171: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _declaration = _interopRequireDefault(require2("./declaration"));
        var _comment = _interopRequireDefault(require2("./comment"));
        var _node = _interopRequireDefault(require2("./node"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it2;
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike) {
              if (it2) o = it2;
              var i = 0;
              return function() {
                if (i >= o.length) return { done: true };
                return { done: false, value: o[i++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          it2 = o[Symbol.iterator]();
          return it2.next.bind(it2);
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _defineProperties(target2, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target2, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          return Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        function cleanSource(nodes) {
          return nodes.map(function(i) {
            if (i.nodes) i.nodes = cleanSource(i.nodes);
            delete i.source;
            return i;
          });
        }
        var Container = /* @__PURE__ */ (function(_Node) {
          _inheritsLoose(Container2, _Node);
          function Container2() {
            return _Node.apply(this, arguments) || this;
          }
          var _proto = Container2.prototype;
          _proto.push = function push(child) {
            child.parent = this;
            this.nodes.push(child);
            return this;
          };
          _proto.each = function each(callback) {
            if (!this.lastEach) this.lastEach = 0;
            if (!this.indexes) this.indexes = {};
            this.lastEach += 1;
            var id = this.lastEach;
            this.indexes[id] = 0;
            if (!this.nodes) return void 0;
            var index, result;
            while (this.indexes[id] < this.nodes.length) {
              index = this.indexes[id];
              result = callback(this.nodes[index], index);
              if (result === false) break;
              this.indexes[id] += 1;
            }
            delete this.indexes[id];
            return result;
          };
          _proto.walk = function walk(callback) {
            return this.each(function(child, i) {
              var result;
              try {
                result = callback(child, i);
              } catch (e) {
                e.postcssNode = child;
                if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
                  var s = child.source;
                  e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
                }
                throw e;
              }
              if (result !== false && child.walk) {
                result = child.walk(callback);
              }
              return result;
            });
          };
          _proto.walkDecls = function walkDecls(prop2, callback) {
            if (!callback) {
              callback = prop2;
              return this.walk(function(child, i) {
                if (child.type === "decl") {
                  return callback(child, i);
                }
              });
            }
            if (prop2 instanceof RegExp) {
              return this.walk(function(child, i) {
                if (child.type === "decl" && prop2.test(child.prop)) {
                  return callback(child, i);
                }
              });
            }
            return this.walk(function(child, i) {
              if (child.type === "decl" && child.prop === prop2) {
                return callback(child, i);
              }
            });
          };
          _proto.walkRules = function walkRules(selector, callback) {
            if (!callback) {
              callback = selector;
              return this.walk(function(child, i) {
                if (child.type === "rule") {
                  return callback(child, i);
                }
              });
            }
            if (selector instanceof RegExp) {
              return this.walk(function(child, i) {
                if (child.type === "rule" && selector.test(child.selector)) {
                  return callback(child, i);
                }
              });
            }
            return this.walk(function(child, i) {
              if (child.type === "rule" && child.selector === selector) {
                return callback(child, i);
              }
            });
          };
          _proto.walkAtRules = function walkAtRules(name, callback) {
            if (!callback) {
              callback = name;
              return this.walk(function(child, i) {
                if (child.type === "atrule") {
                  return callback(child, i);
                }
              });
            }
            if (name instanceof RegExp) {
              return this.walk(function(child, i) {
                if (child.type === "atrule" && name.test(child.name)) {
                  return callback(child, i);
                }
              });
            }
            return this.walk(function(child, i) {
              if (child.type === "atrule" && child.name === name) {
                return callback(child, i);
              }
            });
          };
          _proto.walkComments = function walkComments(callback) {
            return this.walk(function(child, i) {
              if (child.type === "comment") {
                return callback(child, i);
              }
            });
          };
          _proto.append = function append() {
            for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
              children[_key] = arguments[_key];
            }
            for (var _i = 0, _children = children; _i < _children.length; _i++) {
              var child = _children[_i];
              var nodes = this.normalize(child, this.last);
              for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done; ) {
                var node = _step.value;
                this.nodes.push(node);
              }
            }
            return this;
          };
          _proto.prepend = function prepend() {
            for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              children[_key2] = arguments[_key2];
            }
            children = children.reverse();
            for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done; ) {
              var child = _step2.value;
              var nodes = this.normalize(child, this.first, "prepend").reverse();
              for (var _iterator3 = _createForOfIteratorHelperLoose(nodes), _step3; !(_step3 = _iterator3()).done; ) {
                var node = _step3.value;
                this.nodes.unshift(node);
              }
              for (var id in this.indexes) {
                this.indexes[id] = this.indexes[id] + nodes.length;
              }
            }
            return this;
          };
          _proto.cleanRaws = function cleanRaws(keepBetween) {
            _Node.prototype.cleanRaws.call(this, keepBetween);
            if (this.nodes) {
              for (var _iterator4 = _createForOfIteratorHelperLoose(this.nodes), _step4; !(_step4 = _iterator4()).done; ) {
                var node = _step4.value;
                node.cleanRaws(keepBetween);
              }
            }
          };
          _proto.insertBefore = function insertBefore(exist2, add) {
            exist2 = this.index(exist2);
            var type = exist2 === 0 ? "prepend" : false;
            var nodes = this.normalize(add, this.nodes[exist2], type).reverse();
            for (var _iterator5 = _createForOfIteratorHelperLoose(nodes), _step5; !(_step5 = _iterator5()).done; ) {
              var node = _step5.value;
              this.nodes.splice(exist2, 0, node);
            }
            var index;
            for (var id in this.indexes) {
              index = this.indexes[id];
              if (exist2 <= index) {
                this.indexes[id] = index + nodes.length;
              }
            }
            return this;
          };
          _proto.insertAfter = function insertAfter(exist2, add) {
            exist2 = this.index(exist2);
            var nodes = this.normalize(add, this.nodes[exist2]).reverse();
            for (var _iterator6 = _createForOfIteratorHelperLoose(nodes), _step6; !(_step6 = _iterator6()).done; ) {
              var node = _step6.value;
              this.nodes.splice(exist2 + 1, 0, node);
            }
            var index;
            for (var id in this.indexes) {
              index = this.indexes[id];
              if (exist2 < index) {
                this.indexes[id] = index + nodes.length;
              }
            }
            return this;
          };
          _proto.removeChild = function removeChild(child) {
            child = this.index(child);
            this.nodes[child].parent = void 0;
            this.nodes.splice(child, 1);
            var index;
            for (var id in this.indexes) {
              index = this.indexes[id];
              if (index >= child) {
                this.indexes[id] = index - 1;
              }
            }
            return this;
          };
          _proto.removeAll = function removeAll() {
            for (var _iterator7 = _createForOfIteratorHelperLoose(this.nodes), _step7; !(_step7 = _iterator7()).done; ) {
              var node = _step7.value;
              node.parent = void 0;
            }
            this.nodes = [];
            return this;
          };
          _proto.replaceValues = function replaceValues(pattern2, opts, callback) {
            if (!callback) {
              callback = opts;
              opts = {};
            }
            this.walkDecls(function(decl) {
              if (opts.props && opts.props.indexOf(decl.prop) === -1) return;
              if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;
              decl.value = decl.value.replace(pattern2, callback);
            });
            return this;
          };
          _proto.every = function every(condition) {
            return this.nodes.every(condition);
          };
          _proto.some = function some(condition) {
            return this.nodes.some(condition);
          };
          _proto.index = function index(child) {
            if (typeof child === "number") {
              return child;
            }
            return this.nodes.indexOf(child);
          };
          _proto.normalize = function normalize2(nodes, sample) {
            var _this = this;
            if (typeof nodes === "string") {
              var parse2 = require2("./parse");
              nodes = cleanSource(parse2(nodes).nodes);
            } else if (Array.isArray(nodes)) {
              nodes = nodes.slice(0);
              for (var _iterator8 = _createForOfIteratorHelperLoose(nodes), _step8; !(_step8 = _iterator8()).done; ) {
                var i = _step8.value;
                if (i.parent) i.parent.removeChild(i, "ignore");
              }
            } else if (nodes.type === "root") {
              nodes = nodes.nodes.slice(0);
              for (var _iterator9 = _createForOfIteratorHelperLoose(nodes), _step9; !(_step9 = _iterator9()).done; ) {
                var _i2 = _step9.value;
                if (_i2.parent) _i2.parent.removeChild(_i2, "ignore");
              }
            } else if (nodes.type) {
              nodes = [nodes];
            } else if (nodes.prop) {
              if (typeof nodes.value === "undefined") {
                throw new Error("Value field is missed in node creation");
              } else if (typeof nodes.value !== "string") {
                nodes.value = String(nodes.value);
              }
              nodes = [new _declaration["default"](nodes)];
            } else if (nodes.selector) {
              var Rule = require2("./rule");
              nodes = [new Rule(nodes)];
            } else if (nodes.name) {
              var AtRule = require2("./at-rule");
              nodes = [new AtRule(nodes)];
            } else if (nodes.text) {
              nodes = [new _comment["default"](nodes)];
            } else {
              throw new Error("Unknown node type in node creation");
            }
            var processed = nodes.map(function(i2) {
              if (i2.parent) i2.parent.removeChild(i2);
              if (typeof i2.raws.before === "undefined") {
                if (sample && typeof sample.raws.before !== "undefined") {
                  i2.raws.before = sample.raws.before.replace(/[^\s]/g, "");
                }
              }
              i2.parent = _this;
              return i2;
            });
            return processed;
          };
          _createClass(Container2, [{
            key: "first",
            get: function get() {
              if (!this.nodes) return void 0;
              return this.nodes[0];
            }
            /**
            * The containerâ€™s last child.
            *
            * @type {Node}
            *
            * @example
            * rule.last === rule.nodes[rule.nodes.length - 1]
            */
          }, { key: "last", get: function get() {
            if (!this.nodes) return void 0;
            return this.nodes[this.nodes.length - 1];
          } }]);
          return Container2;
        })(_node["default"]);
        var _default2 = Container;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./at-rule": 169, "./comment": 170, "./declaration": 173, "./node": 178, "./parse": 179, "./rule": 186 }], 172: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _supportsColor = _interopRequireDefault(require2("supports-color"));
        var _chalk = _interopRequireDefault(require2("chalk"));
        var _terminalHighlight = _interopRequireDefault(require2("./terminal-highlight"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
          var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
          _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
            if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
            if (typeof Class2 !== "function") {
              throw new TypeError("Super expression must either be null or a function");
            }
            if (typeof _cache !== "undefined") {
              if (_cache.has(Class2)) return _cache.get(Class2);
              _cache.set(Class2, Wrapper);
            }
            function Wrapper() {
              return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
            }
            Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
            return _setPrototypeOf(Wrapper, Class2);
          };
          return _wrapNativeSuper(Class);
        }
        function _construct(Parent, args, Class) {
          if (_isNativeReflectConstruct()) {
            _construct = Reflect.construct;
          } else {
            _construct = function _construct2(Parent2, args2, Class2) {
              var a = [null];
              a.push.apply(a, args2);
              var Constructor = Function.bind.apply(Parent2, a);
              var instance = new Constructor();
              if (Class2) _setPrototypeOf(instance, Class2.prototype);
              return instance;
            };
          }
          return _construct.apply(null, arguments);
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _isNativeFunction(fn) {
          return Function.toString.call(fn).indexOf("[native code]") !== -1;
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        var CssSyntaxError = /* @__PURE__ */ (function(_Error) {
          _inheritsLoose(CssSyntaxError2, _Error);
          function CssSyntaxError2(message, line, column, source, file, plugin2) {
            var _this;
            _this = _Error.call(this, message) || this;
            _this.name = "CssSyntaxError";
            _this.reason = message;
            if (file) {
              _this.file = file;
            }
            if (source) {
              _this.source = source;
            }
            if (plugin2) {
              _this.plugin = plugin2;
            }
            if (typeof line !== "undefined" && typeof column !== "undefined") {
              _this.line = line;
              _this.column = column;
            }
            _this.setMessage();
            if (Error.captureStackTrace) {
              Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError2);
            }
            return _this;
          }
          var _proto = CssSyntaxError2.prototype;
          _proto.setMessage = function setMessage() {
            this.message = this.plugin ? this.plugin + ": " : "";
            this.message += this.file ? this.file : "<css input>";
            if (typeof this.line !== "undefined") {
              this.message += ":" + this.line + ":" + this.column;
            }
            this.message += ": " + this.reason;
          };
          _proto.showSourceCode = function showSourceCode(color) {
            var _this2 = this;
            if (!this.source) return "";
            var css2 = this.source;
            if (_terminalHighlight["default"]) {
              if (typeof color === "undefined") color = _supportsColor["default"].stdout;
              if (color) css2 = (0, _terminalHighlight["default"])(css2);
            }
            var lines = css2.split(/\r?\n/);
            var start = Math.max(this.line - 3, 0);
            var end = Math.min(this.line + 2, lines.length);
            var maxWidth = String(end).length;
            function mark(text2) {
              if (color && _chalk["default"].red) {
                return _chalk["default"].red.bold(text2);
              }
              return text2;
            }
            function aside(text2) {
              if (color && _chalk["default"].gray) {
                return _chalk["default"].gray(text2);
              }
              return text2;
            }
            return lines.slice(start, end).map(function(line, index) {
              var number = start + 1 + index;
              var gutter = " " + (" " + number).slice(-maxWidth) + " | ";
              if (number === _this2.line) {
                var spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, " ");
                return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
              }
              return " " + aside(gutter) + line;
            }).join("\n");
          };
          _proto.toString = function toString() {
            var code2 = this.showSourceCode();
            if (code2) {
              code2 = "\n\n" + code2 + "\n";
            }
            return this.name + ": " + this.message + code2;
          };
          return CssSyntaxError2;
        })(/* @__PURE__ */ _wrapNativeSuper(Error));
        var _default2 = CssSyntaxError;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./terminal-highlight": 2, "chalk": 2, "supports-color": 2 }], 173: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _node = _interopRequireDefault(require2("./node"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Declaration = /* @__PURE__ */ (function(_Node) {
          _inheritsLoose(Declaration2, _Node);
          function Declaration2(defaults) {
            var _this;
            _this = _Node.call(this, defaults) || this;
            _this.type = "decl";
            return _this;
          }
          return Declaration2;
        })(_node["default"]);
        var _default2 = Declaration;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./node": 178 }], 174: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _path = _interopRequireDefault(require2("path"));
        var _cssSyntaxError = _interopRequireDefault(require2("./css-syntax-error"));
        var _previousMap = _interopRequireDefault(require2("./previous-map"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties(target2, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target2, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          return Constructor;
        }
        var sequence = 0;
        var Input = /* @__PURE__ */ (function() {
          function Input2(css2, opts) {
            if (opts === void 0) {
              opts = {};
            }
            if (css2 === null || typeof css2 === "undefined" || _typeof(css2) === "object" && !css2.toString) {
              throw new Error("PostCSS received " + css2 + " instead of CSS string");
            }
            this.css = css2.toString();
            if (this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾") {
              this.hasBOM = true;
              this.css = this.css.slice(1);
            } else {
              this.hasBOM = false;
            }
            if (opts.from) {
              if (/^\w+:\/\//.test(opts.from) || _path["default"].isAbsolute(opts.from)) {
                this.file = opts.from;
              } else {
                this.file = _path["default"].resolve(opts.from);
              }
            }
            var map2 = new _previousMap["default"](this.css, opts);
            if (map2.text) {
              this.map = map2;
              var file = map2.consumer().file;
              if (!this.file && file) this.file = this.mapResolve(file);
            }
            if (!this.file) {
              sequence += 1;
              this.id = "<input css " + sequence + ">";
            }
            if (this.map) this.map.file = this.from;
          }
          var _proto = Input2.prototype;
          _proto.error = function error2(message, line, column, opts) {
            if (opts === void 0) {
              opts = {};
            }
            var result;
            var origin = this.origin(line, column);
            if (origin) {
              result = new _cssSyntaxError["default"](message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
            } else {
              result = new _cssSyntaxError["default"](message, line, column, this.css, this.file, opts.plugin);
            }
            result.input = { line, column, source: this.css };
            if (this.file) result.input.file = this.file;
            return result;
          };
          _proto.origin = function origin(line, column) {
            if (!this.map) return false;
            var consumer = this.map.consumer();
            var from = consumer.originalPositionFor({ line, column });
            if (!from.source) return false;
            var result = { file: this.mapResolve(from.source), line: from.line, column: from.column };
            var source = consumer.sourceContentFor(from.source);
            if (source) result.source = source;
            return result;
          };
          _proto.mapResolve = function mapResolve(file) {
            if (/^\w+:\/\//.test(file)) {
              return file;
            }
            return _path["default"].resolve(this.map.consumer().sourceRoot || ".", file);
          };
          _createClass(Input2, [{ key: "from", get: function get() {
            return this.file || this.id;
          } }]);
          return Input2;
        })();
        var _default2 = Input;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./css-syntax-error": 172, "./previous-map": 182, "path": 168 }], 175: [function(require2, module3, exports3) {
        (function(process2) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _mapGenerator = _interopRequireDefault(require2("./map-generator"));
          var _stringify2 = _interopRequireDefault(require2("./stringify"));
          var _warnOnce = _interopRequireDefault(require2("./warn-once"));
          var _result = _interopRequireDefault(require2("./result"));
          var _parse = _interopRequireDefault(require2("./parse"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _createForOfIteratorHelperLoose(o, allowArrayLike) {
            var it2;
            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
              if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike) {
                if (it2) o = it2;
                var i = 0;
                return function() {
                  if (i >= o.length) return { done: true };
                  return { done: false, value: o[i++] };
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            it2 = o[Symbol.iterator]();
            return it2.next.bind(it2);
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          function _defineProperties(target2, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target2, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            return Constructor;
          }
          function isPromise(obj) {
            return _typeof(obj) === "object" && typeof obj.then === "function";
          }
          var LazyResult = /* @__PURE__ */ (function() {
            function LazyResult2(processor, css2, opts) {
              this.stringified = false;
              this.processed = false;
              var root2;
              if (_typeof(css2) === "object" && css2 !== null && css2.type === "root") {
                root2 = css2;
              } else if (css2 instanceof LazyResult2 || css2 instanceof _result["default"]) {
                root2 = css2.root;
                if (css2.map) {
                  if (typeof opts.map === "undefined") opts.map = {};
                  if (!opts.map.inline) opts.map.inline = false;
                  opts.map.prev = css2.map;
                }
              } else {
                var parser = _parse["default"];
                if (opts.syntax) parser = opts.syntax.parse;
                if (opts.parser) parser = opts.parser;
                if (parser.parse) parser = parser.parse;
                try {
                  root2 = parser(css2, opts);
                } catch (error2) {
                  this.error = error2;
                }
              }
              this.result = new _result["default"](processor, root2, opts);
            }
            var _proto = LazyResult2.prototype;
            _proto.warnings = function warnings() {
              return this.sync().warnings();
            };
            _proto.toString = function toString() {
              return this.css;
            };
            _proto.then = function then(onFulfilled, onRejected) {
              if (process2.env.NODE_ENV !== "production") {
                if (!("from" in this.opts)) {
                  (0, _warnOnce["default"])("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
                }
              }
              return this.async().then(onFulfilled, onRejected);
            };
            _proto["catch"] = function _catch(onRejected) {
              return this.async()["catch"](onRejected);
            };
            _proto["finally"] = function _finally(onFinally) {
              return this.async().then(onFinally, onFinally);
            };
            _proto.handleError = function handleError(error2, plugin2) {
              try {
                this.error = error2;
                if (error2.name === "CssSyntaxError" && !error2.plugin) {
                  error2.plugin = plugin2.postcssPlugin;
                  error2.setMessage();
                } else if (plugin2.postcssVersion) {
                  if (process2.env.NODE_ENV !== "production") {
                    var pluginName = plugin2.postcssPlugin;
                    var pluginVer = plugin2.postcssVersion;
                    var runtimeVer = this.result.processor.version;
                    var a = pluginVer.split(".");
                    var b = runtimeVer.split(".");
                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                      console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
                    }
                  }
                }
              } catch (err) {
                if (console && console.error) console.error(err);
              }
            };
            _proto.asyncTick = function asyncTick(resolve, reject) {
              var _this = this;
              if (this.plugin >= this.processor.plugins.length) {
                this.processed = true;
                return resolve();
              }
              try {
                var plugin2 = this.processor.plugins[this.plugin];
                var promise = this.run(plugin2);
                this.plugin += 1;
                if (isPromise(promise)) {
                  promise.then(function() {
                    _this.asyncTick(resolve, reject);
                  })["catch"](function(error2) {
                    _this.handleError(error2, plugin2);
                    _this.processed = true;
                    reject(error2);
                  });
                } else {
                  this.asyncTick(resolve, reject);
                }
              } catch (error2) {
                this.processed = true;
                reject(error2);
              }
            };
            _proto.async = function async() {
              var _this2 = this;
              if (this.processed) {
                return new Promise(function(resolve, reject) {
                  if (_this2.error) {
                    reject(_this2.error);
                  } else {
                    resolve(_this2.stringify());
                  }
                });
              }
              if (this.processing) {
                return this.processing;
              }
              this.processing = new Promise(function(resolve, reject) {
                if (_this2.error) return reject(_this2.error);
                _this2.plugin = 0;
                _this2.asyncTick(resolve, reject);
              }).then(function() {
                _this2.processed = true;
                return _this2.stringify();
              });
              return this.processing;
            };
            _proto.sync = function sync() {
              if (this.processed) return this.result;
              this.processed = true;
              if (this.processing) {
                throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              if (this.error) throw this.error;
              for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done; ) {
                var plugin2 = _step.value;
                var promise = this.run(plugin2);
                if (isPromise(promise)) {
                  throw new Error("Use process(css).then(cb) to work with async plugins");
                }
              }
              return this.result;
            };
            _proto.run = function run(plugin2) {
              this.result.lastPlugin = plugin2;
              try {
                return plugin2(this.result.root, this.result);
              } catch (error2) {
                this.handleError(error2, plugin2);
                throw error2;
              }
            };
            _proto.stringify = function stringify() {
              if (this.stringified) return this.result;
              this.stringified = true;
              this.sync();
              var opts = this.result.opts;
              var str = _stringify2["default"];
              if (opts.syntax) str = opts.syntax.stringify;
              if (opts.stringifier) str = opts.stringifier;
              if (str.stringify) str = str.stringify;
              var map2 = new _mapGenerator["default"](str, this.result.root, this.result.opts);
              var data = map2.generate();
              this.result.css = data[0];
              this.result.map = data[1];
              return this.result;
            };
            _createClass(LazyResult2, [{
              key: "processor",
              get: function get() {
                return this.result.processor;
              }
              /**
              * Options from the {@link Processor#process} call.
              *
              * @type {processOptions}
              */
            }, {
              key: "opts",
              get: function get() {
                return this.result.opts;
              }
              /**
              * Processes input CSS through synchronous plugins, converts `Root`
              * to a CSS string and returns {@link Result#css}.
              *
              * This property will only work with synchronous plugins.
              * If the processor contains any asynchronous plugins
              * it will throw an error. This is why this method is only
              * for debug purpose, you should always use {@link LazyResult#then}.
              *
              * @type {string}
              * @see Result#css
              */
            }, {
              key: "css",
              get: function get() {
                return this.stringify().css;
              }
              /**
              * An alias for the `css` property. Use it with syntaxes
              * that generate non-CSS output.
              *
              * This property will only work with synchronous plugins.
              * If the processor contains any asynchronous plugins
              * it will throw an error. This is why this method is only
              * for debug purpose, you should always use {@link LazyResult#then}.
              *
              * @type {string}
              * @see Result#content
              */
            }, {
              key: "content",
              get: function get() {
                return this.stringify().content;
              }
              /**
              * Processes input CSS through synchronous plugins
              * and returns {@link Result#map}.
              *
              * This property will only work with synchronous plugins.
              * If the processor contains any asynchronous plugins
              * it will throw an error. This is why this method is only
              * for debug purpose, you should always use {@link LazyResult#then}.
              *
              * @type {SourceMapGenerator}
              * @see Result#map
              */
            }, {
              key: "map",
              get: function get() {
                return this.stringify().map;
              }
              /**
              * Processes input CSS through synchronous plugins
              * and returns {@link Result#root}.
              *
              * This property will only work with synchronous plugins. If the processor
              * contains any asynchronous plugins it will throw an error.
              *
              * This is why this method is only for debug purpose,
              * you should always use {@link LazyResult#then}.
              *
              * @type {Root}
              * @see Result#root
              */
            }, {
              key: "root",
              get: function get() {
                return this.sync().root;
              }
              /**
              * Processes input CSS through synchronous plugins
              * and returns {@link Result#messages}.
              *
              * This property will only work with synchronous plugins. If the processor
              * contains any asynchronous plugins it will throw an error.
              *
              * This is why this method is only for debug purpose,
              * you should always use {@link LazyResult#then}.
              *
              * @type {Message[]}
              * @see Result#messages
              */
            }, { key: "messages", get: function get() {
              return this.sync().messages;
            } }]);
            return LazyResult2;
          })();
          var _default2 = LazyResult;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("_process"));
      }, { "./map-generator": 177, "./parse": 179, "./result": 184, "./stringify": 188, "./warn-once": 191, "_process": 193 }], 176: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var list2 = {
          split: function split(string, separators, last) {
            var array = [];
            var current = "";
            var split2 = false;
            var func = 0;
            var quote = false;
            var escape2 = false;
            for (var i = 0; i < string.length; i++) {
              var letter = string[i];
              if (quote) {
                if (escape2) {
                  escape2 = false;
                } else if (letter === "\\") {
                  escape2 = true;
                } else if (letter === quote) {
                  quote = false;
                }
              } else if (letter === '"' || letter === "'") {
                quote = letter;
              } else if (letter === "(") {
                func += 1;
              } else if (letter === ")") {
                if (func > 0) func -= 1;
              } else if (func === 0) {
                if (separators.indexOf(letter) !== -1) split2 = true;
              }
              if (split2) {
                if (current !== "") array.push(current.trim());
                current = "";
                split2 = false;
              } else {
                current += letter;
              }
            }
            if (last || current !== "") array.push(current.trim());
            return array;
          },
          /**
          * Safely splits space-separated values (such as those for `background`,
          * `border-radius`, and other shorthand properties).
          *
          * @param {string} string Space-separated values.
          *
          * @return {string[]} Split values.
          *
          * @example
          * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
          */
          space: function space(string) {
            var spaces = [" ", "\n", "	"];
            return list2.split(string, spaces);
          },
          /**
          * Safely splits comma-separated values (such as those for `transition-*`
          * and `background` properties).
          *
          * @param {string} string Comma-separated values.
          *
          * @return {string[]} Split values.
          *
          * @example
          * postcss.list.comma('black, linear-gradient(white, black)')
          * //=> ['black', 'linear-gradient(white, black)']
          */
          comma: function comma2(string) {
            return list2.split(string, [","], true);
          }
        };
        var _default2 = list2;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, {}], 177: [function(require2, module3, exports3) {
        (function(Buffer) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _sourceMap = _interopRequireDefault(require2("source-map"));
          var _path = _interopRequireDefault(require2("path"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _createForOfIteratorHelperLoose(o, allowArrayLike) {
            var it2;
            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
              if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike) {
                if (it2) o = it2;
                var i = 0;
                return function() {
                  if (i >= o.length) return { done: true };
                  return { done: false, value: o[i++] };
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            it2 = o[Symbol.iterator]();
            return it2.next.bind(it2);
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          var MapGenerator = /* @__PURE__ */ (function() {
            function MapGenerator2(stringify, root2, opts) {
              this.stringify = stringify;
              this.mapOpts = opts.map || {};
              this.root = root2;
              this.opts = opts;
            }
            var _proto = MapGenerator2.prototype;
            _proto.isMap = function isMap() {
              if (typeof this.opts.map !== "undefined") {
                return !!this.opts.map;
              }
              return this.previous().length > 0;
            };
            _proto.previous = function previous() {
              var _this = this;
              if (!this.previousMaps) {
                this.previousMaps = [];
                this.root.walk(function(node) {
                  if (node.source && node.source.input.map) {
                    var map2 = node.source.input.map;
                    if (_this.previousMaps.indexOf(map2) === -1) {
                      _this.previousMaps.push(map2);
                    }
                  }
                });
              }
              return this.previousMaps;
            };
            _proto.isInline = function isInline() {
              if (typeof this.mapOpts.inline !== "undefined") {
                return this.mapOpts.inline;
              }
              var annotation = this.mapOpts.annotation;
              if (typeof annotation !== "undefined" && annotation !== true) {
                return false;
              }
              if (this.previous().length) {
                return this.previous().some(function(i) {
                  return i.inline;
                });
              }
              return true;
            };
            _proto.isSourcesContent = function isSourcesContent() {
              if (typeof this.mapOpts.sourcesContent !== "undefined") {
                return this.mapOpts.sourcesContent;
              }
              if (this.previous().length) {
                return this.previous().some(function(i) {
                  return i.withContent();
                });
              }
              return true;
            };
            _proto.clearAnnotation = function clearAnnotation() {
              if (this.mapOpts.annotation === false) return;
              var node;
              for (var i = this.root.nodes.length - 1; i >= 0; i--) {
                node = this.root.nodes[i];
                if (node.type !== "comment") continue;
                if (node.text.indexOf("# sourceMappingURL=") === 0) {
                  this.root.removeChild(i);
                }
              }
            };
            _proto.setSourcesContent = function setSourcesContent() {
              var _this2 = this;
              var already = {};
              this.root.walk(function(node) {
                if (node.source) {
                  var from = node.source.input.from;
                  if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                  }
                }
              });
            };
            _proto.applyPrevMaps = function applyPrevMaps() {
              for (var _iterator = _createForOfIteratorHelperLoose(this.previous()), _step; !(_step = _iterator()).done; ) {
                var prev = _step.value;
                var from = this.relative(prev.file);
                var root2 = prev.root || _path["default"].dirname(prev.file);
                var map2 = void 0;
                if (this.mapOpts.sourcesContent === false) {
                  map2 = new _sourceMap["default"].SourceMapConsumer(prev.text);
                  if (map2.sourcesContent) {
                    map2.sourcesContent = map2.sourcesContent.map(function() {
                      return null;
                    });
                  }
                } else {
                  map2 = prev.consumer();
                }
                this.map.applySourceMap(map2, from, this.relative(root2));
              }
            };
            _proto.isAnnotation = function isAnnotation() {
              if (this.isInline()) {
                return true;
              }
              if (typeof this.mapOpts.annotation !== "undefined") {
                return this.mapOpts.annotation;
              }
              if (this.previous().length) {
                return this.previous().some(function(i) {
                  return i.annotation;
                });
              }
              return true;
            };
            _proto.toBase64 = function toBase64(str) {
              if (Buffer) {
                return Buffer.from(str).toString("base64");
              }
              return window.btoa(unescape(encodeURIComponent(str)));
            };
            _proto.addAnnotation = function addAnnotation() {
              var content;
              if (this.isInline()) {
                content = "data:application/json;base64," + this.toBase64(this.map.toString());
              } else if (typeof this.mapOpts.annotation === "string") {
                content = this.mapOpts.annotation;
              } else {
                content = this.outputFile() + ".map";
              }
              var eol = "\n";
              if (this.css.indexOf("\r\n") !== -1) eol = "\r\n";
              this.css += eol + "/*# sourceMappingURL=" + content + " */";
            };
            _proto.outputFile = function outputFile() {
              if (this.opts.to) {
                return this.relative(this.opts.to);
              }
              if (this.opts.from) {
                return this.relative(this.opts.from);
              }
              return "to.css";
            };
            _proto.generateMap = function generateMap() {
              this.generateString();
              if (this.isSourcesContent()) this.setSourcesContent();
              if (this.previous().length > 0) this.applyPrevMaps();
              if (this.isAnnotation()) this.addAnnotation();
              if (this.isInline()) {
                return [this.css];
              }
              return [this.css, this.map];
            };
            _proto.relative = function relative(file) {
              if (file.indexOf("<") === 0) return file;
              if (/^\w+:\/\//.test(file)) return file;
              var from = this.opts.to ? _path["default"].dirname(this.opts.to) : ".";
              if (typeof this.mapOpts.annotation === "string") {
                from = _path["default"].dirname(_path["default"].resolve(from, this.mapOpts.annotation));
              }
              file = _path["default"].relative(from, file);
              if (_path["default"].sep === "\\") {
                return file.replace(/\\/g, "/");
              }
              return file;
            };
            _proto.sourcePath = function sourcePath(node) {
              if (this.mapOpts.from) {
                return this.mapOpts.from;
              }
              return this.relative(node.source.input.from);
            };
            _proto.generateString = function generateString() {
              var _this3 = this;
              this.css = "";
              this.map = new _sourceMap["default"].SourceMapGenerator({ file: this.outputFile() });
              var line = 1;
              var column = 1;
              var lines, last;
              this.stringify(this.root, function(str, node, type) {
                _this3.css += str;
                if (node && type !== "end") {
                  if (node.source && node.source.start) {
                    _this3.map.addMapping({ source: _this3.sourcePath(node), generated: { line, column: column - 1 }, original: { line: node.source.start.line, column: node.source.start.column - 1 } });
                  } else {
                    _this3.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line, column: column - 1 } });
                  }
                }
                lines = str.match(/\n/g);
                if (lines) {
                  line += lines.length;
                  last = str.lastIndexOf("\n");
                  column = str.length - last;
                } else {
                  column += str.length;
                }
                if (node && type !== "start") {
                  var p = node.parent || { raws: {} };
                  if (node.type !== "decl" || node !== p.last || p.raws.semicolon) {
                    if (node.source && node.source.end) {
                      _this3.map.addMapping({ source: _this3.sourcePath(node), generated: { line, column: column - 2 }, original: { line: node.source.end.line, column: node.source.end.column - 1 } });
                    } else {
                      _this3.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line, column: column - 1 } });
                    }
                  }
                }
              });
            };
            _proto.generate = function generate() {
              this.clearAnnotation();
              if (this.isMap()) {
                return this.generateMap();
              }
              var result = "";
              this.stringify(this.root, function(i) {
                result += i;
              });
              return [result];
            };
            return MapGenerator2;
          })();
          var _default2 = MapGenerator;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 3, "path": 168, "source-map": 208 }], 178: [function(require2, module3, exports3) {
        (function(process2) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _cssSyntaxError = _interopRequireDefault(require2("./css-syntax-error"));
          var _stringifier = _interopRequireDefault(require2("./stringifier"));
          var _stringify = _interopRequireDefault(require2("./stringify"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function cloneNode(obj, parent) {
            var cloned = new obj.constructor();
            for (var i in obj) {
              if (!obj.hasOwnProperty(i)) continue;
              var value = obj[i];
              var type = _typeof(value);
              if (i === "parent" && type === "object") {
                if (parent) cloned[i] = parent;
              } else if (i === "source") {
                cloned[i] = value;
              } else if (value instanceof Array) {
                cloned[i] = value.map(function(j) {
                  return cloneNode(j, cloned);
                });
              } else {
                if (type === "object" && value !== null) value = cloneNode(value);
                cloned[i] = value;
              }
            }
            return cloned;
          }
          var Node2 = /* @__PURE__ */ (function() {
            function Node22(defaults) {
              if (defaults === void 0) {
                defaults = {};
              }
              this.raws = {};
              if (process2.env.NODE_ENV !== "production") {
                if (_typeof(defaults) !== "object" && typeof defaults !== "undefined") {
                  throw new Error("PostCSS nodes constructor accepts object, not " + JSON.stringify(defaults));
                }
              }
              for (var name in defaults) {
                this[name] = defaults[name];
              }
            }
            var _proto = Node22.prototype;
            _proto.error = function error2(message, opts) {
              if (opts === void 0) {
                opts = {};
              }
              if (this.source) {
                var pos = this.positionBy(opts);
                return this.source.input.error(message, pos.line, pos.column, opts);
              }
              return new _cssSyntaxError["default"](message);
            };
            _proto.warn = function warn(result, text2, opts) {
              var data = { node: this };
              for (var i in opts) {
                data[i] = opts[i];
              }
              return result.warn(text2, data);
            };
            _proto.remove = function remove2() {
              if (this.parent) {
                this.parent.removeChild(this);
              }
              this.parent = void 0;
              return this;
            };
            _proto.toString = function toString(stringifier) {
              if (stringifier === void 0) {
                stringifier = _stringify["default"];
              }
              if (stringifier.stringify) stringifier = stringifier.stringify;
              var result = "";
              stringifier(this, function(i) {
                result += i;
              });
              return result;
            };
            _proto.clone = function clone(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }
              var cloned = cloneNode(this);
              for (var name in overrides) {
                cloned[name] = overrides[name];
              }
              return cloned;
            };
            _proto.cloneBefore = function cloneBefore(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }
              var cloned = this.clone(overrides);
              this.parent.insertBefore(this, cloned);
              return cloned;
            };
            _proto.cloneAfter = function cloneAfter(overrides) {
              if (overrides === void 0) {
                overrides = {};
              }
              var cloned = this.clone(overrides);
              this.parent.insertAfter(this, cloned);
              return cloned;
            };
            _proto.replaceWith = function replaceWith() {
              if (this.parent) {
                for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
                  nodes[_key] = arguments[_key];
                }
                for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
                  var node = _nodes[_i];
                  this.parent.insertBefore(this, node);
                }
                this.remove();
              }
              return this;
            };
            _proto.next = function next2() {
              if (!this.parent) return void 0;
              var index = this.parent.index(this);
              return this.parent.nodes[index + 1];
            };
            _proto.prev = function prev() {
              if (!this.parent) return void 0;
              var index = this.parent.index(this);
              return this.parent.nodes[index - 1];
            };
            _proto.before = function before(add) {
              this.parent.insertBefore(this, add);
              return this;
            };
            _proto.after = function after(add) {
              this.parent.insertAfter(this, add);
              return this;
            };
            _proto.toJSON = function toJSON() {
              var fixed = {};
              for (var name in this) {
                if (!this.hasOwnProperty(name)) continue;
                if (name === "parent") continue;
                var value = this[name];
                if (value instanceof Array) {
                  fixed[name] = value.map(function(i) {
                    if (_typeof(i) === "object" && i.toJSON) {
                      return i.toJSON();
                    } else {
                      return i;
                    }
                  });
                } else if (_typeof(value) === "object" && value.toJSON) {
                  fixed[name] = value.toJSON();
                } else {
                  fixed[name] = value;
                }
              }
              return fixed;
            };
            _proto.raw = function raw(prop2, defaultType) {
              var str = new _stringifier["default"]();
              return str.raw(this, prop2, defaultType);
            };
            _proto.root = function root2() {
              var result = this;
              while (result.parent) {
                result = result.parent;
              }
              return result;
            };
            _proto.cleanRaws = function cleanRaws(keepBetween) {
              delete this.raws.before;
              delete this.raws.after;
              if (!keepBetween) delete this.raws.between;
            };
            _proto.positionInside = function positionInside(index) {
              var string = this.toString();
              var column = this.source.start.column;
              var line = this.source.start.line;
              for (var i = 0; i < index; i++) {
                if (string[i] === "\n") {
                  column = 1;
                  line += 1;
                } else {
                  column += 1;
                }
              }
              return { line, column };
            };
            _proto.positionBy = function positionBy(opts) {
              var pos = this.source.start;
              if (opts.index) {
                pos = this.positionInside(opts.index);
              } else if (opts.word) {
                var index = this.toString().indexOf(opts.word);
                if (index !== -1) pos = this.positionInside(index);
              }
              return pos;
            };
            return Node22;
          })();
          var _default2 = Node2;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("_process"));
      }, { "./css-syntax-error": 172, "./stringifier": 187, "./stringify": 188, "_process": 193 }], 179: [function(require2, module3, exports3) {
        (function(process2) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _parser = _interopRequireDefault(require2("./parser"));
          var _input = _interopRequireDefault(require2("./input"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function parse2(css2, opts) {
            var input = new _input["default"](css2, opts);
            var parser = new _parser["default"](input);
            try {
              parser.parse();
            } catch (e) {
              if (process2.env.NODE_ENV !== "production") {
                if (e.name === "CssSyntaxError" && opts && opts.from) {
                  if (/\.scss$/i.test(opts.from)) {
                    e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
                  } else if (/\.sass/i.test(opts.from)) {
                    e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
                  } else if (/\.less$/i.test(opts.from)) {
                    e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
                  }
                }
              }
              throw e;
            }
            return parser.root;
          }
          var _default2 = parse2;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("_process"));
      }, { "./input": 174, "./parser": 180, "_process": 193 }], 180: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _declaration = _interopRequireDefault(require2("./declaration"));
        var _tokenize = _interopRequireDefault(require2("./tokenize"));
        var _comment = _interopRequireDefault(require2("./comment"));
        var _atRule = _interopRequireDefault(require2("./at-rule"));
        var _root = _interopRequireDefault(require2("./root"));
        var _rule = _interopRequireDefault(require2("./rule"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        var Parser = /* @__PURE__ */ (function() {
          function Parser2(input) {
            this.input = input;
            this.root = new _root["default"]();
            this.current = this.root;
            this.spaces = "";
            this.semicolon = false;
            this.createTokenizer();
            this.root.source = { input, start: { line: 1, column: 1 } };
          }
          var _proto = Parser2.prototype;
          _proto.createTokenizer = function createTokenizer() {
            this.tokenizer = (0, _tokenize["default"])(this.input);
          };
          _proto.parse = function parse2() {
            var token2;
            while (!this.tokenizer.endOfFile()) {
              token2 = this.tokenizer.nextToken();
              switch (token2[0]) {
                case "space":
                  this.spaces += token2[1];
                  break;
                case ";":
                  this.freeSemicolon(token2);
                  break;
                case "}":
                  this.end(token2);
                  break;
                case "comment":
                  this.comment(token2);
                  break;
                case "at-word":
                  this.atrule(token2);
                  break;
                case "{":
                  this.emptyRule(token2);
                  break;
                default:
                  this.other(token2);
                  break;
              }
            }
            this.endFile();
          };
          _proto.comment = function comment(token2) {
            var node = new _comment["default"]();
            this.init(node, token2[2], token2[3]);
            node.source.end = { line: token2[4], column: token2[5] };
            var text2 = token2[1].slice(2, -2);
            if (/^\s*$/.test(text2)) {
              node.text = "";
              node.raws.left = text2;
              node.raws.right = "";
            } else {
              var match = text2.match(/^(\s*)([^]*[^\s])(\s*)$/);
              node.text = match[2];
              node.raws.left = match[1];
              node.raws.right = match[3];
            }
          };
          _proto.emptyRule = function emptyRule(token2) {
            var node = new _rule["default"]();
            this.init(node, token2[2], token2[3]);
            node.selector = "";
            node.raws.between = "";
            this.current = node;
          };
          _proto.other = function other(start) {
            var end = false;
            var type = null;
            var colon2 = false;
            var bracket = null;
            var brackets = [];
            var tokens = [];
            var token2 = start;
            while (token2) {
              type = token2[0];
              tokens.push(token2);
              if (type === "(" || type === "[") {
                if (!bracket) bracket = token2;
                brackets.push(type === "(" ? ")" : "]");
              } else if (brackets.length === 0) {
                if (type === ";") {
                  if (colon2) {
                    this.decl(tokens);
                    return;
                  } else {
                    break;
                  }
                } else if (type === "{") {
                  this.rule(tokens);
                  return;
                } else if (type === "}") {
                  this.tokenizer.back(tokens.pop());
                  end = true;
                  break;
                } else if (type === ":") {
                  colon2 = true;
                }
              } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
              }
              token2 = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile()) end = true;
            if (brackets.length > 0) this.unclosedBracket(bracket);
            if (end && colon2) {
              while (tokens.length) {
                token2 = tokens[tokens.length - 1][0];
                if (token2 !== "space" && token2 !== "comment") break;
                this.tokenizer.back(tokens.pop());
              }
              this.decl(tokens);
            } else {
              this.unknownWord(tokens);
            }
          };
          _proto.rule = function rule(tokens) {
            tokens.pop();
            var node = new _rule["default"]();
            this.init(node, tokens[0][2], tokens[0][3]);
            node.raws.between = this.spacesAndCommentsFromEnd(tokens);
            this.raw(node, "selector", tokens);
            this.current = node;
          };
          _proto.decl = function decl(tokens) {
            var node = new _declaration["default"]();
            this.init(node);
            var last = tokens[tokens.length - 1];
            if (last[0] === ";") {
              this.semicolon = true;
              tokens.pop();
            }
            if (last[4]) {
              node.source.end = { line: last[4], column: last[5] };
            } else {
              node.source.end = { line: last[2], column: last[3] };
            }
            while (tokens[0][0] !== "word") {
              if (tokens.length === 1) this.unknownWord(tokens);
              node.raws.before += tokens.shift()[1];
            }
            node.source.start = { line: tokens[0][2], column: tokens[0][3] };
            node.prop = "";
            while (tokens.length) {
              var type = tokens[0][0];
              if (type === ":" || type === "space" || type === "comment") {
                break;
              }
              node.prop += tokens.shift()[1];
            }
            node.raws.between = "";
            var token2;
            while (tokens.length) {
              token2 = tokens.shift();
              if (token2[0] === ":") {
                node.raws.between += token2[1];
                break;
              } else {
                if (token2[0] === "word" && /\w/.test(token2[1])) {
                  this.unknownWord([token2]);
                }
                node.raws.between += token2[1];
              }
            }
            if (node.prop[0] === "_" || node.prop[0] === "*") {
              node.raws.before += node.prop[0];
              node.prop = node.prop.slice(1);
            }
            node.raws.between += this.spacesAndCommentsFromStart(tokens);
            this.precheckMissedSemicolon(tokens);
            for (var i = tokens.length - 1; i > 0; i--) {
              token2 = tokens[i];
              if (token2[1].toLowerCase() === "!important") {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== " !important") node.raws.important = string;
                break;
              } else if (token2[1].toLowerCase() === "important") {
                var cache = tokens.slice(0);
                var str = "";
                for (var j = i; j > 0; j--) {
                  var _type = cache[j][0];
                  if (str.trim().indexOf("!") === 0 && _type !== "space") {
                    break;
                  }
                  str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf("!") === 0) {
                  node.important = true;
                  node.raws.important = str;
                  tokens = cache;
                }
              }
              if (token2[0] !== "space" && token2[0] !== "comment") {
                break;
              }
            }
            this.raw(node, "value", tokens);
            if (node.value.indexOf(":") !== -1) this.checkMissedSemicolon(tokens);
          };
          _proto.atrule = function atrule(token2) {
            var node = new _atRule["default"]();
            node.name = token2[1].slice(1);
            if (node.name === "") {
              this.unnamedAtrule(node, token2);
            }
            this.init(node, token2[2], token2[3]);
            var prev;
            var shift;
            var last = false;
            var open = false;
            var params2 = [];
            while (!this.tokenizer.endOfFile()) {
              token2 = this.tokenizer.nextToken();
              if (token2[0] === ";") {
                node.source.end = { line: token2[2], column: token2[3] };
                this.semicolon = true;
                break;
              } else if (token2[0] === "{") {
                open = true;
                break;
              } else if (token2[0] === "}") {
                if (params2.length > 0) {
                  shift = params2.length - 1;
                  prev = params2[shift];
                  while (prev && prev[0] === "space") {
                    prev = params2[--shift];
                  }
                  if (prev) {
                    node.source.end = { line: prev[4], column: prev[5] };
                  }
                }
                this.end(token2);
                break;
              } else {
                params2.push(token2);
              }
              if (this.tokenizer.endOfFile()) {
                last = true;
                break;
              }
            }
            node.raws.between = this.spacesAndCommentsFromEnd(params2);
            if (params2.length) {
              node.raws.afterName = this.spacesAndCommentsFromStart(params2);
              this.raw(node, "params", params2);
              if (last) {
                token2 = params2[params2.length - 1];
                node.source.end = { line: token2[4], column: token2[5] };
                this.spaces = node.raws.between;
                node.raws.between = "";
              }
            } else {
              node.raws.afterName = "";
              node.params = "";
            }
            if (open) {
              node.nodes = [];
              this.current = node;
            }
          };
          _proto.end = function end(token2) {
            if (this.current.nodes && this.current.nodes.length) {
              this.current.raws.semicolon = this.semicolon;
            }
            this.semicolon = false;
            this.current.raws.after = (this.current.raws.after || "") + this.spaces;
            this.spaces = "";
            if (this.current.parent) {
              this.current.source.end = { line: token2[2], column: token2[3] };
              this.current = this.current.parent;
            } else {
              this.unexpectedClose(token2);
            }
          };
          _proto.endFile = function endFile() {
            if (this.current.parent) this.unclosedBlock();
            if (this.current.nodes && this.current.nodes.length) {
              this.current.raws.semicolon = this.semicolon;
            }
            this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          };
          _proto.freeSemicolon = function freeSemicolon(token2) {
            this.spaces += token2[1];
            if (this.current.nodes) {
              var prev = this.current.nodes[this.current.nodes.length - 1];
              if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
                prev.raws.ownSemicolon = this.spaces;
                this.spaces = "";
              }
            }
          };
          _proto.init = function init2(node, line, column) {
            this.current.push(node);
            node.source = { start: { line, column }, input: this.input };
            node.raws.before = this.spaces;
            this.spaces = "";
            if (node.type !== "comment") this.semicolon = false;
          };
          _proto.raw = function raw(node, prop2, tokens) {
            var token2, type;
            var length = tokens.length;
            var value = "";
            var clean = true;
            var next2, prev;
            var pattern2 = /^([.|#])?([\w])+/i;
            for (var i = 0; i < length; i += 1) {
              token2 = tokens[i];
              type = token2[0];
              if (type === "comment" && node.type === "rule") {
                prev = tokens[i - 1];
                next2 = tokens[i + 1];
                if (prev[0] !== "space" && next2[0] !== "space" && pattern2.test(prev[1]) && pattern2.test(next2[1])) {
                  value += token2[1];
                } else {
                  clean = false;
                }
                continue;
              }
              if (type === "comment" || type === "space" && i === length - 1) {
                clean = false;
              } else {
                value += token2[1];
              }
            }
            if (!clean) {
              var raw2 = tokens.reduce(function(all, i2) {
                return all + i2[1];
              }, "");
              node.raws[prop2] = { value, raw: raw2 };
            }
            node[prop2] = value;
          };
          _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
            var lastTokenType;
            var spaces = "";
            while (tokens.length) {
              lastTokenType = tokens[tokens.length - 1][0];
              if (lastTokenType !== "space" && lastTokenType !== "comment") break;
              spaces = tokens.pop()[1] + spaces;
            }
            return spaces;
          };
          _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
            var next2;
            var spaces = "";
            while (tokens.length) {
              next2 = tokens[0][0];
              if (next2 !== "space" && next2 !== "comment") break;
              spaces += tokens.shift()[1];
            }
            return spaces;
          };
          _proto.spacesFromEnd = function spacesFromEnd(tokens) {
            var lastTokenType;
            var spaces = "";
            while (tokens.length) {
              lastTokenType = tokens[tokens.length - 1][0];
              if (lastTokenType !== "space") break;
              spaces = tokens.pop()[1] + spaces;
            }
            return spaces;
          };
          _proto.stringFrom = function stringFrom(tokens, from) {
            var result = "";
            for (var i = from; i < tokens.length; i++) {
              result += tokens[i][1];
            }
            tokens.splice(from, tokens.length - from);
            return result;
          };
          _proto.colon = function colon2(tokens) {
            var brackets = 0;
            var token2, type, prev;
            for (var i = 0; i < tokens.length; i++) {
              token2 = tokens[i];
              type = token2[0];
              if (type === "(") {
                brackets += 1;
              }
              if (type === ")") {
                brackets -= 1;
              }
              if (brackets === 0 && type === ":") {
                if (!prev) {
                  this.doubleColon(token2);
                } else if (prev[0] === "word" && prev[1] === "progid") {
                  continue;
                } else {
                  return i;
                }
              }
              prev = token2;
            }
            return false;
          };
          _proto.unclosedBracket = function unclosedBracket(bracket) {
            throw this.input.error("Unclosed bracket", bracket[2], bracket[3]);
          };
          _proto.unknownWord = function unknownWord(tokens) {
            throw this.input.error("Unknown word", tokens[0][2], tokens[0][3]);
          };
          _proto.unexpectedClose = function unexpectedClose(token2) {
            throw this.input.error("Unexpected }", token2[2], token2[3]);
          };
          _proto.unclosedBlock = function unclosedBlock() {
            var pos = this.current.source.start;
            throw this.input.error("Unclosed block", pos.line, pos.column);
          };
          _proto.doubleColon = function doubleColon(token2) {
            throw this.input.error("Double colon", token2[2], token2[3]);
          };
          _proto.unnamedAtrule = function unnamedAtrule(node, token2) {
            throw this.input.error("At-rule without name", token2[2], token2[3]);
          };
          _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {
          };
          _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
            var colon2 = this.colon(tokens);
            if (colon2 === false) return;
            var founded = 0;
            var token2;
            for (var j = colon2 - 1; j >= 0; j--) {
              token2 = tokens[j];
              if (token2[0] !== "space") {
                founded += 1;
                if (founded === 2) break;
              }
            }
            throw this.input.error("Missed semicolon", token2[2], token2[3]);
          };
          return Parser2;
        })();
        exports3["default"] = Parser;
        module3.exports = exports3["default"];
      }, { "./at-rule": 169, "./comment": 170, "./declaration": 173, "./root": 185, "./rule": 186, "./tokenize": 189 }], 181: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _declaration = _interopRequireDefault(require2("./declaration"));
        var _processor = _interopRequireDefault(require2("./processor"));
        var _stringify = _interopRequireDefault(require2("./stringify"));
        var _comment = _interopRequireDefault(require2("./comment"));
        var _atRule = _interopRequireDefault(require2("./at-rule"));
        var _vendor = _interopRequireDefault(require2("./vendor"));
        var _parse = _interopRequireDefault(require2("./parse"));
        var _list = _interopRequireDefault(require2("./list"));
        var _rule = _interopRequireDefault(require2("./rule"));
        var _root = _interopRequireDefault(require2("./root"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function postcss() {
          for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
            plugins[_key] = arguments[_key];
          }
          if (plugins.length === 1 && Array.isArray(plugins[0])) {
            plugins = plugins[0];
          }
          return new _processor["default"](plugins);
        }
        postcss.plugin = function plugin2(name, initializer) {
          function creator() {
            var transformer = initializer.apply(void 0, arguments);
            transformer.postcssPlugin = name;
            transformer.postcssVersion = new _processor["default"]().version;
            return transformer;
          }
          var cache;
          Object.defineProperty(creator, "postcss", { get: function get() {
            if (!cache) cache = creator();
            return cache;
          } });
          creator.process = function(css2, processOpts, pluginOpts) {
            return postcss([creator(pluginOpts)]).process(css2, processOpts);
          };
          return creator;
        };
        postcss.stringify = _stringify["default"];
        postcss.parse = _parse["default"];
        postcss.vendor = _vendor["default"];
        postcss.list = _list["default"];
        postcss.comment = function(defaults) {
          return new _comment["default"](defaults);
        };
        postcss.atRule = function(defaults) {
          return new _atRule["default"](defaults);
        };
        postcss.decl = function(defaults) {
          return new _declaration["default"](defaults);
        };
        postcss.rule = function(defaults) {
          return new _rule["default"](defaults);
        };
        postcss.root = function(defaults) {
          return new _root["default"](defaults);
        };
        var _default2 = postcss;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./at-rule": 169, "./comment": 170, "./declaration": 173, "./list": 176, "./parse": 179, "./processor": 183, "./root": 185, "./rule": 186, "./stringify": 188, "./vendor": 190 }], 182: [function(require2, module3, exports3) {
        (function(Buffer) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _sourceMap = _interopRequireDefault(require2("source-map"));
          var _path = _interopRequireDefault(require2("path"));
          var _fs = _interopRequireDefault(require2("fs"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function fromBase64(str) {
            if (Buffer) {
              return Buffer.from(str, "base64").toString();
            } else {
              return window.atob(str);
            }
          }
          var PreviousMap = /* @__PURE__ */ (function() {
            function PreviousMap2(css2, opts) {
              this.loadAnnotation(css2);
              this.inline = this.startWith(this.annotation, "data:");
              var prev = opts.map ? opts.map.prev : void 0;
              var text2 = this.loadMap(opts.from, prev);
              if (text2) this.text = text2;
            }
            var _proto = PreviousMap2.prototype;
            _proto.consumer = function consumer() {
              if (!this.consumerCache) {
                this.consumerCache = new _sourceMap["default"].SourceMapConsumer(this.text);
              }
              return this.consumerCache;
            };
            _proto.withContent = function withContent() {
              return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
            };
            _proto.startWith = function startWith(string, start) {
              if (!string) return false;
              return string.substr(0, start.length) === start;
            };
            _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {
              return sourceMapString.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//)[1].trim();
            };
            _proto.loadAnnotation = function loadAnnotation(css2) {
              var annotations = css2.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//mg);
              if (annotations && annotations.length > 0) {
                var lastAnnotation = annotations[annotations.length - 1];
                if (lastAnnotation) {
                  this.annotation = this.getAnnotationURL(lastAnnotation);
                }
              }
            };
            _proto.decodeInline = function decodeInline(text2) {
              var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
              var baseUri = /^data:application\/json;base64,/;
              var uri = "data:application/json,";
              if (this.startWith(text2, uri)) {
                return decodeURIComponent(text2.substr(uri.length));
              }
              if (baseCharsetUri.test(text2) || baseUri.test(text2)) {
                return fromBase64(text2.substr(RegExp.lastMatch.length));
              }
              var encoding = text2.match(/data:application\/json;([^,]+),/)[1];
              throw new Error("Unsupported source map encoding " + encoding);
            };
            _proto.loadMap = function loadMap(file, prev) {
              if (prev === false) return false;
              if (prev) {
                if (typeof prev === "string") {
                  return prev;
                } else if (typeof prev === "function") {
                  var prevPath = prev(file);
                  if (prevPath && _fs["default"].existsSync && _fs["default"].existsSync(prevPath)) {
                    return _fs["default"].readFileSync(prevPath, "utf-8").toString().trim();
                  } else {
                    throw new Error("Unable to load previous source map: " + prevPath.toString());
                  }
                } else if (prev instanceof _sourceMap["default"].SourceMapConsumer) {
                  return _sourceMap["default"].SourceMapGenerator.fromSourceMap(prev).toString();
                } else if (prev instanceof _sourceMap["default"].SourceMapGenerator) {
                  return prev.toString();
                } else if (this.isMap(prev)) {
                  return JSON.stringify(prev);
                } else {
                  throw new Error("Unsupported previous source map format: " + prev.toString());
                }
              } else if (this.inline) {
                return this.decodeInline(this.annotation);
              } else if (this.annotation) {
                var map2 = this.annotation;
                if (file) map2 = _path["default"].join(_path["default"].dirname(file), map2);
                this.root = _path["default"].dirname(map2);
                if (_fs["default"].existsSync && _fs["default"].existsSync(map2)) {
                  return _fs["default"].readFileSync(map2, "utf-8").toString().trim();
                } else {
                  return false;
                }
              }
            };
            _proto.isMap = function isMap(map2) {
              if (_typeof(map2) !== "object") return false;
              return typeof map2.mappings === "string" || typeof map2._mappings === "string";
            };
            return PreviousMap2;
          })();
          var _default2 = PreviousMap;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 3, "fs": 2, "path": 168, "source-map": 208 }], 183: [function(require2, module3, exports3) {
        (function(process2) {
          exports3.__esModule = true;
          exports3["default"] = void 0;
          var _lazyResult = _interopRequireDefault(require2("./lazy-result"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _createForOfIteratorHelperLoose(o, allowArrayLike) {
            var it2;
            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
              if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike) {
                if (it2) o = it2;
                var i = 0;
                return function() {
                  if (i >= o.length) return { done: true };
                  return { done: false, value: o[i++] };
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            it2 = o[Symbol.iterator]();
            return it2.next.bind(it2);
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          var Processor = /* @__PURE__ */ (function() {
            function Processor2(plugins) {
              if (plugins === void 0) {
                plugins = [];
              }
              this.version = "7.0.34";
              this.plugins = this.normalize(plugins);
            }
            var _proto = Processor2.prototype;
            _proto.use = function use(plugin2) {
              this.plugins = this.plugins.concat(this.normalize([plugin2]));
              return this;
            };
            _proto.process = (function(_process) {
              function process22(_x) {
                return _process.apply(this, arguments);
              }
              process22.toString = function() {
                return _process.toString();
              };
              return process22;
            })(function(css2, opts) {
              if (opts === void 0) {
                opts = {};
              }
              if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
                if (process2.env.NODE_ENV !== "production") {
                  if (typeof console !== "undefined" && console.warn) {
                    console.warn("You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on https://www.postcss.parts/ and use them in postcss.config.js.");
                  }
                }
              }
              return new _lazyResult["default"](this, css2, opts);
            });
            _proto.normalize = function normalize2(plugins) {
              var normalized = [];
              for (var _iterator = _createForOfIteratorHelperLoose(plugins), _step; !(_step = _iterator()).done; ) {
                var i = _step.value;
                if (i.postcss === true) {
                  var plugin2 = i();
                  throw new Error("PostCSS plugin " + plugin2.postcssPlugin + " requires PostCSS 8. Update PostCSS or downgrade this plugin.");
                }
                if (i.postcss) i = i.postcss;
                if (_typeof(i) === "object" && Array.isArray(i.plugins)) {
                  normalized = normalized.concat(i.plugins);
                } else if (typeof i === "function") {
                  normalized.push(i);
                } else if (_typeof(i) === "object" && (i.parse || i.stringify)) {
                  if (process2.env.NODE_ENV !== "production") {
                    throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
                  }
                } else if (_typeof(i) === "object" && i.postcssPlugin) {
                  throw new Error("PostCSS plugin " + i.postcssPlugin + " requires PostCSS 8. Update PostCSS or downgrade this plugin.");
                } else {
                  throw new Error(i + " is not a PostCSS plugin");
                }
              }
              return normalized;
            };
            return Processor2;
          })();
          var _default2 = Processor;
          exports3["default"] = _default2;
          module3.exports = exports3["default"];
        }).call(this, require2("_process"));
      }, { "./lazy-result": 175, "_process": 193 }], 184: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _warning = _interopRequireDefault(require2("./warning"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties(target2, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target2, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          return Constructor;
        }
        var Result = /* @__PURE__ */ (function() {
          function Result2(processor, root2, opts) {
            this.processor = processor;
            this.messages = [];
            this.root = root2;
            this.opts = opts;
            this.css = void 0;
            this.map = void 0;
          }
          var _proto = Result2.prototype;
          _proto.toString = function toString() {
            return this.css;
          };
          _proto.warn = function warn(text2, opts) {
            if (opts === void 0) {
              opts = {};
            }
            if (!opts.plugin) {
              if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
                opts.plugin = this.lastPlugin.postcssPlugin;
              }
            }
            var warning = new _warning["default"](text2, opts);
            this.messages.push(warning);
            return warning;
          };
          _proto.warnings = function warnings() {
            return this.messages.filter(function(i) {
              return i.type === "warning";
            });
          };
          _createClass(Result2, [{ key: "content", get: function get() {
            return this.css;
          } }]);
          return Result2;
        })();
        var _default2 = Result;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./warning": 192 }], 185: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _container = _interopRequireDefault(require2("./container"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it2;
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike) {
              if (it2) o = it2;
              var i = 0;
              return function() {
                if (i >= o.length) return { done: true };
                return { done: false, value: o[i++] };
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          it2 = o[Symbol.iterator]();
          return it2.next.bind(it2);
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Root = /* @__PURE__ */ (function(_Container) {
          _inheritsLoose(Root2, _Container);
          function Root2(defaults) {
            var _this;
            _this = _Container.call(this, defaults) || this;
            _this.type = "root";
            if (!_this.nodes) _this.nodes = [];
            return _this;
          }
          var _proto = Root2.prototype;
          _proto.removeChild = function removeChild(child, ignore) {
            var index = this.index(child);
            if (!ignore && index === 0 && this.nodes.length > 1) {
              this.nodes[1].raws.before = this.nodes[index].raws.before;
            }
            return _Container.prototype.removeChild.call(this, child);
          };
          _proto.normalize = function normalize2(child, sample, type) {
            var nodes = _Container.prototype.normalize.call(this, child);
            if (sample) {
              if (type === "prepend") {
                if (this.nodes.length > 1) {
                  sample.raws.before = this.nodes[1].raws.before;
                } else {
                  delete sample.raws.before;
                }
              } else if (this.first !== sample) {
                for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done; ) {
                  var node = _step.value;
                  node.raws.before = sample.raws.before;
                }
              }
            }
            return nodes;
          };
          _proto.toResult = function toResult(opts) {
            if (opts === void 0) {
              opts = {};
            }
            var LazyResult = require2("./lazy-result");
            var Processor = require2("./processor");
            var lazy = new LazyResult(new Processor(), this, opts);
            return lazy.stringify();
          };
          return Root2;
        })(_container["default"]);
        var _default2 = Root;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./container": 171, "./lazy-result": 175, "./processor": 183 }], 186: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _container = _interopRequireDefault(require2("./container"));
        var _list = _interopRequireDefault(require2("./list"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function _defineProperties(target2, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target2, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          return Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var Rule = /* @__PURE__ */ (function(_Container) {
          _inheritsLoose(Rule2, _Container);
          function Rule2(defaults) {
            var _this;
            _this = _Container.call(this, defaults) || this;
            _this.type = "rule";
            if (!_this.nodes) _this.nodes = [];
            return _this;
          }
          _createClass(Rule2, [{
            key: "selectors",
            get: function get() {
              return _list["default"].comma(this.selector);
            },
            set: function set(values) {
              var match = this.selector ? this.selector.match(/,\s*/) : null;
              var sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
              this.selector = values.join(sep);
            }
            /**
            * @memberof Rule#
            * @member {string} selector The ruleâ€™s full selector represented
            *                           as a string.
            *
            * @example
            * const root = postcss.parse('a, b { }')
            * const rule = root.first
            * rule.selector //=> 'a, b'
            */
            /**
            * @memberof Rule#
            * @member {object} raws Information to generate byte-to-byte equal
            *                       node string as it was in the origin input.
            *
            * Every parser saves its own properties,
            * but the default CSS parser uses:
            *
            * * `before`: the space symbols before the node. It also stores `*`
            *   and `_` symbols before the declaration (IE hack).
            * * `after`: the space symbols after the last child of the node
            *   to the end of the node.
            * * `between`: the symbols between the property and value
            *   for declarations, selector and `{` for rules, or last parameter
            *   and `{` for at-rules.
            * * `semicolon`: contains `true` if the last child has
            *   an (optional) semicolon.
            * * `ownSemicolon`: contains `true` if there is semicolon after rule.
            *
            * PostCSS cleans selectors from comments and extra spaces,
            * but it stores origin content in raws properties.
            * As such, if you donâ€™t change a declarationâ€™s value,
            * PostCSS will use the raw value with comments.
            *
            * @example
            * const root = postcss.parse('a {\n  color:black\n}')
            * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
            */
          }]);
          return Rule2;
        })(_container["default"]);
        var _default2 = Rule;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./container": 171, "./list": 176 }], 187: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var DEFAULT_RAW = { colon: ": ", indent: "    ", beforeDecl: "\n", beforeRule: "\n", beforeOpen: " ", beforeClose: "\n", beforeComment: "\n", after: "\n", emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
        function capitalize(str) {
          return str[0].toUpperCase() + str.slice(1);
        }
        var Stringifier = /* @__PURE__ */ (function() {
          function Stringifier2(builder) {
            this.builder = builder;
          }
          var _proto = Stringifier2.prototype;
          _proto.stringify = function stringify(node, semicolon) {
            this[node.type](node, semicolon);
          };
          _proto.root = function root2(node) {
            this.body(node);
            if (node.raws.after) this.builder(node.raws.after);
          };
          _proto.comment = function comment(node) {
            var left = this.raw(node, "left", "commentLeft");
            var right = this.raw(node, "right", "commentRight");
            this.builder("/*" + left + node.text + right + "*/", node);
          };
          _proto.decl = function decl(node, semicolon) {
            var between2 = this.raw(node, "between", "colon");
            var string = node.prop + between2 + this.rawValue(node, "value");
            if (node.important) {
              string += node.raws.important || " !important";
            }
            if (semicolon) string += ";";
            this.builder(string, node);
          };
          _proto.rule = function rule(node) {
            this.block(node, this.rawValue(node, "selector"));
            if (node.raws.ownSemicolon) {
              this.builder(node.raws.ownSemicolon, node, "end");
            }
          };
          _proto.atrule = function atrule(node, semicolon) {
            var name = "@" + node.name;
            var params2 = node.params ? this.rawValue(node, "params") : "";
            if (typeof node.raws.afterName !== "undefined") {
              name += node.raws.afterName;
            } else if (params2) {
              name += " ";
            }
            if (node.nodes) {
              this.block(node, name + params2);
            } else {
              var end = (node.raws.between || "") + (semicolon ? ";" : "");
              this.builder(name + params2 + end, node);
            }
          };
          _proto.body = function body(node) {
            var last = node.nodes.length - 1;
            while (last > 0) {
              if (node.nodes[last].type !== "comment") break;
              last -= 1;
            }
            var semicolon = this.raw(node, "semicolon");
            for (var i = 0; i < node.nodes.length; i++) {
              var child = node.nodes[i];
              var before = this.raw(child, "before");
              if (before) this.builder(before);
              this.stringify(child, last !== i || semicolon);
            }
          };
          _proto.block = function block2(node, start) {
            var between2 = this.raw(node, "between", "beforeOpen");
            this.builder(start + between2 + "{", node, "start");
            var after;
            if (node.nodes && node.nodes.length) {
              this.body(node);
              after = this.raw(node, "after");
            } else {
              after = this.raw(node, "after", "emptyBody");
            }
            if (after) this.builder(after);
            this.builder("}", node, "end");
          };
          _proto.raw = function raw(node, own, detect) {
            var value;
            if (!detect) detect = own;
            if (own) {
              value = node.raws[own];
              if (typeof value !== "undefined") return value;
            }
            var parent = node.parent;
            if (detect === "before") {
              if (!parent || parent.type === "root" && parent.first === node) {
                return "";
              }
            }
            if (!parent) return DEFAULT_RAW[detect];
            var root2 = node.root();
            if (!root2.rawCache) root2.rawCache = {};
            if (typeof root2.rawCache[detect] !== "undefined") {
              return root2.rawCache[detect];
            }
            if (detect === "before" || detect === "after") {
              return this.beforeAfter(node, detect);
            } else {
              var method = "raw" + capitalize(detect);
              if (this[method]) {
                value = this[method](root2, node);
              } else {
                root2.walk(function(i) {
                  value = i.raws[own];
                  if (typeof value !== "undefined") return false;
                });
              }
            }
            if (typeof value === "undefined") value = DEFAULT_RAW[detect];
            root2.rawCache[detect] = value;
            return value;
          };
          _proto.rawSemicolon = function rawSemicolon(root2) {
            var value;
            root2.walk(function(i) {
              if (i.nodes && i.nodes.length && i.last.type === "decl") {
                value = i.raws.semicolon;
                if (typeof value !== "undefined") return false;
              }
            });
            return value;
          };
          _proto.rawEmptyBody = function rawEmptyBody(root2) {
            var value;
            root2.walk(function(i) {
              if (i.nodes && i.nodes.length === 0) {
                value = i.raws.after;
                if (typeof value !== "undefined") return false;
              }
            });
            return value;
          };
          _proto.rawIndent = function rawIndent(root2) {
            if (root2.raws.indent) return root2.raws.indent;
            var value;
            root2.walk(function(i) {
              var p = i.parent;
              if (p && p !== root2 && p.parent && p.parent === root2) {
                if (typeof i.raws.before !== "undefined") {
                  var parts = i.raws.before.split("\n");
                  value = parts[parts.length - 1];
                  value = value.replace(/[^\s]/g, "");
                  return false;
                }
              }
            });
            return value;
          };
          _proto.rawBeforeComment = function rawBeforeComment(root2, node) {
            var value;
            root2.walkComments(function(i) {
              if (typeof i.raws.before !== "undefined") {
                value = i.raws.before;
                if (value.indexOf("\n") !== -1) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            });
            if (typeof value === "undefined") {
              value = this.raw(node, null, "beforeDecl");
            } else if (value) {
              value = value.replace(/[^\s]/g, "");
            }
            return value;
          };
          _proto.rawBeforeDecl = function rawBeforeDecl(root2, node) {
            var value;
            root2.walkDecls(function(i) {
              if (typeof i.raws.before !== "undefined") {
                value = i.raws.before;
                if (value.indexOf("\n") !== -1) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            });
            if (typeof value === "undefined") {
              value = this.raw(node, null, "beforeRule");
            } else if (value) {
              value = value.replace(/[^\s]/g, "");
            }
            return value;
          };
          _proto.rawBeforeRule = function rawBeforeRule(root2) {
            var value;
            root2.walk(function(i) {
              if (i.nodes && (i.parent !== root2 || root2.first !== i)) {
                if (typeof i.raws.before !== "undefined") {
                  value = i.raws.before;
                  if (value.indexOf("\n") !== -1) {
                    value = value.replace(/[^\n]+$/, "");
                  }
                  return false;
                }
              }
            });
            if (value) value = value.replace(/[^\s]/g, "");
            return value;
          };
          _proto.rawBeforeClose = function rawBeforeClose(root2) {
            var value;
            root2.walk(function(i) {
              if (i.nodes && i.nodes.length > 0) {
                if (typeof i.raws.after !== "undefined") {
                  value = i.raws.after;
                  if (value.indexOf("\n") !== -1) {
                    value = value.replace(/[^\n]+$/, "");
                  }
                  return false;
                }
              }
            });
            if (value) value = value.replace(/[^\s]/g, "");
            return value;
          };
          _proto.rawBeforeOpen = function rawBeforeOpen(root2) {
            var value;
            root2.walk(function(i) {
              if (i.type !== "decl") {
                value = i.raws.between;
                if (typeof value !== "undefined") return false;
              }
            });
            return value;
          };
          _proto.rawColon = function rawColon(root2) {
            var value;
            root2.walkDecls(function(i) {
              if (typeof i.raws.between !== "undefined") {
                value = i.raws.between.replace(/[^\s:]/g, "");
                return false;
              }
            });
            return value;
          };
          _proto.beforeAfter = function beforeAfter(node, detect) {
            var value;
            if (node.type === "decl") {
              value = this.raw(node, null, "beforeDecl");
            } else if (node.type === "comment") {
              value = this.raw(node, null, "beforeComment");
            } else if (detect === "before") {
              value = this.raw(node, null, "beforeRule");
            } else {
              value = this.raw(node, null, "beforeClose");
            }
            var buf = node.parent;
            var depth = 0;
            while (buf && buf.type !== "root") {
              depth += 1;
              buf = buf.parent;
            }
            if (value.indexOf("\n") !== -1) {
              var indent = this.raw(node, null, "indent");
              if (indent.length) {
                for (var step = 0; step < depth; step++) {
                  value += indent;
                }
              }
            }
            return value;
          };
          _proto.rawValue = function rawValue(node, prop2) {
            var value = node[prop2];
            var raw = node.raws[prop2];
            if (raw && raw.value === value) {
              return raw.raw;
            }
            return value;
          };
          return Stringifier2;
        })();
        var _default2 = Stringifier;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, {}], 188: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var _stringifier = _interopRequireDefault(require2("./stringifier"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { "default": obj };
        }
        function stringify(node, builder) {
          var str = new _stringifier["default"](builder);
          str.stringify(node);
        }
        var _default2 = stringify;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, { "./stringifier": 187 }], 189: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = tokenizer2;
        var SINGLE_QUOTE = "'".charCodeAt(0);
        var DOUBLE_QUOTE = '"'.charCodeAt(0);
        var BACKSLASH = "\\".charCodeAt(0);
        var SLASH = "/".charCodeAt(0);
        var NEWLINE = "\n".charCodeAt(0);
        var SPACE = " ".charCodeAt(0);
        var FEED = "\f".charCodeAt(0);
        var TAB = "	".charCodeAt(0);
        var CR = "\r".charCodeAt(0);
        var OPEN_SQUARE = "[".charCodeAt(0);
        var CLOSE_SQUARE = "]".charCodeAt(0);
        var OPEN_PARENTHESES = "(".charCodeAt(0);
        var CLOSE_PARENTHESES = ")".charCodeAt(0);
        var OPEN_CURLY = "{".charCodeAt(0);
        var CLOSE_CURLY = "}".charCodeAt(0);
        var SEMICOLON = ";".charCodeAt(0);
        var ASTERISK = "*".charCodeAt(0);
        var COLON = ":".charCodeAt(0);
        var AT = "@".charCodeAt(0);
        var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
        var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
        var RE_BAD_BRACKET = /.[\\/("'\n]/;
        var RE_HEX_ESCAPE = /[a-f0-9]/i;
        function tokenizer2(input, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var css2 = input.css.valueOf();
          var ignore = options2.ignoreErrors;
          var code2, next2, quote, lines, last, content, escape2;
          var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
          var length = css2.length;
          var offset = -1;
          var line = 1;
          var pos = 0;
          var buffer = [];
          var returned = [];
          function position() {
            return pos;
          }
          function unclosed(what) {
            throw input.error("Unclosed " + what, line, pos - offset);
          }
          function endOfFile() {
            return returned.length === 0 && pos >= length;
          }
          function nextToken(opts) {
            if (returned.length) return returned.pop();
            if (pos >= length) return;
            var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
            code2 = css2.charCodeAt(pos);
            if (code2 === NEWLINE || code2 === FEED || code2 === CR && css2.charCodeAt(pos + 1) !== NEWLINE) {
              offset = pos;
              line += 1;
            }
            switch (code2) {
              case NEWLINE:
              case SPACE:
              case TAB:
              case CR:
              case FEED:
                next2 = pos;
                do {
                  next2 += 1;
                  code2 = css2.charCodeAt(next2);
                  if (code2 === NEWLINE) {
                    offset = next2;
                    line += 1;
                  }
                } while (code2 === SPACE || code2 === NEWLINE || code2 === TAB || code2 === CR || code2 === FEED);
                currentToken = ["space", css2.slice(pos, next2)];
                pos = next2 - 1;
                break;
              case OPEN_SQUARE:
              case CLOSE_SQUARE:
              case OPEN_CURLY:
              case CLOSE_CURLY:
              case COLON:
              case SEMICOLON:
              case CLOSE_PARENTHESES:
                var controlChar = String.fromCharCode(code2);
                currentToken = [controlChar, controlChar, line, pos - offset];
                break;
              case OPEN_PARENTHESES:
                prev = buffer.length ? buffer.pop()[1] : "";
                n = css2.charCodeAt(pos + 1);
                if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                  next2 = pos;
                  do {
                    escaped = false;
                    next2 = css2.indexOf(")", next2 + 1);
                    if (next2 === -1) {
                      if (ignore || ignoreUnclosed) {
                        next2 = pos;
                        break;
                      } else {
                        unclosed("bracket");
                      }
                    }
                    escapePos = next2;
                    while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                      escapePos -= 1;
                      escaped = !escaped;
                    }
                  } while (escaped);
                  currentToken = ["brackets", css2.slice(pos, next2 + 1), line, pos - offset, line, next2 - offset];
                  pos = next2;
                } else {
                  next2 = css2.indexOf(")", pos + 1);
                  content = css2.slice(pos, next2 + 1);
                  if (next2 === -1 || RE_BAD_BRACKET.test(content)) {
                    currentToken = ["(", "(", line, pos - offset];
                  } else {
                    currentToken = ["brackets", content, line, pos - offset, line, next2 - offset];
                    pos = next2;
                  }
                }
                break;
              case SINGLE_QUOTE:
              case DOUBLE_QUOTE:
                quote = code2 === SINGLE_QUOTE ? "'" : '"';
                next2 = pos;
                do {
                  escaped = false;
                  next2 = css2.indexOf(quote, next2 + 1);
                  if (next2 === -1) {
                    if (ignore || ignoreUnclosed) {
                      next2 = pos + 1;
                      break;
                    } else {
                      unclosed("string");
                    }
                  }
                  escapePos = next2;
                  while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                content = css2.slice(pos, next2 + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next2 - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                currentToken = ["string", css2.slice(pos, next2 + 1), line, pos - offset, nextLine, next2 - nextOffset];
                offset = nextOffset;
                line = nextLine;
                pos = next2;
                break;
              case AT:
                RE_AT_END.lastIndex = pos + 1;
                RE_AT_END.test(css2);
                if (RE_AT_END.lastIndex === 0) {
                  next2 = css2.length - 1;
                } else {
                  next2 = RE_AT_END.lastIndex - 2;
                }
                currentToken = ["at-word", css2.slice(pos, next2 + 1), line, pos - offset, line, next2 - offset];
                pos = next2;
                break;
              case BACKSLASH:
                next2 = pos;
                escape2 = true;
                while (css2.charCodeAt(next2 + 1) === BACKSLASH) {
                  next2 += 1;
                  escape2 = !escape2;
                }
                code2 = css2.charCodeAt(next2 + 1);
                if (escape2 && code2 !== SLASH && code2 !== SPACE && code2 !== NEWLINE && code2 !== TAB && code2 !== CR && code2 !== FEED) {
                  next2 += 1;
                  if (RE_HEX_ESCAPE.test(css2.charAt(next2))) {
                    while (RE_HEX_ESCAPE.test(css2.charAt(next2 + 1))) {
                      next2 += 1;
                    }
                    if (css2.charCodeAt(next2 + 1) === SPACE) {
                      next2 += 1;
                    }
                  }
                }
                currentToken = ["word", css2.slice(pos, next2 + 1), line, pos - offset, line, next2 - offset];
                pos = next2;
                break;
              default:
                if (code2 === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
                  next2 = css2.indexOf("*/", pos + 2) + 1;
                  if (next2 === 0) {
                    if (ignore || ignoreUnclosed) {
                      next2 = css2.length;
                    } else {
                      unclosed("comment");
                    }
                  }
                  content = css2.slice(pos, next2 + 1);
                  lines = content.split("\n");
                  last = lines.length - 1;
                  if (last > 0) {
                    nextLine = line + last;
                    nextOffset = next2 - lines[last].length;
                  } else {
                    nextLine = line;
                    nextOffset = offset;
                  }
                  currentToken = ["comment", content, line, pos - offset, nextLine, next2 - nextOffset];
                  offset = nextOffset;
                  line = nextLine;
                  pos = next2;
                } else {
                  RE_WORD_END.lastIndex = pos + 1;
                  RE_WORD_END.test(css2);
                  if (RE_WORD_END.lastIndex === 0) {
                    next2 = css2.length - 1;
                  } else {
                    next2 = RE_WORD_END.lastIndex - 2;
                  }
                  currentToken = ["word", css2.slice(pos, next2 + 1), line, pos - offset, line, next2 - offset];
                  buffer.push(currentToken);
                  pos = next2;
                }
                break;
            }
            pos++;
            return currentToken;
          }
          function back(token2) {
            returned.push(token2);
          }
          return { back, nextToken, endOfFile, position };
        }
        module3.exports = exports3["default"];
      }, {}], 190: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var vendor = {
          /**
          * Returns the vendor prefix extracted from an input string.
          *
          * @param {string} prop String with or without vendor prefix.
          *
          * @return {string} vendor prefix or empty string
          *
          * @example
          * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
          * postcss.vendor.prefix('tab-size')      //=> ''
          */
          prefix: function prefix(prop2) {
            var match = prop2.match(/^(-\w+-)/);
            if (match) {
              return match[0];
            }
            return "";
          },
          /**
          * Returns the input string stripped of its vendor prefix.
          *
          * @param {string} prop String with or without vendor prefix.
          *
          * @return {string} String name without vendor prefixes.
          *
          * @example
          * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
          */
          unprefixed: function unprefixed(prop2) {
            return prop2.replace(/^-\w+-/, "");
          }
        };
        var _default2 = vendor;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, {}], 191: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = warnOnce;
        var printed = {};
        function warnOnce(message) {
          if (printed[message]) return;
          printed[message] = true;
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
        }
        module3.exports = exports3["default"];
      }, {}], 192: [function(require2, module3, exports3) {
        exports3.__esModule = true;
        exports3["default"] = void 0;
        var Warning = /* @__PURE__ */ (function() {
          function Warning2(text2, opts) {
            if (opts === void 0) {
              opts = {};
            }
            this.type = "warning";
            this.text = text2;
            if (opts.node && opts.node.source) {
              var pos = opts.node.positionBy(opts);
              this.line = pos.line;
              this.column = pos.column;
            }
            for (var opt in opts) {
              this[opt] = opts[opt];
            }
          }
          var _proto = Warning2.prototype;
          _proto.toString = function toString() {
            if (this.node) {
              return this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message;
            }
            if (this.plugin) {
              return this.plugin + ": " + this.text;
            }
            return this.text;
          };
          return Warning2;
        })();
        var _default2 = Warning;
        exports3["default"] = _default2;
        module3.exports = exports3["default"];
      }, {}], 193: [function(require2, module3, exports3) {
        var process2 = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker2) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker2);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker2);
          }
          try {
            return cachedClearTimeout(marker2);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker2);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker2);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process2.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process2.title = "browser";
        process2.browser = true;
        process2.env = {};
        process2.argv = [];
        process2.version = "";
        process2.versions = {};
        function noop() {
        }
        process2.on = noop;
        process2.addListener = noop;
        process2.once = noop;
        process2.off = noop;
        process2.removeListener = noop;
        process2.removeAllListeners = noop;
        process2.emit = noop;
        process2.prependListener = noop;
        process2.prependOnceListener = noop;
        process2.listeners = function(name) {
          return [];
        };
        process2.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process2.cwd = function() {
          return "/";
        };
        process2.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process2.umask = function() {
          return 0;
        };
      }, {}], 194: [function(require2, module3, exports3) {
        (function(global2) {
          (function(root2) {
            var freeExports = _typeof(exports3) == "object" && exports3 && !exports3.nodeType && exports3;
            var freeModule = _typeof(module3) == "object" && module3 && !module3.nodeType && module3;
            var freeGlobal = _typeof(global2) == "object" && global2;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
              root2 = freeGlobal;
            }
            var punycode2, maxInt2 = 2147483647, base2 = 36, tMin2 = 1, tMax2 = 26, skew2 = 38, damp2 = 700, initialBias2 = 72, initialN2 = 128, delimiter2 = "-", regexPunycode2 = /^xn--/, regexNonASCII2 = /[^\x20-\x7E]/, regexSeparators2 = /[\x2E\u3002\uFF0E\uFF61]/g, errors2 = { "overflow": "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, baseMinusTMin2 = base2 - tMin2, floor2 = Math.floor, stringFromCharCode2 = String.fromCharCode, key;
            function error2(type) {
              throw new RangeError(errors2[type]);
            }
            function map2(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }
            function mapDomain2(string, fn) {
              var parts = string.split("@");
              var result = "";
              if (parts.length > 1) {
                result = parts[0] + "@";
                string = parts[1];
              }
              string = string.replace(regexSeparators2, ".");
              var labels = string.split(".");
              var encoded = map2(labels, fn).join(".");
              return result + encoded;
            }
            function ucs2decode2(string) {
              var output2 = [], counter = 0, length = string.length, value, extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                  extra = string.charCodeAt(counter++);
                  if ((extra & 64512) == 56320) {
                    output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                  } else {
                    output2.push(value);
                    counter--;
                  }
                } else {
                  output2.push(value);
                }
              }
              return output2;
            }
            function ucs2encode2(array) {
              return map2(array, function(value) {
                var output2 = "";
                if (value > 65535) {
                  value -= 65536;
                  output2 += stringFromCharCode2(value >>> 10 & 1023 | 55296);
                  value = 56320 | value & 1023;
                }
                output2 += stringFromCharCode2(value);
                return output2;
              }).join("");
            }
            function basicToDigit2(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base2;
            }
            function digitToBasic2(digit, flag) {
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            function adapt2(delta2, numPoints, firstTime) {
              var k = 0;
              delta2 = firstTime ? floor2(delta2 / damp2) : delta2 >> 1;
              delta2 += floor2(delta2 / numPoints);
              for (
                ;
                /* no initialization */
                delta2 > baseMinusTMin2 * tMax2 >> 1;
                k += base2
              ) {
                delta2 = floor2(delta2 / baseMinusTMin2);
              }
              return floor2(k + (baseMinusTMin2 + 1) * delta2 / (delta2 + skew2));
            }
            function decode2(input) {
              var output2 = [], inputLength = input.length, out, i = 0, n = initialN2, bias = initialBias2, basic, j, index, oldi, w, k, digit, t, baseMinusT;
              basic = input.lastIndexOf(delimiter2);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 128) {
                  error2("not-basic");
                }
                output2.push(input.charCodeAt(j));
              }
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                for (
                  oldi = i, w = 1, k = base2;
                  ;
                  /* no condition */
                  k += base2
                ) {
                  if (index >= inputLength) {
                    error2("invalid-input");
                  }
                  digit = basicToDigit2(input.charCodeAt(index++));
                  if (digit >= base2 || digit > floor2((maxInt2 - i) / w)) {
                    error2("overflow");
                  }
                  i += digit * w;
                  t = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base2 - t;
                  if (w > floor2(maxInt2 / baseMinusT)) {
                    error2("overflow");
                  }
                  w *= baseMinusT;
                }
                out = output2.length + 1;
                bias = adapt2(i - oldi, out, oldi == 0);
                if (floor2(i / out) > maxInt2 - n) {
                  error2("overflow");
                }
                n += floor2(i / out);
                i %= out;
                output2.splice(i++, 0, n);
              }
              return ucs2encode2(output2);
            }
            function encode2(input) {
              var n, delta2, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output2 = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
              input = ucs2decode2(input);
              inputLength = input.length;
              n = initialN2;
              delta2 = 0;
              bias = initialBias2;
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 128) {
                  output2.push(stringFromCharCode2(currentValue));
                }
              }
              handledCPCount = basicLength = output2.length;
              if (basicLength) {
                output2.push(delimiter2);
              }
              while (handledCPCount < inputLength) {
                for (m = maxInt2, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor2((maxInt2 - delta2) / handledCPCountPlusOne)) {
                  error2("overflow");
                }
                delta2 += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta2 > maxInt2) {
                    error2("overflow");
                  }
                  if (currentValue == n) {
                    for (
                      q = delta2, k = base2;
                      ;
                      /* no condition */
                      k += base2
                    ) {
                      t = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base2 - t;
                      output2.push(stringFromCharCode2(digitToBasic2(t + qMinusT % baseMinusT, 0)));
                      q = floor2(qMinusT / baseMinusT);
                    }
                    output2.push(stringFromCharCode2(digitToBasic2(q, 0)));
                    bias = adapt2(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta2 = 0;
                    ++handledCPCount;
                  }
                }
                ++delta2;
                ++n;
              }
              return output2.join("");
            }
            function toUnicode2(input) {
              return mapDomain2(input, function(string) {
                return regexPunycode2.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
              });
            }
            function toASCII2(input) {
              return mapDomain2(input, function(string) {
                return regexNonASCII2.test(string) ? "xn--" + encode2(string) : string;
              });
            }
            punycode2 = {
              /**
              * A string representing the current Punycode.js version number.
              * @memberOf punycode
              * @type String
              */
              "version": "1.4.1",
              /**
              * An object of methods to convert from JavaScript's internal character
              * representation (UCS-2) to Unicode code points, and back.
              * @see <https://mathiasbynens.be/notes/javascript-encoding>
              * @memberOf punycode
              * @type Object
              */
              "ucs2": { "decode": ucs2decode2, "encode": ucs2encode2 },
              "decode": decode2,
              "encode": encode2,
              "toASCII": toASCII2,
              "toUnicode": toUnicode2
            };
            if (freeExports && freeModule) {
              if (module3.exports == freeExports) {
                freeModule.exports = punycode2;
              } else {
                for (key in punycode2) {
                  punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
                }
              }
            } else {
              root2.punycode = punycode2;
            }
          })(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 195: [function(require2, module3, exports3) {
        function hasOwnProperty(obj, prop2) {
          return Object.prototype.hasOwnProperty.call(obj, prop2);
        }
        module3.exports = function(qs, sep, eq, options2) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1e3;
          if (options2 && typeof options2.maxKeys === "number") {
            maxKeys = options2.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }, {}], 196: [function(require2, module3, exports3) {
        var stringifyPrimitive = function stringifyPrimitive2(v) {
          switch (_typeof(v)) {
            case "string":
              return v;
            case "boolean":
              return v ? "true" : "false";
            case "number":
              return isFinite(v) ? v : "";
            default:
              return "";
          }
        };
        module3.exports = function(obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (_typeof(obj) === "object") {
            return map2(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map2(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name) return "";
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map2(xs, f) {
          if (xs.map) return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
          }
          return res;
        };
      }, {}], 197: [function(require2, module3, exports3) {
        exports3.decode = exports3.parse = require2("./decode");
        exports3.encode = exports3.stringify = require2("./encode");
      }, { "./decode": 195, "./encode": 196 }], 198: [function(require2, module3, exports3) {
        var util = require2("./util");
        var has2 = Object.prototype.hasOwnProperty;
        var hasNativeMap = typeof Map !== "undefined";
        function ArraySet() {
          this._array = [];
          this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        }
        ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
          var set = new ArraySet();
          for (var i = 0, len = aArray.length; i < len; i++) {
            set.add(aArray[i], aAllowDuplicates);
          }
          return set;
        };
        ArraySet.prototype.size = function ArraySet_size() {
          return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        };
        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
          var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
          var isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr);
          var idx = this._array.length;
          if (!isDuplicate || aAllowDuplicates) {
            this._array.push(aStr);
          }
          if (!isDuplicate) {
            if (hasNativeMap) {
              this._set.set(aStr, idx);
            } else {
              this._set[sStr] = idx;
            }
          }
        };
        ArraySet.prototype.has = function ArraySet_has(aStr) {
          if (hasNativeMap) {
            return this._set.has(aStr);
          } else {
            var sStr = util.toSetString(aStr);
            return has2.call(this._set, sStr);
          }
        };
        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
          if (hasNativeMap) {
            var idx = this._set.get(aStr);
            if (idx >= 0) {
              return idx;
            }
          } else {
            var sStr = util.toSetString(aStr);
            if (has2.call(this._set, sStr)) {
              return this._set[sStr];
            }
          }
          throw new Error('"' + aStr + '" is not in the set.');
        };
        ArraySet.prototype.at = function ArraySet_at(aIdx) {
          if (aIdx >= 0 && aIdx < this._array.length) {
            return this._array[aIdx];
          }
          throw new Error("No element indexed by " + aIdx);
        };
        ArraySet.prototype.toArray = function ArraySet_toArray() {
          return this._array.slice();
        };
        exports3.ArraySet = ArraySet;
      }, { "./util": 207 }], 199: [function(require2, module3, exports3) {
        var base64 = require2("./base64");
        var VLQ_BASE_SHIFT = 5;
        var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
        var VLQ_BASE_MASK = VLQ_BASE - 1;
        var VLQ_CONTINUATION_BIT = VLQ_BASE;
        function toVLQSigned(aValue) {
          return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }
        function fromVLQSigned(aValue) {
          var isNegative = (aValue & 1) === 1;
          var shifted = aValue >> 1;
          return isNegative ? -shifted : shifted;
        }
        exports3.encode = function base64VLQ_encode(aValue) {
          var encoded = "";
          var digit;
          var vlq = toVLQSigned(aValue);
          do {
            digit = vlq & VLQ_BASE_MASK;
            vlq >>>= VLQ_BASE_SHIFT;
            if (vlq > 0) {
              digit |= VLQ_CONTINUATION_BIT;
            }
            encoded += base64.encode(digit);
          } while (vlq > 0);
          return encoded;
        };
        exports3.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
          var strLen = aStr.length;
          var result = 0;
          var shift = 0;
          var continuation, digit;
          do {
            if (aIndex >= strLen) {
              throw new Error("Expected more digits in base 64 VLQ value.");
            }
            digit = base64.decode(aStr.charCodeAt(aIndex++));
            if (digit === -1) {
              throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
            }
            continuation = !!(digit & VLQ_CONTINUATION_BIT);
            digit &= VLQ_BASE_MASK;
            result = result + (digit << shift);
            shift += VLQ_BASE_SHIFT;
          } while (continuation);
          aOutParam.value = fromVLQSigned(result);
          aOutParam.rest = aIndex;
        };
      }, { "./base64": 200 }], 200: [function(require2, module3, exports3) {
        var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        exports3.encode = function(number) {
          if (0 <= number && number < intToCharMap.length) {
            return intToCharMap[number];
          }
          throw new TypeError("Must be between 0 and 63: " + number);
        };
        exports3.decode = function(charCode) {
          var bigA = 65;
          var bigZ = 90;
          var littleA = 97;
          var littleZ = 122;
          var zero2 = 48;
          var nine = 57;
          var plus2 = 43;
          var slash = 47;
          var littleOffset = 26;
          var numberOffset = 52;
          if (bigA <= charCode && charCode <= bigZ) {
            return charCode - bigA;
          }
          if (littleA <= charCode && charCode <= littleZ) {
            return charCode - littleA + littleOffset;
          }
          if (zero2 <= charCode && charCode <= nine) {
            return charCode - zero2 + numberOffset;
          }
          if (charCode == plus2) {
            return 62;
          }
          if (charCode == slash) {
            return 63;
          }
          return -1;
        };
      }, {}], 201: [function(require2, module3, exports3) {
        exports3.GREATEST_LOWER_BOUND = 1;
        exports3.LEAST_UPPER_BOUND = 2;
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
          var mid2 = Math.floor((aHigh - aLow) / 2) + aLow;
          var cmp = aCompare(aNeedle, aHaystack[mid2], true);
          if (cmp === 0) {
            return mid2;
          } else if (cmp > 0) {
            if (aHigh - mid2 > 1) {
              return recursiveSearch(mid2, aHigh, aNeedle, aHaystack, aCompare, aBias);
            }
            if (aBias == exports3.LEAST_UPPER_BOUND) {
              return aHigh < aHaystack.length ? aHigh : -1;
            } else {
              return mid2;
            }
          } else {
            if (mid2 - aLow > 1) {
              return recursiveSearch(aLow, mid2, aNeedle, aHaystack, aCompare, aBias);
            }
            if (aBias == exports3.LEAST_UPPER_BOUND) {
              return mid2;
            } else {
              return aLow < 0 ? -1 : aLow;
            }
          }
        }
        exports3.search = function search(aNeedle, aHaystack, aCompare, aBias) {
          if (aHaystack.length === 0) {
            return -1;
          }
          var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports3.GREATEST_LOWER_BOUND);
          if (index < 0) {
            return -1;
          }
          while (index - 1 >= 0) {
            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
              break;
            }
            --index;
          }
          return index;
        };
      }, {}], 202: [function(require2, module3, exports3) {
        var util = require2("./util");
        function generatedPositionAfter(mappingA, mappingB) {
          var lineA = mappingA.generatedLine;
          var lineB = mappingB.generatedLine;
          var columnA = mappingA.generatedColumn;
          var columnB = mappingB.generatedColumn;
          return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
        }
        function MappingList() {
          this._array = [];
          this._sorted = true;
          this._last = { generatedLine: -1, generatedColumn: 0 };
        }
        MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        };
        MappingList.prototype.add = function MappingList_add(aMapping) {
          if (generatedPositionAfter(this._last, aMapping)) {
            this._last = aMapping;
            this._array.push(aMapping);
          } else {
            this._sorted = false;
            this._array.push(aMapping);
          }
        };
        MappingList.prototype.toArray = function MappingList_toArray() {
          if (!this._sorted) {
            this._array.sort(util.compareByGeneratedPositionsInflated);
            this._sorted = true;
          }
          return this._array;
        };
        exports3.MappingList = MappingList;
      }, { "./util": 207 }], 203: [function(require2, module3, exports3) {
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y];
          ary[y] = temp;
        }
        function randomIntInRange(low, high) {
          return Math.round(low + Math.random() * (high - low));
        }
        function doQuickSort(ary, comparator, p, r) {
          if (p < r) {
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            for (var j = p; j < r; j++) {
              if (comparator(ary[j], pivot) <= 0) {
                i += 1;
                swap(ary, i, j);
              }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
          }
        }
        exports3.quickSort = function(ary, comparator) {
          doQuickSort(ary, comparator, 0, ary.length - 1);
        };
      }, {}], 204: [function(require2, module3, exports3) {
        var util = require2("./util");
        var binarySearch = require2("./binary-search");
        var ArraySet = require2("./array-set").ArraySet;
        var base64VLQ = require2("./base64-vlq");
        var quickSort = require2("./quick-sort").quickSort;
        function SourceMapConsumer(aSourceMap, aSourceMapURL) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
        }
        SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
          return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
        };
        SourceMapConsumer.prototype._version = 3;
        SourceMapConsumer.prototype.__generatedMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function get() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        } });
        SourceMapConsumer.prototype.__originalMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function get() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        } });
        SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        };
        SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        };
        SourceMapConsumer.GENERATED_ORDER = 1;
        SourceMapConsumer.ORIGINAL_ORDER = 2;
        SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
        SourceMapConsumer.LEAST_UPPER_BOUND = 2;
        SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order2 = aOrder || SourceMapConsumer.GENERATED_ORDER;
          var mappings;
          switch (order2) {
            case SourceMapConsumer.GENERATED_ORDER:
              mappings = this._generatedMappings;
              break;
            case SourceMapConsumer.ORIGINAL_ORDER:
              mappings = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var sourceRoot = this.sourceRoot;
          mappings.map(function(mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
            return { source, generatedLine: mapping.generatedLine, generatedColumn: mapping.generatedColumn, originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name: mapping.name === null ? null : this._names.at(mapping.name) };
          }, this).forEach(aCallback, context);
        };
        SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
          var line = util.getArg(aArgs, "line");
          var needle = { source: util.getArg(aArgs, "source"), originalLine: line, originalColumn: util.getArg(aArgs, "column", 0) };
          needle.source = this._findSourceIndex(needle.source);
          if (needle.source < 0) {
            return [];
          }
          var mappings = [];
          var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (aArgs.column === void 0) {
              var originalLine = mapping.originalLine;
              while (mapping && mapping.originalLine === originalLine) {
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) });
                mapping = this._originalMappings[++index];
              }
            } else {
              var originalColumn = mapping.originalColumn;
              while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) });
                mapping = this._originalMappings[++index];
              }
            }
          }
          return mappings;
        };
        exports3.SourceMapConsumer = SourceMapConsumer;
        function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          var version = util.getArg(sourceMap, "version");
          var sources = util.getArg(sourceMap, "sources");
          var names = util.getArg(sourceMap, "names", []);
          var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          var mappings = util.getArg(sourceMap, "mappings");
          var file = util.getArg(sourceMap, "file", null);
          if (version != this._version) {
            throw new Error("Unsupported version: " + version);
          }
          if (sourceRoot) {
            sourceRoot = util.normalize(sourceRoot);
          }
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          });
          this._names = ArraySet.fromArray(names.map(String), true);
          this._sources = ArraySet.fromArray(sources, true);
          this._absoluteSources = this._sources.toArray().map(function(s) {
            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
          });
          this.sourceRoot = sourceRoot;
          this.sourcesContent = sourcesContent;
          this._mappings = mappings;
          this._sourceMapURL = aSourceMapURL;
          this.file = file;
        }
        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
        BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
          var relativeSource = aSource;
          if (this.sourceRoot != null) {
            relativeSource = util.relative(this.sourceRoot, relativeSource);
          }
          if (this._sources.has(relativeSource)) {
            return this._sources.indexOf(relativeSource);
          }
          var i;
          for (i = 0; i < this._absoluteSources.length; ++i) {
            if (this._absoluteSources[i] == aSource) {
              return i;
            }
          }
          return -1;
        };
        BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
          var smc = Object.create(BasicSourceMapConsumer.prototype);
          var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
          smc.file = aSourceMap._file;
          smc._sourceMapURL = aSourceMapURL;
          smc._absoluteSources = smc._sources.toArray().map(function(s) {
            return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
          });
          var generatedMappings = aSourceMap._mappings.toArray().slice();
          var destGeneratedMappings = smc.__generatedMappings = [];
          var destOriginalMappings = smc.__originalMappings = [];
          for (var i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i];
            var destMapping = new Mapping();
            destMapping.generatedLine = srcMapping.generatedLine;
            destMapping.generatedColumn = srcMapping.generatedColumn;
            if (srcMapping.source) {
              destMapping.source = sources.indexOf(srcMapping.source);
              destMapping.originalLine = srcMapping.originalLine;
              destMapping.originalColumn = srcMapping.originalColumn;
              if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
              }
              destOriginalMappings.push(destMapping);
            }
            destGeneratedMappings.push(destMapping);
          }
          quickSort(smc.__originalMappings, util.compareByOriginalPositions);
          return smc;
        };
        BasicSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function get() {
          return this._absoluteSources.slice();
        } });
        function Mapping() {
          this.generatedLine = 0;
          this.generatedColumn = 0;
          this.source = null;
          this.originalLine = null;
          this.originalColumn = null;
          this.name = null;
        }
        BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var length = aStr.length;
          var index = 0;
          var cachedSegments = {};
          var temp = {};
          var originalMappings = [];
          var generatedMappings = [];
          var mapping, str, segment, end, value;
          while (index < length) {
            if (aStr.charAt(index) === ";") {
              generatedLine++;
              index++;
              previousGeneratedColumn = 0;
            } else if (aStr.charAt(index) === ",") {
              index++;
            } else {
              mapping = new Mapping();
              mapping.generatedLine = generatedLine;
              for (end = index; end < length; end++) {
                if (this._charIsMappingSeparator(aStr, end)) {
                  break;
                }
              }
              str = aStr.slice(index, end);
              segment = cachedSegments[str];
              if (segment) {
                index += str.length;
              } else {
                segment = [];
                while (index < end) {
                  base64VLQ.decode(aStr, index, temp);
                  value = temp.value;
                  index = temp.rest;
                  segment.push(value);
                }
                if (segment.length === 2) {
                  throw new Error("Found a source, but no line and column");
                }
                if (segment.length === 3) {
                  throw new Error("Found a source and line, but no column");
                }
                cachedSegments[str] = segment;
              }
              mapping.generatedColumn = previousGeneratedColumn + segment[0];
              previousGeneratedColumn = mapping.generatedColumn;
              if (segment.length > 1) {
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                mapping.originalLine += 1;
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                  mapping.name = previousName + segment[4];
                  previousName += segment[4];
                }
              }
              generatedMappings.push(mapping);
              if (typeof mapping.originalLine === "number") {
                originalMappings.push(mapping);
              }
            }
          }
          quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
          this.__generatedMappings = generatedMappings;
          quickSort(originalMappings, util.compareByOriginalPositions);
          this.__originalMappings = originalMappings;
        };
        BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
          }
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
        BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
            mapping.lastGeneratedColumn = Infinity;
          }
        };
        BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") };
          var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, "source", null);
              if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
              }
              var name = util.getArg(mapping, "name", null);
              if (name !== null) {
                name = this._names.at(name);
              }
              return { source, line: util.getArg(mapping, "originalLine", null), column: util.getArg(mapping, "originalColumn", null), name };
            }
          }
          return { source: null, line: null, column: null, name: null };
        };
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
          if (!this.sourcesContent) {
            return false;
          }
          return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc2) {
            return sc2 == null;
          });
        };
        BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          if (!this.sourcesContent) {
            return null;
          }
          var index = this._findSourceIndex(aSource);
          if (index >= 0) {
            return this.sourcesContent[index];
          }
          var relativeSource = aSource;
          if (this.sourceRoot != null) {
            relativeSource = util.relative(this.sourceRoot, relativeSource);
          }
          var url;
          if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
            var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
            if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            }
            if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
            }
          }
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + relativeSource + '" is not in the SourceMap.');
          }
        };
        BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
          var source = util.getArg(aArgs, "source");
          source = this._findSourceIndex(source);
          if (source < 0) {
            return { line: null, column: null, lastColumn: null };
          }
          var needle = { source, originalLine: util.getArg(aArgs, "line"), originalColumn: util.getArg(aArgs, "column") };
          var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (mapping.source === needle.source) {
              return { line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) };
            }
          }
          return { line: null, column: null, lastColumn: null };
        };
        exports3.BasicSourceMapConsumer = BasicSourceMapConsumer;
        function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
          var sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          var version = util.getArg(sourceMap, "version");
          var sections = util.getArg(sourceMap, "sections");
          if (version != this._version) {
            throw new Error("Unsupported version: " + version);
          }
          this._sources = new ArraySet();
          this._names = new ArraySet();
          var lastOffset = { line: -1, column: 0 };
          this._sections = sections.map(function(s) {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            var offset = util.getArg(s, "offset");
            var offsetLine = util.getArg(offset, "line");
            var offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            return { generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            }, consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL) };
          });
        }
        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
        IndexedSourceMapConsumer.prototype._version = 3;
        Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function get() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        } });
        IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") };
          var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          });
          var section = this._sections[sectionIndex];
          if (!section) {
            return { source: null, line: null, column: null, name: null };
          }
          return section.consumer.originalPositionFor({ line: needle.generatedLine - (section.generatedOffset.generatedLine - 1), column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), bias: aArgs.bias });
        };
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
          return this._sections.every(function(s) {
            return s.consumer.hasContentsOfAllSources();
          });
        };
        IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var content = section.consumer.sourceContentFor(aSource, true);
            if (content) {
              return content;
            }
          }
          if (nullOnMissing) {
            return null;
          } else {
            throw new Error('"' + aSource + '" is not in the SourceMap.');
          }
        };
        IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
              continue;
            }
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = { line: generatedPosition.line + (section.generatedOffset.generatedLine - 1), column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0) };
              return ret;
            }
          }
          return { line: null, column: null };
        };
        IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          this.__generatedMappings = [];
          this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            var sectionMappings = section.consumer._generatedMappings;
            for (var j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[j];
              var source = section.consumer._sources.at(mapping.source);
              source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
              this._sources.add(source);
              source = this._sources.indexOf(source);
              var name = null;
              if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
              }
              var adjustedMapping = { source, generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1), generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name };
              this.__generatedMappings.push(adjustedMapping);
              if (typeof adjustedMapping.originalLine === "number") {
                this.__originalMappings.push(adjustedMapping);
              }
            }
          }
          quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
          quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
        exports3.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
      }, { "./array-set": 198, "./base64-vlq": 199, "./binary-search": 201, "./quick-sort": 203, "./util": 207 }], 205: [function(require2, module3, exports3) {
        var base64VLQ = require2("./base64-vlq");
        var util = require2("./util");
        var ArraySet = require2("./array-set").ArraySet;
        var MappingList = require2("./mapping-list").MappingList;
        function SourceMapGenerator(aArgs) {
          if (!aArgs) {
            aArgs = {};
          }
          this._file = util.getArg(aArgs, "file", null);
          this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
          this._skipValidation = util.getArg(aArgs, "skipValidation", false);
          this._sources = new ArraySet();
          this._names = new ArraySet();
          this._mappings = new MappingList();
          this._sourcesContents = null;
        }
        SourceMapGenerator.prototype._version = 3;
        SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({ file: aSourceMapConsumer.file, sourceRoot });
          aSourceMapConsumer.eachMapping(function(mapping) {
            var newMapping = { generated: { line: mapping.generatedLine, column: mapping.generatedColumn } };
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
              newMapping.original = { line: mapping.originalLine, column: mapping.originalColumn };
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var sourceRelative = sourceFile;
            if (sourceRoot !== null) {
              sourceRelative = util.relative(sourceRoot, sourceFile);
            }
            if (!generator._sources.has(sourceRelative)) {
              generator._sources.add(sourceRelative);
            }
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
        SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, "generated");
          var original = util.getArg(aArgs, "original", null);
          var source = util.getArg(aArgs, "source", null);
          var name = util.getArg(aArgs, "name", null);
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
          if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
              this._sources.add(source);
            }
          }
          if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
              this._names.add(name);
            }
          }
          this._mappings.add({ generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name });
        };
        SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
          if (aSourceContent != null) {
            if (!this._sourcesContents) {
              this._sourcesContents = /* @__PURE__ */ Object.create(null);
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
        SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          var newSources = new ArraySet();
          var newNames = new ArraySet();
          this._mappings.unsortedForEach(function(mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({ line: mapping.originalLine, column: mapping.originalColumn });
              if (original.source != null) {
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
          }, this);
          this._sources = newSources;
          this._names = newNames;
          aSourceMapConsumer.sources.forEach(function(sourceFile2) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile2 = util.join(aSourceMapPath, sourceFile2);
              }
              if (sourceRoot != null) {
                sourceFile2 = util.relative(sourceRoot, sourceFile2);
              }
              this.setSourceContent(sourceFile2, content);
            }
          }, this);
        };
        SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
          if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          }
          if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
            return;
          } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
            return;
          } else {
            throw new Error("Invalid mapping: " + JSON.stringify({ generated: aGenerated, source: aSource, original: aOriginal, name: aName }));
          }
        };
        SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = "";
          var next2;
          var mapping;
          var nameIdx;
          var sourceIdx;
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
            next2 = "";
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                next2 += ";";
                previousGeneratedLine++;
              }
            } else {
              if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                  continue;
                }
                next2 += ",";
              }
            }
            next2 += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
            if (mapping.source != null) {
              sourceIdx = this._sources.indexOf(mapping.source);
              next2 += base64VLQ.encode(sourceIdx - previousSource);
              previousSource = sourceIdx;
              next2 += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
              next2 += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
              if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next2 += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
            result += next2;
          }
          return result;
        };
        SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function(source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
          }, this);
        };
        SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
          var map2 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
          if (this._file != null) {
            map2.file = this._file;
          }
          if (this._sourceRoot != null) {
            map2.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
          }
          return map2;
        };
        SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
        exports3.SourceMapGenerator = SourceMapGenerator;
      }, { "./array-set": 198, "./base64-vlq": 199, "./mapping-list": 202, "./util": 207 }], 206: [function(require2, module3, exports3) {
        var SourceMapGenerator = require2("./source-map-generator").SourceMapGenerator;
        var util = require2("./util");
        var REGEX_NEWLINE = /(\r?\n)/;
        var NEWLINE_CODE = 10;
        var isSourceNode = "$$$isSourceNode$$$";
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
          this.children = [];
          this.sourceContents = {};
          this.line = aLine == null ? null : aLine;
          this.column = aColumn == null ? null : aColumn;
          this.source = aSource == null ? null : aSource;
          this.name = aName == null ? null : aName;
          this[isSourceNode] = true;
          if (aChunks != null) this.add(aChunks);
        }
        SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          var node = new SourceNode();
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var remainingLinesIndex = 0;
          var shiftNextLine = function shiftNextLine2() {
            var lineContents = getNextLine();
            var newLine = getNextLine() || "";
            return lineContents + newLine;
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
            }
          };
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
          var lastMapping = null;
          aSourceMapConsumer.eachMapping(function(mapping) {
            if (lastMapping !== null) {
              if (lastGeneratedLine < mapping.generatedLine) {
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
              } else {
                var nextLine = remainingLines[remainingLinesIndex] || "";
                var code2 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code2);
                lastMapping = mapping;
                return;
              }
            }
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          if (remainingLinesIndex < remainingLines.length) {
            if (lastMapping) {
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            node.add(remainingLines.splice(remainingLinesIndex).join(""));
          }
          aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
          return node;
          function addMappingWithCode(mapping, code2) {
            if (mapping === null || mapping.source === void 0) {
              node.add(code2);
            } else {
              var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
              node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code2, mapping.name));
            }
          }
        };
        SourceNode.prototype.add = function SourceNode_add(aChunk) {
          if (Array.isArray(aChunk)) {
            aChunk.forEach(function(chunk) {
              this.add(chunk);
            }, this);
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            if (aChunk) {
              this.children.push(aChunk);
            }
          } else {
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
          }
          return this;
        };
        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
          if (Array.isArray(aChunk)) {
            for (var i = aChunk.length - 1; i >= 0; i--) {
              this.prepend(aChunk[i]);
            }
          } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
            this.children.unshift(aChunk);
          } else {
            throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
          }
          return this;
        };
        SourceNode.prototype.walk = function SourceNode_walk(aFn) {
          var chunk;
          for (var i = 0, len = this.children.length; i < len; i++) {
            chunk = this.children[i];
            if (chunk[isSourceNode]) {
              chunk.walk(aFn);
            } else {
              if (chunk !== "") {
                aFn(chunk, { source: this.source, line: this.line, column: this.column, name: this.name });
              }
            }
          }
        };
        SourceNode.prototype.join = function SourceNode_join(aSep) {
          var newChildren;
          var i;
          var len = this.children.length;
          if (len > 0) {
            newChildren = [];
            for (i = 0; i < len - 1; i++) {
              newChildren.push(this.children[i]);
              newChildren.push(aSep);
            }
            newChildren.push(this.children[i]);
            this.children = newChildren;
          }
          return this;
        };
        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
          var lastChild = this.children[this.children.length - 1];
          if (lastChild[isSourceNode]) {
            lastChild.replaceRight(aPattern, aReplacement);
          } else if (typeof lastChild === "string") {
            this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
          } else {
            this.children.push("".replace(aPattern, aReplacement));
          }
          return this;
        };
        SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
        SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][isSourceNode]) {
              this.children[i].walkSourceContents(aFn);
            }
          }
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
        SourceNode.prototype.toString = function SourceNode_toString() {
          var str = "";
          this.walk(function(chunk) {
            str += chunk;
          });
          return str;
        };
        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
          var generated = { code: "", line: 1, column: 0 };
          var map2 = new SourceMapGenerator(aArgs);
          var sourceMappingActive = false;
          var lastOriginalSource = null;
          var lastOriginalLine = null;
          var lastOriginalColumn = null;
          var lastOriginalName = null;
          this.walk(function(chunk, original) {
            generated.code += chunk;
            if (original.source !== null && original.line !== null && original.column !== null) {
              if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map2.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name });
              }
              lastOriginalSource = original.source;
              lastOriginalLine = original.line;
              lastOriginalColumn = original.column;
              lastOriginalName = original.name;
              sourceMappingActive = true;
            } else if (sourceMappingActive) {
              map2.addMapping({ generated: { line: generated.line, column: generated.column } });
              lastOriginalSource = null;
              sourceMappingActive = false;
            }
            for (var idx = 0, length = chunk.length; idx < length; idx++) {
              if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                if (idx + 1 === length) {
                  lastOriginalSource = null;
                  sourceMappingActive = false;
                } else if (sourceMappingActive) {
                  map2.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name });
                }
              } else {
                generated.column++;
              }
            }
          });
          this.walkSourceContents(function(sourceFile, sourceContent) {
            map2.setSourceContent(sourceFile, sourceContent);
          });
          return { code: generated.code, map: map2 };
        };
        exports3.SourceNode = SourceNode;
      }, { "./source-map-generator": 205, "./util": 207 }], 207: [function(require2, module3, exports3) {
        function getArg(aArgs, aName, aDefaultValue) {
          if (aName in aArgs) {
            return aArgs[aName];
          } else if (arguments.length === 3) {
            return aDefaultValue;
          } else {
            throw new Error('"' + aName + '" is a required argument.');
          }
        }
        exports3.getArg = getArg;
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
          var match = aUrl.match(urlRegexp);
          if (!match) {
            return null;
          }
          return { scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5] };
        }
        exports3.urlParse = urlParse;
        function urlGenerate(aParsedUrl) {
          var url = "";
          if (aParsedUrl.scheme) {
            url += aParsedUrl.scheme + ":";
          }
          url += "//";
          if (aParsedUrl.auth) {
            url += aParsedUrl.auth + "@";
          }
          if (aParsedUrl.host) {
            url += aParsedUrl.host;
          }
          if (aParsedUrl.port) {
            url += ":" + aParsedUrl.port;
          }
          if (aParsedUrl.path) {
            url += aParsedUrl.path;
          }
          return url;
        }
        exports3.urlGenerate = urlGenerate;
        function normalize2(aPath) {
          var path = aPath;
          var url = urlParse(aPath);
          if (url) {
            if (!url.path) {
              return aPath;
            }
            path = url.path;
          }
          var isAbsolute = exports3.isAbsolute(path);
          var parts = path.split(/\/+/);
          for (var part2, up = 0, i = parts.length - 1; i >= 0; i--) {
            part2 = parts[i];
            if (part2 === ".") {
              parts.splice(i, 1);
            } else if (part2 === "..") {
              up++;
            } else if (up > 0) {
              if (part2 === "") {
                parts.splice(i + 1, up);
                up = 0;
              } else {
                parts.splice(i, 2);
                up--;
              }
            }
          }
          path = parts.join("/");
          if (path === "") {
            path = isAbsolute ? "/" : ".";
          }
          if (url) {
            url.path = path;
            return urlGenerate(url);
          }
          return path;
        }
        exports3.normalize = normalize2;
        function join2(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          if (aPath === "") {
            aPath = ".";
          }
          var aPathUrl = urlParse(aPath);
          var aRootUrl = urlParse(aRoot);
          if (aRootUrl) {
            aRoot = aRootUrl.path || "/";
          }
          if (aPathUrl && !aPathUrl.scheme) {
            if (aRootUrl) {
              aPathUrl.scheme = aRootUrl.scheme;
            }
            return urlGenerate(aPathUrl);
          }
          if (aPathUrl || aPath.match(dataUrlRegexp)) {
            return aPath;
          }
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
            aRootUrl.host = aPath;
            return urlGenerate(aRootUrl);
          }
          var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
          if (aRootUrl) {
            aRootUrl.path = joined;
            return urlGenerate(aRootUrl);
          }
          return joined;
        }
        exports3.join = join2;
        exports3.isAbsolute = function(aPath) {
          return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
        };
        function relative(aRoot, aPath) {
          if (aRoot === "") {
            aRoot = ".";
          }
          aRoot = aRoot.replace(/\/$/, "");
          var level = 0;
          while (aPath.indexOf(aRoot + "/") !== 0) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0) {
              return aPath;
            }
            aRoot = aRoot.slice(0, index);
            if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
              return aPath;
            }
            ++level;
          }
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports3.relative = relative;
        var supportsNullProto = (function() {
          var obj = /* @__PURE__ */ Object.create(null);
          return !("__proto__" in obj);
        })();
        function identity(s) {
          return s;
        }
        function toSetString(aStr) {
          if (isProtoString(aStr)) {
            return "$" + aStr;
          }
          return aStr;
        }
        exports3.toSetString = supportsNullProto ? identity : toSetString;
        function fromSetString(aStr) {
          if (isProtoString(aStr)) {
            return aStr.slice(1);
          }
          return aStr;
        }
        exports3.fromSetString = supportsNullProto ? identity : fromSetString;
        function isProtoString(s) {
          if (!s) {
            return false;
          }
          var length = s.length;
          if (length < 9) {
            return false;
          }
          if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
            return false;
          }
          for (var i = length - 10; i >= 0; i--) {
            if (s.charCodeAt(i) !== 36) {
              return false;
            }
          }
          return true;
        }
        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
          var cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0 || onlyCompareOriginal) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports3.compareByOriginalPositions = compareByOriginalPositions;
        function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0 || onlyCompareGenerated) {
            return cmp;
          }
          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports3.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
        function strcmp(aStr1, aStr2) {
          if (aStr1 === aStr2) {
            return 0;
          }
          if (aStr1 === null) {
            return 1;
          }
          if (aStr2 === null) {
            return -1;
          }
          if (aStr1 > aStr2) {
            return 1;
          }
          return -1;
        }
        function compareByGeneratedPositionsInflated(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.generatedColumn - mappingB.generatedColumn;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = strcmp(mappingA.source, mappingB.source);
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalLine - mappingB.originalLine;
          if (cmp !== 0) {
            return cmp;
          }
          cmp = mappingA.originalColumn - mappingB.originalColumn;
          if (cmp !== 0) {
            return cmp;
          }
          return strcmp(mappingA.name, mappingB.name);
        }
        exports3.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
        function parseSourceMapInput(str) {
          return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
        }
        exports3.parseSourceMapInput = parseSourceMapInput;
        function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
          sourceURL = sourceURL || "";
          if (sourceRoot) {
            if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
              sourceRoot += "/";
            }
            sourceURL = sourceRoot + sourceURL;
          }
          if (sourceMapURL) {
            var parsed = urlParse(sourceMapURL);
            if (!parsed) {
              throw new Error("sourceMapURL could not be parsed");
            }
            if (parsed.path) {
              var index = parsed.path.lastIndexOf("/");
              if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
              }
            }
            sourceURL = join2(urlGenerate(parsed), sourceURL);
          }
          return normalize2(sourceURL);
        }
        exports3.computeSourceURL = computeSourceURL;
      }, {}], 208: [function(require2, module3, exports3) {
        exports3.SourceMapGenerator = require2("./lib/source-map-generator").SourceMapGenerator;
        exports3.SourceMapConsumer = require2("./lib/source-map-consumer").SourceMapConsumer;
        exports3.SourceNode = require2("./lib/source-node").SourceNode;
      }, { "./lib/source-map-consumer": 204, "./lib/source-map-generator": 205, "./lib/source-node": 206 }], 209: [function(require2, module3, exports3) {
        var punycode2 = require2("punycode");
        var util = require2("./util");
        exports3.parse = urlParse;
        exports3.resolve = urlResolve;
        exports3.resolveObject = urlResolveObject;
        exports3.format = urlFormat;
        exports3.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = { "javascript": true, "javascript:": true }, hostlessProtocol = { "javascript": true, "javascript:": true }, slashedProtocol = { "http": true, "https": true, "ftp": true, "gopher": true, "file": true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, querystring = require2("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url;
          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + _typeof(url));
          }
          var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);
          var rest = url;
          rest = rest.trim();
          if (!slashesDenoteHost && url.split("#").length === 1) {
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
            }
            var auth, atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf("@");
            } else {
              atSign = rest.lastIndexOf("@", hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
            }
            if (hostEnd === -1) hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || "";
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part2 = hostparts[i];
                if (!part2) continue;
                if (!part2.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part2.length; j < k; j++) {
                    if (part2.charCodeAt(j) > 127) {
                      newpart += "x";
                    } else {
                      newpart += part2[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part2.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              this.hostname = punycode2.toASCII(this.hostname);
            }
            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1) continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          if (rest) this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (util.isString(obj)) obj = urlParse(obj);
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }
          var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }
          if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || query && "?" + query || "";
          if (protocol && protocol.substr(-1) !== ":") protocol += ":";
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }
          if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
          if (search && search.charAt(0) !== "?") search = "?" + search;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source) return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }
          result.hash = relative.hash;
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol") result[rkey] = relative[rkey];
            }
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift())) {
              }
              if (!relative.host) relative.host = "";
              if (!relative.hostname) relative.hostname = "";
              if (relPath[0] !== "") relPath.unshift("");
              if (relPath.length < 2) relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "") srcPath[0] = result.host;
              else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }
          if (isRelAbs) {
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }
          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }
          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }
          var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host) this.hostname = host;
        };
      }, { "./util": 210, "punycode": 194, "querystring": 197 }], 210: [function(require2, module3, exports3) {
        module3.exports = { isString: function isString(arg) {
          return typeof arg === "string";
        }, isObject: function isObject(arg) {
          return _typeof(arg) === "object" && arg !== null;
        }, isNull: function isNull(arg) {
          return arg === null;
        }, isNullOrUndefined: function isNullOrUndefined(arg) {
          return arg == null;
        } };
      }, {}], 211: [function(require2, module3, exports3) {
        var htmlparser = require2("htmlparser2");
        var quoteRegexp = require2("lodash/escapeRegExp");
        var cloneDeep = require2("lodash/cloneDeep");
        var mergeWith = require2("lodash/mergeWith");
        var isString = require2("lodash/isString");
        var isPlainObject = require2("lodash/isPlainObject");
        var parseSrcset = require2("parse-srcset");
        var postcss = require2("postcss");
        var url = require2("url");
        var mediaTags = ["img", "audio", "video", "picture", "svg", "object", "map", "iframe", "embed"];
        var vulnerableTags = ["script", "style"];
        function each(obj, cb) {
          if (obj) {
            Object.keys(obj).forEach(function(key) {
              cb(obj[key], key);
            });
          }
        }
        function has2(obj, key) {
          return {}.hasOwnProperty.call(obj, key);
        }
        function filter(a, cb) {
          var n = [];
          each(a, function(v) {
            if (cb(v)) {
              n.push(v);
            }
          });
          return n;
        }
        function isEmptyObject(obj) {
          for (var key in obj) {
            if (has2(obj, key)) {
              return false;
            }
          }
          return true;
        }
        function stringifySrcset(parsedSrcset) {
          return parsedSrcset.map(function(part2) {
            if (!part2.url) {
              throw new Error("URL missing");
            }
            return part2.url + (part2.w ? " ".concat(part2.w, "w") : "") + (part2.h ? " ".concat(part2.h, "h") : "") + (part2.d ? " ".concat(part2.d, "x") : "");
          }).join(", ");
        }
        module3.exports = sanitizeHtml2;
        var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
        function sanitizeHtml2(html2, options2, _recursing) {
          var result = "";
          var tempResult = "";
          function Frame(tag, attribs) {
            var that = this;
            this.tag = tag;
            this.attribs = attribs || {};
            this.tagPosition = result.length;
            this.text = "";
            this.mediaChildren = [];
            this.updateParentNodeText = function() {
              if (stack.length) {
                var parentFrame = stack[stack.length - 1];
                parentFrame.text += that.text;
              }
            };
            this.updateParentNodeMediaChildren = function() {
              if (stack.length && mediaTags.indexOf(this.tag) > -1) {
                var parentFrame = stack[stack.length - 1];
                parentFrame.mediaChildren.push(this.tag);
              }
            };
          }
          if (!options2) {
            options2 = sanitizeHtml2.defaults;
            options2.parser = htmlParserDefaults;
          } else {
            options2 = Object.assign({}, sanitizeHtml2.defaults, options2);
            if (options2.parser) {
              options2.parser = Object.assign({}, htmlParserDefaults, options2.parser);
            } else {
              options2.parser = htmlParserDefaults;
            }
          }
          vulnerableTags.forEach(function(tag) {
            if (options2.allowedTags && options2.allowedTags.indexOf(tag) > -1 && !options2.allowVulnerableTags) {
              console.warn("\n\nâš ï¸ Your `allowedTags` option includes, `".concat(tag, "`, which is inherently\nvulnerable to XSS attacks. Please remove it from `allowedTags`.\nOr, to disable this warning, add the `allowVulnerableTags` option\nand ensure you are accounting for this risk.\n\n"));
            }
          });
          var nonTextTagsArray = options2.nonTextTags || ["script", "style", "textarea", "option"];
          var allowedAttributesMap;
          var allowedAttributesGlobMap;
          if (options2.allowedAttributes) {
            allowedAttributesMap = {};
            allowedAttributesGlobMap = {};
            each(options2.allowedAttributes, function(attributes, tag) {
              allowedAttributesMap[tag] = [];
              var globRegex = [];
              attributes.forEach(function(obj) {
                if (isString(obj) && obj.indexOf("*") >= 0) {
                  globRegex.push(quoteRegexp(obj).replace(/\\\*/g, ".*"));
                } else {
                  allowedAttributesMap[tag].push(obj);
                }
              });
              allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
            });
          }
          var allowedClassesMap = {};
          each(options2.allowedClasses, function(classes, tag) {
            if (allowedAttributesMap) {
              if (!has2(allowedAttributesMap, tag)) {
                allowedAttributesMap[tag] = [];
              }
              allowedAttributesMap[tag].push("class");
            }
            allowedClassesMap[tag] = classes;
          });
          var transformTagsMap = {};
          var transformTagsAll;
          each(options2.transformTags, function(transform, tag) {
            var transFun;
            if (typeof transform === "function") {
              transFun = transform;
            } else if (typeof transform === "string") {
              transFun = sanitizeHtml2.simpleTransform(transform);
            }
            if (tag === "*") {
              transformTagsAll = transFun;
            } else {
              transformTagsMap[tag] = transFun;
            }
          });
          var depth;
          var stack;
          var skipMap;
          var transformMap;
          var skipText;
          var skipTextDepth;
          var addedText = false;
          initializeState();
          var parser = new htmlparser.Parser({ onopentag: function onopentag(name, attribs) {
            if (options2.enforceHtmlBoundary && name === "html") {
              initializeState();
            }
            if (skipText) {
              skipTextDepth++;
              return;
            }
            var frame = new Frame(name, attribs);
            stack.push(frame);
            var skip = false;
            var hasText = !!frame.text;
            var transformedTag;
            if (has2(transformTagsMap, name)) {
              transformedTag = transformTagsMap[name](name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (transformedTag.text !== void 0) {
                frame.innerText = transformedTag.text;
              }
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (transformTagsAll) {
              transformedTag = transformTagsAll(name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (options2.allowedTags && options2.allowedTags.indexOf(name) === -1 || options2.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap)) {
              skip = true;
              skipMap[depth] = true;
              if (options2.disallowedTagsMode === "discard") {
                if (nonTextTagsArray.indexOf(name) !== -1) {
                  skipText = true;
                  skipTextDepth = 1;
                }
              }
              skipMap[depth] = true;
            }
            depth++;
            if (skip) {
              if (options2.disallowedTagsMode === "discard") {
                return;
              }
              tempResult = result;
              result = "";
            }
            result += "<" + name;
            if (!allowedAttributesMap || has2(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
              each(attribs, function(value, a) {
                if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
                  delete frame.attribs[a];
                  return;
                }
                var parsed;
                var passedAllowedAttributesMapCheck = false;
                if (!allowedAttributesMap || has2(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has2(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
                  passedAllowedAttributesMapCheck = true;
                } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                  var _iterator10 = _createForOfIteratorHelper(allowedAttributesMap[name]), _step10;
                  try {
                    for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                      var o = _step10.value;
                      if (isPlainObject(o) && o.name && o.name === a) {
                        passedAllowedAttributesMapCheck = true;
                        var newValue = "";
                        if (o.multiple === true) {
                          var splitStrArray = value.split(" ");
                          var _iterator11 = _createForOfIteratorHelper(splitStrArray), _step11;
                          try {
                            for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                              var s = _step11.value;
                              if (o.values.indexOf(s) !== -1) {
                                if (newValue === "") {
                                  newValue = s;
                                } else {
                                  newValue += " " + s;
                                }
                              }
                            }
                          } catch (err) {
                            _iterator11.e(err);
                          } finally {
                            _iterator11.f();
                          }
                        } else if (o.values.indexOf(value) >= 0) {
                          newValue = value;
                        }
                        value = newValue;
                      }
                    }
                  } catch (err) {
                    _iterator10.e(err);
                  } finally {
                    _iterator10.f();
                  }
                }
                if (passedAllowedAttributesMapCheck) {
                  if (options2.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
                    if (naughtyHref(name, value)) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (name === "iframe" && a === "src") {
                    var allowed = true;
                    try {
                      parsed = url.parse(value, false, true);
                      var isRelativeUrl = parsed && parsed.host === null && parsed.protocol === null;
                      if (isRelativeUrl) {
                        allowed = has2(options2, "allowIframeRelativeUrls") ? options2.allowIframeRelativeUrls : !options2.allowedIframeHostnames && !options2.allowedIframeDomains;
                      } else if (options2.allowedIframeHostnames || options2.allowedIframeDomains) {
                        var allowedHostname = (options2.allowedIframeHostnames || []).find(function(hostname) {
                          return hostname === parsed.hostname;
                        });
                        var allowedDomain = (options2.allowedIframeDomains || []).find(function(domain) {
                          return parsed.hostname === domain || parsed.hostname.endsWith(".".concat(domain));
                        });
                        allowed = allowedHostname || allowedDomain;
                      }
                    } catch (e) {
                      allowed = false;
                    }
                    if (!allowed) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "srcset") {
                    try {
                      parsed = parseSrcset(value);
                      each(parsed, function(value2) {
                        if (naughtyHref("srcset", value2.url)) {
                          value2.evil = true;
                        }
                      });
                      parsed = filter(parsed, function(v) {
                        return !v.evil;
                      });
                      if (!parsed.length) {
                        delete frame.attribs[a];
                        return;
                      } else {
                        value = stringifySrcset(filter(parsed, function(v) {
                          return !v.evil;
                        }));
                        frame.attribs[a] = value;
                      }
                    } catch (e) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "class") {
                    value = filterClasses(value, allowedClassesMap[name]);
                    if (!value.length) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  if (a === "style") {
                    try {
                      var abstractSyntaxTree = postcss.parse(name + " {" + value + "}");
                      var filteredAST = filterCss(abstractSyntaxTree, options2.allowedStyles);
                      value = stringifyStyleAttributes(filteredAST);
                      if (value.length === 0) {
                        delete frame.attribs[a];
                        return;
                      }
                    } catch (e) {
                      delete frame.attribs[a];
                      return;
                    }
                  }
                  result += " " + a;
                  if (value && value.length) {
                    result += '="' + escapeHtml(value, true) + '"';
                  }
                } else {
                  delete frame.attribs[a];
                }
              });
            }
            if (options2.selfClosing.indexOf(name) !== -1) {
              result += " />";
            } else {
              result += ">";
              if (frame.innerText && !hasText && !options2.textFilter) {
                result += frame.innerText;
                addedText = true;
              }
            }
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
          }, ontext: function ontext(text2) {
            if (skipText) {
              return;
            }
            var lastFrame = stack[stack.length - 1];
            var tag;
            if (lastFrame) {
              tag = lastFrame.tag;
              text2 = lastFrame.innerText !== void 0 ? lastFrame.innerText : text2;
            }
            if (options2.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
              result += text2;
            } else {
              var escaped = escapeHtml(text2, false);
              if (options2.textFilter && !addedText) {
                result += options2.textFilter(escaped, tag);
              } else if (!addedText) {
                result += escaped;
              }
            }
            if (stack.length) {
              var frame = stack[stack.length - 1];
              frame.text += text2;
            }
          }, onclosetag: function onclosetag(name) {
            if (skipText) {
              skipTextDepth--;
              if (!skipTextDepth) {
                skipText = false;
              } else {
                return;
              }
            }
            var frame = stack.pop();
            if (!frame) {
              return;
            }
            skipText = options2.enforceHtmlBoundary ? name === "html" : false;
            depth--;
            var skip = skipMap[depth];
            if (skip) {
              delete skipMap[depth];
              if (options2.disallowedTagsMode === "discard") {
                frame.updateParentNodeText();
                return;
              }
              tempResult = result;
              result = "";
            }
            if (transformMap[depth]) {
              name = transformMap[depth];
              delete transformMap[depth];
            }
            if (options2.exclusiveFilter && options2.exclusiveFilter(frame)) {
              result = result.substr(0, frame.tagPosition);
              return;
            }
            frame.updateParentNodeMediaChildren();
            frame.updateParentNodeText();
            if (options2.selfClosing.indexOf(name) !== -1) {
              if (skip) {
                result = tempResult;
                tempResult = "";
              }
              return;
            }
            result += "</" + name + ">";
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
          } }, options2.parser);
          parser.write(html2);
          parser.end();
          return result;
          function initializeState() {
            result = "";
            depth = 0;
            stack = [];
            skipMap = {};
            transformMap = {};
            skipText = false;
            skipTextDepth = 0;
          }
          function escapeHtml(s, quote) {
            if (typeof s !== "string") {
              s = s + "";
            }
            if (options2.parser.decodeEntities) {
              s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\>/g, "&gt;");
              if (quote) {
                s = s.replace(/\"/g, "&quot;");
              }
            }
            s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/\>/g, "&gt;");
            if (quote) {
              s = s.replace(/\"/g, "&quot;");
            }
            return s;
          }
          function naughtyHref(name, href) {
            href = href.replace(/[\x00-\x20]+/g, "");
            href = href.replace(/<\!\-\-.*?\-\-\>/g, "");
            var matches = href.match(/^([a-zA-Z]+)\:/);
            if (!matches) {
              if (href.match(/^[\/\\]{2}/)) {
                return !options2.allowProtocolRelative;
              }
              return false;
            }
            var scheme = matches[1].toLowerCase();
            if (has2(options2.allowedSchemesByTag, name)) {
              return options2.allowedSchemesByTag[name].indexOf(scheme) === -1;
            }
            return !options2.allowedSchemes || options2.allowedSchemes.indexOf(scheme) === -1;
          }
          function filterCss(abstractSyntaxTree, allowedStyles) {
            if (!allowedStyles) {
              return abstractSyntaxTree;
            }
            var filteredAST = cloneDeep(abstractSyntaxTree);
            var astRules = abstractSyntaxTree.nodes[0];
            var selectedRule;
            if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
              selectedRule = mergeWith(cloneDeep(allowedStyles[astRules.selector]), allowedStyles["*"], function(objValue, srcValue) {
                if (Array.isArray(objValue)) {
                  return objValue.concat(srcValue);
                }
              });
            } else {
              selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
            }
            if (selectedRule) {
              filteredAST.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
            }
            return filteredAST;
          }
          function stringifyStyleAttributes(filteredAST) {
            return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attributeObject) {
              extractedAttributes.push(attributeObject.prop + ":" + attributeObject.value);
              return extractedAttributes;
            }, []).join(";");
          }
          function filterDeclarations(selectedRule) {
            return function(allowedDeclarationsList, attributeObject) {
              if (has2(selectedRule, attributeObject.prop)) {
                var matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
                  return regularExpression.test(attributeObject.value);
                });
                if (matchesRegex) {
                  allowedDeclarationsList.push(attributeObject);
                }
              }
              return allowedDeclarationsList;
            };
          }
          function filterClasses(classes, allowed) {
            if (!allowed) {
              return classes;
            }
            classes = classes.split(/\s+/);
            return classes.filter(function(clss) {
              return allowed.indexOf(clss) !== -1;
            }).join(" ");
          }
        }
        var htmlParserDefaults = { decodeEntities: true };
        sanitizeHtml2.defaults = {
          allowedTags: ["h3", "h4", "h5", "h6", "blockquote", "p", "a", "ul", "ol", "nl", "li", "b", "i", "strong", "em", "strike", "abbr", "code", "hr", "br", "div", "table", "thead", "caption", "tbody", "tr", "th", "td", "pre", "iframe"],
          disallowedTagsMode: "discard",
          allowedAttributes: {
            a: ["href", "name", "target"],
            // We don't currently allow img itself by default, but this
            // would make sense if we did. You could add srcset here,
            // and if you do the URL is checked for safety
            img: ["src"]
          },
          // Lots of these won't come up by default because we don't allow them
          selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
          // URL schemes we permit
          allowedSchemes: ["http", "https", "ftp", "mailto"],
          allowedSchemesByTag: {},
          allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
          allowProtocolRelative: true,
          enforceHtmlBoundary: false
        };
        sanitizeHtml2.simpleTransform = function(newTagName, newAttribs, merge) {
          merge = merge === void 0 ? true : merge;
          newAttribs = newAttribs || {};
          return function(tagName, attribs) {
            var attrib;
            if (merge) {
              for (attrib in newAttribs) {
                attribs[attrib] = newAttribs[attrib];
              }
            } else {
              attribs = newAttribs;
            }
            return { tagName: newTagName, attribs };
          };
        };
      }, { "htmlparser2": 31, "lodash/cloneDeep": 140, "lodash/escapeRegExp": 143, "lodash/isPlainObject": 155, "lodash/isString": 157, "lodash/mergeWith": 162, "parse-srcset": 167, "postcss": 181, "url": 209 }] }, {}, [211])(211);
    });
  })(sanitizeHtml, sanitizeHtml.exports);
  return sanitizeHtml.exports;
}
var sanitizeHtmlExports = /* @__PURE__ */ requireSanitizeHtml();
const sanitize = /* @__PURE__ */ getDefaultExportFromCjs(sanitizeHtmlExports);
(function() {
  (function() {
    const Cell = function(initial) {
      let value = initial;
      const get = function() {
        return value;
      };
      const set = function(v) {
        value = v;
      };
      const clone = function() {
        return Cell(get());
      };
      return {
        get,
        set,
        clone
      };
    };
    const PluginManager = tinymce$1.util.Tools.resolve("tinymce.PluginManager");
    const Tools = tinymce$1.util.Tools.resolve("tinymce.util.Tools");
    const DomParser = tinymce$1.util.Tools.resolve("tinymce.html.DomParser");
    const Node2 = tinymce$1.util.Tools.resolve("tinymce.html.Node");
    const Serializer = tinymce$1.util.Tools.resolve("tinymce.html.Serializer");
    const shouldHideInSourceView = function(editor) {
      return editor.getParam("fullpage_hide_in_source_view");
    };
    const getDefaultXmlPi = function(editor) {
      return editor.getParam("fullpage_default_xml_pi");
    };
    const getDefaultEncoding = function(editor) {
      return editor.getParam("fullpage_default_encoding");
    };
    const getDefaultFontFamily = function(editor) {
      return editor.getParam("fullpage_default_font_family");
    };
    const getDefaultFontSize = function(editor) {
      return editor.getParam("fullpage_default_font_size");
    };
    const getDefaultTextColor = function(editor) {
      return editor.getParam("fullpage_default_text_color");
    };
    const getDefaultTitle = function(editor) {
      return editor.getParam("fullpage_default_title");
    };
    const getDefaultDocType = function(editor) {
      return editor.getParam("fullpage_default_doctype", "<!DOCTYPE html>");
    };
    const $_4aeordbdjdud7a9d = {
      shouldHideInSourceView,
      getDefaultXmlPi,
      getDefaultEncoding,
      getDefaultFontFamily,
      getDefaultFontSize,
      getDefaultTextColor,
      getDefaultTitle,
      getDefaultDocType
    };
    const parseHeader = function(head) {
      return DomParser({
        validate: false,
        root_name: "#document"
      }).parse(head);
    };
    const htmlToData = function(editor, head) {
      const headerFragment = parseHeader(head);
      const data = { pagemode: editor.getParam("fullpage_pagemode", "body") };
      let elm;
      function getAttr(elm2, name) {
        const value = elm2.attr(name);
        return value || "";
      }
      data.fontface = $_4aeordbdjdud7a9d.getDefaultFontFamily(editor);
      data.fontsize = $_4aeordbdjdud7a9d.getDefaultFontSize(editor);
      elm = headerFragment.getAll("#doctype")[0];
      if (elm) {
        data.pagemode = elm.value.match(/XHTML/ig) ? "xhtml" : "html";
      }
      elm = headerFragment.getAll("title")[0];
      if (elm && elm.firstChild) {
        data.title = elm.firstChild.value;
      }
      Tools.each(headerFragment.getAll("meta"), (meta) => {
        const name = meta.attr("name");
        const httpEquiv = meta.attr("http-equiv");
        let matches;
        if (name) {
          data[name.toLowerCase()] = meta.attr("content");
        } else if (httpEquiv === "Content-Type") {
          matches = /charset\s*=\s*(.*)\s*/gi.exec(meta.attr("content"));
          if (matches) {
            data.docencoding = matches[1];
          }
        }
      });
      elm = headerFragment.getAll("html")[0];
      if (elm) {
        data.langcode = getAttr(elm, "lang") || getAttr(elm, "xml:lang");
        data.htmlAttrs = [...elm.attributes].map(({ name, value }) => ({ name, value }));
      }
      data.stylesheets = [];
      Tools.each(headerFragment.getAll("link"), (link2) => {
        if (link2.attr("rel") === "stylesheet") {
          data.stylesheets.push(link2.attr("href"));
        }
      });
      elm = headerFragment.getAll("body")[0];
      if (elm) {
        data.bodyAttrs = [...elm.attributes].map(({ name, value }) => ({ name, value }));
      }
      return data;
    };
    const dataToHtml = function(editor, data, head) {
      let headElement;
      let elm;
      editor.dom;
      function setAttr(elm2, name, value) {
        elm2.attr(name, value ? value : void 0);
      }
      function addHeadNode(node) {
        if (headElement.firstChild) {
          headElement.insert(node, headElement.firstChild);
        } else {
          headElement.append(node);
        }
      }
      const headerFragment = parseHeader(head);
      headElement = headerFragment.getAll("head")[0];
      if (!headElement) {
        elm = headerFragment.getAll("html")[0];
        headElement = new Node2("head", 1);
        if (elm.firstChild) {
          elm.insert(headElement, elm.firstChild, true);
        } else {
          elm.append(headElement);
        }
      }
      elm = headerFragment.getAll("#doctype")[0];
      const pagemode = data.pagemode || editor.getParam("fullpage_pagemode", "body");
      if (pagemode !== "body") {
        if (!elm) {
          elm = new Node2("#doctype", 10);
          addHeadNode(elm);
        }
        elm.value = data.pagemode === "html" ? " html" : ` html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"`;
      } else {
        data.pagemode = "body";
        if (elm) {
          elm.remove();
        }
      }
      elm = null;
      Tools.each(headerFragment.getAll("meta"), (meta) => {
        if (meta.attr("http-equiv") === "Content-Type") {
          elm = meta;
        }
      });
      if (data.docencoding) {
        if (!elm) {
          elm = new Node2("meta", 1);
          elm.attr("http-equiv", "Content-Type");
          elm.shortEnded = true;
          addHeadNode(elm);
        }
        elm.attr("content", "text/html; charset=" + data.docencoding);
      } else if (elm) {
        elm.remove();
      }
      elm = headerFragment.getAll("title")[0];
      if (data.title) {
        if (!elm) {
          elm = new Node2("title", 1);
          addHeadNode(elm);
        } else {
          elm.empty();
        }
        elm.append(new Node2("#text", 3)).value = data.title;
      } else if (elm) {
        elm.remove();
      }
      Tools.each("keywords,description,author,copyright,robots".split(","), (name) => {
        const nodes = headerFragment.getAll("meta");
        let i;
        let meta;
        const value = data[name];
        for (i = 0; i < nodes.length; i++) {
          meta = nodes[i];
          if (meta.attr("name") === name) {
            if (value) {
              meta.attr("content", value);
            } else {
              meta.remove();
            }
            return;
          }
        }
        if (value) {
          elm = new Node2("meta", 1);
          elm.attr("name", name);
          elm.attr("content", value);
          elm.shortEnded = true;
          addHeadNode(elm);
        }
      });
      const currentStyleSheetsMap = {};
      Tools.each(headerFragment.getAll("link"), (stylesheet) => {
        if (stylesheet.attr("rel") === "stylesheet") {
          currentStyleSheetsMap[stylesheet.attr("href")] = stylesheet;
        }
      });
      Tools.each(data.stylesheets, (stylesheet) => {
        if (!currentStyleSheetsMap[stylesheet]) {
          elm = new Node2("link", 1);
          elm.attr({
            rel: "stylesheet",
            text: "text/css",
            href: stylesheet
          });
          elm.shortEnded = true;
          addHeadNode(elm);
        }
        delete currentStyleSheetsMap[stylesheet];
      });
      Tools.each(currentStyleSheetsMap, (stylesheet) => {
        stylesheet.remove();
      });
      elm = headerFragment.getAll("body")[0];
      elm = headerFragment.getAll("html")[0];
      if (elm) {
        if (data.pagemode === "xhtml") {
          elm.attr("lang", null);
          setAttr(elm, "xml:lang", data.langcode);
          setAttr(elm, "xmlns", "http://www.w3.org/1999/xhtml");
        } else {
          [...elm.attributes].map(({ name }) => name).filter((n) => {
            return n.startsWith("xml");
          }).forEach((n) => {
            elm.attr(n, null);
          });
          setAttr(elm, "lang", data.langcode);
        }
      }
      if (!headElement.firstChild) {
        headElement.remove();
      }
      const html2 = Serializer({
        validate: false,
        indent: true,
        apply_source_formatting: true,
        indent_before: "head,html,body,meta,title,script,link,style",
        indent_after: "head,html,body,meta,title,script,link,style"
      }).serialize(headerFragment);
      return html2.substring(0, html2.indexOf("</body>"));
    };
    const $_58tdt7b9jdud7a94 = {
      parseHeader,
      htmlToData,
      dataToHtml
    };
    const open = function(editor, headState) {
      const data = $_58tdt7b9jdud7a94.htmlToData(editor, headState.get());
      editor.windowManager.open({
        title: "Document properties",
        data,
        defaults: {
          type: "textbox",
          size: 40
        },
        body: [
          {
            type: "listbox",
            name: "pagemode",
            label: "Page mode",
            values: [
              { text: "body", value: "body" },
              { text: "xhtml", value: "xhtml" },
              { text: "html", value: "html" }
            ],
            value: data.pagemode
          },
          {
            name: "title",
            label: "Title"
          },
          {
            name: "keywords",
            label: "Keywords"
          },
          {
            name: "description",
            label: "Description"
          },
          {
            name: "robots",
            label: "Robots"
          },
          {
            name: "author",
            label: "Author"
          },
          {
            name: "docencoding",
            label: "Encoding"
          }
        ],
        onSubmit(e) {
          editor.settings.fullpage_pagemode = e.data.pagemode;
          editor.settings.fullpage_ignoreswitch = true;
          if (e.data.pagemode !== "body") {
            editor.setContent(editor.getContent());
            const headHtml = $_58tdt7b9jdud7a94.dataToHtml(editor, Tools.extend(data, e.data), headState.get());
            headState.set(headHtml);
          } else {
            headState.set("");
            editor.setContent(editor.getContent());
          }
          editor.settings.fullpage_ignoreswitch = false;
        }
      });
    };
    const $_1z4w7sb7jdud7a90 = { open };
    const register = function(editor, headState) {
      editor.addCommand("mceFullPageProperties", () => {
        $_1z4w7sb7jdud7a90.open(editor, headState);
      });
    };
    const $_9bxf9tb6jdud7a8z = { register };
    const protectHtml = function(protect, html2) {
      Tools.each(protect, (pattern2) => {
        html2 = html2.replace(pattern2, (str) => {
          return "<!--mce:protected " + escape(str) + "-->";
        });
      });
      return html2;
    };
    const unprotectHtml = function(html2) {
      return html2.replace(/<!--mce:protected ([\s\S]*?)-->/g, (a, m) => {
        return unescape(m);
      });
    };
    const $_73m398bfjdud7a9l = {
      protectHtml,
      unprotectHtml
    };
    const each = Tools.each;
    const low = function(s) {
      return s.replace(/<\/?[A-Z]+/g, (a) => {
        return a.toLowerCase();
      });
    };
    const handleSetContent = function(editor, headState, footState, evt) {
      let startPos;
      let endPos;
      let content;
      let styles = "";
      const dom = editor.dom;
      let elm;
      if (evt.selection) {
        return;
      }
      content = $_73m398bfjdud7a9l.protectHtml(editor.settings.protect, evt.content);
      if (evt.format === "raw" && headState.get()) {
        return;
      }
      if (evt.source_view && $_4aeordbdjdud7a9d.shouldHideInSourceView(editor)) {
        return;
      }
      if (content.length === 0 && !evt.source_view) {
        content = Tools.trim(headState.get()) + "\n" + Tools.trim(content) + "\n" + Tools.trim(footState.get());
      }
      content = content.replace(/<(\/?)BODY/gi, "<$1body");
      startPos = content.indexOf("<body");
      if (startPos !== -1) {
        startPos = content.indexOf(">", startPos);
        headState.set(low(content.substring(0, startPos + 1)));
        endPos = content.indexOf("</body", startPos);
        if (endPos === -1) {
          endPos = content.length;
        }
        evt.content = Tools.trim(content.substring(startPos + 1, endPos));
        footState.set(low(content.substring(endPos)));
      } else {
        headState.set(getDefaultHeader(editor));
        footState.set("\n</body>\n</html>");
      }
      const headerFragment = $_58tdt7b9jdud7a94.parseHeader(headState.get());
      each(headerFragment.getAll("style"), (node) => {
        if (node.firstChild) {
          styles += node.firstChild.value;
        }
      });
      elm = headerFragment.getAll("html")[0];
      if (elm) {
        const html2 = editor.getBody().parentNode;
        const htmlAttrs = [...html2.attributes].reduce((res, { name }) => {
          res[name] = false;
          return res;
        }, {});
        const attrs = [...elm.attributes].map(({ name, value }) => ({ name, value }));
        attrs.forEach(({ name, value }) => {
          htmlAttrs[name] = true;
          html2.setAttribute(name, value);
        });
        Object.keys(htmlAttrs).forEach((key) => {
          if (!htmlAttrs[key]) {
            html2.removeAttribute(key);
          }
        });
      }
      elm = headerFragment.getAll("body")[0];
      if (elm) {
        const body = editor.getBody();
        const ignoreAttrs = ["id", "class", "data-id", "contenteditable", "spellcheck"];
        const bodyAttrs = [...body.attributes].filter((attr) => !ignoreAttrs.includes(attr.name)).reduce((res, { name }) => {
          res[name] = false;
          return res;
        }, {});
        const attrs = [...elm.attributes].filter((attr) => !ignoreAttrs.includes(attr.name)).map(({ name, value }) => ({ name, value }));
        attrs.forEach(({ name, value }) => {
          bodyAttrs[name] = true;
          body.setAttribute(name, value);
        });
        Object.keys(bodyAttrs).forEach((key) => {
          if (!bodyAttrs[key]) {
            body.removeAttribute(key);
          }
        });
        body.setAttribute("class", "mce-content-body " + elm.attr("class"));
      }
      dom.remove("fullpage_styles");
      const headElm = editor.getDoc().getElementsByTagName("head")[0];
      if (styles) {
        dom.add(headElm, "style", { id: "fullpage_styles" }, styles);
        elm = dom.get("fullpage_styles");
        if (elm.styleSheet) {
          elm.styleSheet.cssText = styles;
        }
      }
      const currentStyleSheetsMap = {};
      Tools.each(headElm.getElementsByTagName("link"), (stylesheet) => {
        if (stylesheet.rel === "stylesheet" && stylesheet.getAttribute("data-mce-fullpage")) {
          currentStyleSheetsMap[stylesheet.href] = stylesheet;
        }
      });
      Tools.each(headerFragment.getAll("link"), (stylesheet) => {
        const href = stylesheet.attr("href");
        if (!href) {
          return true;
        }
        if (!currentStyleSheetsMap[href] && stylesheet.attr("rel") === "stylesheet") {
          dom.add(headElm, "link", {
            "rel": "stylesheet",
            "text": "text/css",
            href,
            "data-mce-fullpage": "1"
          });
        }
        delete currentStyleSheetsMap[href];
      });
      Tools.each(currentStyleSheetsMap, (stylesheet) => {
        stylesheet.parentNode.removeChild(stylesheet);
      });
    };
    const getDefaultHeader = function(editor) {
      let header = "";
      let value;
      let styles = "";
      if ($_4aeordbdjdud7a9d.getDefaultXmlPi(editor)) {
        const piEncoding = $_4aeordbdjdud7a9d.getDefaultEncoding(editor);
        header += '<?xml version="1.0" encoding="' + (piEncoding ? piEncoding : "ISO-8859-1") + '" ?>\n';
      }
      header += $_4aeordbdjdud7a9d.getDefaultDocType(editor);
      header += `
<html>
<head>
`;
      if (value = $_4aeordbdjdud7a9d.getDefaultTitle(editor)) {
        header += "<title>" + value + "</title>\n";
      }
      if (value = $_4aeordbdjdud7a9d.getDefaultEncoding(editor)) {
        header += '<meta http-equiv="Content-Type" content="text/html; charset=' + value + '" />\n';
      }
      if (value = $_4aeordbdjdud7a9d.getDefaultFontFamily(editor)) {
        styles += "font-family: " + value + ";";
      }
      if (value = $_4aeordbdjdud7a9d.getDefaultFontSize(editor)) {
        styles += "font-size: " + value + ";";
      }
      if (value = $_4aeordbdjdud7a9d.getDefaultTextColor(editor)) {
        styles += "color: " + value + ";";
      }
      header += "</head>\n<body" + (styles ? ' style="' + styles + '"' : "") + ">\n";
      return header;
    };
    const handleGetContent = function(editor, head, foot, evt) {
      if (!evt.selection && (!evt.source_view || !$_4aeordbdjdud7a9d.shouldHideInSourceView(editor))) {
        evt.content = $_73m398bfjdud7a9l.unprotectHtml(Tools.trim(head) + "\n" + Tools.trim(evt.content) + "\n" + Tools.trim(foot));
      }
    };
    const setup = function(editor, headState, footState) {
      editor.on("BeforeSetContent", (event) => {
        let pagemode = editor.getParam("fullpage_pagemode", "body");
        if (editor.settings.modifyingCode) {
          if (!editor.settings.fullpage_ignoreswitch) {
            if (pagemode !== "body" && !event.content.match(/<html.*?>/)) {
              pagemode = "body";
              headState.set("");
              editor.settings.fullpage_pagemode = pagemode;
            } else if (pagemode === "body" && event.content.match(/<html.*?>/)) {
              headState.set(event.content.substring(0, event.content.indexOf("</body>")));
              pagemode = event.content.match(/^<!DOCTYPE[^>]+XHTML.*?>/ig) ? "xhtml" : "html";
              editor.settings.fullpage_pagemode = pagemode;
            }
          }
        }
        if (pagemode !== "body") {
          handleSetContent(editor, headState, footState, event);
        }
      });
      editor.on("GetContent", (evt) => {
        let pagemode = editor.getParam("fullpage_pagemode", "body");
        if (pagemode !== "body") {
          handleGetContent(editor, headState.get(), footState.get(), evt);
        }
      });
    };
    const $_101dyabejdud7a9g = { setup };
    const register$1 = function(editor) {
      editor.addButton("fullpage", {
        title: "Document properties",
        cmd: "mceFullPageProperties"
      });
      editor.addMenuItem("fullpage", {
        text: "Document properties",
        cmd: "mceFullPageProperties",
        context: "file"
      });
    };
    const $_g8k18qbgjdud7a9m = { register: register$1 };
    PluginManager.add("fullpage", function(editor) {
      const headState = Cell("");
      const footState = Cell("");
      $_9bxf9tb6jdud7a8z.register(editor, headState);
      $_g8k18qbgjdud7a9m.register(editor);
      $_101dyabejdud7a9g.setup(editor, headState, footState);
    });
    function Plugin() {
    }
    return Plugin;
  })();
})();
var js = { exports: {} };
var src = {};
var javascript = { exports: {} };
var beautifier$2 = {};
var output = {};
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput) return output;
  hasRequiredOutput = 1;
  function OutputLine(parent) {
    this.__parent = parent;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  }
  OutputLine.prototype.clone_empty = function() {
    var line = new OutputLine(this.__parent);
    line.set_indent(this.__indent_count, this.__alignment_count);
    return line;
  };
  OutputLine.prototype.item = function(index) {
    if (index < 0) {
      return this.__items[this.__items.length + index];
    } else {
      return this.__items[index];
    }
  };
  OutputLine.prototype.has_match = function(pattern2) {
    for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern2)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next2 = this.__parent.current_line;
      next2.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next2.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next2.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next2.__items[0] === " ") {
        next2.__items.splice(0, 1);
        next2.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf("\n");
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result += this.__items.join("");
    }
    return result;
  };
  function IndentStringCache(options2, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options2.indent_size;
    this.__indent_string = options2.indent_char;
    if (!options2.indent_with_tabs) {
      this.__indent_string = new Array(options2.indent_size + 1).join(options2.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options2.indent_level > 0) {
      baseIndentString = new Array(options2.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  }
  IndentStringCache.prototype.get_indent_size = function(indent, column) {
    var result = this.__base_string_length;
    column = column || 0;
    if (indent < 0) {
      result = 0;
    }
    result += indent * this.__indent_size;
    result += column;
    return result;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
    var result = this.__base_string;
    column = column || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result = "";
    }
    column += indent_level * this.__indent_size;
    this.__ensure_cache(column);
    result += this.__cache[column];
    return result;
  };
  IndentStringCache.prototype.__ensure_cache = function(column) {
    while (column >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column = this.__cache.length;
    var indent = 0;
    var result = "";
    if (this.__indent_size && column >= this.__indent_size) {
      indent = Math.floor(column / this.__indent_size);
      column -= indent * this.__indent_size;
      result = new Array(indent + 1).join(this.__indent_string);
    }
    if (column) {
      result += new Array(column + 1).join(" ");
    }
    this.__cache.push(result);
  };
  function Output(options2, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options2, baseIndentString);
    this.raw = false;
    this._end_with_newline = options2.end_with_newline;
    this.indent_size = options2.indent_size;
    this.wrap_line_length = options2.wrap_line_length;
    this.indent_empty_lines = options2.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  }
  Output.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output.prototype.get_indent_string = function(indent, column) {
    return this.__indent_cache.get_indent_string(indent, column);
  };
  Output.prototype.get_indent_size = function(indent, column) {
    return this.__indent_cache.get_indent_size(indent, column);
  };
  Output.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === "\n") {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join("\n");
    if (eol !== "\n") {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output.prototype.add_raw_token = function(token2) {
    for (var x = 0; x < token2.newlines; x++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token2.whitespace_before);
    this.current_line.push(token2.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output.prototype.remove_indent = function(index) {
    var output_length = this.__lines.length;
    while (index < output_length) {
      this.__lines[index]._remove_indent();
      index++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index = this.__lines.length - 2;
    while (index >= 0) {
      var potentialEmptyLine = this.__lines[index];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index--;
    }
  };
  output.Output = Output;
  return output;
}
var token = {};
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken) return token;
  hasRequiredToken = 1;
  function Token(type, text2, newlines, whitespace_before) {
    this.type = type;
    this.text = text2;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  }
  token.Token = Token;
  return token;
}
var acorn = {};
var hasRequiredAcorn;
function requireAcorn() {
  if (hasRequiredAcorn) return acorn;
  hasRequiredAcorn = 1;
  (function(exports$1) {
    var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
    var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
    var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
    var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
    var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
    var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
    var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
    exports$1.identifier = new RegExp(identifierStart + identifierChars, "g");
    exports$1.identifierStart = new RegExp(identifierStart);
    exports$1.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
    exports$1.newline = /[\n\r\u2028\u2029]/;
    exports$1.lineBreak = new RegExp("\r\n|" + exports$1.newline.source);
    exports$1.allLineBreaks = new RegExp(exports$1.lineBreak.source, "g");
  })(acorn);
  return acorn;
}
var options$3 = {};
var options$2 = {};
var hasRequiredOptions$3;
function requireOptions$3() {
  if (hasRequiredOptions$3) return options$2;
  hasRequiredOptions$3 = 1;
  function Options(options2, merge_child_field) {
    this.raw_options = _mergeOpts(options2, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
    if (this.indent_with_tabs) {
      this.indent_char = "	";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "angular", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  }
  Options.prototype._get_array = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result;
  };
  Options.prototype._get_boolean = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = option_value === void 0 ? !!default_value : !!option_value;
    return result;
  };
  Options.prototype._get_characters = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = default_value || "";
    if (typeof option_value === "string") {
      result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
    }
    return result;
  };
  Options.prototype._get_number = function(name, default_value) {
    var option_value = this.raw_options[name];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result = parseInt(option_value, 10);
    if (isNaN(result)) {
      result = default_value;
    }
    return result;
  };
  Options.prototype._get_selection = function(name, selection_list, default_value) {
    var result = this._get_selection_list(name, selection_list, default_value);
    if (result.length !== 1) {
      throw new Error(
        "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'"
      );
    }
    return result[0];
  };
  Options.prototype._get_selection_list = function(name, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result = this._get_array(name, default_value);
    if (!this._is_valid_selection(result, selection_list)) {
      throw new Error(
        "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'"
      );
    }
    return result;
  };
  Options.prototype._is_valid_selection = function(result, selection_list) {
    return result.length && selection_list.length && !result.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  function _mergeOpts(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name;
    for (name in allOptions) {
      if (name !== childFieldName) {
        finalOpts[name] = allOptions[name];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name in allOptions[childFieldName]) {
        finalOpts[name] = allOptions[childFieldName][name];
      }
    }
    return finalOpts;
  }
  function _normalizeOpts(options2) {
    var convertedOpts = {};
    var key;
    for (key in options2) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options2[key];
    }
    return convertedOpts;
  }
  options$2.Options = Options;
  options$2.normalizeOpts = _normalizeOpts;
  options$2.mergeOpts = _mergeOpts;
  return options$2;
}
var hasRequiredOptions$2;
function requireOptions$2() {
  if (hasRequiredOptions$2) return options$3;
  hasRequiredOptions$2 = 1;
  var BaseOptions = requireOptions$3().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  function Options(options2) {
    BaseOptions.call(this, options2, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== void 0) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs = 0; bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  }
  Options.prototype = new BaseOptions();
  options$3.Options = Options;
  return options$3;
}
var tokenizer$2 = {};
var inputscanner = {};
var hasRequiredInputscanner;
function requireInputscanner() {
  if (hasRequiredInputscanner) return inputscanner;
  hasRequiredInputscanner = 1;
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  function InputScanner(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  }
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val;
  };
  InputScanner.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      val = this.__input.charAt(index);
    }
    return val;
  };
  InputScanner.prototype.__match = function(pattern2, index) {
    pattern2.lastIndex = index;
    var pattern_match = pattern2.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern2.sticky)) {
      if (pattern_match.index !== index) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern2, index) {
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      return !!this.__match(pattern2, index);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern2, index) {
    var val = this.peek(index);
    pattern2.lastIndex = 0;
    return val !== null && pattern2.test(val);
  };
  InputScanner.prototype.match = function(pattern2) {
    var pattern_match = this.__match(pattern2, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val += this.readUntil(until_pattern, until_after);
    }
    return val;
  };
  InputScanner.prototype.readUntil = function(pattern2, until_after) {
    var val = "";
    var match_index = this.__position;
    pattern2.lastIndex = this.__position;
    var pattern_match = pattern2.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val;
  };
  InputScanner.prototype.readUntilAfter = function(pattern2) {
    return this.readUntil(pattern2, true);
  };
  InputScanner.prototype.get_regexp = function(pattern2, match_from) {
    var result = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern2 === "string" && pattern2 !== "") {
      result = new RegExp(pattern2, flags);
    } else if (pattern2) {
      result = new RegExp(pattern2.source, flags);
    }
    return result;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern2) {
    var start = this.__position;
    var val = this.readUntilAfter(pattern2);
    this.__position = start;
    return val;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  inputscanner.InputScanner = InputScanner;
  return inputscanner;
}
var tokenizer$1 = {};
var tokenstream = {};
var hasRequiredTokenstream;
function requireTokenstream() {
  if (hasRequiredTokenstream) return tokenstream;
  hasRequiredTokenstream = 1;
  function TokenStream(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  }
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val;
  };
  TokenStream.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__tokens_length) {
      val = this.__tokens[index];
    }
    return val;
  };
  TokenStream.prototype.add = function(token2) {
    if (this.__parent_token) {
      token2.parent = this.__parent_token;
    }
    this.__tokens.push(token2);
    this.__tokens_length += 1;
  };
  tokenstream.TokenStream = TokenStream;
  return tokenstream;
}
var whitespacepattern = {};
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  function Pattern(input_scanner, parent) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent) {
      this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent._until_pattern);
      this._until_after = parent._until_after;
    }
  }
  Pattern.prototype.read = function() {
    var result = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result) {
      result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern2) {
    var result = this._create();
    result._until_after = true;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.until = function(pattern2) {
    var result = this._create();
    result._until_after = false;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.starting_with = function(pattern2) {
    var result = this._create();
    result._starting_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype.matching = function(pattern2) {
    var result = this._create();
    result._match_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {
  };
  pattern.Pattern = Pattern;
  return pattern;
}
var hasRequiredWhitespacepattern;
function requireWhitespacepattern() {
  if (hasRequiredWhitespacepattern) return whitespacepattern;
  hasRequiredWhitespacepattern = 1;
  var Pattern = requirePattern().Pattern;
  function WhitespacePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    if (parent) {
      this._line_regexp = this._input.get_regexp(parent._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  }
  WhitespacePattern.prototype = new Pattern();
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp(
      "[" + whitespace_chars + newline_chars + "]+",
      true
    );
    this._newline_regexp = this._input.get_regexp(
      "\\r\\n|[" + newline_chars + "]"
    );
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result = this._create();
    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result._update();
    return result;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp, input_string) {
    regexp.lastIndex = 0;
    var start_index = 0;
    var result = [];
    var next_match = regexp.exec(input_string);
    while (next_match) {
      result.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp.exec(input_string);
    }
    if (start_index < input_string.length) {
      result.push(input_string.substring(start_index, input_string.length));
    } else {
      result.push("");
    }
    return result;
  };
  whitespacepattern.WhitespacePattern = WhitespacePattern;
  return whitespacepattern;
}
var hasRequiredTokenizer$2;
function requireTokenizer$2() {
  if (hasRequiredTokenizer$2) return tokenizer$1;
  hasRequiredTokenizer$2 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var Token = requireToken().Token;
  var TokenStream = requireTokenstream().TokenStream;
  var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer = function(input_string, options2) {
    this._input = new InputScanner(input_string);
    this._options = options2 || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream();
    this._reset();
    var current;
    var previous = new Token(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream();
    while (previous.type !== TOKEN.EOF) {
      current = this._get_next_token(previous, open_token);
      while (this._is_comment(current)) {
        comments.add(current);
        current = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current.comments_before = comments;
        comments = new TokenStream();
      }
      current.parent = open_token;
      if (this._is_opening(current)) {
        open_stack.push(open_token);
        open_token = current;
      } else if (open_token && this._is_closing(current, open_token)) {
        current.opened = open_token;
        open_token.closed = current;
        open_token = open_stack.pop();
        current.parent = open_token;
      }
      current.previous = previous;
      previous.next = current;
      this.__tokens.add(current);
      previous = current;
    }
    return this.__tokens;
  };
  Tokenizer.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer.prototype._reset = function() {
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer.prototype._create_token = function(type, text2) {
    var token2 = new Token(
      type,
      text2,
      this._patterns.whitespace.newline_count,
      this._patterns.whitespace.whitespace_before_token
    );
    return token2;
  };
  Tokenizer.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  tokenizer$1.Tokenizer = Tokenizer;
  tokenizer$1.TOKEN = TOKEN;
  return tokenizer$1;
}
var directives = {};
var hasRequiredDirectives;
function requireDirectives() {
  if (hasRequiredDirectives) return directives;
  hasRequiredDirectives = 1;
  function Directives(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  }
  Directives.prototype.get_directives = function(text2) {
    if (!text2.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives2 = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text2);
    while (directive_match) {
      directives2[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text2);
    }
    return directives2;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  directives.Directives = Directives;
  return directives;
}
var templatablepattern = {};
var hasRequiredTemplatablepattern;
function requireTemplatablepattern() {
  if (hasRequiredTemplatablepattern) return templatablepattern;
  hasRequiredTemplatablepattern = 1;
  var Pattern = requirePattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false,
    angular: false
  };
  function TemplatablePattern(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent) {
      this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent._excluded);
      this._disabled = Object.assign(this._disabled, parent._disabled);
    }
    var pattern2 = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern2.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern2.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern2.starting_with(/{{/).until_after(/}}/),
      php: pattern2.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern2.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      // django coflicts with handlebars a bit.
      django: pattern2.starting_with(/{%/).until_after(/%}/),
      django_value: pattern2.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern2.starting_with(/{#/).until_after(/#}/),
      smarty: pattern2.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern2.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern2.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  }
  TemplatablePattern.prototype = new Pattern();
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result = this._create();
    result._disabled[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read_options = function(options2) {
    var result = this._create();
    for (var language in template_names) {
      result._disabled[language] = options2.templating.indexOf(language) === -1;
    }
    result._update();
    return result;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result = this._create();
    result._excluded[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read = function() {
    var result = "";
    if (this._match_pattern) {
      result = this._input.read(this._starting_pattern);
    } else {
      result = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next2 = this._read_template();
    while (next2) {
      if (this._match_pattern) {
        next2 += this._input.read(this._match_pattern);
      } else {
        next2 += this._input.readUntil(this.__template_pattern);
      }
      result += next2;
      next2 = this._read_template();
    }
    if (this._until_after) {
      result += this._input.readUntilAfter(this._until_pattern);
    }
    return result;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.angular) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c = this._input.peek();
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  templatablepattern.TemplatablePattern = TemplatablePattern;
  return templatablepattern;
}
var hasRequiredTokenizer$1;
function requireTokenizer$1() {
  if (hasRequiredTokenizer$1) return tokenizer$2;
  hasRequiredTokenizer$1 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var acorn2 = requireAcorn();
  var Pattern = requirePattern().Pattern;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
  var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer = function(input_string, options2) {
    BaseTokenizer.call(this, input_string, options2);
    this._patterns.whitespace = this._patterns.whitespace.matching(
      /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
      /\u2028\u2029/.source
    );
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn2.identifier).matching(acorn2.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      // comment ends just before nearest linefeed or end of file
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      //  /* ... */ comment ends with nearest */ or end of file
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn2.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn2.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer.prototype = new BaseTokenizer();
  Tokenizer.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c = this._input.peek();
    if (c === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_non_javascript(c);
    token2 = token2 || this._read_string(c);
    token2 = token2 || this._read_pair(c, this._input.peek(1));
    token2 = token2 || this._read_word(previous_token);
    token2 = token2 || this._read_singles(c);
    token2 = token2 || this._read_comment(c);
    token2 = token2 || this._read_regexp(c, previous_token);
    token2 = token2 || this._read_xml(c, previous_token);
    token2 = token2 || this._read_punctuation();
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer.prototype._read_singles = function(c) {
    var token2 = null;
    if (c === "(" || c === "[") {
      token2 = this._create_token(TOKEN.START_EXPR, c);
    } else if (c === ")" || c === "]") {
      token2 = this._create_token(TOKEN.END_EXPR, c);
    } else if (c === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c);
    } else if (c === "}") {
      token2 = this._create_token(TOKEN.END_BLOCK, c);
    } else if (c === ";") {
      token2 = this._create_token(TOKEN.SEMICOLON, c);
    } else if (c === "." && dot_pattern.test(this._input.peek(1))) {
      token2 = this._create_token(TOKEN.DOT, c);
    } else if (c === ",") {
      token2 = this._create_token(TOKEN.COMMA, c);
    }
    if (token2) {
      this._input.next();
    }
    return token2;
  };
  Tokenizer.prototype._read_pair = function(c, d) {
    var token2 = null;
    if (c === "#" && d === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c + d);
    }
    if (token2) {
      this._input.next();
      this._input.next();
    }
    return token2;
  };
  Tokenizer.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer.prototype._read_non_javascript = function(c) {
    var resulting_string = "";
    if (c === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
      }
      c = this._input.next();
      var sharp2 = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c = this._input.next();
          sharp2 += c;
        } while (this._input.hasNext() && c !== "#" && c !== "=");
        if (c === "#") ;
        else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp2 += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp2 += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp2);
      }
      this._input.back();
    } else if (c === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn2.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer.prototype._read_comment = function(c) {
    var token2 = null;
    if (c === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn2.allLineBreaks, "\n");
        token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token2.directives = directives2;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token2 = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_string = function(c) {
    if (c === "`" || c === "'" || c === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer.prototype._read_regexp = function(c, previous_token) {
    if (c === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn2.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn2.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_xml = function(c, previous_token) {
    if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn2.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  function unescape_string(s) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          if (!matched) {
            matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
          }
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
        } else if (escaped > 1114111) {
          out += "\\" + matched[0];
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  }
  Tokenizer.prototype._read_string_recursive = function(delimiter2, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern2;
    if (delimiter2 === "'") {
      pattern2 = this.__patterns.single_quote;
    } else if (delimiter2 === '"') {
      pattern2 = this.__patterns.double_quote;
    } else if (delimiter2 === "`") {
      pattern2 = this.__patterns.template_text;
    } else if (delimiter2 === "}") {
      pattern2 = this.__patterns.template_expression;
    }
    var resulting_string = pattern2.read();
    var next2 = "";
    while (this._input.hasNext()) {
      next2 = this._input.next();
      if (next2 === delimiter2 || !allow_unescaped_newlines && acorn2.newline.test(next2)) {
        this._input.back();
        break;
      } else if (next2 === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === "\n") {
          this._input.next();
        }
        next2 += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next2 === "$" && this._input.peek() === "{") {
          next2 += this._input.next();
        }
        if (start_sub === next2) {
          if (delimiter2 === "`") {
            next2 += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next2 += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next2 += this._input.next();
          }
        }
      }
      next2 += pattern2.read();
      resulting_string += next2;
    }
    return resulting_string;
  };
  tokenizer$2.Tokenizer = Tokenizer;
  tokenizer$2.TOKEN = TOKEN;
  tokenizer$2.positionable_operators = positionable_operators.slice();
  tokenizer$2.line_starters = line_starters.slice();
  return tokenizer$2;
}
var hasRequiredBeautifier$2;
function requireBeautifier$2() {
  if (hasRequiredBeautifier$2) return beautifier$2;
  hasRequiredBeautifier$2 = 1;
  var Output = requireOutput().Output;
  var Token = requireToken().Token;
  var acorn2 = requireAcorn();
  var Options = requireOptions$2().Options;
  var Tokenizer = requireTokenizer$1().Tokenizer;
  var line_starters = requireTokenizer$1().line_starters;
  var positionable_operators = requireTokenizer$1().positionable_operators;
  var TOKEN = requireTokenizer$1().TOKEN;
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function ltrim(s) {
    return s.replace(/^\s+/g, "");
  }
  function generateMapFromStrings(list2) {
    var result = {};
    for (var x = 0; x < list2.length; x++) {
      result[list2[x].replace(/-/g, "_")] = list2[x];
    }
    return result;
  }
  function reserved_word(token2, word) {
    return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
  }
  function reserved_array(token2, words) {
    return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
  }
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    // 'BLOCK'
    Statement: "Statement",
    // 'STATEMENT'
    ObjectLiteral: "ObjectLiteral",
    // 'OBJECT',
    ArrayLiteral: "ArrayLiteral",
    //'[EXPRESSION]',
    ForInitializer: "ForInitializer",
    //'(FOR-EXPRESSION)',
    Conditional: "Conditional",
    //'(COND-EXPRESSION)',
    Expression: "Expression"
    //'(EXPRESSION)'
  };
  function remove_redundant_indentation(output2, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output2.remove_indent(frame.start_line_index);
  }
  function split_linebreaks(s) {
    s = s.replace(acorn2.allLineBreaks, "\n");
    var out = [], idx = s.indexOf("\n");
    while (idx !== -1) {
      out.push(s.substring(0, idx));
      s = s.substring(idx + 1);
      idx = s.indexOf("\n");
    }
    if (s.length) {
      out.push(s);
    }
    return out;
  }
  function is_array(mode) {
    return mode === MODE.ArrayLiteral;
  }
  function is_expression(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  }
  function all_lines_start_with(lines, c) {
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.charAt(0) !== c) {
        return false;
      }
    }
    return true;
  }
  function each_line_matches_indent(lines, indent) {
    var i = 0, len = lines.length, line;
    for (; i < len; i++) {
      line = lines[i];
      if (line && line.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  }
  function Beautifier(source_text, options2) {
    options2 = options2 || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options2);
  }
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
      // last token text
      last_word: flags_base ? flags_base.last_word : "",
      // last TOKEN.WORD passed
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      // switch(..){ INSIDE HERE }
      in_case: false,
      // we're on the exact line with "case 0:"
      case_body: false,
      // the indented case-action block
      case_block: false,
      // the indented case-action block is wrapped with {}
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer2 = new Tokenizer(source_text, this._options);
    this._tokens = tokenizer2.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && acorn2.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn2.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i = 0; i < newlines; i += 1) {
        this.print_newline(i > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j = 1; j < newlines; j += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === void 0 ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(
          current_token,
          reserved_array(current_token, ["do", "for", "if", "while"])
        );
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(
        current_token,
        current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation
      );
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index += 1;
        check_token = this._tokens.peek(index - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators
      (in_array(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) ;
      else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix = "NEWLINE";
        } else {
          prefix = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line = this._output.current_line;
        if (line.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) ;
    else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token)) ;
    else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token)) ;
    else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (in_array(current_token.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn2.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j = 0; j < lines.length; j++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j]));
        } else if (starless && lines[j]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token)) ;
    else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(
        current_token,
        this._flags.last_token.text === ")" && this._options.break_chained_methods
      );
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === "\n") {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  beautifier$2.Beautifier = Beautifier;
  return beautifier$2;
}
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript.exports;
  hasRequiredJavascript = 1;
  var Beautifier = requireBeautifier$2().Beautifier, Options = requireOptions$2().Options;
  function js_beautify(js_source_text, options2) {
    var beautifier2 = new Beautifier(js_source_text, options2);
    return beautifier2.beautify();
  }
  javascript.exports = js_beautify;
  javascript.exports.defaultOptions = function() {
    return new Options();
  };
  return javascript.exports;
}
var css = { exports: {} };
var beautifier$1 = {};
var options$1 = {};
var hasRequiredOptions$1;
function requireOptions$1() {
  if (hasRequiredOptions$1) return options$1;
  hasRequiredOptions$1 = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options2) {
    BaseOptions.call(this, options2, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs = 0; bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
  }
  Options.prototype = new BaseOptions();
  options$1.Options = Options;
  return options$1;
}
var hasRequiredBeautifier$1;
function requireBeautifier$1() {
  if (hasRequiredBeautifier$1) return beautifier$1;
  hasRequiredBeautifier$1 = 1;
  var Options = requireOptions$1().Options;
  var Output = requireOutput().Output;
  var InputScanner = requireInputscanner().InputScanner;
  var Directives = requireDirectives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  function Beautifier(source_text, options2) {
    this._source_text = source_text || "";
    this._options = new Options(options2);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      "page": true,
      "font-face": true,
      "keyframes": true,
      // also in CONDITIONAL_GROUP_RULE below
      "media": true,
      "supports": true,
      "document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
      "media": true,
      "supports": true,
      "document": true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  }
  Beautifier.prototype.eatString = function(endChars) {
    var result = "";
    this._ch = this._input.next();
    while (this._ch) {
      result += this._ch;
      if (this._ch === "\\") {
        result += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
        break;
      }
      this._ch = this._input.next();
    }
    return result;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === "\n") {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i = 1;
    var ch = this._input.peek(i);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i++;
      ch = this._input.peek(i);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text || "")) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideNonNestedAtRule = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        if (variable.match(/[ :]$/)) {
          variable = this.eatString(": ").replace(/\s+$/, "");
          this.print_string(variable);
          this._output.space_before_token = true;
        }
        if (parenLevel === 0 && variable.indexOf(":") !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      } else if (this._ch === "@") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s+$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          } else if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (parenLevel === 0 && !insidePropertyValue) {
            insideNonNestedAtRule = true;
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        insideNonNestedAtRule = false;
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideNonNestedAtRule = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  beautifier$1.Beautifier = Beautifier;
  return beautifier$1;
}
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss) return css.exports;
  hasRequiredCss = 1;
  var Beautifier = requireBeautifier$1().Beautifier, Options = requireOptions$1().Options;
  function css_beautify(source_text, options2) {
    var beautifier2 = new Beautifier(source_text, options2);
    return beautifier2.beautify();
  }
  css.exports = css_beautify;
  css.exports.defaultOptions = function() {
    return new Options();
  };
  return css.exports;
}
var html = { exports: {} };
var beautifier = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options2) {
    BaseOptions.call(this, options2, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection(
      "wrap_attributes",
      ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]
    );
    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      /* 'script', */
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      // obsolete inline tags
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
    this.void_elements = this._get_array("void_elements", [
      // HTLM void elements - aka self-closing tags - aka singletons
      // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      // NOTE: Optional tags are too complex for a simple list
      // they are hard coded in _do_optional_end_element
      // Doctype and xml elements
      "!doctype",
      "?xml",
      // obsolete tags
      // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
      // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  }
  Options.prototype = new BaseOptions();
  options.Options = Options;
  return options;
}
var tokenizer = {};
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer) return tokenizer;
  hasRequiredTokenizer = 1;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  var Pattern = requirePattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    CONTROL_FLOW_OPEN: "TK_CONTROL_FLOW_OPEN",
    CONTROL_FLOW_CLOSE: "TK_CONTROL_FLOW_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer = function(input_string, options2) {
    BaseTokenizer.call(this, input_string, options2);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      word_control_flow_close_excluded: templatable_reader.until(/[\n\r\t <}]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      angular_control_flow_start: pattern_reader.matching(/\@[a-zA-Z]+[^({]*[({]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      // https://en.wikipedia.org/wiki/Conditional_comment
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
      this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer.prototype = new BaseTokenizer();
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{")) || current_token.type === TOKEN.CONTROL_FLOW_CLOSE && (current_token.text === "}" && open_token.text.endsWith("{"));
  };
  Tokenizer.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c = this._input.peek();
    if (c === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_open_handlebars(c, open_token);
    token2 = token2 || this._read_attribute(c, previous_token, open_token);
    token2 = token2 || this._read_close(c, open_token);
    token2 = token2 || this._read_script_and_style(c, previous_token);
    token2 = token2 || this._read_control_flows(c, open_token);
    token2 = token2 || this._read_raw_content(c, previous_token, open_token);
    token2 = token2 || this._read_content_word(c, open_token);
    token2 = token2 || this._read_comment_or_cdata(c);
    token2 = token2 || this._read_processing(c);
    token2 = token2 || this._read_open(c, open_token);
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer.prototype._read_comment_or_cdata = function(c) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives2 = directives_core.get_directives(resulting_string);
          if (directives2 && directives2.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_processing = function(c) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_open = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      if (c === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      if ((this._options.templating.includes("angular") || this._options.indent_handlebars) && c === "{" && this._input.peek(1) === "{") {
        if (this._options.indent_handlebars && this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_control_flows = function(c, open_token) {
    var resulting_string = "";
    var token2 = null;
    if (!this._options.templating.includes("angular")) {
      return token2;
    }
    if (c === "@") {
      resulting_string = this.__patterns.angular_control_flow_start.read();
      if (resulting_string === "") {
        return token2;
      }
      var opening_parentheses_count = resulting_string.endsWith("(") ? 1 : 0;
      var closing_parentheses_count = 0;
      while (!(resulting_string.endsWith("{") && opening_parentheses_count === closing_parentheses_count)) {
        var next_char = this._input.next();
        if (next_char === null) {
          break;
        } else if (next_char === "(") {
          opening_parentheses_count++;
        } else if (next_char === ")") {
          closing_parentheses_count++;
        }
        resulting_string += next_char;
      }
      token2 = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);
    } else if (c === "}" && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
      resulting_string = this._input.next();
      token2 = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);
    }
    return token2;
  };
  Tokenizer.prototype._read_close = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (open_token && open_token.type === TOKEN.TAG_OPEN) {
      if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c === "/") {
          resulting_string += this._input.next();
        }
        token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
    var token2 = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c === "=") {
        token2 = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c === '"' || c === "'") {
        var content = this._input.next();
        if (c === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token2 = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token2 = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token2;
  };
  Tokenizer.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_script_and_style = function(c, previous_token) {
    if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token2 = this._read_comment_or_cdata(c);
        if (token2) {
          token2.type = TOKEN.TEXT;
          return token2;
        }
        var resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
        if (resulting_string) {
          return this._create_token(TOKEN.TEXT, resulting_string);
        }
      }
    }
    return null;
  };
  Tokenizer.prototype._read_content_word = function(c, open_token) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  tokenizer.Tokenizer = Tokenizer;
  tokenizer.TOKEN = TOKEN;
  return tokenizer;
}
var hasRequiredBeautifier;
function requireBeautifier() {
  if (hasRequiredBeautifier) return beautifier;
  hasRequiredBeautifier = 1;
  var Options = requireOptions().Options;
  var Output = requireOutput().Output;
  var Tokenizer = requireTokenizer().Tokenizer;
  var TOKEN = requireTokenizer().TOKEN;
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options2, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options2.max_preserve_newlines;
    this.preserve_newlines = options2.preserve_newlines;
    this._output = new Output(options2, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern2) {
    return this._output.current_line.has_match(pattern2);
  };
  Printer.prototype.set_space_before_token = function(value, non_breaking) {
    this._output.space_before_token = value;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token2) {
    this._output.add_raw_token(token2);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n = 0; n < newlines; n++) {
      this.print_newline(n > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token2) {
    if (token2.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token2.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.deindent = function() {
    if (this.indent_level > 0) {
      this.indent_level--;
      this._output.set_indent(this.indent_level, this.alignment_size);
    }
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result = "null";
    }
    return result;
  };
  function in_array(what, arr) {
    return arr.indexOf(what) !== -1;
  }
  function TagFrame(parent, parser_token, indent_level) {
    this.parent = parent || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  }
  function TagStack(printer) {
    this._printer = printer;
    this._current_frame = null;
  }
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  function Beautifier(source_text, options2, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options2 = options2 || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options2, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  }
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text)) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken(this._options);
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {
        parser_token = this._handle_control_flow_open(printer, raw_token);
      } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {
        parser_token = this._handle_control_flow_close(printer, raw_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (raw_token.newlines) {
      printer.print_preserved_newlines(raw_token);
    } else {
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    }
    printer.print_token(raw_token);
    printer.indent();
    return parser_token;
  };
  Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.deindent();
    if (raw_token.newlines) {
      printer.print_preserved_newlines(raw_token);
    } else {
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    }
    printer.print_token(raw_token);
    return parser_token;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond
        this._is_wrap_attributes_force_expand_multiline)) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text2 = raw_token.text, _beautifier, script_indent_level = 1, pre2 = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options2) {
          var beautifier2 = new Beautifier(html_source, options2, local._js_beautify, local._css_beautify);
          return beautifier2.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text2 = text2.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text2[0] === "<" && text2.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text2);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre2 = indentation + matched[1] + "\n";
        text2 = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text2 = text2.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf("\n") !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text2) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = "\n";
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options();
          text2 = _beautifier(indentation + text2, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text2 = text2.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
          }
          text2 = indentation + text2.replace(/\n/g, "\n" + indentation);
        }
      }
      if (pre2) {
        if (!text2) {
          text2 = pre2 + post;
        } else {
          text2 = pre2 + text2 + "\n" + post;
        }
      }
      printer.print_newline(false);
      if (text2) {
        raw_token.text = text2;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
      var peek_index = 0;
      var peek_token;
      do {
        peek_token = tokens.peek(peek_index);
        if (peek_token.type === TOKEN.ATTRIBUTE) {
          parser_token.attr_count += 1;
        }
        peek_index += 1;
      } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(options2, parent, raw_token) {
    this.parent = parent || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (!options2.indent_handlebars || this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._options, this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) ;
      else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result = result || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result = result || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result = result || this._tag_stack.try_pop("dt", ["dl"]);
      result = result || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result = result || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result = result || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("thead", ["table"]);
      result = result || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result;
  };
  beautifier.Beautifier = Beautifier;
  return beautifier;
}
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html.exports;
  hasRequiredHtml = 1;
  var Beautifier = requireBeautifier().Beautifier, Options = requireOptions().Options;
  function style_html(html_source, options2, js_beautify, css_beautify) {
    var beautifier2 = new Beautifier(html_source, options2, js_beautify, css_beautify);
    return beautifier2.beautify();
  }
  html.exports = style_html;
  html.exports.defaultOptions = function() {
    return new Options();
  };
  return html.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var js_beautify = requireJavascript();
  var css_beautify = requireCss();
  var html_beautify = requireHtml();
  function style_html(html_source, options2, js2, css2) {
    js2 = js2 || js_beautify;
    css2 = css2 || css_beautify;
    return html_beautify(html_source, options2, js2, css2);
  }
  style_html.defaultOptions = html_beautify.defaultOptions;
  src.js = js_beautify;
  src.css = css_beautify;
  src.html = style_html;
  return src;
}
var hasRequiredJs;
function requireJs() {
  if (hasRequiredJs) return js.exports;
  hasRequiredJs = 1;
  (function(module) {
    function get_beautify(js_beautify, css_beautify, html_beautify) {
      var beautify = function(src2, config) {
        return js_beautify.js_beautify(src2, config);
      };
      beautify.js = js_beautify.js_beautify;
      beautify.css = css_beautify.css_beautify;
      beautify.html = html_beautify.html_beautify;
      beautify.js_beautify = js_beautify.js_beautify;
      beautify.css_beautify = css_beautify.css_beautify;
      beautify.html_beautify = html_beautify.html_beautify;
      return beautify;
    }
    {
      (function(mod) {
        var beautifier2 = requireSrc();
        beautifier2.js_beautify = beautifier2.js;
        beautifier2.css_beautify = beautifier2.css;
        beautifier2.html_beautify = beautifier2.html;
        mod.exports = get_beautify(beautifier2, beautifier2, beautifier2);
      })(module);
    }
  })(js);
  return js.exports;
}
/*!
 * is-whitespace <https://github.com/jonschlinkert/is-whitespace>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isWhitespace;
var hasRequiredIsWhitespace;
function requireIsWhitespace() {
  if (hasRequiredIsWhitespace) return isWhitespace;
  hasRequiredIsWhitespace = 1;
  var cache;
  isWhitespace = function isWhitespace2(str) {
    return typeof str === "string" && regex2().test(str);
  };
  function regex2() {
    return cache || (cache = new RegExp('^[\\s	\n\v\f\r Â áš€á â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\uFEFF"]+$'));
  }
  return isWhitespace;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtendable;
var hasRequiredIsExtendable;
function requireIsExtendable() {
  if (hasRequiredIsExtendable) return isExtendable;
  hasRequiredIsExtendable = 1;
  isExtendable = function isExtendable2(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  };
  return isExtendable;
}
var extendShallow;
var hasRequiredExtendShallow;
function requireExtendShallow() {
  if (hasRequiredExtendShallow) return extendShallow;
  hasRequiredExtendShallow = 1;
  var isObject = requireIsExtendable();
  extendShallow = function extend2(o) {
    if (!isObject(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1; i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  return extendShallow;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer_1;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer_1;
  hasRequiredIsBuffer = 1;
  isBuffer_1 = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
  };
  function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
  }
  return isBuffer_1;
}
var kindOf;
var hasRequiredKindOf;
function requireKindOf() {
  if (hasRequiredKindOf) return kindOf;
  hasRequiredKindOf = 1;
  var isBuffer = requireIsBuffer();
  var toString = Object.prototype.toString;
  kindOf = function kindOf2(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
  return kindOf;
}
/*!
 * condense-newlines <https://github.com/jonschlinkert/condense-newlines>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */
var condenseNewlines;
var hasRequiredCondenseNewlines;
function requireCondenseNewlines() {
  if (hasRequiredCondenseNewlines) return condenseNewlines;
  hasRequiredCondenseNewlines = 1;
  var isWhitespace2 = requireIsWhitespace();
  var extend2 = requireExtendShallow();
  var typeOf = requireKindOf();
  condenseNewlines = function(str, options2) {
    var opts = extend2({}, options2);
    var sep = opts.sep || "\n\n";
    var min = opts.min;
    var re2;
    if (typeof min === "number" && min !== 2) {
      re2 = new RegExp("(\\r\\n|\\n|\\u2424) {" + min + ",}");
    }
    if (typeof re2 === "undefined") {
      re2 = opts.regex || /(\r\n|\n|\u2424){2,}/g;
    }
    if (opts.keepWhitespace !== true) {
      str = str.split("\n").map(function(line) {
        return isWhitespace2(line) ? line.trim() : line;
      }).join("\n");
    }
    str = trailingNewline(str, opts);
    return str.replace(re2, sep);
  };
  function trailingNewline(str, options2) {
    var val = options2.trailingNewline;
    if (val === false) {
      return str;
    }
    switch (typeOf(val)) {
      case "string":
        str = str.replace(/\s+$/, options2.trailingNewline);
        break;
      case "function":
        str = options2.trailingNewline(str);
        break;
      case "undefined":
      case "boolean":
      default: {
        str = str.replace(/\s+$/, "\n");
        break;
      }
    }
    return str;
  }
  return condenseNewlines;
}
/*!
 * pretty <https://github.com/jonschlinkert/pretty>
 *
 * Copyright (c) 2013-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var pretty$1;
var hasRequiredPretty;
function requirePretty() {
  if (hasRequiredPretty) return pretty$1;
  hasRequiredPretty = 1;
  var beautify = requireJs();
  var condense = requireCondenseNewlines();
  var extend2 = requireExtendShallow();
  var defaults = {
    unformatted: ["code", "pre", "em", "strong", "span"],
    indent_inner_html: true,
    indent_char: " ",
    indent_size: 2,
    sep: "\n"
  };
  pretty$1 = function pretty2(str, options2) {
    var opts = extend2({}, defaults, options2);
    str = beautify.html(str, opts);
    if (opts.ocd === true) {
      if (opts.newlines) opts.sep = opts.newlines;
      return ocd(str, opts);
    }
    return str;
  };
  function ocd(str, options2) {
    return condense(str, options2).replace(/^\s+/g, "").replace(/\s+$/g, "\n").replace(/(\s*<!--)/g, "\n$1").replace(/>(\s*)(?=<!--\s*\/)/g, "> ");
  }
  return pretty$1;
}
var prettyExports = requirePretty();
const pretty = /* @__PURE__ */ getDefaultExportFromCjs(prettyExports);
function dehydrateRange(range2) {
  if (range2) {
    return {
      startContainer: range2.startContainer,
      startOffset: range2.startOffset,
      endContainer: range2.endContainer,
      endOffset: range2.endOffset
    };
  }
  return null;
}
function hydrateRange(window2, range2) {
  return null;
}
function selectionMan(window2) {
  const document2 = window2.document;
  let saveSelection;
  let restoreSelection;
  let saveAbsSelection;
  let restoreAbsSelection;
  saveSelection = () => {
    if (window2.getSelection) {
      const sel = window2.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        return dehydrateRange(sel.getRangeAt(0));
      }
    } else if (document2.selection && document2.selection.createRange) {
      return document2.selection.createRange();
    }
    return null;
  };
  restoreSelection = (range2) => {
    range2 = hydrateRange();
    if (range2) {
      if (window2.getSelection) {
        const sel = window2.getSelection();
        sel.removeAllRanges();
        sel.addRange(range2);
      } else if (document2.selection && range2.select) {
        range2.select();
      }
    }
  };
  if (window2.getSelection && document2.createRange) {
    saveAbsSelection = function(containerEl) {
      const range2 = window2.getSelection().getRangeAt(0);
      const preSelectionRange = range2.cloneRange();
      preSelectionRange.selectNodeContents(containerEl);
      preSelectionRange.setEnd(range2.startContainer, range2.startOffset);
      const start = preSelectionRange.toString().length;
      return {
        start,
        end: start + range2.toString().length
      };
    };
    restoreAbsSelection = function(containerEl, savedSel) {
      let charIndex = 0;
      const range2 = document2.createRange();
      range2.setStart(containerEl, 0);
      range2.collapse(true);
      const nodeStack = [containerEl];
      let node;
      let foundStart = false;
      let stop = false;
      while (!stop && (node = nodeStack.pop())) {
        if (node.nodeType == 3) {
          const nextCharIndex = charIndex + node.length;
          if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
            range2.setStart(node, savedSel.start - charIndex);
            foundStart = true;
          }
          if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
            range2.setEnd(node, savedSel.end - charIndex);
            stop = true;
          }
          charIndex = nextCharIndex;
        } else {
          let i = node.childNodes.length;
          while (i--) {
            nodeStack.push(node.childNodes[i]);
          }
        }
      }
      const sel = window2.getSelection();
      sel.removeAllRanges();
      sel.addRange(range2);
    };
  } else if (document2.selection) {
    saveAbsSelection = function(containerEl) {
      const selectedTextRange = document2.selection.createRange();
      const preSelectionTextRange = document2.body.createTextRange();
      preSelectionTextRange.moveToElementText(containerEl);
      preSelectionTextRange.setEndPoint("EndToStart", selectedTextRange);
      const start = preSelectionTextRange.text.length;
      return {
        start,
        end: start + selectedTextRange.text.length
      };
    };
    restoreAbsSelection = function(containerEl, savedSel) {
      const textRange = document2.body.createTextRange();
      textRange.moveToElementText(containerEl);
      textRange.collapse(true);
      textRange.moveEnd("character", savedSel.end);
      textRange.moveStart("character", savedSel.start);
      textRange.select();
    };
  }
  return {
    saveSelection,
    restoreSelection,
    saveAbsSelection,
    restoreAbsSelection
  };
}
let inititalized = false;
const masterWindow = window.opener || window.parent;
const params = window.location.search.substring(1).split("&").reduce((res, i) => {
  if (i.split("=")[0]) {
    let val = i.split("=")[1];
    val = val == null ? true : val;
    res[i.split("=")[0]] = val;
  }
  return res;
}, {});
let editors;
if (params.init && masterWindow) {
  window.addEventListener("message", (event) => {
    if (event.data) {
      const data = JSON.parse(event.data);
      if (data.id === params.init) {
        if (data.type === "init" && !inititalized) {
          init(data.data).then((ed) => {
            masterWindow.postMessage(JSON.stringify({ type: `initialized`, id: params.init }), "*");
            editors = ed;
          });
        }
        if (data.type === "save") {
          editors && editors.ctrl.save();
        }
        if (data.type === "cancel") {
          editors && editors.ctrl.cancel();
        }
        if (data.type === "changemode") {
          editors && editors.ctrl.changemode(data.mode);
        }
        if (data.type === "setColorScheme") {
          editors && editors.ctrl.setColorScheme(data.colorScheme);
        }
        if (data.type === "settings") {
          editors && editors.ctrl.settings(data.data);
        }
      }
    }
  });
  masterWindow.postMessage(JSON.stringify({ type: `preinit`, id: params.init }), "*");
} else {
  init();
}
function init({ color = "#275fa6", content = "", settings = {}, callbackId } = {}) {
  return new Promise((resolve) => {
    const colorPrimary = color;
    let markdown;
    let turndown;
    let colorScheme = "";
    inititalized = true;
    settings = Object.assign({
      // default settings
      codeMode: "html",
      topbar: params.init && masterWindow,
      menubar: true,
      statusbar: true
    }, settings);
    if (settings.codeMode === "markdown") {
      markdown = new Markdown({ linkify: true, breaks: true, typographer: true, html: true });
      markdown.use(alertsPlugin, {
        ignoreUnknownTypes: false
      });
      markdown.use(checklistPlugin$1);
      turndown = new TurndownService();
      turndown.use(checklistPlugin);
      turndown.use([
        tables,
        strikethrough,
        highlightedCodeBlock
      ]);
      turndown.use(githubAlerts);
    }
    const topbar = document.querySelector(".editor-wrapper-menu");
    if (!settings.topbar) {
      topbar.parentElement.removeChild(topbar);
    } else {
      topbar.style.display = "";
    }
    document.documentElement.style.setProperty("--color--primary", colorPrimary);
    const isMD = settings.codeMode === "markdown";
    const defaultToolbar = `undo redo | styleselect | bold italic | alignleft
		                   aligncenter alignright alignjustify |
		                   bullist numlist outdent indent | link image`;
    const formatMenuMD = [
      { title: "Headers", items: [
        { title: "Header 1", format: "h1" },
        { title: "Header 2", format: "h2" },
        { title: "Header 3", format: "h3" },
        { title: "Header 4", format: "h4" },
        { title: "Header 5", format: "h5" },
        { title: "Header 6", format: "h6" }
      ] },
      { title: "Inline", items: [
        { title: "Bold", icon: "bold", format: "bold" },
        { title: "Italic", icon: "italic", format: "italic" }
      ] },
      { title: "Blocks", items: [
        { title: "Blockquote", format: "blockquote" },
        { title: "Code", format: "code" }
      ] },
      { title: "Clear formatting", format: "removeformat" }
    ];
    const tinymceSettings = Object.assign(
      {},
      isMD ? {
        object_resizing: false,
        image_dimensions: false,
        toolbar: `undo redo | styleselect | bold italic | bullist numlist | link image hr`,
        plugins: [
          "link",
          "lists",
          "hr",
          "image"
        ],
        menu: {
          edit: { title: "Edit", items: "undo redo | cut copy paste pastetext | selectall" },
          insert: { title: "Insert", items: "link image hr" },
          view: { title: "View", items: "visualaid" }
        },
        style_formats: formatMenuMD,
        extended_valid_elements: "svg[*],path[*],circle[*],rect[*],line[*],polyline[*],polygon[*],g[*],defs[*],use[*]"
      } : {
        plugins: [
          "fullpage",
          "link",
          "lists",
          "table",
          "colorpicker",
          "textcolor",
          "hr",
          "image"
        ],
        toolbar: `${defaultToolbar} | forecolor backcolor`,
        table_toolbar: false,
        valid_elements: "+*[*]",
        valid_children: "+body[style]",
        object_resizing: false,
        paste_data_images: true
      },
      {
        skin_url: "./css/tinymce/lightgray",
        content_style: `:root{--color--primary: ${colorPrimary};}`,
        content_css: ["./css/wisywig-content.css"],
        menubar: settings.menubar,
        statusbar: settings.statusbar,
        selector: "#wysiwyg",
        language: "ru",
        force_p_newlines: true,
        force_br_newlines: true,
        remove_linebreaks: false,
        forced_root_block: false,
        branding: false,
        setup,
        cleanup_callback(type, value) {
          console.log("TINYMCE", "cleanup_callback", type, value);
          return value;
        },
        onchange_callback(inst) {
          console.log("TINYMCE CHANGE CALLBACK", inst, inst.getBody());
        },
        init_instance_callback(editor) {
          editor.on("paste", (e) => {
            if (isMD) {
              const turned = turndown.turndown(editor.getContent());
              console.log("TURNED", turned, editor.getContent());
              const markdowned = markdown.render(turned);
              console.log("MARKDOWNED", markdowned);
              editor.setContent(markdowned);
            }
          });
        },
        images_dataimg_filter(img) {
          return img.hasAttribute("internal-blob");
        }
      },
      {
        relative_urls: false,
        convert_urls: false,
        remove_script_host: false
      }
    );
    console.log("tinymceSettings", tinymceSettings);
    function setup(editor) {
      editor.hasVisual = false;
      editor.addSidebar("codebar", {
        tooltip: "Code sidebar",
        icon: "code",
        classes: "code-btn",
        onshow() {
          const sidebar = document.body.querySelector(".mce-tinymce .mce-sidebar");
          sidebar.classList.add("sidebar-visible");
          sidebar.classList.remove("sidebar-hidden");
        },
        onhide() {
          const sidebar = document.body.querySelector(".mce-tinymce .mce-sidebar");
          sidebar.classList.add("sidebar-hidden");
          sidebar.classList.remove("sidebar-visible");
        },
        async onrender(api) {
          const panel = api.element();
          panel.classList.add("code-editor-panel");
          panel.innerHTML = `<div class="divider-splitter"></div><iframe id="code-editor" src="./code-editor.html"></iframe>`;
          const divider = panel.children[0];
          const iframe = panel.children[1];
          const sidebar = document.body.querySelector(".mce-tinymce .mce-sidebar");
          const sidebarContainer = sidebar.offsetParent;
          handleDrag(divider, {
            start: (startPoint, type, pressure) => {
              console.log("start", startPoint);
              document.body.classList.add("dragging");
            },
            move: (point, delta2, type, pressure) => {
              console.log("move", delta2);
              const crect = sidebarContainer.getBoundingClientRect();
              sidebar.style.setProperty("width", `${(1 - (point.x - crect.left) / crect.width) * 100}%`);
            },
            end: () => {
              console.log("end");
              document.body.classList.remove("dragging");
            }
          });
          const codeEditor = await new Promise((resolve2) => {
            const inerv = setInterval(() => {
              if (iframe.contentWindow && iframe.contentWindow.editor) {
                clearInterval(inerv);
                iframe.contentWindow.setMode(settings.codeMode);
                resolve2(iframe.contentWindow.editor);
              }
            }, 100);
          });
          const wysiwyg_ifr = document.querySelector("#wysiwyg_ifr");
          const sl = selectionMan(wysiwyg_ifr.contentWindow);
          const ce = wysiwyg_ifr.contentWindow.document.body;
          let lastSelection;
          let lastAbsSelection;
          wysiwyg_ifr.contentWindow.document.addEventListener("selectionchange", (event) => {
            lastAbsSelection = sl.saveAbsSelection(ce);
            lastSelection = sl.saveSelection();
          });
          ce.addEventListener("paste", (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (lastSelection && lastSelection.startContainer && lastSelection.startContainer.parentNode && lastSelection.endContainer && lastSelection.endContainer.parentNode) {
              sl.restoreSelection(lastSelection);
            } else {
              sl.restoreAbsSelection(ce, lastAbsSelection);
            }
            const window2 = wysiwyg_ifr.contentWindow;
            const document2 = window2.document;
            const text2 = event.clipboardData.getData("text/plain");
            let html2 = event.clipboardData.getData("text/html") || text2;
            console.log("PASTE", text2, html2);
            let sel;
            let range2;
            if (window2.getSelection) {
              sel = window2.getSelection();
              if (sel.getRangeAt && sel.rangeCount) {
                range2 = sel.getRangeAt(0);
                range2.deleteContents();
                const tmp = document2.createElement("div");
                tmp.innerHTML = html2;
                const root2 = tmp.querySelector(`:scope > b[id^="docs-internal-guid"]`) || tmp;
                [...root2.querySelectorAll("*")].forEach((node) => {
                  const italic = node.style.fontStyle === "italic";
                  const bold = node.style.fontWeight === "bold" || node.style.fontWeight > 400;
                  if (italic && bold) {
                    const b = document2.createElement("b");
                    const i = document2.createElement("i");
                    i.appendChild(b);
                    [...node.childNodes].forEach((n) => b.appendChild(n));
                    node.parentNode.replaceChild(i, node);
                  } else if (italic) {
                    const i = document2.createElement("i");
                    [...node.childNodes].forEach((n) => i.appendChild(n));
                    node.parentNode.replaceChild(i, node);
                  } else if (bold) {
                    const b = document2.createElement("b");
                    [...node.childNodes].forEach((n) => b.appendChild(n));
                    node.parentNode.replaceChild(b, node);
                  }
                });
                html2 = root2.innerHTML;
                html2 = html2.replace(/&nbsp;/ig, " ");
                const sanitized = sanitize(html2, {
                  allowedSchemes: ["data", "http"],
                  allowedTags: [
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "ul",
                    "ol",
                    "li",
                    "b",
                    "i",
                    "p",
                    "strong",
                    "hr",
                    "br",
                    "img",
                    "a",
                    "table",
                    "thead",
                    "caption",
                    "tbody",
                    "tr",
                    "th",
                    "td"
                  ],
                  allowedAttributes: {
                    a: ["href", "target"],
                    img: ["src", "width", "height"]
                  }
                });
                console.log("sanitized", sanitized);
                tmp.innerHTML = sanitized;
                [...tmp.childNodes].forEach((node, idx, arr) => {
                  range2.insertNode(node);
                  range2.selectNode(node);
                  range2.collapse(false);
                });
                sel.removeAllRanges();
                sel.addRange(range2);
              }
            } else if (document2.selection && document2.selection.createRange) {
              document2.selection.createRange().text = text2;
            }
            return false;
          }, true);
          const ctrl = {
            save(close = false) {
              masterWindow.postMessage(JSON.stringify({
                type: "save",
                close,
                id: callbackId,
                content: codeEditor.getValue()
              }), "*");
            },
            cancel() {
              window.close();
            },
            changemode(mode) {
              iframe.contentWindow.setMode(mode);
            },
            setColorScheme(_colorScheme) {
              colorScheme = _colorScheme;
              if (colorScheme === "system" || !colorScheme) {
                delete wysiwyg_ifr.contentWindow.document.body.dataset.colorScheme;
              } else {
                wysiwyg_ifr.contentWindow.document.body.dataset.colorScheme = _colorScheme;
              }
            },
            settings(data = {}) {
              const customCssClass = "customcss-" + btoa(Math.random()).replace(/\=/ig, "");
              const customStyleClass = "customstyle-" + btoa(Math.random()).replace(/\=/ig, "");
              function addCssToDocument(document2, css2) {
                const tmp = document2.createElement("div");
                [...document2.querySelectorAll(`.${customCssClass}`)].forEach((link2) => {
                  link2.parentNode.removeChild(link2);
                });
                const head = document2.querySelector("head");
                [].concat(css2).forEach((link2) => {
                  tmp.innerHTML = `<link rel="stylesheet" type="text/css" class="${customCssClass}" href="${link2}">`;
                  head.appendChild(tmp.firstChild);
                });
              }
              function addStyleToDocument(document2, style) {
                const tmp = document2.createElement("div");
                [...document2.querySelectorAll(`.${customStyleClass}`)].forEach((link2) => {
                  link2.parentNode.removeChild(link2);
                });
                const head = document2.querySelector("head");
                [].concat(style).forEach((style2) => {
                  tmp.innerHTML = `<style class="${customStyleClass}">${style2}</style>`;
                  head.appendChild(tmp.firstChild);
                });
              }
              if (data.contentCss) {
                addCssToDocument(wysiwyg_ifr.contentWindow.document, data.contentCss);
              }
              if (data.contentStyle) {
                addStyleToDocument(wysiwyg_ifr.contentWindow.document, data.contentStyle);
              }
              if (data.editorCss) {
                addCssToDocument(document, data.editorCss);
              }
              if (data.editorStyle) {
                addStyleToDocument(document, data.editorStyle);
              }
              if (data.codeEditorCss) {
                addCssToDocument(iframe.contentWindow.document, data.codeEditorCss);
              }
              if (data.codeEditorStyle) {
                addStyleToDocument(iframe.contentWindow.document, data.codeEditorStyle);
              }
              if (data.theme) {
                iframe.contentWindow.setTheme(data.theme);
              }
              if (data.colorScheme) {
                ctrl.setColorScheme(data.colorScheme);
              }
            }
          };
          if (masterWindow && params.init) {
            if (settings.topbar) {
              document.querySelector(".button-ok").addEventListener("click", () => ctrl.save(true));
              document.querySelector(".button-cancel").addEventListener("click", () => ctrl.cancel());
            }
            window.addEventListener("beforeunload", () => {
              masterWindow.postMessage(JSON.stringify({
                type: "cancel",
                id: callbackId
              }), "*");
            });
          }
          iframe.contentWindow.document.documentElement.style.setProperty("--color--primary", colorPrimary);
          codeEditor.$blockScrolling = Infinity;
          let ignoreInput = false;
          let ignoreInputTimeout;
          function toWysiwyg(content2) {
            editor.settings.modifyingCode = true;
            if (settings.codeMode === "markdown") {
              const markdowned = markdown.render(content2);
              console.log("MARKDOWNED2", markdowned);
              editor.setContent(markdowned);
            } else {
              editor.setContent(content2);
            }
            try {
              const bg = editor.iframeElement.contentWindow.document.body.getAttribute("data-preview-bg");
              editor.iframeElement.contentWindow.document.documentElement.style.background = bg || "";
            } catch (error2) {
            }
            editor.settings.modifyingCode = false;
          }
          function updateCodeEditor() {
            clearTimeout(ignoreInputTimeout);
            ignoreInput = true;
            const pos = codeEditor.session.selection.toJSON();
            if (settings.codeMode === "markdown") {
              const turned = turndown.turndown(editor.getContent());
              console.log("TURNED2", turned, editor.getContent());
              codeEditor.session.setValue(turned);
            } else {
              codeEditor.session.setValue(pretty(editor.getContent(), { "indent-with-tabs": true, "indent_char": "	", indent_size: 1 }));
            }
            codeEditor.session.selection.fromJSON(pos);
            if (settings.saveOnChange) {
              ctrl.save();
            }
            ignoreInputTimeout = setTimeout(() => {
              ignoreInput = false;
            }, 50);
          }
          codeEditor.on("input", () => {
            if (ignoreInput) {
              return;
            }
            toWysiwyg(codeEditor.getValue());
          });
          let lastContent = "";
          setInterval(() => {
            if (document.activeElement !== iframe) {
              const content2 = editor.getContent();
              if (lastContent !== content2) {
                lastContent = content2;
                updateCodeEditor();
              }
            }
          }, 50);
          toWysiwyg(content);
          updateCodeEditor();
          setTimeout(() => {
            toWysiwyg(codeEditor.getValue());
          }, 100);
          resolve({ codeEditor, editor, ctrl });
        }
      });
    }
    tinymce$1.init(tinymceSettings).then(([editor]) => {
      console.log("editor", editor);
      window.mceEditor = editor;
      editor.on("SetContent", () => {
        editor.getBody().dataset.preview = "editor";
        if (colorScheme) {
          const body = editor.getBody();
          if (colorScheme === "system" || !colorScheme) {
            delete body.dataset.colorScheme;
          } else {
            body.dataset.colorScheme = colorScheme;
          }
        }
      });
      editor.theme.panel.find(".sidebar-toolbar button")[0].$el.trigger("click");
    });
  });
}
function handleDrag(el2, { start, move, end }) {
  let last;
  let point;
  let pointerId;
  const onstart = (event) => {
    if (pointerId) {
      return;
    }
    if (![1, 2].includes(event.button)) {
      pointerId = event.pointerId;
      event.stopPropagation();
      event.preventDefault();
      event.stopImmediatePropagation();
      last = { x: event.pageX, y: event.pageY };
      const rect2 = el2.getBoundingClientRect();
      point = { x: event.pageX - rect2.x, y: event.pageY - rect2.y };
      if (start && start(point, event.pointerType, event.pressure) !== false) {
        document.addEventListener("pointermove", onmove, { passive: false });
        document.addEventListener("pointerup", onend, { passive: false });
      }
    }
  };
  const onmove = (event) => {
    if (event.pointerId === pointerId) {
      event.stopPropagation();
      event.preventDefault();
      event.stopImmediatePropagation();
      if (move) {
        const point2 = { x: event.pageX, y: event.pageY };
        const delta2 = { x: point2.x - last.x, y: point2.y - last.y };
        last = point2;
        move(point2, delta2, event.pointerType, event.pressure);
      }
    }
  };
  const onend = (event) => {
    if (event.pointerId === pointerId) {
      pointerId = null;
      document.removeEventListener("pointermove", onmove, { passive: false });
      document.removeEventListener("pointerup", onend, { passive: false });
      end && end();
    }
  };
  el2.addEventListener("pointerdown", onstart, { passive: false });
  return function unbind() {
    el2.removeEventListener("pointerdown", onstart, { passive: false });
    document.removeEventListener("pointermove", onmove, { passive: false });
    document.removeEventListener("pointerup", onend, { passive: false });
  };
}
//# sourceMappingURL=wysiwyg.esm.js.map
